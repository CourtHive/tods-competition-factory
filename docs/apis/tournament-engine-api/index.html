<!doctype html>
<html lang="en" dir="ltr" class="docs-wrapper plugin-docs plugin-id-default docs-version-current docs-doc-page docs-doc-id-apis/tournament-engine-api" data-has-hydrated="false">
<head>
<meta charset="UTF-8">
<meta name="generator" content="Docusaurus v3.0.0">
<title data-rh="true">tournamentEngine API | Competition Factory</title><meta data-rh="true" name="viewport" content="width=device-width,initial-scale=1"><meta data-rh="true" name="twitter:card" content="summary_large_image"><meta data-rh="true" property="og:url" content="https://courthive.github.com/tods-competition-factory/docs/apis/tournament-engine-api"><meta data-rh="true" property="og:locale" content="en"><meta data-rh="true" name="docusaurus_locale" content="en"><meta data-rh="true" name="docsearch:language" content="en"><meta data-rh="true" name="docusaurus_version" content="current"><meta data-rh="true" name="docusaurus_tag" content="docs-default-current"><meta data-rh="true" name="docsearch:version" content="current"><meta data-rh="true" name="docsearch:docusaurus_tag" content="docs-default-current"><meta data-rh="true" property="og:title" content="tournamentEngine API | Competition Factory"><meta data-rh="true" name="description" content="All _tournamentEngine_ methods which make a mutation return either { success: true } or { error }"><meta data-rh="true" property="og:description" content="All _tournamentEngine_ methods which make a mutation return either { success: true } or { error }"><link data-rh="true" rel="icon" href="/tods-competition-factory/img/favicon.ico"><link data-rh="true" rel="canonical" href="https://courthive.github.com/tods-competition-factory/docs/apis/tournament-engine-api"><link data-rh="true" rel="alternate" href="https://courthive.github.com/tods-competition-factory/docs/apis/tournament-engine-api" hreflang="en"><link data-rh="true" rel="alternate" href="https://courthive.github.com/tods-competition-factory/docs/apis/tournament-engine-api" hreflang="x-default"><link rel="stylesheet" href="/tods-competition-factory/assets/css/styles.52dc517a.css">
<script src="/tods-competition-factory/assets/js/runtime~main.0de24c90.js" defer="defer"></script>
<script src="/tods-competition-factory/assets/js/main.d9a63bdf.js" defer="defer"></script>
</head>
<body class="navigation-with-keyboard" data-theme="light">
<script>!function(){function t(t){document.documentElement.setAttribute("data-theme",t)}var e=function(){try{return new URLSearchParams(window.location.search).get("docusaurus-theme")}catch(t){}}()||function(){try{return localStorage.getItem("theme")}catch(t){}}();t(null!==e?e:"light")}(),function(){try{const c=new URLSearchParams(window.location.search).entries();for(var[t,e]of c)if(t.startsWith("docusaurus-data-")){var a=t.replace("docusaurus-data-","data-");document.documentElement.setAttribute(a,e)}}catch(t){}}()</script><div id="__docusaurus"><div role="region" aria-label="Skip to main content"><a class="skipToContent_XIrk" href="#__docusaurus_skipToContent_fallback">Skip to main content</a></div><nav aria-label="Main" class="navbar navbar--fixed-top"><div class="navbar__inner"><div class="navbar__items"><button aria-label="Toggle navigation bar" aria-expanded="false" class="navbar__toggle clean-btn" type="button"><svg width="30" height="30" viewBox="0 0 30 30" aria-hidden="true"><path stroke="currentColor" stroke-linecap="round" stroke-miterlimit="10" stroke-width="2" d="M4 7h22M4 15h22M4 23h22"></path></svg></button><a class="navbar__brand" href="/tods-competition-factory/"><div class="navbar__logo"><img src="/tods-competition-factory/img/CourtHive.png" alt="CourtHive Logo" class="themedComponent_LOPD themedComponent--light_yK2g"><img src="/tods-competition-factory/img/CourtHive.png" alt="CourtHive Logo" class="themedComponent_LOPD themedComponent--dark_Fl0Q"></div><b class="navbar__title text--truncate">Competition Factory</b></a><a aria-current="page" class="navbar__item navbar__link navbar__link--active" href="/tods-competition-factory/docs/">Docs</a></div><div class="navbar__items navbar__items--right"><a href="https://github.com/CourtHive/tods-competition-factory" target="_blank" rel="noopener noreferrer" class="navbar__item navbar__link">GitHub<svg width="13.5" height="13.5" aria-hidden="true" viewBox="0 0 24 24" class="iconExternalLink_mtdL"><path fill="currentColor" d="M21 13v10h-21v-19h12v2h-10v15h17v-8h2zm3-12h-10.988l4.035 4-6.977 7.07 2.828 2.828 6.977-7.07 4.125 4.172v-11z"></path></svg></a><div class="toggle_HCq0 colorModeToggle_TBa1"><button class="clean-btn toggleButton_mV3c toggleButtonDisabled_gPVl" type="button" disabled="" title="Switch between dark and light mode (currently light mode)" aria-label="Switch between dark and light mode (currently light mode)" aria-live="polite"><svg viewBox="0 0 24 24" width="24" height="24" class="lightToggleIcon_ulA6"><path fill="currentColor" d="M12,9c1.65,0,3,1.35,3,3s-1.35,3-3,3s-3-1.35-3-3S10.35,9,12,9 M12,7c-2.76,0-5,2.24-5,5s2.24,5,5,5s5-2.24,5-5 S14.76,7,12,7L12,7z M2,13l2,0c0.55,0,1-0.45,1-1s-0.45-1-1-1l-2,0c-0.55,0-1,0.45-1,1S1.45,13,2,13z M20,13l2,0c0.55,0,1-0.45,1-1 s-0.45-1-1-1l-2,0c-0.55,0-1,0.45-1,1S19.45,13,20,13z M11,2v2c0,0.55,0.45,1,1,1s1-0.45,1-1V2c0-0.55-0.45-1-1-1S11,1.45,11,2z M11,20v2c0,0.55,0.45,1,1,1s1-0.45,1-1v-2c0-0.55-0.45-1-1-1C11.45,19,11,19.45,11,20z M5.99,4.58c-0.39-0.39-1.03-0.39-1.41,0 c-0.39,0.39-0.39,1.03,0,1.41l1.06,1.06c0.39,0.39,1.03,0.39,1.41,0s0.39-1.03,0-1.41L5.99,4.58z M18.36,16.95 c-0.39-0.39-1.03-0.39-1.41,0c-0.39,0.39-0.39,1.03,0,1.41l1.06,1.06c0.39,0.39,1.03,0.39,1.41,0c0.39-0.39,0.39-1.03,0-1.41 L18.36,16.95z M19.42,5.99c0.39-0.39,0.39-1.03,0-1.41c-0.39-0.39-1.03-0.39-1.41,0l-1.06,1.06c-0.39,0.39-0.39,1.03,0,1.41 s1.03,0.39,1.41,0L19.42,5.99z M7.05,18.36c0.39-0.39,0.39-1.03,0-1.41c-0.39-0.39-1.03-0.39-1.41,0l-1.06,1.06 c-0.39,0.39-0.39,1.03,0,1.41s1.03,0.39,1.41,0L7.05,18.36z"></path></svg><svg viewBox="0 0 24 24" width="24" height="24" class="darkToggleIcon_jfS4"><path fill="currentColor" d="M9.37,5.51C9.19,6.15,9.1,6.82,9.1,7.5c0,4.08,3.32,7.4,7.4,7.4c0.68,0,1.35-0.09,1.99-0.27C17.45,17.19,14.93,19,12,19 c-3.86,0-7-3.14-7-7C5,9.07,6.81,6.55,9.37,5.51z M12,3c-4.97,0-9,4.03-9,9s4.03,9,9,9s9-4.03,9-9c0-0.46-0.04-0.92-0.1-1.36 c-0.98,1.37-2.58,2.26-4.4,2.26c-2.98,0-5.4-2.42-5.4-5.4c0-1.81,0.89-3.42,2.26-4.4C12.92,3.04,12.46,3,12,3L12,3z"></path></svg></button></div><div class="navbarSearchContainer_rBGs"><div class="dsla-search-wrapper"><div class="dsla-search-field" data-tags="default,docs-default-current"></div></div></div></div></div><div role="presentation" class="navbar-sidebar__backdrop"></div></nav><div id="__docusaurus_skipToContent_fallback" class="main-wrapper mainWrapper_j166"><div class="docsWrapper_WccV"><button aria-label="Scroll back to top" class="clean-btn theme-back-to-top-button backToTopButton_zNLY" type="button"></button><div class="docRoot_pxTM"><aside class="theme-doc-sidebar-container docSidebarContainer_f0K6"><div class="sidebarViewport_VW25"><div class="sidebar_gUGL"><nav aria-label="Docs sidebar" class="menu thin-scrollbar menu_owLA"><ul class="theme-doc-sidebar-menu menu__list"><li class="theme-doc-sidebar-item-category theme-doc-sidebar-item-category-level-1 menu__list-item menu__list-item--collapsed"><div class="menu__list-item-collapsible"><a class="menu__link menu__link--sublist menu__link--sublist-caret" aria-expanded="false" href="/tods-competition-factory/docs/">Competition Factory</a></div></li><li class="theme-doc-sidebar-item-category theme-doc-sidebar-item-category-level-1 menu__list-item menu__list-item--collapsed"><div class="menu__list-item-collapsible"><a class="menu__link menu__link--sublist menu__link--sublist-caret" aria-expanded="false" href="/tods-competition-factory/docs/concepts/actions">Concepts</a></div></li><li class="theme-doc-sidebar-item-category theme-doc-sidebar-item-category-level-1 menu__list-item menu__list-item--collapsed"><div class="menu__list-item-collapsible"><a class="menu__link menu__link--sublist menu__link--sublist-caret" aria-expanded="false" href="/tods-competition-factory/docs/engines/mocks-engine-overview">Mocks Engine</a></div></li><li class="theme-doc-sidebar-item-category theme-doc-sidebar-item-category-level-1 menu__list-item menu__list-item--collapsed"><div class="menu__list-item-collapsible"><a class="menu__link menu__link--sublist menu__link--sublist-caret" aria-expanded="false" href="/tods-competition-factory/docs/engines/competition-engine-overview">Competition Engine</a></div></li><li class="theme-doc-sidebar-item-category theme-doc-sidebar-item-category-level-1 menu__list-item"><div class="menu__list-item-collapsible"><a class="menu__link menu__link--sublist menu__link--sublist-caret menu__link--active" aria-expanded="true" href="/tods-competition-factory/docs/engines/tournament-engine-overview">Tournament Engine</a></div><ul style="display:block;overflow:visible;height:auto" class="menu__list"><li class="theme-doc-sidebar-item-link theme-doc-sidebar-item-link-level-2 menu__list-item"><a class="menu__link" tabindex="0" href="/tods-competition-factory/docs/engines/tournament-engine-overview">Overview</a></li><li class="theme-doc-sidebar-item-link theme-doc-sidebar-item-link-level-2 menu__list-item"><a class="menu__link menu__link--active" aria-current="page" tabindex="0" href="/tods-competition-factory/docs/apis/tournament-engine-api">API</a></li></ul></li><li class="theme-doc-sidebar-item-category theme-doc-sidebar-item-category-level-1 menu__list-item menu__list-item--collapsed"><div class="menu__list-item-collapsible"><a class="menu__link menu__link--sublist menu__link--sublist-caret" aria-expanded="false" href="/tods-competition-factory/docs/engines/draw-engine-overview">Draw Engine</a></div></li><li class="theme-doc-sidebar-item-category theme-doc-sidebar-item-category-level-1 menu__list-item menu__list-item--collapsed"><div class="menu__list-item-collapsible"><a class="menu__link menu__link--sublist menu__link--sublist-caret" aria-expanded="false" href="/tods-competition-factory/docs/engines/matchup-engine-overview">MatchUp Engine</a></div></li><li class="theme-doc-sidebar-item-category theme-doc-sidebar-item-category-level-1 menu__list-item menu__list-item--collapsed"><div class="menu__list-item-collapsible"><a class="menu__link menu__link--sublist menu__link--sublist-caret" aria-expanded="false" href="/tods-competition-factory/docs/engines/scale-engine-overview">Scale Engine</a></div></li><li class="theme-doc-sidebar-item-link theme-doc-sidebar-item-link-level-1 menu__list-item"><a class="menu__link" href="/tods-competition-factory/docs/scoreGovernor">Score Governor</a></li><li class="theme-doc-sidebar-item-category theme-doc-sidebar-item-category-level-1 menu__list-item menu__list-item--collapsed"><div class="menu__list-item-collapsible"><a class="menu__link menu__link--sublist menu__link--sublist-caret" aria-expanded="false" href="/tods-competition-factory/docs/constants">Data</a></div></li><li class="theme-doc-sidebar-item-category theme-doc-sidebar-item-category-level-1 menu__list-item menu__list-item--collapsed"><div class="menu__list-item-collapsible"><a class="menu__link menu__link--sublist menu__link--sublist-caret" aria-expanded="false" href="/tods-competition-factory/docs/utilities/utilities-overview">Utilities</a></div></li></ul></nav></div></div></aside><main class="docMainContainer_Mfgp"><div class="container padding-top--md padding-bottom--lg"><div class="row"><div class="col docItemCol_l2wo"><div class="docItemContainer_M9ev"><article><nav class="theme-doc-breadcrumbs breadcrumbsContainer_wxjA" aria-label="Breadcrumbs"><ul class="breadcrumbs" itemscope="" itemtype="https://schema.org/BreadcrumbList"><li class="breadcrumbs__item"><a aria-label="Home page" class="breadcrumbs__link" href="/tods-competition-factory/"><svg viewBox="0 0 24 24" class="breadcrumbHomeIcon_eUt2"><path d="M10 19v-5h4v5c0 .55.45 1 1 1h3c.55 0 1-.45 1-1v-7h1.7c.46 0 .68-.57.33-.87L12.67 3.6c-.38-.34-.96-.34-1.34 0l-8.36 7.53c-.34.3-.13.87.33.87H5v7c0 .55.45 1 1 1h3c.55 0 1-.45 1-1z" fill="currentColor"></path></svg></a></li><li class="breadcrumbs__item"><span class="breadcrumbs__link">Tournament Engine</span><meta itemprop="position" content="1"></li><li itemscope="" itemprop="itemListElement" itemtype="https://schema.org/ListItem" class="breadcrumbs__item breadcrumbs__item--active"><span class="breadcrumbs__link" itemprop="name">API</span><meta itemprop="position" content="2"></li></ul></nav><div class="tocCollapsible_w28O theme-doc-toc-mobile tocMobile_k8pe"><button type="button" class="clean-btn tocCollapsibleButton_kVUG">On this page</button></div><div class="theme-doc-markdown markdown"><header><h1>tournamentEngine API</h1></header><p>All <strong><em>tournamentEngine</em></strong> methods which make a mutation return either <code>{ success: true }</code> or <code>{ error }</code></p>
<hr>
<h2 id="addadhocmatchups">addAdHocMatchUps</h2>
<p>Adds <code>matchUps</code> generated by <a href="#generateadhocmatchups">generateAdHocMatchUps</a> to specified structure within an AD_HOC <code>drawDefinition</code>.</p>
<pre><code class="language-js">  tournamentEngine.addAdHocMatchUps({
    structureId,
    matchUps,
    drawId,
  }
</code></pre>
<hr>
<h2 id="addcollectiondefinition">addCollectionDefinition</h2>
<p>Adds a <code>collectionDefinition</code> to the specified target, either <code>matchUp</code>, <code>structure</code>, <code>drawDefinition</code> or <code>event</code>.</p>
<pre><code class="language-js">tournamentEngine.addCollectionDefinition({
  updateInProgressMatchUps, // defaults to true; in progress matchUps have matchUpStatus: IN_PROGRESS
  collectionDefinition, // will be validated
  tieFormatName, // if not provided, existing tieFormatName will be deleted
  structureId, // optional - if provided only tieFormat on structure will be modified
  matchUpId, // optional - if provided only tieFormat on matchUp will be modified
  eventId, // optional - if provided only tieFormat on event will be modified
  drawId, // required if structureId is specified; if provided without structureId only tieFormat on drawDefinition will be modified
  uuids, // optional - array of UUIDs to use for newly created matchUps
});
</code></pre>
<hr>
<h2 id="addcollectiongroup">addCollectionGroup</h2>
<pre><code class="language-js">tournamentEngine.addCollectionGroup({
  collectionIds: result.modifiedCollectionIds,
  tieFormatName: &#x27;Swelled&#x27;,
  groupDefinition,
  structureId, // optional - if provided only tieFormat on structure will be modified
  matchUpId, // optional - if provided only tieFormat on matchUp will be modified
  eventId, // optional - if provided only tieFormat on event will be modified
  drawId, // required if structureId is specified; if provided without structureId only tieFormat on drawDefinition will be modified
});
</code></pre>
<hr>
<h2 id="addcourt">addCourt</h2>
<p>Add a court to a Venue. See <strong>court</strong> under <strong>venue</strong> in <a href="/docs/types/typedefs#venue">Type Defs</a>.</p>
<pre><code class="language-js">const court = {
  altitude, // optional
  courtDimensions, // optional
  courtId, // generated automatically if not provided
  courtName,
  dateAvailability, // optional - see below
  latitude, // optional
  longitude, // optional
  onlineResources,  // optional
  pace, // optional - string; ITF enums
  surfaceCategory, // optional - surface constant, e.g. CLAY, HARD, GRASS, CARPET, or ARTIFICIAL
  surfaceType, // string; see: https://www.itftennis.com/en/about-us/tennis-tech/recognised-courts/
  surfacedDate?: Date;
}

tournamentEngine.addCourt({ venueId, court });
</code></pre>
<hr>
<h2 id="addcourts">addCourts</h2>
<p>Convenience function to bulk add courts to a Venue. Only adds <strong>dataAvailability</strong> and <strong>courtName</strong>. See <a href="/docs/concepts/scheduling">Scheduling</a>.</p>
<pre><code class="language-js">const dateAvailability = [
  {
    date: &#x27;2020-01-01T00:00&#x27;, // if no date is provided then this profile will be used as default
    startTime: &#x27;07:00&#x27;,
    endTime: &#x27;19:00&#x27;,
    bookings: [
      { startTime: &#x27;07:00&#x27;, endTime: &#x27;08:30&#x27;, bookingType: &#x27;PRACTICE&#x27; },
      { startTime: &#x27;08:30&#x27;, endTime: &#x27;09:00&#x27;, bookingType: &#x27;MAINTENANCE&#x27; },
      { startTime: &#x27;13:30&#x27;, endTime: &#x27;14:00&#x27;, bookingType: &#x27;MAINTENANCE&#x27; },
    ],
  },
];
tournamentEngine.addCourts({
  venueAbbreviationRoot, // optional boolean; whether to use venue.venueAbbreviation in court naming
  dateAvailability, // optional -- see definition in Tournament Engine API
  courtNameRoot, // optional; defaults to &#x27;Court&#x27;
  courtNames: [&#x27;Court 1&#x27;, &#x27;Court 2&#x27;, &#x27;Court 3&#x27;], // optional
  courtsCount: 3, // optional, can be added/modified later; also can be derived from courtNames.length
  venueId,
});
</code></pre>
<hr>
<h2 id="adddrawdefinition">addDrawDefinition</h2>
<p>Adds a drawDefinition to an event in a tournamentRecord. Called after <a href="#generatedrawdefinition">generateDrawDefinition</a>.</p>
<pre><code class="language-js">const { drawDefinition, error } =
  tournamentEngine.generateDrawDefinition(drawDefinitionValues);
if (!error) {
  const result = tournamentEngine.addDrawDefinition({
    modifyEventEntries, // event.entries[{entryStatus}] are modified to match draw.entries[{entryStatus}]
    existingDrawCount, // number of draws that exist in the event, used to check that two clients don&#x27;t attempt to add simultaneously
    allowReplacement, // optional - defaults to false
    checkEntryStatus, // optional - defualts to false
    drawDefinition,
    eventId,
    flight, // optional - pass flight definition object for integrity check
  });
}
</code></pre>
<hr>
<h2 id="adddrawdefinitionextension">addDrawDefinitionExtension</h2>
<p>Add an extension to a drawDefinition.</p>
<pre><code class="language-js">tournamentEngine.addDrawDefinitionExtension({
  extension: {
    name: &#x27;extension name&#x27;,
    value: {},
  },
});
</code></pre>
<hr>
<h2 id="adddrawentries">addDrawEntries</h2>
<p>Bulk add an array of <code>participantIds</code> to a specific <strong>stage</strong> of a draw with a specific <strong>entryStatus</strong>. Will fail if <code>participantIds</code> are not already present in <code>event.entries</code>. Use <code>addEventEntries</code> to add to both <code>event</code> and <code>drawDefinition</code> at the same time.</p>
<pre><code class="language-js">tournamentEngine.addDrawEntries({
  entryStage: MAIN, // optional
  entryStatus: ALTERNATE, // optional
  ignoreStageSpace, // optional boolean to disable checking available positions
  entryStageSequence, // optional - applies to qualifying
  autoEntryPositions, // optional - keeps entries ordered by entryStage/entryStatus and auto-increments
  participantIds,
  eventId,
  drawId,
});
</code></pre>
<hr>
<h2 id="addevent">addEvent</h2>
<p>Add an event object to a tournamentRecord.</p>
<pre><code class="language-js">tournamentEngine.addEvent({ event });
</code></pre>
<hr>
<h2 id="addevententries">addEventEntries</h2>
<p>Adds <code>participantIds</code> to <code>event.entries</code>; optionally pass drawId to add participantIds to <code>flightProfile.flight[].drawEntries</code> at the same time.</p>
<admonition type="note"><p>Will <strong><em>not</em></strong> throw an error if unable to add entries into specified <code>flightProfile.flight[].drawEntries</code>,
which can occur if a <code>drawDefinition</code> has already been generated and an attempt is made to add
a participant with <code>entryStatus: DIRECT_ACCEPTANCE</code>.</p></admonition>
<pre><code class="language-js">tournamentEngine.addEventEntries({
  entryStatus: ALTERNATE, // optional; defaults to DIRECT_ACCEPTANCE
  entryStage: MAIN, // optional; defaults to MAIN
  autoEntryPositions, // optional - keeps entries ordered by entryStage/entryStatus and auto-increments
  ignoreEventGender, // optional - override peson.sex correspondes to event.gender
  participantIds,
  eventId,
  drawId, // optional - will add participantIds to specified flightProfile.flight[].drawEntries and drawDefinition.entries (if possible)
});
</code></pre>
<hr>
<h2 id="addevententrypairs">addEventEntryPairs</h2>
<p>Add <strong>PAIR</strong> participant to an event. Creates new <code>{ participantType: PAIR }</code> participants if the combination of <code>individualParticipantIds</code> does not already exist.</p>
<pre><code class="language-js">tournamentEngine.addEventEntryPairs({
  allowDuplicateParticipantIdPairs, // optional - boolean - allow multiple pair participants with the same individualParticipantIds
  uuids, // optional - array of UUIDs to use for newly created pairs
  entryStatus: ALTERNATE, // optional
  entryStage: QUALIFYING, // optional
  participantIdPairs,
  eventId,
});
</code></pre>
<hr>
<h2 id="addeventextension">addEventExtension</h2>
<pre><code class="language-js">tournamentEngine.addEventExtension({
  extension: {
    name: &#x27;extension name&#x27;,
    value: {},
  },
});
</code></pre>
<hr>
<h2 id="addflight">addFlight</h2>
<pre><code class="language-js">tournamentEngine.addFlight({
  drawEntries, // optional
  drawName,
  eventId,
  drawId, // optional -- if scenario involves client and server side tournamentEngines, provide { drawId: UUID() }
  stage,
});
</code></pre>
<hr>
<h2 id="addindividualparticipantids">addIndividualParticipantIds</h2>
<p>Adds individualParticipantIds to GROUP or TEAM participants</p>
<pre><code class="language-js">tournamentEngine.addIndividualParticipantIds({
  individualParticipantIds,
  groupingParticipantId,
  removeFromOtherTeams, // optional boolean
});
</code></pre>
<hr>
<h2 id="addmatchupendtime">addMatchUpEndTime</h2>
<pre><code class="language-js">const endTime = &#x27;2020-01-01T09:05:00Z&#x27;;
tournamentEngine.addMatchUpEndTime({
  validateTimeSeries, // optional - true by default - when false does not verify endTime is later than startTime
  disableNotice, // when disabled subscribers will not be notified
  matchUpId,
  endTime,
  drawId,
});
</code></pre>
<hr>
<h2 id="addmatchupofficial">addMatchUpOfficial</h2>
<pre><code class="language-js">tournamentEngine.addMatchUpOfficial({
  disableNotice, // when disabled subscribers will not be notified
  participantId,
  officialType,
  matchUpId,
  drawId,
});
</code></pre>
<hr>
<h2 id="addmatchupresumetime">addMatchUpResumeTime</h2>
<pre><code class="language-js">const resumeTime = &#x27;2020-01-01T09:00:00Z&#x27;;
tournamentEngine.addMatchUpResumeTime({
  disableNotice, // when disabled subscribers will not be notified
  resumeTime,
  matchUpId,
  drawId,
});
</code></pre>
<hr>
<h2 id="addmatchupscheduleddate">addMatchUpScheduledDate</h2>
<pre><code class="language-js">const scheduledDate = &#x27;2020-01-01&#x27;;
tournamentEngine.addMatchUpScheduledDate({
  disableNotice, // when disabled subscribers will not be notified
  scheduledDate,
  matchUpId,
  drawId,
});
</code></pre>
<hr>
<h2 id="addmatchupscheduledtime">addMatchUpScheduledTime</h2>
<pre><code class="language-js">const scheduledTime = &#x27;08:00&#x27;;
tournamentEngine.addMatchUpScheduledTime({
  disableNotice, // when disabled subscribers will not be notified
  scheduledTime,
  matchUpId,
  drawId,
});
</code></pre>
<hr>
<h2 id="addmatchupscheduleitems">addMatchUpScheduleItems</h2>
<p>Convenience function to add several schedule items at once.</p>
<pre><code class="language-js">tournamentEngine.addMatchUpScheduleItems({
  matchUpId,
  drawId,
  schedule: {
    scheduledTime,
    scheduledDate,
    startTime,
    courtIds, // applies only to TEAM matchUps
    courtId, // requires scheduledDate
    venueId,
    endTime,
  },
  disableNotice, // when disabled subscribers will not be notified
});
</code></pre>
<hr>
<h2 id="addmatchupstarttime">addMatchUpStartTime</h2>
<pre><code class="language-js">const startTime = &#x27;2020-01-01T08:05:00Z&#x27;;
tournamentEngine.addMatchUpStartTime({
  drawId,
  matchUpId,
  startTime,
  disableNotice, // when disabled subscribers will not be notified
});
</code></pre>
<hr>
<h2 id="addmatchupstoptime">addMatchUpStopTime</h2>
<pre><code class="language-js">const stopTime = &#x27;2020-01-01T08:15:00Z&#x27;;
tournamentEngine.addMatchUpStopTime({
  drawId,
  matchUpId,
  stopTime,
  disableNotice, // when disabled subscribers will not be notified
});
</code></pre>
<hr>
<h2 id="addmatchupcourtorder">addMatchUpCourtOrder</h2>
<p>When using Pro-scheduling, assign order on court</p>
<pre><code class="language-js">tournamentEngine.addMatchUpCourtOrder({
  removePriorValues, // optional boolean
  drawId, // drawId where matchUp is found
  courtOrder,
  matchUpId,
  courtId,
});
</code></pre>
<hr>
<h2 id="addparticipant">addParticipant</h2>
<p>Adds an INDIVIDUAL, PAIR or TEAM participant to tournament participants. Includes integrity checks for <code>{ participantType: PAIR }</code> to ensure <code>participant.individualParticipantIds</code> are valid.</p>
<admonition type="note"><p>To add PAIR participants it is only necessary to provide an array of 2 valid individualParticipantIds, participantType and participantRole.</p></admonition>
<pre><code class="language-js">const participant = {
  participantId, // automatically generated if not provided
  participantRole: COMPETITOR,
  participantType: INDIVIDUAL,
  person: {
    standardFamilyName: &#x27;Family&#x27;,
    standardGivenName: &#x27;Given&#x27;,
    nationalityCode, // optional
    sex, // optional
  },
};

tournamentEngine.addParticipant({ participant });
</code></pre>
<hr>
<h2 id="addparticipants">addParticipants</h2>
<p>Bulk add participants to a tournamentRecord.</p>
<pre><code class="language-js">tournamentEngine.addParticipants({ participants });
</code></pre>
<hr>
<h2 id="addpenalty">addPenalty</h2>
<p>Add a penaltyItem to one or more participants.</p>
<pre><code class="language-js">const createdAt = new Date().toISOString();
const penaltyData = {
  refereeParticipantId, // optional
  participantIds: [&#x27;participantId&#x27;],
  penaltyCode: &#x27;Organization specific code&#x27;, // optional
  penaltyType: BALL_ABUSE,
  matchUpId,
  issuedAt, // optional ISO timeStamp for time issued to participant
  createdAt,
  notes: &#x27;Hit ball into sea&#x27;,
};
let result = tournamentEngine.addPenalty(penaltyData);
</code></pre>
<hr>
<h2 id="addpersons">addPersons</h2>
<p>Creates tournament <code>participants</code> from an array of defined persons. Useful for adding registered persons to a tournament record.
See <strong>person</strong> under <strong>participant</strong> in <a href="../types/typedefs#participant">Type Definitions</a> for additional <code>person</code> attributes.</p>
<admonition type="note"><ul>
<li><code>participantIds</code> are unique within a tournament</li>
<li><code>personIds</code> are unique to an individual, and should be identical across tournaments.</li>
</ul></admonition>
<pre><code class="language-js">const persons = [
  {
    personId, // optional - providing a personId allows person to be tracked across tournaments
    participantExtensions, // optional - any relevant extensions for created participant
    participantTimeItems, // optional - any relevant timeItems (e.g. rankings/ratings) for created participant
    standardFamilyName,
    standardGivenName,
    nationalityCode,
    sex,

    // optional - will create pair participants
    pairedPersons: [
      {
        participantExtensions, // optional - any relevant extensions for created participant
        participantTimeItems, // optional - any relevant timeItems (e.g. rankings/ratings) for created participant
        personId,
      },
    ],
  },
];

tournamentEngine.addPersons({
  participantRole, // optional - defaults to COMPETITOR
  persons,
});
</code></pre>
<hr>
<h2 id="addplayoffstructures">addPlayoffStructures</h2>
<p>Adds playoff structures to an existing drawDefinition.</p>
<pre><code class="language-js">tournamentEngine.addPlayoffStructures({
  drawId,
  structureId,
  roundNumbers: [3], // required if no playoffPositions - source roundNumbers which will feed target structures, e.g. [1, 2]
  roundProfiles, // optional - source roundNumbers as Object.keys with depth as Object.values, e.g. [{ 1: 2}, {2: 1}]
  playoffPositions: [3, 4], // required if not provided roundNumbers
  playoffAttributes, // optional - mapping of either exitProfile or finishingPositionRange to structure names, e.g. 0-1-1 for South
  exitProfileLimit, // limit playoff rounds generated by the attributes present in playoffAttributes
  playoffStructureNameBase, // optional - base word for default playoff naming, e.g. &#x27;Playoff&#x27;
});

// example use of playoffAttributes - will generated playoff structure from 2nd round with structureName: &#x27;BRONZE&#x27;
const playoffAttributes = {
  &#x27;0-2&#x27;: { name: &#x27;BRONZE&#x27;, abbreviation: &#x27;B&#x27; },
};
</code></pre>
<hr>
<h2 id="addqualifyingstructure">addQualifyingStructure</h2>
<pre><code class="language-js">tournamentEngine.addQualifyingStructure({
  targetStructureId, // required: structure for which participants will qualify
  qualifyingPositions, // optional: specify the # of qualifyingPositions
  qualifyingRoundNumber, // optional: determine qualifyingPositions by # of matchUps in specified round; does not apply to ROUND_ROBIN
  structureOptions, // optional: specific to ROUND_ROBIN generation
  structureName, // optional
  drawSize,
  drawType, // optional: defaults to SINGLE_ELIMINATION
  drawId, // required: draw within which target structure appears
});
</code></pre>
<hr>
<h2 id="addtournamentextension">addTournamentExtension</h2>
<pre><code class="language-js">tournamentEngine.addTournamentExtension({
  extension: {
    name: &#x27;extension name&#x27;,
    value: {},
  },
});
</code></pre>
<hr>
<h2 id="addvenue">addVenue</h2>
<p>Adds <strong>venueId</strong> if not provided.</p>
<pre><code class="language-js">tournamentEngine.addVenue({
  venue: { venueName },
  context, // optional - adds detail in CONTEXT extension
});
</code></pre>
<hr>
<h2 id="addvoluntaryconsolationstage">addVoluntaryConsolationStage</h2>
<p>Modifies the entryProfile for a draw to allow <code>{ entryStage: VOLUNTARY_CONSOLATION }</code></p>
<pre><code class="language-js">tournamentEngine.addVoluntaryConsolationStage({
  drawSize,
  drawId,
});
</code></pre>
<hr>
<h2 id="addvoluntaryconsolationstructure">addVoluntaryConsolationStructure</h2>
<p>Generates a new structure within a <code>drawDefinition</code> if any draw entries are present for <code>{ entryStage: VOLUNTARY_CONSOLATION }</code>.</p>
<pre><code class="language-js">tournamentEngine.addVoluntaryConsolationStructure({
  structureAbbreviation, // optional
  structureName, // optional - defaults to &#x27;VOLUNTARY_CONSOLATION&#x27;
  drawId,
});
</code></pre>
<hr>
<h2 id="allocateteammatchupcourts">allocateTeamMatchUpCourts</h2>
<pre><code class="language-js">let result = tournamentEngine.allocateTeamMatchUpCourts({
  removePriorValues, // optional boolean
  matchUpId,
  courtIds,
  drawId,
});
</code></pre>
<hr>
<h2 id="alldrawmatchups">allDrawMatchUps</h2>
<p>Returns all matchUps from all structures within a draw.</p>
<pre><code class="language-js">const { matchUps } = tournamentEngine.allDrawMatchUps({
  participantsProfile, // optional - ability to specify additions to context (see parameters of getParticipants())
  contextFilters, // filters based on context attributes
  matchUpFilters, // attribute filters
  nextMatchUps, // optioanl - boolean - to include winnerTo and loserTo
  inContext, // boolean - add context { drawId, structureId, participant, individualParticipants ... }
  context, // optional context to be added into matchUps
  drawId,
});
</code></pre>
<hr>
<h2 id="alleventmatchups">allEventMatchUps</h2>
<p>Returns all matchUps for an event.</p>
<pre><code class="language-js">const { matchUps } = allEventMatchUps({
  participantsProfile, // optional - ability to specify additions to context (see parameters of getParticipants())
  scheduleVisibilityFilters, // { visibilityThreshold: Date, eventIds, drawIds }
  matchUpFilters, // optional; [ scheduledDates: [], courtIds: [], stages: [], roundNumbers: [], matchUpStatuses: [], matchUpFormats: []]
  contextFilters, // filters based on context attributes
  nextMatchUps: true, // include winner/loser target matchUp details
  inContext: true, // include contextual details
  eventId,
});
</code></pre>
<hr>
<h2 id="alltournamentmatchups">allTournamentMatchUps</h2>
<p>Return an array of all matchUps contained within a tournament. These matchUps are returned <strong>inContext</strong>.</p>
<pre><code class="language-js">const { matchUps } = tournamentEngine.allTournamentMatchUps({
  scheduleVisibilityFilters, // { visibilityThreshold: Date, eventIds, drawIds }
  participantsProfile, // optional - ability to specify additions to context (see parameters of getParticipants())
  matchUpFilters, // optional; [ scheduledDates: [], courtIds: [], stages: [], roundNumbers: [], matchUpStatuses: [], matchUpFormats: []]
  contextFilters, // filters based on context attributes
  nextMatchUps, // include winnerTo and loserTo matchUps
  contextProfile, // optional: { inferGender: true, withCompetitiveness: true, withScaleValues: true, exclude: [&#x27;attribute&#x27;, &#x27;to&#x27;, &#x27;exclude&#x27;]}
});
</code></pre>
<hr>
<h2 id="alternatedrawpositionassignment">alternateDrawPositionAssignment</h2>
<p>Replaces an existing drawPosition assignment with an alternateParticipantId. This method is included in <code>validActions</code> for <a href="../policies/positionActions">positionActions</a></p>
<pre><code class="language-js">tournamentEngine.alternateDrawPositionAssignment({
  drawId,
  structureId,
  drawPosition,
  alternateParticipantId,
});
</code></pre>
<hr>
<h2 id="applylinueups">applyLinueUps</h2>
<p>Applies <code>lineUps</code> to the <code>sides</code> of a <em>TEAM</em> matchUp. Order is not important as team side is determined automatically. Does not check to ensure that participants in <code>lineUps</code> are part of teams; this is assumed. It is possible to have <strong><em>some</em></strong> participants assigned to a team side who are not part of a team.</p>
<pre><code class="language-js">result = tournamentEngine.applyLineUps({
  matchUpId, // must be { matchUpType: TEAM }
  lineUps, // array of at most two lineUps (see TODS)
  drawId, // reference to draw in which matchUp occurs
});
</code></pre>
<hr>
<h2 id="assigndrawposition">assignDrawPosition</h2>
<p>Low level function normally called by higher order convenience functions.</p>
<pre><code class="language-js">tournamentEngine.assignDrawPosition({
  participantId, // optional - if assigning position to a participant
  drawPosition,
  structureId,
  qualifier, // optional boolean, if assigning a space for a qualifier
  drawId,
  bye, // optional boolean, if assigning a bye
});
</code></pre>
<hr>
<h2 id="assignmatchupsideparticipant">assignMatchUpSideParticipant</h2>
<p>Assign participant to AD_HOC matchUp.</p>
<pre><code class="language-js">tournamentEngine.assignMatchUpSideParticipant({
  participantId,
  sideNumber,
  matchUpId,
  drawId,
});
</code></pre>
<hr>
<h2 id="assignmatchupcourt">assignMatchUpCourt</h2>
<pre><code class="language-js">tournamentEngine.assignMatchUpCourt({
  removePriorValues, // optional boolean
  drawId, // drawId where matchUp is found
  courtDayDate, // ISO date string
  matchUpId,
  courtId,
});
</code></pre>
<hr>
<h2 id="assignmatchupvenue">assignMatchUpVenue</h2>
<pre><code class="language-js">tournamentEngine.assignMatchUVenue({
  removePriorValues, // optional boolean
  drawId, // drawId where matchUp is found
  matchUpId,
  venueId,
});
</code></pre>
<hr>
<h2 id="assignseedpositions">assignSeedPositions</h2>
<p>Assign <strong>seedNumbers</strong> to <strong>participantIds</strong> within a target draw structure.</p>
<ul>
<li>Provides the ability to assign seeding <em>after</em> a structure has been generated</li>
<li>To be used <em>before</em> participants are positioned</li>
</ul>
<p><strong>seedNumber</strong> is unique while <strong>seedValue</strong> can be any string representation, e.g <code>&quot;5-8&quot;</code></p>
<pre><code class="language-js">tournamentEngine.assignSeedPositions({
  assignments, // [{ seedNumber: 1, seedValue: &#x27;1&#x27;, participantId: &#x27;pid&#x27; }];
  structureId,
  eventId,
  drawId,

  stage, // opional; defaults to { stage: MAIN }
  stageSequence, // optional; defaults to { stageSequence: 1 }
  useExistingSeedLimits, // optional; restrict ability to assign seedNumbers beyond established limit
});
</code></pre>
<hr>
<h2 id="assigntiematchupparticipantid">assignTieMatchUpParticipantId</h2>
<p>Used when interactively assigning participants to <code>matchUps</code>. When individual <code>participantIds</code> are assigned to <code>{ matchUpType: &#x27;DOUBLES&#x27; }</code> it handles creating <code>{ participantType: PAIR }</code> participants dynamically.</p>
<pre><code class="language-js">tournamentEngine.assignTieMatchUpParticipantId({
  teamParticipantId, // optional - participant team can be derived from participantId. This supports assigning &quot;borrowed&quot; players from other teams.
  participantId, // id of INDIVIDUAL or PAIR participant to be assigned to a matchUp
  tieMatchUpId, // matchUpId of a SINGLES or DOUBLES that is part of a matchUp between teams
  sideNumber, // optional - only necessary if a participant is part of both teams (edge case!)
  drawId, // identifies draw in which matchUp is present
});
</code></pre>
<hr>
<h2 id="attacheventpolicies">attachEventPolicies</h2>
<p>Attaches a policy to an event within a tournamentRecord.</p>
<p>See <a href="../concepts/policies">Policies</a>.</p>
<pre><code class="language-js">tournamentEngine.attachEventPolicies({
  policyDefinitions: SEEDING_POLICY,
  eventId,
});
</code></pre>
<hr>
<h2 id="attachflightprofile">attachFlightProfile</h2>
<p>Attaches a <code>flightProfile</code> to the <code>event</code> specified by <code>eventId</code>. A <code>flightProfile</code> is first generated with <code>generateFlightProfile()</code>.</p>
<pre><code class="language-js">tournamentEngine.attachFlightProfile({ flightProfile, eventId });
</code></pre>
<hr>
<h2 id="attachplayoffstructures">attachPlayoffStructures</h2>
<p>Attaches the results of <code>generateAndPopulatePlayoffStructures</code> to a <code>drawDefinition</code>.
Used primarily when multiple instances of <code>drawEngine</code> are in use and the generation step is performed by one instance.</p>
<admonition type="note"><p><code>tournamentEngine.addPlayoffStructures()</code> calls both <code>generateAndPopulatePlayoffStructures</code> and <code>attachPlayoffStructures</code> and is used when there is only one instance of <code>drawEngine</code>.</p></admonition>
<pre><code class="language-js">tournamentEngine.attachPlayoffStructures({
  matchUpModifications, // optional - pass any modifications external to the structure that are relevant to structure generation
  structures,
  drawId,
  links,
});
</code></pre>
<hr>
<h2 id="attachpolicies">attachPolicies</h2>
<p>Attaches a policy to a tournamentRecord.</p>
<p>See <a href="../concepts/policies">Policies</a>.</p>
<pre><code class="language-js">tournamentEngine.attachPolicies({
  policyDefinitions: SEEDING_POLICY,
  allowReplacement, // optional boolean
});
</code></pre>
<hr>
<h2 id="attachqualifyingstructure">attachQualifyingStructure</h2>
<pre><code class="language-js">tournamentEngine.attachQualifyingStructure({
  structure, // required: structure object; see `generateQualifyingStructure`
  drawId, // required: id of drawDedfinition to which structure will be attached
  link, // required
});
</code></pre>
<hr>
<h2 id="attachstructures">attachStructures</h2>
<p>Use to attach structures and links which are generated by <code>generateVoluntaryConsolation</code>.</p>
<pre><code class="language-js">tournamentEngine.attachStructures({
  matchUpModifications, // optional - pass any modifications external to the structure that are relevant to structure generation
  structures,
  drawId,
  links,
});
</code></pre>
<hr>
<h2 id="automatedplayoffpositioning">automatedPlayoffPositioning</h2>
<p>For Round Robin structures, uses Round Robin Tallies to position participants in playoff structure(s).</p>
<pre><code class="language-js">tournamentEngine.automatedPlayoffPositioning({
  structureId: mainStructure.structureId,
  provisionalPositioning, // optional boolean, defaults to false; when true will honor provisionalOrder if no groupOrder is found in tallyResults
  applyPositioning, // optional boolean, defaults to true; when false will return positioning but not apply it to playoff structures
  drawId,
});
</code></pre>
<hr>
<h2 id="automatedpositioning">automatedPositioning</h2>
<p>Positions participants in a draw structure.</p>
<p>See <a href="../concepts/policies">Policies</a>.</p>
<pre><code class="language-js">tournamentEngine.automatedPositioning({ drawId, structureId });
</code></pre>
<hr>
<h2 id="autoseeding">autoSeeding</h2>
<admonition type="note"><p>Only generates seeding. To apply <code>tournamentEngine.setParticipantScaleItems({ scaleItemsWithParticipantIds }</code>.</p></admonition>
<pre><code class="language-js">const { scaleItemsWithParticipantIds } = tournamentEngine.autoSeeding({
  eventId,
  policyDefinitions, // seeding policyDefinition determines the # of seeds for given participantsCount/drawSize
  scaleAttributes, // { scaleType, scaleName, eventType, accessor }
  scaleName, // Optional - defaults to scaleAttributes.scaleName
  drawSize, // Optional - defaults to calculation based on # of entries
  drawId, // Optional - will use flight.drawEntries or drawDefinition.entries rather than event.entries
  stage, // Optional - filters entries by specified stage

  scaleSortMethod, // Optional - user defined sorting method
  sortDescending, // Optional - defaults to false
});

tournamentEngine.setParticipantScaleItems({
  scaleItemsWithParticipantIds,
});
</code></pre>
<hr>
<h2 id="bulkmatchupstatusupdate">bulkMatchUpStatusUpdate</h2>
<p>Provides the ability to update the outcomes of multiple matchUps at once.</p>
<pre><code class="language-js">const outcomes = [
  {
    eventId,
    drawId,
    matchUpId,
    matchUpFormat,
    matchUpStatus,
    winningSide,
    score,
  },
];
tournamentEngine.bulkMatchUpStatusUpdate({ outcomes });
</code></pre>
<hr>
<h2 id="bulkreschedulematchups">bulkRescheduleMatchUps</h2>
<pre><code class="language-js">const {
  rescheduled, // array of inContext matchUps which have been rescheduled
  notRescheduled, // array of inContext matchUps which have NOT been rescheduled
  allRescheduled, // boolean indicating whether all matchUps have been rescheduled
  dryRun, // boolean - only report what would happen without making modifications
} = tournamentEngine.bulkRescheduleMatchUps({
  matchUpIds, // array of matchUupIds for matchUps which are to be rescheduled
  scheduleChange: {
    daysChange: 1, // number of days +/-
    minutesChange: 30, // number of minutes +/-
  },
});
</code></pre>
<hr>
<h2 id="bulkschedulematchups">bulkScheduleMatchUps</h2>
<pre><code class="language-js">const schedule = {
  scheduledTime: &#x27;08:00&#x27;,
  scheduledDate: &#x27;2021-01-01T00:00&#x27;, // best practice to provide ISO date string
  venueId,
};
const matchUpDetails = [{ matchUpId, schedule }];
tournamentEngine.bulkScheduleMatchUps({
  matchUpDetails, // optional - for use when matchUps have different scheduling details
  matchUpIds, // optional - used together with schedule when all matchUps will have the same schedule details applied
  schedule, // optiona - used together with matchUpIds when all matchUps will ahve the same schedule details applied
});
</code></pre>
<h2 id="bulkupdatepublishedeventids">bulkUpdatePublishedEventIds</h2>
<p>Returns a filtered array of publishedEventIds from all eventIds which are included in a bulkMatchUpStatusUpdate. publishedEventIds can be used to determine which events to re-publish.</p>
<pre><code class="language-js">const { publishedEventIds } = tournamentEngine.bulkUpdatePublishedEventIds({
  outcomes,
});
</code></pre>
<hr>
<h2 id="checkinparticipant">checkInParticipant</h2>
<p>Set the check-in state for a participant. Used to determine when both participants in a matchUp are available to be assigned to a court.</p>
<pre><code class="language-js">tournamentEngine.checkInParticipant({
  participantId,
  matchUpId,
  drawId,
});
</code></pre>
<hr>
<h2 id="checkoutparticipant">checkOutParticipant</h2>
<pre><code class="language-js">tournamentEngine.checkOutParticipant({
  participantId,
  matchUpId,
  drawId,
});
</code></pre>
<hr>
<h2 id="checkvalidentries">checkValidEntries</h2>
<pre><code class="language-js">const { error, success } = tournamentEngine.checkValidEntries({
  consideredEntries, // optional array of entries to check
  enforceGender, // optional boolean - defaults to true
  eventId, // required
});
</code></pre>
<hr>
<h2 id="clearmatchupschedule">clearMatchUpSchedule</h2>
<pre><code class="language-js">tournamentEngine.clearMatchUpSchedule({
  scheduleAttributes, // optional array of schedule constants
  matchUpId,
  drawId, // optional optimizes matchUp lookup, triggers drawModificationNotice
});
</code></pre>
<hr>
<h2 id="clearscheduledmatchups">clearScheduledMatchUps</h2>
<pre><code class="language-js">tournamentEngine.clearScheduledMatchUps({
  ignoreMatchUpStatuses, // optional - specify matchUpStatus values to be ignored; defaults to all completed matchUpStatuses
  scheduleAttributes, // optional - specify which attributes should be considered; defaults to [&#x27;scheduledDate&#x27;, &#x27;scheduledTime&#x27;]
  scheduledDates, // optional - array of dates to be cleared; only matchUps with specified scheduledDate will be cleared
  venueIds, // optional - array of venueIds; only matchUps at specified venues will be cleared
});
</code></pre>
<hr>
<h2 id="deleteadhocmatchups">deleteAdHocMatchUps</h2>
<pre><code class="language-js">const result = tournamentEngine.deleteAdHocMatchUps({
  drawId, // required - drawId of drawDefinition in which target structure is found
  structureId, // required - structureId of structure for which matchUps are being generated
  matchUpIds, // array of matchUpIds identifying matchUps to be deleted
});
</code></pre>
<hr>
<h2 id="deletecourt">deleteCourt</h2>
<pre><code class="language-js">tournamentEngine.deleteCourt({
  courtId,
  force, // override warnings about matchUps scheduled on specified court
});
</code></pre>
<hr>
<h2 id="deletedrawdefinitions">deleteDrawDefinitions</h2>
<p>Remove <code>drawDefinitions</code> from an <code>event</code>. An audit timeItem is added to the tournamentRecord whenever this method is called. If <code>autoPublish: true</code> (default behavior) then if a deleted draw was published then the <code>event</code> to which it belongs will be re-published.</p>
<pre><code class="language-js">tournamentEngine.deleteDrawDefinitions({
  autoPublish, // optional - defaults to true.
  drawIds: [drawId],
  eventId,
});
</code></pre>
<hr>
<h2 id="deleteflightandflightdraw">deleteFlightAndFlightDraw</h2>
<p>Removes flight from <code>event</code> flightProfile as well as associated <code>drawDefinition</code> (if generated).</p>
<pre><code class="language-js">tournamentEngine.deleteFlightAndFlightDraw({
  autoPublish, // optional - defaults to true.
  eventId,
  drawId,
});
</code></pre>
<hr>
<h2 id="deleteflightprofileandflightdraws">deleteFlightProfileAndFlightDraws</h2>
<p>Removes flightProfiles and all associated drawDefinitions from a specified event.</p>
<pre><code class="language-js">tournamentEngine.deleteFlightProfileAndFlightDraws({ eventId });
</code></pre>
<hr>
<h2 id="deleteevents">deleteEvents</h2>
<pre><code class="language-js">tournamentEngine.deleteEvents({ eventIds });
</code></pre>
<hr>
<h2 id="deleteparticipants">deleteParticipants</h2>
<pre><code class="language-js">tournamentEngine.deleteParticipants({
  addIndividualParticipantsToEvents, // optional boolean
  paricipantIds,
});
</code></pre>
<hr>
<h2 id="deletevenue">deleteVenue</h2>
<p>If a venue has scheduled matchUps then it will not be deleted unless <code>{ force: true }</code> in which case all relevant matchUps will be unscheduled.</p>
<pre><code class="language-js">tournamentEngine.deleteVenue({ venueId, force });
</code></pre>
<hr>
<h2 id="deletevenues">deleteVenues</h2>
<p>If a venue has scheduled matchUps then it will not be deleted unless <code>{ force: true }</code> in which case all relevant matchUps will be unscheduled.</p>
<pre><code class="language-js">tournamentEngine.deleteVenues({ venueIds, force });
</code></pre>
<hr>
<h2 id="destroygroupentry">destroyGroupEntry</h2>
<p>Removes a &quot;grouping&quot; entry from a event and adds the <code>individualParticipantIds</code> to entries. Grouping entries are <code>participantType</code> <strong>TEAM</strong> and <strong>PAIR</strong>, both of which include <code>individualParticipantIds</code>.</p>
<pre><code class="language-js">tournamentEngine.destroyGroupEntry({
  participantId,
  eventId,

  entryStatus, // optional - new entryStatus for individualParticipantIds
  removeGroupParticipant, // optional - removes group participant from tournament participants
});
</code></pre>
<hr>
<h2 id="destroypairentry">destroyPairEntry</h2>
<p>Removes a <code>{ participantType: PAIR }</code> entry from an event and adds the individualParticipantIds to entries as entryStatus: UNGROUPED</p>
<pre><code class="language-js">tournamentEngine.destroyPairEntry({
  participantId,
  eventId,
});
</code></pre>
<hr>
<h2 id="devcontext">devContext</h2>
<p>Setting devContext(true) bypasses <strong>try <!-- --> catch (err) </strong> code block and in some cases enables enhanced logging</p>
<pre><code class="language-js">tournamentEngine.devContext(true);
</code></pre>
<hr>
<h2 id="disablecourts">disableCourts</h2>
<pre><code class="language-js">tournamentEngine.disableCourts({
  courtIds,
  dates, // optional - if not provided, courts will be disalbed for all dates
});
</code></pre>
<hr>
<h2 id="disabletiaautocalc">disableTiaAutoCalc</h2>
<p>Disable default behavior of auto calculating TEAM matchUp scores.</p>
<pre><code class="language-js">tournamentEngine.disableTieAutoCalc({ drawId, matchUpId });
</code></pre>
<hr>
<h2 id="disablevenues">disableVenues</h2>
<pre><code class="language-js">tournamentEngine.disableVenues({ venueIds });
</code></pre>
<hr>
<h2 id="drawmatic">drawMatic</h2>
<pre><code class="language-js">const { matchUps, participantIdPairings, iterations, candidatesCount } =
  tournamentEngine.drawMatic({
    restrictEntryStatus, // optional - only allow STRUCTURE_SELECTED_STATUSES
    generateMatchUps, // optional - defaults to true; when false only returns { participantIdPairings }
    addToStructure, // optional - defaults to true
    maxIterations, // optional - defaults to 5000
    structureId, // optional; if no structureId is specified find the latest AD_HOC stage which has matchUps
    matchUpIds, // optional array of uuids to be used when generating matchUps
    eventType, // optional - override eventType of event within which draw appears; e.g. to force use of SINGLES ratings in DOUBLES events
    drawId, // required

    scaleAccessor, // optional string to access value within scaleValue, e.g. &#x27;wtnRating&#x27;
    scaleName, // optional; custom rating name to seed dynamic ratings
  });
</code></pre>
<hr>
<h2 id="enablecourts">enableCourts</h2>
<pre><code class="language-js">tournamentEngine.enableCourts({
  enableAll, // optional boolean
  courtIds,
  dates, // optional - array of dates to enable (if they have been disabled)
});
</code></pre>
<hr>
<h2 id="enabletiaautocalc">enableTiaAutoCalc</h2>
<p>Re-enable default behavior of auto calculating TEAM matchUp scores, and trigger auto calculation.</p>
<pre><code class="language-js">tournamentEngine.enableTieAutoCalc({ drawId, matchUpId });
</code></pre>
<hr>
<h2 id="enablevenues">enableVenues</h2>
<pre><code class="language-js">tournamentEngine.enableVenues({ venueIds, enableAll });
</code></pre>
<hr>
<h2 id="eventmatchups">eventMatchUps</h2>
<p>Returns matchUps for an event grouped by status.</p>
<pre><code class="language-js">const {
  abandonedMatchUps,
  byeMatchUps,
  completedMatchUps,
  pendingMatchUps,
  upcomingMatchUps,
} = tournamentEngine.eventMatchUps({
  eventId,
  nextMatchUps, // optional boolean; include winner/loser target matchUp details
  matchUpFilters, // optional; [ scheduledDates: [], courtIds: [], stages: [], roundNumbers: [], matchUpStatuses: [], matchUpFormats: []]
  contextFilters,
  tournamentAppliedPolicies,
  scheduleVisibilityFilters, // { visibilityThreshold: Date, eventIds, drawIds }
  inContext: true, // optional - adds context details to all matchUps
});
</code></pre>
<hr>
<h2 id="executionqueue">executionQueue</h2>
<p>The <code>executionQueue</code> method accepts an array of <code>tournamentEngine</code> methods and associated parameters,
allowing for multiple queries or mutations in a single API call, which is significant if a client is making a
request of a server and the server needs to prepare context by loading a tournament record.</p>
<p>An additional benefit of the <code>executionQueue</code> is that subscribers to <code>tournamentEngine</code> events are not notified
until all methods in the queue have completed successfully, and a failure of any one method can be used to roll back state
with the assurance that there are no side-effects caused by subscribers responding to notifications. This also means
that the server context can not be blocked by any long-running external processes.</p>
<pre><code class="language-js">const result = tournamentEngine.executionQueue([
  {
    method: &#x27;getParticipants&#x27;,
    params: { participantFilters: { participantTypes: [PAIR] } },
  },
  {
    method: &#x27;getParticipants&#x27;,
    params: { participantFilters: { participantTypes: [INDIVIDUAL] } },
  },
]);
</code></pre>
<hr>
<h2 id="findcourt">findCourt</h2>
<pre><code class="language-js">const { court, venue } = tournamentEngine.findCourt({ courtId });
</code></pre>
<hr>
<h2 id="finddrawdefinitionextension">findDrawDefinitionExtension</h2>
<pre><code class="language-js">const { extension } = tournamentEngine.findDrawDefinitionExtension({
  drawId,
  eventId,
  name,
});
</code></pre>
<hr>
<h2 id="findeventextension">findEventExtension</h2>
<pre><code class="language-js">const { extension } = tournamentEngine.findEventExtension({ eventId, name });
</code></pre>
<hr>
<h2 id="findmatchup">findMatchUp</h2>
<pre><code class="language-js">const {
  matchUp,
  structure, // returned for convenience
} = tournamentEngine.findMatchUp({
  inContext, // optional - boolean - returns matchUp with additional attributes
  matchUpId,
  drawId,
});
</code></pre>
<hr>
<h2 id="findparticipant">findParticipant</h2>
<pre><code class="language-js">const { participant } = tournamentEngine.findParticipant({
  participantId, // required only if no personId provided
  personId, // required only if no participantId provided
});
</code></pre>
<hr>
<h2 id="findparticipantextension">findParticipantExtension</h2>
<pre><code class="language-js">const { extension } = tournamentEngine.findParticipantExtension({
  participantId,
  name,
});
</code></pre>
<hr>
<h2 id="findpolicy">findPolicy</h2>
<p>Find <code>policyType</code> either on an event object or the tournamentRecord.</p>
<pre><code class="language-js">const { policy } = tournamentEngine.findPolicy({
  policyType: POLICY_TYPE_SCORING,
  eventId, // optional
});
</code></pre>
<hr>
<h2 id="findtournamentextension">findTournamentExtension</h2>
<pre><code class="language-js">const { extension } = tournamentEngine.findTournamentExtension({ name });
</code></pre>
<hr>
<h2 id="findvenue">findVenue</h2>
<p>Returns a complete venue object. Primarily used internally.</p>
<pre><code class="language-js">tournamentEngine.findVenue({ venueId });
</code></pre>
<hr>
<h2 id="generateadhocmatchups">generateAdHocMatchUps</h2>
<p>Draws with <code>{ drawType: AD_HOC }</code> allow <code>matchUps</code> to be dynamically added. In this type of draw there is no automatic participant progression between rounds. Participant assignment to <code>matchUps</code> is done manually, or via <strong>DrawMatic</strong>. The only restriction is that a participant may appear once per round. To generate only, and not add to the structure/draw, use the boolean <code>addToStructure</code> and then subsequently use <a href="#addadhocmatchups">addAddHocMatchUps</a>.</p>
<pre><code class="language-js">const result = tournamentEngine.generateAdHocMatchUps({
  addToStructure, // boolean - defaults to true
  participantIdPairings, // optional - array of array of pairings [[&#x27;id1&#x27;, &#x27;id2&#x27;], [&#x27;id3&#x27;, &#x27;id4&#x27;]]
  drawId, // required - drawId of drawDefinition in which target structure is found
  structureId, // required only when more than one structure is present and { addToStructure: true }
  matchUpIds, // optional - if matchUpIds are not specified UUIDs are generated
  roundNumber, // optional - specify round for which matchUps will be generated
  newRound, // optional - boolean defaults to false - whether to auto-increment to next roundNumber
});
</code></pre>
<hr>
<h2 id="generateandpopulateplayoffstructures">generateAndPopulatePlayoffStructures</h2>
<p>Generates values but does not attach them to the <code>drawDefinition</code>. Used in conjunction with <code>attachPlayoffStructures</code>.</p>
<pre><code class="language-js">const { structures, links, matchUpModifications } =
  tournamentEngine.generateAndPopulatePlayoffStructures({
    requireSequential, // boolean defaults to true; only applies to Round Robin; require finishingPositions to be sequential
    roundNumbers: [3], // optional if playoffPositions not provided; roundNumbers of structure to be played off.
    roundProfiles, // optional - source roundNumbers as Object.keys with depth as Object.values, e.g. [{ 1: 2}, {2: 1}]
    playoffPositions: [3, 4], // optional if roundNumbers not provided; finishing positions to be played off.
    playoffStructureNameBase, // optional - Root word for default playoff naming, e.g. &#x27;Playoff&#x27; for &#x27;Playoff 3-4&#x27;
    exitProfileLimit, // limit playoff rounds generated by the attributes present in playoffAttributes
    playoffAttributes, // optional - mapping of either exitProfile or finishingPositionRange to structure names, e.g. 0-1-1 for South
    playoffGroups, // optional - only applies to Playoffs from ROUND_ROBIN: { structureNameMap: {}, finishingPositions: [], drawType: &#x27;&#x27; }
    structureId,
    drawId,
  });
</code></pre>
<hr>
<h2 id="generatedrawdefinition">generateDrawDefinition</h2>
<p>This is a convenience method which handles most use cases for draw generation.</p>
<p>The <code>automated</code> parameter is &quot;truthy&quot; and supports placing only seeded participants and any byes which are adjacent to seeded positions.
Support for this scenario is provided to enable some unique positioning strategies where unseeded participants have some agency in the selection process.</p>
<pre><code class="language-js">const drawDefinitionValues = {
  eventId, // optional - used to find any avoidance policies to be applied
  drawSize, // number of drawPositions in the first draw structure
  drawType, // optional - defaults to SINGLE_ELIMINATION
  drawName, // cutom name for generated draw structure(s)
  drawEntries, // array of entries, equal to or a subset of event.entries
  automated, // optional - whether or not to automatically place participants in structures; true/false or &#x27;truthy&#x27; { seedsOnly: true }
  matchUpType, // optional - SINGLES, DOUBLES, or TEAM
  matchUpFormat, // optional - default matchUpFormatCode for all contained matchUps
  playoffMatchUpFormat, // optional - relevant for ROUND_ROBIN_WITH_PLAYOFFS
  hydrateCollections, // optional - propagate { category, gender } for event to collectionDefinitions in tieFormats
  tieFormat, // optional - { collectionDefinitions, winCriteria } for &#x27;dual&#x27; or &#x27;tie&#x27; matchUps
  seedsCount, // optional - number of seeds to generate if no seededParticipants provided
  seededParticipants, // optional - { participantId: &#x27;id&#x27;, seedNumber: 1, seedValue, &#x27;1&#x27; }
  seedingScaleName, // optional - custom scale for determining seeded participants

  // { positioing: WATERFALL } seeding for ROUND_ROBIN structures
  // { positioning: CLUSTER } or { positioning: SEPARATE } seeding for elimination structures
  // { groupSeedingThreshold: 5 } will set seedValue to lowest value within all groups where seedNumber is &gt; 5
  seedingProfile, // optional { positioning, groupSeedingThreshold }

  qualifyingPlaceholder, // optional boolean - generate a placeholder qualifying structure if qualifiersCount and no qualifyingProfiles
  qualifiersCount, // optional - how many positionsAssignments will have { qualifier: true }
  qualifyingOnly, // optional boolean - ignore event.entries that are not entryStage: QUALIFYING
  qualifyingProfiles, // optional array [{ roundTarget, structureProfiles: [{ drawSize, seedsCount, seedingScaleName, qualifyingPositions }]}]

  structureOptions: {
    // optional - for ROUND_ROBIN - { groupSize, playoffGroups }
    groupSize, // e.g. 4 participants per group
    groupSizeLimit: 8,
    playoffGroups: [
      { finishingPositions: [1], structureName: &#x27;Gold Flight&#x27;, drawType }, // drawype defaults to SINGLE_ELIMINATION
      { finishingPositions: [2], structureName: &#x27;Silver Flight&#x27;, drawType }, // drawType can also be COMPASS or FIRST_MATCH_LOSER_CONSOLATION
    ],
  },

  staggeredEntry, // optional - accepts non-base-2 drawSizes and generates feed arms for &quot;extra&quot; drawPositions
  policyDefinitions, // optional - seeding or avoidance policies to be used when placing participants
  qualifyingPositions, // optional - number of positions in draw structure to be filled by qualifiers
  playoffAttributes, // optional - map of { [finishingPositionRange || exitProfile]: { name: &#x27;customName&#x27;, abbreviation: &#x27;A&#x27; } }
  enforcePolicyLimits, // optional boolean - defaults to true - constrains seedsCount to policyDefinition limits
  voluntaryConsolation, // optional { structureName, structureAbbreviation } - causes voluntary consolation structure to be added
  enforceMinimumDrawSize, // optional boolean - defaults to true - false will allow generation of multi-structure drawTypes with only 2 participants
  drawTypeCoercion, // optional boolean - coerce multi-structure drawTypes to SINGLE_ELIMINATION for drawSize: 2
  ignoreStageSpace, // optional boolean - ignore wildcards count &amp; etc.

  compassAttributes, // optional - provide translations for name mappings
  olympicAttributes, // optional - provide translations for name mappings
};

const { drawDefinition } =
  tournamentEngine.generateDrawDefinition(drawDefinitionValues);
</code></pre>
<hr>
<h2 id="generatedrawmaticround">generateDrawMaticRound</h2>
<p>Typically not called directly. <code>tournamentEngine.drawMatic</code> is a higher level wrapper which automates derivation of <code>adHocRatings</code>.</p>
<pre><code class="language-js">const {
  participantIdPairings,
  candidatesCount,
  iterations,
  matchUps,
  success,
} = generateDrawMaticRound({
  maxIterations,// optional - defaults to 5000
  generateMatchUps = true, // optional - defaults to true; when false only returns { participantIdPairings }
  participantIds, // required
  addToStructure, // optional - defaults to true
  adHocRatings, // optional { [&#x27;participantId&#x27;]: numericRating }
  structureId, // required
  matchUpIds, // optional array of uuids to be used when generating matchUps
  eventType, // optional - override eventType of event within which draw appears; e.g. to force use of SINGLES ratings in DOUBLES events
  drawId, // required
});
</code></pre>
<hr>
<h2 id="generateflightprofile">generateFlightProfile</h2>
<p>Splits event entries into <code>flightsCount</code> (# of draws). <code>flightProfile</code> is an extension on an event which contains attributes to be used by <code>generateDrawDefinition</code>.</p>
<p>NOTE: The method returns <code>{ flightProfile, splitEntries }</code> for testing; <code>splitEntries</code> provides a breakdown on how <code>event.entries</code> were split across each <code>flight</code> within the <code>event</code>.</p>
<p>For an explanation of <code>scaleAttributes</code> see <a href="../concepts/scaleItems">Scale Items</a>.</p>
<pre><code class="language-js">const scaleAttributes = {
  scaleType: RATING,
  eventType: SINGLES,
  scaleName: &#x27;WTN&#x27;,
  accessor, // optional - string determining how to access attribute if scaleValue is an object
};

const { flightProfile, splitEntries } = tournamentEngine.generateFlightProfile({
  eventId, // event for which entries will be split
  attachFlightProfile, // boolean - also attach to event after generation
  scaledEntries, // optional - overrides the use of scaleAttributes, scaleSortMethod, and sortDescending
  scaleAttributes, // defines participant sort method prior to split
  scaleSortMethod, // optional - function(a, b) {} sort method, useful when scaleValue is an object or further proessing is required
  sortDescending, // optional - default sorting is ASCENDING; only applies to default sorting method.
  flightsCount: 3, // number of draws to be created
  deleteExisting: true, // optional - remove existing flightProfile
  splitMethod: SPLIT_WATERFALL, // optional - defaults to SPLIT_LEVEL_BASED
  drawNames: [&#x27;Green Flight&#x27;, &#x27;Blue Flight&#x27;], // optional
  drawNameRoot: &#x27;Flight&#x27;, // optional - used to generate drawNames, e.g. &#x27;Flight 1&#x27;, &#x27;Flight 2&#x27;
});

const {
  flights: [
    {
      drawId, // unique identifier for generating drawDefinitions
      drawName, // custom name for generated draw
      drawEntries, // entries allocated to target draw
    },
  ],
} = flightProfile;

// use flight information to generate drawDefinition
const {
  flights: [flight],
} = flightProfile;

Object.assign(drawDefinitionValues, flight);
const { drawDefinition } =
  tournamentEngine.generateDrawDefinition(drawDefinitionValues);
</code></pre>
<hr>
<h2 id="generatelineups">generateLineUps</h2>
<p>Generates lineUps for TEAM events which have selected teams with ranked or rated individualParticipants. Individual TEAM participants are assigned line positions based on the scale specified.</p>
<pre><code class="language-js">const scaleAccessor = {
  scaleName: categoryName,
  scaleType: RANKING,
  sortOrder, // optional - ASCENDING or DESCENDING - defaults to ASCENDING
};
const { lineUps, participantsToAdd } = tournamentEngine.generateLineUps({
  useDefaultEventRanking, // optional boolen; when true scaleAccessor is not required
  scaleAccessor, // see above
  singlesOnly, // optional boolean - when true SINGLES rankings will be used for DOUBLES position assignment
  attach, // optional boolean - when true the lineUps will be attached to the drawDefinition specified by drawId
  drawId,
});
</code></pre>
<hr>
<h2 id="generatequalifyingstructure">generateQualifyingStructure</h2>
<pre><code class="language-js">let { structure, link } = tournamentEngine.generateQualifyingStructure({
  targetStructureId, // required: structure for which participants will qualify
  qualifyingPositions, // optional: specify the # of qualifyingPositions
  qualifyingRoundNumber, // optional: determine qualifyingPositions by # of matchUps in specified round; does not apply to ROUND_ROBIN
  structureOptions, // optional: specific to ROUND_ROBIN generation
  structureName, // optional
  drawSize,
  drawType, // optional: defaults to SINGLE_ELIMINATION
  drawId, // required: draw within which target structure appears
});
</code></pre>
<hr>
<h2 id="generateseedingscaleitems">generateSeedingScaleItems</h2>
<p>Used in conjunction with <code>getEntriesAndSeedsCount</code> when it is necessary to make use of a custom function for generating <code>scaledEntries</code>.</p>
<pre><code class="language-js">const { scaleItemsWithParticipantIds } =
  tournamentEngine.generateSeedingScaleItems({
    scaleAttributes,
    scaledEntries,
    stageEntries,
    seedsCount,
    scaleName,
  });
</code></pre>
<hr>
<h2 id="generateteamsfromparticipantattribute">generateTeamsFromParticipantAttribute</h2>
<p>Uses attributes of individual participnts or persons to generate <code>{ participantType: TEAM }</code> participants.</p>
<p>Returns count of # of TEAM participants added;</p>
<pre><code class="language-js">const { participantsAdded } =
  tournamentEngine.generateTeamsFromParticipantAttribute({
    participantAttribute, // optional -- attribute of participant object
    addParticipants, // optional boolean; defaults to true; when false return new participants
    personAttribute, // optional - attribute of person object
    accessor, // optional - use accessor string to retrieve nested value (even from person address arrays)
    uuids, // optional - uuids to assign to generated participants
  });
</code></pre>
<hr>
<h2 id="generatevolunataryconsolation">generateVolunataryConsolation</h2>
<pre><code class="language-js">const { structures, links } = tournamentEngine.generateVoluntaryConsolation({
  attachConsolation: false, // optional - defaults to true
  automated: true,
  drawId,
});

// if { attachConsolation: false } then it will be necessary to subsequently attach the structures and links
tournamentEngine.attachConsolationStructures({ drawId, structures, links });
</code></pre>
<hr>
<h2 id="getalleventdata">getAllEventData</h2>
<p>Returns all <code>matchUps</code> for all draws in all events along with <code>tournamentInfo</code>, <code>eventInfo</code>, and <code>drawInfo</code>.</p>
<pre><code class="language-js">const { allEventData } = tournamentEngine.getAllEventData({
  policyDefinitions, // optional - allows participant data to be filtered via a privacy policy
});

const { tournamentInfo, eventsData, venuesData } = allEventData;
</code></pre>
<hr>
<h2 id="getalloweddrawtypes">getAllowedDrawTypes</h2>
<p>Returns an array of names of allowed Draw Types, if any applicable policies have been applied to the tournamentRecord.</p>
<pre><code class="language-js">const drawTypes = tournamentEngine.getAllowedDrawTypes();
</code></pre>
<hr>
<h2 id="getallowedmatchupformats">getAllowedMatchUpFormats</h2>
<p>Returns an array of TODS matchUpFormat codes for allowed scoring formats, if any applicable policies have been applied to the tournamentRecord.</p>
<pre><code class="language-js">const drawTypes = tournamentEngine.getAllowedMatchUpFormats();
</code></pre>
<hr>
<h2 id="getavailableplayoffprofiles">getAvailablePlayoffProfiles</h2>
<p>If provided a <code>structureId</code>, returns rounds of the selected structure which are available for adding playoff structures.</p>
<pre><code class="language-js">const { playoffRounds, playoffRoundsRanges, positionsPlayedOff } =
  tournamentEngine.getAvailablePlayoffProfiles({
    structureId,
    drawId,
  });
</code></pre>
<p>...for a SINGLE_ELIMINATION struture with <code>{ drawSize: 16 }</code> this would return:</p>
<pre><code class="language-js">{
  playoffRounds: [ 1, 2, 3 ],
  playoffRoundsRanges: [
    { round: 1, range: &#x27;9-16&#x27; },
    { round: 2, range: &#x27;5-8&#x27; },
    { round: 3, range: &#x27;3-4&#x27; }
  ]
}
</code></pre>
<p>...for a ROUND_ROBIN struture with <code>{ drawSize: 16 }</code> and <code>{ groupSize: 4 }</code> this would return:</p>
<pre><code class="language-js">{
    &quot;finishingPositionsAvailable&quot;: [ 1, 2, 3, 4 ],
    &quot;playoffFinishingPositionRanges&quot;: [
        {
            &quot;finishingPosition&quot;: 1,
            &quot;finishingPositions&quot;: [ 1, 2, 3, 4 ],
            &quot;finishingPositionRange&quot;: &quot;1-4&quot;
        },
        {
            &quot;finishingPosition&quot;: 2,
            &quot;finishingPositions&quot;: [ 5, 6, 7, 8 ],
            &quot;finishingPositionRange&quot;: &quot;5-8&quot;
        },
        {
            &quot;finishingPosition&quot;: 3,
            &quot;finishingPositions&quot;: [ 9, 10, 11, 12 ],
            &quot;finishingPositionRange&quot;: &quot;9-12&quot;
        },
        {
            &quot;finishingPosition&quot;: 4,
            &quot;finishingPositions&quot;: [ 13, 14, 15, 16 ],
            &quot;finishingPositionRange&quot;: &quot;13-16&quot;
        }
    ],
}
</code></pre>
<p>When no <code>structureId</code> is provided, returns an array of <code>availablePlayoffProfiles</code> with entries for each structure in a specified <code>drawDefinition</code>.</p>
<pre><code class="language-js">const { availablePlayoffProfiles, positionsPlayedOff } =
  tournamentEngine.getAvailablePlayoffProfiles({ drawId });
</code></pre>
<hr>
<h2 id="getcourtinfo">getCourtInfo</h2>
<pre><code class="language-js">const {
  altitude,
  courtId,
  courtName,
  courtDimensions,
  latitude,
  longitude,
  surfaceCategory,
  surfaceType,
  surfacedDate,
  pace,
  notes,
} = tournamentEngine.getCourtInfo({ courtId });
</code></pre>
<hr>
<h2 id="getcourts">getCourts</h2>
<p>Returns courts associated with a tournaments; optionally filter by venue(s).</p>
<pre><code class="language-js">const { courts } = tournamentEngine.getCourts({
  venueId, // optional - return courts for a specific venue
  venueIds, // optional - return courts for specified venues
});
</code></pre>
<hr>
<h2 id="getdrawdata">getDrawData</h2>
<p>Primarily used by <code>getEventData</code> for publishing purposes.</p>
<pre><code class="language-js">const {
  drawInfo: {
    drawActive, // boolean - draw has active matchUps
    drawCompleted, // boolean - all draw matchUps are complete
    drawGenerated, // boolean - draw has structures containing matchUps
    participantPlacements, // boolean - whether any participants have been placed in the draw
  },
  structures,
} = tournamentEngine.getDrawData({ drawDefinition });
</code></pre>
<hr>
<h2 id="getdrawparticipantrepresentativeids">getDrawParticipantRepresentativeIds</h2>
<p>Get the participantIds of participants in the draw who are representing players by observing the creation of the draw.</p>
<pre><code class="language-js">const { representativeParticipantIds } =
  tournamentEngine.getDrawParticipantRepresentativeIds({
    drawId,
  });
</code></pre>
<hr>
<h2 id="geteligiblevoluntaryconsolationparticipants">getEligibleVoluntaryConsolationParticipants</h2>
<pre><code class="language-js">const { eligibleParticipants } =
  tournamentEngine.getEligibleVoluntaryConsolationParticipants({
    excludedMatchUpStatuses, // optional - array of matchUpStatuses which are excluded from matchUpsLimit
    includeQualifyingStage, // optional - allow losers in qualifying
    finishingRoundLimit, // optional number - limits considered matchUps by finishingRound, e.g. 3 doesn&#x27;t consider past QF
    roundNumberLimit, // optional number - limits matchUps by roundNumber
    matchUpsLimit, // optional number - limits the number of considered matchUps; works in tandem with excludedMatchUpStatuses
    winsLimit, // defaults to 0, meaning only participants with no wins are eligible
    requireLoss, // optional boolean - defaults to true; if false then all participants who have played and appear in MAIN draw are considered
    requirePlay, // optional boolean - defaults to true; if false then all participants who appear in MAIN draw are considered
    allEntries, // optional boolean - consider all entries, regardless of whether placed in draw
    includeEventParticipants, // optional boolean - consider event entries rather than draw entries (if event is present)
    drawId,
  });
</code></pre>
<hr>
<h2 id="getentriesandseedscount">getEntriesAndSeedsCount</h2>
<pre><code class="language-js">const { error, entries, seedsCount, stageEntries } =
  tournamentEngine.getEntriesAndSeedsCount({
    policyDefinitions, // seeding policy which determines # of seeds for # of participants/drawSize
    eventId,
    drawSize, // optional - overrides number calculaed from entries in either event or draw
    drawId, // optional - scopes entries to a specific flight/drawDefinition
    stage, // optional - scopes entries to a specific stage
  });
</code></pre>
<hr>
<h2 id="getentrystatusreports">getEntryStatusReports</h2>
<pre><code class="language-js">const {
  tournamentEntryReport: {
    nonParticipatingEntriesCount,
    individualParticipantsCount,
    drawDefinitionsCount,
    eventsCount,
  },
  entryStatusReports, // count and pct of total for all entryStatuses for each event
  participantEntryReports, // person entryStatus, ranking, seeding, WTN and confidence for each event
  eventReports, // primarily internal use - entries for each event with main/qualifying seeding
} = tournamentEngine.getEntryStatusReports();
</code></pre>
<p>To export reports as CSV:</p>
<pre><code class="language-js">const entryStatusCSV = utilities.JSON2CSV(entryStatusReports);
const personEntryCSV = utilities.JSON2CSV(participantEntryReports);
</code></pre>
<hr>
<h2 id="getevent">getEvent</h2>
<p>Get an event by either its <code>eventId</code> or by a <code>drawId</code> which it contains. Also returns <code>drawDefinition</code> if a <code>drawId</code> is specified.</p>
<pre><code class="language-js">const {
  event,
  drawDefinition, // only returned if drawId is specified
} = tournamentEngine.getEvent({
  eventId, // optional - find event by eventId
  drawId, // optional - find the event which contains specified drawId
});
</code></pre>
<hr>
<h2 id="getevents">getEvents</h2>
<p>Return <strong>deepCopies</strong> of all events in a tournament record.</p>
<pre><code class="language-js">const { events } = tournamentEngine.getEvents({
  withScaleValues, // optional boolean
  scaleEventType, // override event.eventType for accessing scales, e.g. SINGLES override for DOUBLES events
  inContext, // optional boolean hydrates with tournamentId
  eventIds, // optional array
  drawIds, // optional array
  context, // optional object to spread into all targeted events
});
</code></pre>
<hr>
<h2 id="geteventdata">getEventData</h2>
<p>Returns event information optimized for publishing: <code>matchUps</code> have context and separated into rounds for consumption by visualization libraries such as <code>tods-react-draws</code>.</p>
<p>See <a href="#publishevent">publishEvent</a> for details on <code>policyDefinitions</code>.</p>
<pre><code class="language-js">const { eventData } = tournamentEngine.getEventData({
  participantsProfile, // optional - ability to specify additions to context (see parameters of getParticipants())
  policyDefinitions, // optional
  usePublishState, // optional - filter out draws which are not published
  eventId,
});
const { drawsData, venuesData, eventInfo, tournamentInfo } = eventData;
</code></pre>
<hr>
<h2 id="geteventtimeitem">getEventTimeItem</h2>
<pre><code class="language-js">const { timeItem } = tournamentEngine.getEventTimeItem({
  itemType: ADD_SCALE_ITEMS,
  itemSubTypes: [SEEDING], // optional
  eventId,
});
</code></pre>
<hr>
<h2 id="geteventproperties">getEventProperties</h2>
<p>Gather attributes of events which come from other tournament elements, e.g. participants which have rankings/ratings/seedings for a given event.</p>
<pre><code class="language-js">const {
  entryScaleAttributes,
  hasSeededParticipants,
  hasRankedParticipants,
  hasRatedParticipants,
} = tournamentEngine.getEventProperties({ eventId });
</code></pre>
<p>... where <strong>entryScaleAttributes</strong> is an array of <code>{ participantId, participantName, seed, ranking, rating }</code></p>
<hr>
<h2 id="geteventmatchupformattiming">getEventMatchUpFormatTiming</h2>
<p>Method is used internally in advanced scheduling to determine averageMatchUp times for matchUps within an event.</p>
<p>Requires an array of <code>matchUpFormats</code> either be defined in scoring policy that is attached to the tournamentRecord or an event, or passed in as parameter. <code>matchUpFormats</code> can be passed either as an array of strings, or an array of <code>[{ matchUpFormat }]</code>.</p>
<pre><code class="language-js">const { eventMatchUpFormatTiming } =
  tournamentEngine.getEventMatchUpFormatTiming({
    matchUpFormats, // optional - can be retrieved from policy
    categoryType, // optional - categoryType is not part of TODS or event attributes, but can be defined in a policy
    eventId,
  });
</code></pre>
<hr>
<h2 id="geteventstructures">getEventStructures</h2>
<pre><code class="language-js">const { structures, stageStructures } = tournamentEngine.getEventStructures({
  withStageGrouping: true, // optional return structures grouped by stages
  stageSequences, // optional - specify stageSequences to include
  stageSequence, // optional - filter by stageSequence
  stages, // optional - specify stageSequences to include
  stage, // optional - filter by stage
  eventId, // REQUIRED
});
</code></pre>
<hr>
<h2 id="getflightprofile">getFlightProfile</h2>
<p>A <code>flightProfile</code> is an extension on an <code>event</code> detailing the parameters that will be used to generate <code>drawDefinitions</code> within the <code>event</code>. There is an array of <code>flights</code> which specify attributes of a draw such as <code>drawEntries, drawName, drawId, flightNumber</code> as well as <code>stage</code>, which is significant for flights which are only intended to reflect VOLUNTARY_CONSOLATION structures. A Voluntary Consolation flight is &quot;linked&quot; to the flight from which competitors originate and will be automatically deleted if the source flight is deleted.</p>
<p>If a <code>flight</code> has already been used to generate a draw, the <code>drawDefinition</code> will be returned with the profile.</p>
<pre><code class="language-js">const { flightProfile } = tournamentEngine.getFlightProfile({ eventId });
</code></pre>
<hr>
<h2 id="getmatchupcompetitiveprofile">getMatchUpCompetitiveProfile</h2>
<p>Returns a categorization of a matchUp as &quot;Competitive&quot;, &quot;Routine&quot; or &quot;Decisive&quot;</p>
<pre><code class="language-js">const {
  competitiveness, // [COMPETITIVE, DECISIVE, ROUTINE]
  pctSpread, // 0-100 - rounded loser&#x27;s percent of games required to win
} = tournamentEngine.getMatchUpCompetitiveProfile({
  profileBands, // optional { [DECISIVE]: 20, [ROUTINE]: 50 } // can be attached to tournamentRecord as a policy
  matchUp,
});
</code></pre>
<hr>
<h2 id="getmatchupdependencies">getMatchUpDependencies</h2>
<p>For each <code>matchUpId</code> returns an array of other <code>matchUpIds</code> which occur earlier in the draw.</p>
<p>Optionally returns an array of <code>participantIds</code> which could potentially appear in each <code>matchUp</code>;
used internally to ensure that auto scheduling respects the <code>timeAfterRecovery</code> of all potential participants.</p>
<pre><code class="language-js">const {
  matchUpDependencies: {
    [matchUpId]: {
      matchUpIds: [matchUpIdDependency], // array of all matchUpIds which occur prior to this matchUpId in the draw; crosses all structures
      participantIds: [potentialParticipantIds], // array of all participantIds which could potentially appear in this matchUp
      dependentMatchUpIds: [dependentMatchUpId], // array of matchUpIds which occur after this matchUpId in the draw; crosses all structures
    },
  },
} = tournamentEngine.getMatchUpDependencies({
  includeParticipantDependencies, // boolean - defaults to false
  drawIds, // optional array of drawIds to scope the analysis
});
</code></pre>
<hr>
<h2 id="getmatchupformat">getMatchUpFormat</h2>
<p>Returns <code>matchUpFormat</code> codes for specified context(s). Refer to <code>getMatchUpFormat.test.js</code> for specfic use cases.</p>
<p><code>matchUpFormat</code> for each matchUp is determined by traversing the hierarchy: <code>matchUp =&gt; stucture =&gt; drawDefinition =&gt; event</code></p>
<pre><code class="language-js">const {
  matchUpFormat,
  structureDefaultMatchUpFormat,
  drawDefaultMatchUpFormat,
  eventDefaultMatchUpFormat,
} = tournamentEngine.getMatchUpFormat({
  eventId,
  drawId,
  structureId,
  matchUpId,
});
</code></pre>
<hr>
<h2 id="getmatchupformattiming">getMatchUpFormatTiming</h2>
<p>Searches for policy definitions or extensions to determine the <code>averageMinutes</code> and <code>recoveryMinutes</code> for a given <code>matchUpFormat</code>. Extensions are considered to be overrides of policy definitions.</p>
<pre><code class="language-js">const { averageMinutes, recoveryMinutes } =
  tournamentEngine.getMatchUpFormatTiming({
    defaultAverageMinutes, // optional setting if no matching definition found
    defaultRecoveryMinutes, // optional setting if no matching definition found
    matchUpFormat,
    categoryName, // optional
    categoryType, // optional
    eventType, // optional - defaults to SINGLES; SINGLES, DOUBLES
    eventId, // optional - prioritizes policy definition attached to event before tournament record
  });
</code></pre>
<hr>
<h2 id="getmatchupformattimingupdate">getMatchUpFormatTimingUpdate</h2>
<p>Returns an array of methods/params necessary for updating a remote instance of a tournamentRecord to match a local instance. This method enables multiple &quot;provisional&quot; updates to be made on a local document without contacting a server; support deployments where a server is considered &quot;master&quot;.</p>
<pre><code class="language-js">const { methods } = tournamentEngine.getMatchUpFormatTimingUpdate();
</code></pre>
<hr>
<h2 id="getmatchupscheduledetails">getMatchUpScheduleDetails</h2>
<p>Returns the latest values for all <code>matchUp.timeItems</code>, along with calculated values, that relate to the scheduling of a <code>matchUp</code>.</p>
<pre><code class="language-js">const {
  schedule: {
    time,
    courtId,
    venueId,
    startTime,
    endTime,
    milliseconds,
    scheduledDate,
    scheduledTime,
    allocatedCourts: [{ venueId, courtid }], // applies only to TEAM matchUps
  },
} = tournamentEngine.getMatchUpScheduleDetails({
  scheduleVisibilityFilters, // { visibilityThreshold: Date, eventIds, drawIds }
  matchUp,
});
</code></pre>
<hr>
<h2 id="getmatchupsstats">getMatchUpsStats</h2>
<p>Returns percentages of matchUps which fall into <code>cmpetitiveBands</code> defined as &quot;Competitive&quot;, &quot;Routine&quot;, and &quot;Decisive&quot;.</p>
<pre><code class="language-js">const { competitiveBands } = tournamentEngine.getMatchUpsStats({
  profileBands, // optional { [DECISIVE]: 20, [ROUTINE]: 50 } // can also be set in policyDefinitions
  matchUps,
});
</code></pre>
<hr>
<h2 id="getmatchupdailylimits">getMatchUpDailyLimits</h2>
<p>Returns player daily match limits for singles/doubles/total matches.</p>
<pre><code class="language-js">const { matchUpDailyLimits } = tournamentId.getMatchUpDailyLimits();
const { DOUBLES, SINGLES, total } = matchUpDailyLimits;
</code></pre>
<hr>
<h2 id="getmodifiedmatchupformattiming">getModifiedMatchUpFormatTiming</h2>
<p>Returns <code>averageTimes</code> and <code>recoveryTimes</code> configuration objects for specified <code>matchUpFormat</code>. Useful before calling <code>modifyMatchUpFormatTiming</code> to preserve existing modifications.</p>
<pre><code class="language-js">const { matchUpFormat, averageTimes, recoveryTimes } =
  tournamentEngine.getModifiedMatchUpFormatTiming({
    matchUpFormat, // TODS matchUpFormat code
    event, // optional - include event in scope for search
  });
</code></pre>
<hr>
<h2 id="getpairedparticipant">getPairedParticipant</h2>
<p>Returns the <code>{ participantType: PAIR }</code>, if any, which contains the specified <code>individualParticipantIds</code>.</p>
<pre><code class="language-js">const { participant } = tournamentEngine.getPairedParticipant({
  participantIds: individualParticipantIds,
});
</code></pre>
<hr>
<h2 id="getparticipanteventdetails">getParticipantEventDetails</h2>
<p>Returns an array of eventDetails in which a specified <code>participantId</code> appears. For details on draw entry within events use <code>tournamentEngine.getParticipants({ inContext: true })</code>.</p>
<pre><code class="language-js">const { eventDetails } = tournamentEngine.getParticipantEventDetails({
  participantId,
});

const [{ eventName, eventId }] = eventDetails;
</code></pre>
<hr>
<h2 id="getparticipantidfinishingpositions">getParticipantIdFinishingPositions</h2>
<p>Returns the Range of finishing positions possible for all participantIds within a draw</p>
<pre><code class="language-js">const idMap = tournamentEngine.getParticipantIdFinishingPositions({
  byeAdvancements, // optional boolean - whether or not to consider byeAdvancements
  drawId,
});

const { relevantMatchUps, finishingPositionRanges, finishingPositionRange } =
  idMap[&#x27;participantId&#x27;];
</code></pre>
<hr>
<h2 id="getparticipantmembership">getParticipantMembership</h2>
<p>Returns all grouping participants which include <code>participantId</code> in <code>{ individualParticipantIds }</code>.</p>
<pre><code class="language-js">const {
  [PAIR]: doublesParticipantIds,
  [GROUP]: groupParticipantIds,
  [TEAM]: teamParticipantIds,
} = tournamentEngine.getParticipantMembership({
  participantId,
});
</code></pre>
<hr>
<h2 id="getparticipants">getParticipants</h2>
<p>Returns <strong>deepCopies</strong> of competition participants filtered by participantFilters which are arrays of desired participant attribute values. This method is an optimization of <code>getCompetitionParticipants</code> and will replace it going forward.</p>
<pre><code class="language-js">const participantFilters = {
  accessorValues: [{ accessor, value }], // optional - see Accessors in Concepts
  eventEntryStatuses, // boolean
  participantTypes: [INDIVIDUAL],
  participantRoles, [COMPETITOR],
  signInStatus, // specific signIn status
  eventIds, // events in which participants appear
};
const {
  participantIdsWithConflicts, // returns array of participantIds which have scheduling conflicts
  competitionParticipants,
  eventsPublishStatuses,
  derivedEventInfo,
  derivedDrawInfo,
  participantsMap, // object { [&#x27;participantId&#x27;]: participant }
  mappedMatchUps, // object { [matchUpId]: matchUp }; when { withMatchUps: true }
  participants, // array of participants
  matchUps, // array of all matchUps; when { withMatchUps: true }
 } =
  tournamentEngine.getParticipants({
    convertExtensions, // optional - BOOLEAN - convert extensions so _extensionName attributes
    participantFilters, // optional - filters
    policyDefinitions, // optional - can accept a privacy policy to filter participant attributes
    usePublishState, // optional - BOOLEAN - don&#x27;t add seeding information when not published
    scheduleAnalysis: {
      scheduledMinutesDifference // optional - scheduling conflicts determined by scheduledTime difference between matchUps
    },
    usePublishState,  // optional boolean
    withDraws, // optional - defaults to true if any other context options are specified
    withEvents, // optional - defaults to true if any other context options are specified
    withGroupings, // optional - include membership in group, pair, and team participants
    withIndividualParticipants, // optional - include hydrated individualParticiapnts for TEAM/PAIR participants
    withIOC, // optional - will add IOC country code and countryName to participant persons
    withISO2, // optional - will add ISO2 country code and countryName to participant persons
    withMatchUps, // optional - include all matchUps in which the participant appears, as well as potentialMatchUps
    withOpponents, // optional - include opponent participantIds
    withPotentialMatchUps, // optional boolean
    withRankingProfile, // optional boolean - include details necessary for point awards
    withScaleValues, // optional - include { ratings, rankings } attributes extracted from timeItems
    withSeeding, // optionsl - add event seeding
    withScheduleItems, // optional boolean - include array of scheduled matchUp details
    withSignInStatus, // optional boolean
    withStatistics, // optional - adds events, matchUps and statistics, e.g. &#x27;winRatio&#x27;
    withTeamMatchUps // optional boolean
  });
</code></pre>
<h3 id="participantfilters">participantFilters</h3>
<ul>
<li>enableOrFiltering: boolean - use OR logic instead of default AND</li>
<li>accessorValues: array of accessors and targeted value <code>[{ accessor, value }]</code></li>
<li>drawEntryStatuses: array of <code>entryStatus</code> values for participantIds found in draw.entries</li>
<li>eventEntryStatuses: array of <code>entryStatus</code> values for participantIds found in event.entries</li>
<li>eventIds: array of targeted eventIds</li>
<li>participantIds: array of targeted participantIds</li>
<li>participantRoles: array of targeted participantRoles</li>
<li>participantTypes: array of targeted participantTypes</li>
<li>positionedParticipants: participantIds positioned in structures <code>[true, false, undefined]</code></li>
<li>signInStatus: SIGNED_IN or SIGNED_OUT</li>
</ul>
<hr>
<h2 id="getparticipantscaleitem">getParticipantScaleItem</h2>
<p>Return a ranking or rating or seeding value for a participant, referenced by participantId.</p>
<p>See <a href="../concepts/scaleItems">Scale Items</a>.</p>
<pre><code class="language-js">const scaleAttributes = {
  scaleType: RATING,
  eventType: SINGLES,
  scaleName: &#x27;WTN&#x27;,
  accessor, // optional - string determining how to access attribute if scaleValue is an object
};
const {
  scaleItem: { scaleValue },
} = tournamentEngine.getParticipantScaleItem({
  scaleAttributes,
  participantId,
});
</code></pre>
<hr>
<h2 id="getparticipantschedules">getParticipantSchedules</h2>
<pre><code class="language-js">const { participantSchedules } = tournamentEngine.getParticipantSchedules({
  participantFilters: { participantIds, participantTypes, eventIds },
});
</code></pre>
<hr>
<h2 id="getparticipantsigninstatus">getParticipantSignInStatus</h2>
<p>Participant signInStatus can be either &#x27;SIGNED_IN&#x27; or &#x27;SIGNED_OUT&#x27; (or undefined). See <a href="#modifyparticipantssigninstatus">modifyParticipantsSignInStatus</a>.</p>
<pre><code class="language-js">const signInStatus = tournamentEngine.getParticipantSignInStatus({
  participantId,
});
</code></pre>
<hr>
<h2 id="getpolicydefinitions">getPolicyDefinitions</h2>
<p>Finds policies which have been attached to the tournamentRecord, or to a target event, or target drawDefinition, in reverse order.
Once a matching <code>policyType</code> has been found, higher level policies of the same type are ignored, enabling a default policy to be attached to the tournamentRecord and for event-specific or draw-specific policies to override the default(s).</p>
<p>The constructed <code>policyDefinitions</code> object contains targeted policies from all levels, scoped to the lowest level specified.</p>
<p>See <a href="../concepts/policies">Policies</a>.</p>
<pre><code class="language-js">const { policyDefinitions } = tournamentEngine.getPolicyDefinitions({
  policyTypes: [POLICY_TYPE_SEEDING],
  eventId, // optional
  drawId, // optional
});
</code></pre>
<hr>
<h2 id="getpositionassignments">getPositionAssignments</h2>
<p>Returns an array of <code>positionAssignments</code> for a structure. Combines <code>positionAssginments</code> for child structures in the case of ROUND_ROBIN where <code>{ structureType: CONTAINER }</code>.</p>
<pre><code class="language-js">let { positionAssignments } = tournamentEngine.getPositionAssignments({
  structureId, // optional if { structure } is provided
  structure, // optional if { drawId, structureId } are provided
  drawId, // optional if { structure } is provided
});

const [{ drawPosition, participantId, qualifier, bye }] = positionAssignments;
</code></pre>
<hr>
<h2 id="getpredictiveaccuracy">getPredictiveAccuracy</h2>
<pre><code class="language-js">const { accuracy, zoneDistribution } = tournamentEngine.getPredictiveAccuracy({
  exclusionRule: { valueAccessor: &#x27;confidence&#x27;, range: [0, 70] }, // exclude low confidence values

  zoneMargin: 3, // optional - creates +/- range and report competitiveness distribution
  zonePct: 20, // optional - precedence over zoneMargin, defaults to 100% of rating range

  valueAccessor: &#x27;wtnRating&#x27;, // optional if `scaleName` is defined in factory `ratingsParameters`
  ascending: false, // optional - scale goes from low to high with high being the &quot;best&quot;
  scaleName: WTN,
});
</code></pre>
<hr>
<h2 id="getroundmatchups">getRoundMatchUps</h2>
<p>Organizes matchUps by roundNumber. <strong>roundMatchUps</strong> contains matchUp objects; <strong>roundProfile</strong> provides an overview of drawPositions which have advanced to each round, a matchUpsCount, finishingPositionRange for winners and losers, and finishingRound.</p>
<pre><code class="language-js">const { roundMatchUps, roundProfile } = tournamentEngine.getRoundMatchUps({
  matchUps,
});
</code></pre>
<hr>
<h2 id="getscaledentries">getScaledEntries</h2>
<p>See <a href="../concepts/scaleItems">Scale Items</a>.</p>
<pre><code class="language-js">const { scaledEntries } = tournamentEngine.getScaledEntries({
  eventId, // optional - not required if provided array of entries
  entries, // optional - overrides use of event.entries
  stage, // optional - filter entries by stage

  scaleAttributes,
  scaleSortMethod, // optional - function(a, b) {} sort method, useful when scaleValue is an object or further proessing is required
  sortDescending, // optional - default sorting is ASCENDING; only applies to default sorting method.
});
</code></pre>
<hr>
<h2 id="getseedscount">getSeedsCount</h2>
<p>Takes a policyDefinition, drawSize and participantsCount and returrns the number of seeds valid for the specified drawSize</p>
<admonition type="note"><p><code>drawSizeProgression</code> will be overridden by a <code>{ drawSizeProgression }</code> value in a policyDefinition.</p></admonition>
<pre><code class="language-js">const { seedsCount, error } = tournamentEngine.getSeedsCount({
  drawSizeProgression, // optional - fits the seedsCount to the participantsCount rather than the drawSize
  policyDefinitions: SEEDING_USTA,
  participantsCount: 15,
  drawSize: 128,
});
</code></pre>
<hr>
<h2 id="getstate">getState</h2>
<p>Returns a deep copy of the current tournamentEngine state.</p>
<pre><code class="language-js">const { tournamentRecord } = tournamentEngine.getState({
  convertExtensions, // optional - convert extensions to &#x27;_&#x27; prefixed attributes
  removeExtensions, // optional - strip all extensions out of tournamentRecord
});
</code></pre>
<hr>
<h2 id="getstructurereports">getStructureReports</h2>
<p>Returns details of all structures within a tournamentRecord, as well as aggregated details per event.</p>
<p><code>tournamentId, eventId, structureId, drawId, eventType, category: subType, categoryName, ageCategoryCode, flightNumber, drawType, stage, winningPersonId, winningPersonWTNrating, winningPersonWTNconfidence, winningPerson2Id, winningPerson2WTNrating, winningPerson2WTNconfidence, positionManipulations, pctNoRating, matchUpFormat, pctInitialMatchUpFormat, matchUpsCount, tieFormatDesc, tieFormatName, avgConfidence, avgWTN</code></p>
<pre><code class="language-js">const {
  structureReports,
  eventStructureReports: {
    totalPositionManipulations,
    maxPositionManipulations,
    generatedDrawsCount,
    drawDeletionsCount,
  },
} = tournamentEngine.getStructureReports({
  firstFlightOnly, // boolean - defaults to true - only return first flight when multiple drawDefinitions per event
  extensionProfiles: [
    {
      name, // extension name
      label, // label for generated attribute
      accessor, // dot-notation accessor for extension value, e.g. &#x27;attribute.attribute&#x27;
    },
  ],
});
</code></pre>
<p>To export report as CSV:</p>
<pre><code class="language-js">const csv = utilities.JSON2CSV(structureReports);
</code></pre>
<hr>
<h2 id="getteamlineup">getTeamLineUp</h2>
<pre><code class="language-js">const { lineUp } = tournamentEngine.getTeamLineUp({ drawId, participantId });
</code></pre>
<hr>
<h2 id="gettieformat">getTieFormat</h2>
<p>Returns <code>tieFormat</code> definition objects for specified context(s).</p>
<p><code>tieFormat</code> for each matchUp is determined by traversing the hierarchy: <code>matchUp =&gt; stucture =&gt; drawDefinition =&gt; event</code></p>
<pre><code class="language-js">const {
  tieFormat,
  structureDefaultTieFormat,
  drawDefaultTieFormat,
  eventDefaultTieFormat,
} = tournamentEngine.getTieFormat({
  structureId,
  matchUpId,
  eventId,
  drawId,
});
</code></pre>
<hr>
<h2 id="gettournamentinfo">getTournamentInfo</h2>
<p>Returns tournament attributes. Used to attach details to publishing payload by <code>getEventData</code>.</p>
<pre><code class="language-js">const { tournamentInfo } = getTournamentInfo({ tournamentRecord });
const {
  tournamentId,
  tournamentRank,

  formalName,
  tournamentName,
  promotionalName,
  onlineResources,

  localTimeZone,
  startDate,
  endDate,

  hostCountryCode,
  tournamentContacts,
  tournamentAddresses,
} = tournamentInfo;
</code></pre>
<hr>
<h2 id="gettournamentparticipants">getTournamentParticipants</h2>
<admonition type="warning"><p>TO BE DEPRECATED: transition to use <code>getParticipants()</code></p></admonition>
<p>Returns <strong>deepCopies</strong> of tournament participants filtered by participantFilters which are arrays of desired participant attribute values.</p>
<pre><code class="language-js">const participantFilters = {
  accessorValues: [{ accessor, value }], // optional - see Accessors in Concepts
  eventEntryStatuses, // boolean
  participantTypes: [INDIVIDUAL],
  participantRoles, [COMPETITOR],
  signInStatus, // specific signIn status
  eventIds, // events in which participants appear
};
const {
  tournamentParticipants,
  participantIdsWithConflicts //  returns array of participantIds which have scheduling conflicts
  eventsPublishStatuses: { publishedDrawIds, publishedSeeding }, // useful for presenting tournament participants on public sites
} = tournamentEngine.getTournamentParticipants({
  inContext, // optional - adds individualParticipants for all individualParticipantIds

  withMatchUps, // optional - include all matchUps in which the participant appears, as well as potentialMatchUps
  withScaleValues, // optional - include { ratings, rankings } attributes extracted from timeItems
  withStatistics, // optional - adds events, matchUps and statistics, e.g. &#x27;winRatio&#x27;
  withGroupings, // optional - include membership in group, pair, and team participants
  withOpponents, // optional - include opponent participantIds
  withSeeding, // optionsl - add event seeding
  withEvents, // optional - defaults to true if any other context options are specified
  withDraws, // optional - defaults to true if any other context options are specified
  withISO2, // optional - will add ISO2 country code and countryName to participant persons
  withIOC, // optional - will add IOC country code and countryName to participant persons

  scheduleAnalysis: {
    scheduledMinutesDifference // optional - scheduling conflicts determined by scheduledTime difference between matchUps
  },

  convertExtensions, // optional - BOOLEAN - convert extensions so _extensionName attributes
  policyDefinitions, // optional - can accept a privacy policy to filter participant attributes
  participantFilters, // optional - filters
  usePublishState, // optional - BOOLEAN - don&#x27;t add seeding information when not published
});
</code></pre>
<h3 id="implemented-participantfilters">Implemented participantFilters</h3>
<ul>
<li>enableOrFiltering: boolean - use OR logic instead of default AND</li>
<li>accessorValues: array of accessors and targeted value <code>[{ accessor, value }]</code></li>
<li>drawEntryStatuses: array of <code>entryStatus</code> values for participantIds found in draw.entries</li>
<li>eventEntryStatuses: array of <code>entryStatus</code> values for participantIds found in event.entries</li>
<li>eventIds: array of targeted eventIds</li>
<li>participantIds: array of targeted participantIds</li>
<li>participantRoles: array of targeted participantRoles</li>
<li>participantTypes: array of targeted participantTypes</li>
<li>positionedParticipants: participantIds positioned in structures <code>[true, false, undefined]</code></li>
<li>signInStatus: SIGNED_IN or SIGNED_OUT</li>
</ul>
<hr>
<h2 id="gettournamentpersons">getTournamentPersons</h2>
<p>Returns <strong>deepCopies</strong> of persons extracted from tournament participants. Each person includes an array of <code>participantIds</code> from which person data was retrieved.</p>
<pre><code class="language-js">const { tournamentPersons } = tournamentEngine.getTournamentPersons({
  participantFilters: { participantRoles: [COMPETITOR] }, // optional - filters
});
</code></pre>
<hr>
<h2 id="gettournamentpenalties">getTournamentPenalties</h2>
<p>Returns an array of all penalties issued during a tournament.</p>
<pre><code class="language-js">const { penalties } = tournamentEngine.getTournamentPenalties();
</code></pre>
<hr>
<h2 id="gettournamentstructures">getTournamentStructures</h2>
<pre><code class="language-js">const { structures, stageStructures } =
  tournamentEngine.getTournamentStructures({
    withStageGrouping: true, // optional return structures grouped by stages
    stageSequences, // optional - specify stageSequences to include
    stageSequence, // optional - filter by stageSequence
    stages, // optional - specify stageSequences to include
    stage, // optional - filter by stage
  });
</code></pre>
<hr>
<h2 id="getvenuesandcourts">getVenuesAndCourts</h2>
<p>Returns an array of all Venues which are part of a tournamentRecord and an aggregation of courts across all venues.</p>
<pre><code class="language-js">const { venues, courts } = tournamentEngine.getVenuesAndCourts({
  convertExtensions, // optional boolean
  ignoreDisabled, // optional boolean
  dates, // optional - used with ignoreDisabled - applies to courts
});
</code></pre>
<hr>
<h2 id="getvenuedata">getVenueData</h2>
<p>Returns restricted venue attributes along with information for all associated courts. Used primarily by <code>getEventData</code> to return a subset of venue/courts information for publishing purposes.</p>
<pre><code class="language-js">const {
  venueName,
  venueAbbreviation,
  courtsInfo, // array of courts and associated attributes
} = tournamentEngine.getVenueData({ venueId });
</code></pre>
<hr>
<h2 id="isvalidmatchupformat">isValidMatchUpFormat</h2>
<p>Returns boolean indicating whether matchUpFormat code is valid.</p>
<pre><code class="language-js">const valid = tournamentEngine.isValidMatchUpFormat(matchUpFormat);
</code></pre>
<hr>
<h2 id="luckyloserdrawpositionassignment">luckyLoserDrawPositionAssignment</h2>
<p>Replaces an existing drawPosition assignment with a luckyLoserParticipantId. This method is included in <code>validActions</code> for <a href="../policies/positionActions">positionActions</a></p>
<pre><code class="language-js">tournamentEngine.luckyLoserDrawPositionAssignment({
  luckyLoserParticipantId,
  drawPosition,
  structureId,
  drawId,
});
</code></pre>
<hr>
<h2 id="matchupactions">matchUpActions</h2>
<p>Return an array of all validActions for a specific matchUp.</p>
<pre><code class="language-js">const {
  isByeMatchUp, // boolean; true if matchUp includes a BYE
  structureIsComplete, // boolean; true if structure is ready for positioning
  validActions, // array of possible actions given current matchUpStatus
} = tournamentEngine.matchUpActions({
  restrictAdHocRoundParticipants, // optional - true by default; applies to AD_HOC; disallow the same participant being in the same round multiple times
  sideNumber, // optional - select side to which action should apply; applies to AD_HOC position assignments
  matchUpId, // required - reference to targeted matchUp
  drawId, // optional - not strictly required; method will find matchUp by brute force without it
});

const {
  type, // &#x27;REFEREE&#x27;, &#x27;SCHEDULE&#x27;, &#x27;PENALTY&#x27;, &#x27;STATUS&#x27;, &#x27;SCORE&#x27;, &#x27;START&#x27;, &#x27;END&#x27;, &#x27;SUBSTITUTION&#x27;.
  method, // tournamentEngine method relating to action type
  payload, // attributes to be passed to method
  // additional method-specific options for values to be added to payload when calling method
} = validAction;
</code></pre>
<hr>
<h2 id="mergeparticipants">mergeParticipants</h2>
<p>Merge <code>participants</code> array with existing tournament participants. Useful when synchronizing with a remote registration service, for example.</p>
<pre><code class="language-js">tournamentEngine.mergeParticipants({ participants });
</code></pre>
<hr>
<h2 id="modifycollectiondefinition">modifyCollectionDefinition</h2>
<p>Modifies the <code>collectionName</code> and/or <code>matchUpFormat</code> for targeted <code>collectionId</code> within the <code>tieFormat</code> specified by <code>eventId</code>, <code>drawId</code>, <code>structureId</code> or <code>matchUpId</code>.</p>
<pre><code class="language-js">tournamentEngine.modifyCollectionDefinition({
  collectionName, // optional
  matchUpFormat, // optional
  collectionId, // required
  structureId, // required if modifying tieFormat for a structure
  matchUpId, // required if modifying tieFormat for a matchUp
  eventId, // required if modifying tieFormat for a event
  drawId, // required if modifying tieFormat for a drawDefinition or a structure
  gender, // optional

  // value assignment, only one is allowed to have a value
  collectionValueProfiles, // optional - [{ collectionPosition: 1, value: 2 }] - there must be a value provided for all matchUp positions
  collectionValue, // optional - value awarded for winning more than half of the matchUps in the collection
  matchUpValue, // optional - value awarded for each matchUp won
  scoreValue, // optional - value awarded for each game or point won (points for tiebreak sets)
  setValue, // optional - value awarded for each set won
});
</code></pre>
<hr>
<h2 id="modifycourt">modifyCourt</h2>
<pre><code class="language-js">tournamentEngine.modifyCourt({
  courtId,
  force, // applies only to dateAvailability, will remove scheduling information from matchUps where court is no longer available
  modifications: {
    courtName,
    dateAvailability,
    courtDimensions,
    onlineResources,
    surfaceCategory,
    surfacedDate,
    surfaceType,
    altitude,
    latitude,
    longitude,
    notes,
    pace,
  },
});
</code></pre>
<hr>
<h2 id="modifycourtavailability">modifyCourtAvailability</h2>
<p>Modifies the <code>dateAvailability</code> attribute of a specified court. Warns if existing scheduled matchUps would be affected. See <a href="/docs/concepts/scheduling">Scheduling</a>.</p>
<pre><code class="language-js">const result = tournamentEngine.modifyCourtAvailability({
  dateAvailability,
  courtId,
  force, // override warning that existing scheduled matchUps exist
});
</code></pre>
<hr>
<h2 id="modifydrawdefinition">modifyDrawDefinition</h2>
<pre><code class="language-js">tournamentEngine.modifyDrawDefinition({
  drawUpdates: { policyDefinitions: { ...policies } },
  drawName: &#x27;League Play&#x27;,
  drawId,
});
</code></pre>
<hr>
<h2 id="modifymatchupformattiming">modifyMatchUpFormatTiming</h2>
<pre><code class="language-js">tournamentEngine.modifyMatchUpFormatTiming({
  matchUpFormat: &#x27;SET3-S:6/TB7&#x27;,
  averageTimes: [
    {
      categoryNames: [U12, U14],
      minutes: { [DOUBLES]: 110, default: 130 },
    },
    {
      categoryNames: [U16, U18],
      minutes: { [DOUBLES]: 100, default: 120 },
    },
  ],
  recoveryTimes: [
    { categoryNames: [], minutes: { default: 15, [DOUBLES]: 15 } },
  ],
});
</code></pre>
<hr>
<h2 id="modifyentriesstatus">modifyEntriesStatus</h2>
<p>Modify the entryStatus of participants already in an event or flight/draw. Does not allow participants assigned positions in structures to have an entryStatus of WITHDRAWN.</p>
<pre><code class="language-js">const result = tournamentEngine.modifyEntriesStatus({
  autoEntryPositions, // optional - keeps entries ordered by entryStage/entryStatus and auto-increments
  participantIds, // ids of participants whose entryStatus will be modified
  entryStatus, // new entryStatus
  entryStage, // optional - e.g. QUALIFYING
  eventSync, // optional - if there is only a single drawDefinition in event, keep event.entries in sync
  extension, // optional - { name, value } - add if value; removes if value is undefined
  eventId, // id of event where the modification(s) will occur
  drawId, // optional - scope to a specific flight/draw
  stage, // optional - scope to a specific stage
});
</code></pre>
<hr>
<h2 id="modifyevententries">modifyEventEntries</h2>
<p>Modify the entries for an event. For DOUBLES events automatically create PAIR participants if not already present.</p>
<pre><code class="language-js">tournamentEngine.modifyEventEntries({
  entryStatus = DIRECT_ACCEPTANCE,
  unpairedParticipantIds = [],
  participantIdPairs = [],
  entryStage = MAIN,
  eventId,
})
</code></pre>
<hr>
<h2 id="modifyevent">modifyEvent</h2>
<pre><code class="language-js">tournamentEngine.modifyEvent({
  eventUpdates: {
    eventGender, // optional - must validate against current event entries, if any
    eventType, // optional - must validate against current event entries, if any
    eventName, // optional
  },
  eventId,
});
</code></pre>
<hr>
<h2 id="modifyeventmatchupformattiming">modifyEventMatchUpFormatTiming</h2>
<pre><code class="language-js">tournamentEngine.modifyEventMatchUpFormatTiming({
  recoveryMinutes,
  averageMinutes,
  matchUpFormat,
  eventId,
});
</code></pre>
<hr>
<h2 id="modifyindividualparticipantids">modifyIndividualParticipantIds</h2>
<p>Modify <code>individualParticipantIds</code> of a grouping participant <code>{ participantType: TEAM || GROUP }</code>.</p>
<pre><code class="language-js">tournamentEngine.devContext(true).modifyIndividualParticipantIds({
  groupingParticipantId, // participant (TEAM or GROUP) to which participantIds are to be added
  individualParticipantIds: newIndividualParticipantIds,
});
</code></pre>
<hr>
<h2 id="modifypairassignment">modifyPairAssignment</h2>
<p>Modifies an individualParticipantId within a PAIR particiapnt entered into an event or draw. Will clean up (delete) any PAIR participants that are not entered into any other draws or events.</p>
<pre><code class="language-js">tournamentEngine.modifyPairAssignment({
  replacementIndividualParticipantId,
  existingIndividualParticipantId,
  participantId,
  eventId, // optional if drawId is provided
  drawId, // optional if eventId is provided; scopes change to specified draw
  uuids, // optional array of uuids for use when generating new participant
});
</code></pre>
<hr>
<h2 id="modifyparticipant">modifyParticipant</h2>
<p>Modifies attributes of a participant with integrity checks to ensure valid values for e.g. <code>{ participantType, participantRole }</code>. Adds participant if not found.</p>
<pre><code class="language-js">tournamentEngine.modifyParticipant({
  participant: updatedIndividualParticipant,
});
</code></pre>
<hr>
<h2 id="modifypenalty">modifyPenalty</h2>
<pre><code class="language-js">const penaltyData = {
  participantIds: [&#x27;participantId&#x27;],
  penaltyType: BALL_ABUSE,
  matchUpId,
  issuedAt,
  notes: &#x27;Hit ball into sea&#x27;,
};
let result = tournamentEngine.addPenalty(penaltyData);
const { penaltyId } = result;

const notes = &#x27;Hit ball into spectator&#x27;;
const modifications = { notes };
tournamentEngine.modifyPenalty({ penaltyId, modifications });
</code></pre>
<hr>
<h2 id="modifyparticipantssigninstatus">modifyParticipantsSignInStatus</h2>
<p>Modify the signInStatus of multiple participants, referenced by participantId.</p>
<pre><code class="language-js">tournamentEngine.modifyParticipantsSignInStatus({
  participantIds: [&#x27;participantId&#x27;],
  signInState: SIGNED_IN,
});
</code></pre>
<hr>
<h2 id="modifyseedassignment">modifySeedAssignment</h2>
<p>Change the display representation of a seedNumber for a specified <code>participantId</code>. This method is included in <code>validActions</code> for <a href="../policies/positionActions">positionActions</a>.</p>
<p>The rationale for <code>seedValue</code> is to be able to, for instance, represent the fifth through the eighth seed as <code>5-8</code>, or simply as <code>5</code>. When there are no restrictions on seed positioning <code>seedValue</code> allows assigning seeding to arbitrary <code>participants</code>.</p>
<pre><code class="language-js">tournamentEngine.modifySeedAssignment({
  participantId,
  structureId,
  seedValue, // display representation such as &#x27;5-8&#x27;
  drawId,
});
</code></pre>
<hr>
<h2 id="modifytieformat">modifyTieFormat</h2>
<p>Both modifies the <code>tieFormat</code> on the target <code>event</code>, <code>drawDefinition</code>, <code>structure</code> or <code>matchUp</code> and adds/deletes <code>tieMatchUps</code> as necessary.</p>
<pre><code class="language-js">tournamentEngine.modifyTieFormat({
  modifiedTieFormat, // will be compared to existing tieFormat that is targeted and differences calculated
  structureId, // required if modifying tieFormat for a structure
  matchUpId, // required if modifying tieFormat for a matchUp
  eventId, // required if modifying tieFormat for a event
  drawId, // required if modifying tieFormat for a drawDefinition or a structure
});
</code></pre>
<hr>
<h2 id="modifyvenue">modifyVenue</h2>
<p>See <a href="/docs/concepts/scheduling">Scheduling</a>.</p>
<pre><code class="language-js">const modifications = {
  venueAbbreviation,
  venueName,

  courts: [
    {
      courtId: &#x27;b9df6177-e430-4a70-ba47-9b9ff60258cb&#x27;,
      courtName: &#x27;Custom Court 1&#x27;,
      dateAvailability: [
        {
          date: &#x27;2020-01-01&#x27;, // if no date is provided then `startTime` and `endTime` will be considered default values
          startTime: &#x27;16:30&#x27;,
          endTime: &#x27;17:30&#x27;,
        },
      ],
    },
  ],
};

tournamentEngine.modifyVenue({ venueId, modifications });
</code></pre>
<hr>
<h2 id="newtournamentrecord">newTournamentRecord</h2>
<p>Creates a new tournamentRecord in tournamentEngine state.</p>
<pre><code class="language-js">tournamentEngine.newTournamentRecord({
  tournamentId, // optional - will be generated if not provided
});

const { tournamentRecord } = tournamentEngine.getState();
</code></pre>
<hr>
<h2 id="ordercollectiondefinitions">orderCollectionDefinitions</h2>
<p>Modify the array order of <code>tieFormat.collectionDefinitions</code> for an <code>event</code>, a <code>drawDefinition</code>, <code>structure</code>, or <code>matchUp</code>.</p>
<pre><code class="language-js">tournamentEngine.orderCollectionDefinitions({
  orderMap: { collectionId1: 1, collectionId2: 2 },
  structureId, // required if modifying tieFormat for a structure
  matchUpId, // required if modifying tieFormat for a matchUp
  eventId, // required if modifying tieFormat for a event
  drawId, // required if modifying tieFormat for a drawDefinition or a structure
});
</code></pre>
<hr>
<h2 id="participantscaleitem">participantScaleItem</h2>
<p>Similar to <a href="#getparticipantscaleitem">getParticipantScaleItem</a> but takes a <code>participant</code> object and doesn&#x27;t require <code>tournamentEngine.setState(tournamentRecord)</code>.</p>
<p>See <a href="../concepts/scaleItems">Scale Items</a>.</p>
<pre><code class="language-js">const scaleAttributes = {
  scaleType: RATING,
  eventType: SINGLES,
  scaleName: &#x27;WTN&#x27;,
  accessor, // optional - string determining how to access attribute if scaleValue is an object
};
const {
  scaleItem: { scaleValue },
} = tournamentEngine.participantScaleItem({
  scaleAttributes,
  participant,
});
</code></pre>
<hr>
<h2 id="participantscheduledmatchups">participantScheduledMatchUps</h2>
<p>Returns <code>matchUps</code> which have been scheduled, organized by <code>scheduledDate</code> and sorted by <code>scheduledTime</code>.</p>
<pre><code class="language-js">const { scheduledMatchUps } = tournamentEngine.participantScheduledMatchUps({
  matchUps,
});
</code></pre>
<hr>
<h2 id="positionactions">positionActions</h2>
<p>Returns valid actions for a given <code>drawPosition</code>. If params includes <code>matchUpId</code> will pass through to <a href="#matchupactions">matchUpActions</a> when called for <strong>AD_HOC</strong> structures.</p>
<pre><code class="language-js">const positionActions = tournamentEngine.positionActions({
  policyDefinitions: positionActionsPolicy, // optional - policy defining what actions are allowed in client context
  returnParticipants, // optional boolean; defaults to true; performance optimization when false requires client to provide participants.
  drawPosition,
  structureId,
  drawId,
});

const {
  isActiveDrawPosition, // boolean
  isByePosition, // boolean
  isDrawPosition, // boolean
  hasPositionAssiged, // boolean
  validActions,
} = positionActions;

const {
  type, // &#x27;ASSIGN&#x27;, &#x27;LUCKY&#x27;, &#x27;SWAP&#x27;, &#x27;BYE&#x27;, &#x27;REMOVE&#x27;
  method, // tournamentEngine method relating to action type
  payload, // attributes to be passed to method
  // additional method-specific options for values to be added to payload when calling method
} = validAction;
</code></pre>
<hr>
<h2 id="promotealternates">promoteAlternates</h2>
<pre><code class="language-js">tournamentEngine.promoteAlternates({
  participantIds,
  // either drawId or eventId are REQUIRED
  eventId, // optional if drawId proided
  drawId, // optional if eventId proided
});
</code></pre>
<hr>
<h2 id="publishevent">publishEvent</h2>
<p>Utilizes <a href="#geteventdata">getEventData</a> to prepare data for display. Differs from <a href="#geteventdata">getEventData</a> in that it modifies the <code>publishState</code> of the event. Subscriptions or middleware may be used to deliver the generated payload for presentation on a public website.</p>
<p>See <a href="../concepts/policies">Policies</a> for more details on <code>policyDefinitions</code>.</p>
<pre><code class="language-js">const policyDefinitions = Object.assign(
  {},
  ROUND_NAMING_POLICY,
  PARTICIPANT_PRIVACY_DEFAULT
);

const { eventData } = tournamentEngine.publishEvent({
  removePriorValues, // optional boolean - when true will delete prior timeItems
  drawIdsToRemove, // optional - drawIds to remove from drawIds already published
  drawIdsToAdd, // optional - drawIds to add to drawIds already published
  drawIds, // optional - array of drawIds within the event to publish

  structureIdsToRemove, // optional - structureIds to remove from structureIds already published
  structureIdsToAdd, // optional - structureIds to add to structureIds already published
  structureIds, // optional array - specify structureIds to publish

  stagesToRemove, // optional array - stages to remove from stages already published
  stagesToAdd, // optional array - stages to add to stages already published
  stages, // optional array - specify stages to publish

  policyDefinitions, // optional - e.g. participant privacy policy (if not already attached)
  eventId, // required - eventId of event to publish
});
</code></pre>
<hr>
<h2 id="publisheventseeding">publishEventSeeding</h2>
<pre><code class="language-js">tournamentEngine.publishEventSeeding({
  removePriorValues, // optional boolean - when true will delete prior timeItems
  stageSeedingScaleNames, // { MAIN: &#x27;mainScaleName&#x27;, QUALIFYING: &#x27;qualifyingScaleName&#x27; } - required if a distinction is made between MAIN and QUALIFYING seeding
  seedingScaleNames, // optional
  drawIds, // optional - publish specific drawIds (flights) within the event
  eventId,
});
</code></pre>
<hr>
<h2 id="publishorderofplay">publishOrderOfPlay</h2>
<pre><code class="language-js">tournamentEngine.publishOrderOfPlay({
  removePriorValues, // optional boolean - when true will delete prior timeItems
  scheduledDates, // optional - if not provided will publish all scheduledDates
  eventIds, // optional - if not provided will publish all eventIds
});
</code></pre>
<hr>
<h2 id="qualifierdrawpositionassignment">qualifierDrawPositionAssignment</h2>
<p>Replaces an existing drawPosition assignment with a qualifierParticipantId. This method is included in <code>validActions</code> for <a href="../policies/positionActions">positionActions</a></p>
<pre><code class="language-js">tournamentEngine.qualifierDrawPositionAssignment({
  qualifierParticipantId,
  drawPosition,
  structureId,
  drawId,
});
</code></pre>
<hr>
<h2 id="regenerateparticipantnames">regenerateParticipantNames</h2>
<p>Regenerate <code>.participantName</code> for SINGLES and DOUBLES <code>participants</code>.</p>
<p>Upper/lower case and order are derived from <code>personFormat</code> string which must contain &quot;last&quot; and may contain &quot;first&quot; or &quot;f&quot;, for first initial.</p>
<pre><code class="language-js">const formats = {
  PAIR: { personFormat: &#x27;LAST&#x27;, doublesJointer: &#x27;/&#x27; },
  INDIVIDUAL: { personFormat: &#x27;LAST, First&#x27; },
};
tournamentEngine.regenerateParticipantNames({ formats });
</code></pre>
<hr>
<h2 id="removecollectiondefinition">removeCollectionDefinition</h2>
<pre><code class="language-js">tournamentEngine.removeCollectionDefinition({
  updateInProgressMatchUps, // optional; defaults to true
  tieFormatComparison, // optional; defaults to false; when true will not delete unique collections on unscored matchUps
  tieFormatName, // any time a collectionDefinition is modified a new name must be provided
  collectionId, // required - id of collectionDefinition to be removed
  structureId, // optional - if removing from tieFormat associated with a specific structure
  matchUpId, // optional - if removing from tieFormat asscoiated with a specific matchUp
  eventId, // optional - if removing from tieFormat asscoiated with an event
  drawId, // required if structureId is specified or if tieFormat associated with drawDefinition is to be modified
});
</code></pre>
<hr>
<h2 id="removecollectiongroup">removeCollectionGroup</h2>
<p>Removes a <code>collectionGroup</code> from the <code>tieFormat</code> found for the <code>event</code>, <code>drawDefinition</code>, <code>structure</code> or <code>matchUp</code>; recalculates</p>
<pre><code class="language-js">tournamentEngine.removeCollectionGroup({
  updateInProgressMatchUps, // optional - defaults to true
  tieFormatName: &#x27;New tieFormat&#x27;, // if no name is provided then there will be no name
  collectionGroupNumber: 1,
  structureId, // optional
  matchUpId, // optional
  eventId, // optional
  drawId, // optional; required if structureId is targeted
});
</code></pre>
<hr>
<h2 id="removedrawdefinitionextension">removeDrawDefinitionExtension</h2>
<pre><code class="language-js">tournamentEngine.removeDrawDefintionExtension({ eventId, drawId, name });
</code></pre>
<hr>
<h2 id="removedrawpositionassignment">removeDrawPositionAssignment</h2>
<p>Clear draw position and optionally replace with a BYE, change entryStatus, or decompose a PAIR participant into UNGROUPED participants (DOUBLES only).</p>
<pre><code class="language-js">removeDrawPositionAssignment({
  drawDefinition,
  structureId,
  drawPosition,
  replaceWithBye, // optional
  entryStatus, // optional - change the entryStatus of the removed participant
  destroyPair, // optional - decompose PAIR participant into UNGROUPED participants
});
</code></pre>
<hr>
<h2 id="removedrawentries">removeDrawEntries</h2>
<p>Removes participantIds from <code>drawDefinition.entries</code> (if generated) as well as any relevent <code>flightProfile.flights</code>.</p>
<pre><code class="language-js">tournamentEngine.removeDrawEntries({
  autoEntryPositions, // optional - keeps entries ordered by entryStage/entryStatus and auto-increments
  participantIds
  eventId,
  stages, // optional array of stages to consider, e.g. [VOLUNTARY_CONSOLATION]
  drawId,
  });
</code></pre>
<hr>
<h2 id="removeevententries">removeEventEntries</h2>
<p>Removes <code>event.entries</code> with integrity checks.</p>
<p>Filters <code>participantIds</code> by specified <code>entryStatuses</code> and/or <code>stage</code>. If no <code>participantIds</code> are provided, removes all <code>entries</code> that match both <code>entryStatuses</code> and <code>stage</code>.</p>
<pre><code class="language-js">tournamentEngine.removeEventEntries({
  autoEntryPositions, // optional - keeps entries ordered by entryStage/entryStatus and auto-increments
  participantIds, // optional array of participantIds to remove
  entryStatuses, // optional array of entryStatuses to remove
  stage, // optional - remove entries for specified stage
  eventId,
});
</code></pre>
<hr>
<h2 id="removeeventextension">removeEventExtension</h2>
<pre><code class="language-js">tournamentEngine.removeEventExtension({ eventId, name });
</code></pre>
<hr>
<h2 id="removeeventmatchupformattiming">removeEventMatchUpFormatTiming</h2>
<pre><code class="language-js">tournamentEngine.removeEventMatchUpFormatTiming({ eventId });
</code></pre>
<hr>
<h2 id="removeeventpolicy">removeEventPolicy</h2>
<pre><code class="language-js">tournamentEngine.removeEventPolicy({ policyType });
</code></pre>
<hr>
<h2 id="removeindividualparticipantids">removeIndividualParticipantIds</h2>
<p>Remove an array of individualParticipantIds from a grouping participant [TEAM, GROUP].
If an individualParticipant is in a matchUp with a result they cannot be removed.</p>
<pre><code class="language-js">const { removed, notRemoved, cannotRemove } =
  tournamentEngine.removeIndividualParticipantIds({
    addIndividualParticipantsToEvents, // optional boolean
    individualParticipantIds,
    groupingParticipantId,
    suppressErrors, // optional boolean - do not throw an error if an individualParticipant cannot be removed
  });
</code></pre>
<hr>
<h2 id="removematchupsideparticipant">removeMatchUpSideParticipant</h2>
<p>Removes participant assigned to AD_HOC matchUp.</p>
<pre><code class="language-js">removeMatchUpSideParticipant({
  sideNumber, // number - required
  matchUpId, // required
  drawId, // required
});
</code></pre>
<hr>
<h2 id="removeparticipantidsfromallteams">removeParticipantIdsFromAllTeams</h2>
<pre><code class="language-js">tournamentEngine.removeParticipantIdsFromAllTeams({
  individualParticipantIds,
  groupingType, // optional - restrict to removing from only specified groupingType
});
</code></pre>
<hr>
<h2 id="removeparticipantextension">removeParticipantExtension</h2>
<pre><code class="language-js">tournamentEngine.removeParticipantExtension({ participantId, name });
</code></pre>
<hr>
<h2 id="removepenalty">removePenalty</h2>
<p>Removes a penalty from all relevant tournament participants.</p>
<pre><code class="language-js">tournamentEngine.removePenalty({ penaltyId });
</code></pre>
<hr>
<h2 id="removeroundmatchups">removeRoundMatchUps</h2>
<pre><code class="language-js">const {
  deltedMatchUpsCount, // number
  roundRemoved, // boolean
  success, // boolean
  error, // if any
} = tournamentEngine.removeRoundMatchUps({
  removeCompletedMatchUps, // optional boolean - whether to remove completed matchUps
  roundNumber, // required - roundNumber to remove
  structureId, // required
  drawId, // required
});
</code></pre>
<hr>
<h2 id="removescalevalues">removeScaleValues</h2>
<p>Removes scale values for participants in a particular event. Optionally restrict by draw or stage.</p>
<pre><code class="language-js">tournamentEngine.removeScaleValues({
  eventId,
  scaleAttributes, // { scaleType, scaleName, eventType }
  scaleName, // optional - override default scaleName, event.category.categoryName || event.category.ageCategoryCode
  drawId, // optional - to scope participants to entries in a specific draw
  stage, // optinal - scope participants to entries in a specific stage of draw
});
</code></pre>
<hr>
<h2 id="removeseeding">removeSeeding</h2>
<pre><code class="language-js">tournamentEngine.removeSeeding({
  eventId,
  entryStatuses, // optional array of entryStatues to consider
  scaleName, // optional - override default scaleName, event.category.categoryName || event.category.ageCategoryCode
  drawId, // optional - to scope participants to entries in a specific draw
  stage, // optinal - scope participants to entries in a specific stage of draw
});
</code></pre>
<hr>
<h2 id="removestructure">removeStructure</h2>
<p>Removes targeted <code>drawDefinition.structure</code> and all other child <code>structures</code> along with all associated <code>drawDefinition.links</code>.</p>
<pre><code class="language-js">const { removedMatchUpIds } = tournamentEngine.removeStructure({
  drawId,
  structureId,
});
</code></pre>
<hr>
<h2 id="removetiematchupparticipantid">removeTieMatchUpParticipantId</h2>
<pre><code class="language-js">tournamentEngine.removeTieMatchUpParticipantId({
  participantId, // id of INDIVIDUAL or PAIR be removed
  tieMatchUpId, // tieMatchUp, matchUpType either DOUBLES or SINGLES
  drawId, // draw within which tieMatchUp is found
});
</code></pre>
<hr>
<h2 id="removetournamentextension">removeTournamentExtension</h2>
<pre><code class="language-js">tournamentEngine.removeTournamentExtension({ name });
</code></pre>
<hr>
<h2 id="renamestructures">renameStructures</h2>
<pre><code class="language-js">tournamentEngine.renameStructures({
  structureDetails: [{ structureId, structureName }],
  drawId,
});
</code></pre>
<h2 id="replacetiematchupparticipantid">replaceTieMatchUpParticipantId</h2>
<pre><code class="language-js">tournamentEngine.replaceTieMatchUpParticipantId({
  existingParticipantId,
  newParticipantId,
  tieMatchUpId,
  drawId,
});
</code></pre>
<hr>
<h2 id="resetdrawdefinition">resetDrawDefinition</h2>
<pre><code class="language-js">tournamentEngine.resetDrawDefinition({ drawId });
</code></pre>
<hr>
<h2 id="resetscorecard">resetScorecard</h2>
<p>Removes all scores from <code>tieMatchUps</code> within a TEAM <code>matchUp</code>; preserves <code>lineUps</code>.</p>
<pre><code class="language-js">tournamentEngine.resetScorecard({
  tiebreakReset, // optional boolean - check for tiebreak scenarios and reset tieFormat
  matchUpId, // required - must be a TEAM matchUp
  drawId, // required
});
</code></pre>
<hr>
<h2 id="resettieformat">resetTieFormat</h2>
<p>Remove the <code>tieFormat</code> from a TEAM <code>matchUp</code> if there is a <code>tieFormat</code> further up the hierarchy; modifies <code>matchUp.tieMatchUps</code> to correspond.</p>
<pre><code class="language-js">tournamentEngine.resetTieFormat({
  matchUpId, // must be a TEAM matchUp
  drawId, // required
  uuids, // optional - in client/server scenarios generated matchUps must have equivalent matchUpIds
});
</code></pre>
<hr>
<h2 id="resetvoluntaryconsolationstructure">resetVoluntaryConsolationStructure</h2>
<pre><code class="language-js">tournamentEngine.resetVoluntaryConsolationStructure({
  resetEntries, // optional - remove all { entryStage: VOLUNTARY_CONSOLATION }
  drawId,
});
</code></pre>
<p>--</p>
<h2 id="scaledteamassignment">scaledTeamAssignment</h2>
<p>Assigns individual participants to teams using a waterfall pattern; removes UNGROUPED entries as appropriate for TEAM events. May be called with either <code>individualParticipantIds</code> and <code>scaleAttributes</code> or with an array of <code>scaledParticipants</code>.</p>
<admonition type="info"><p>By default existing <code>individualParticipant</code> assignments are cleared. If existing assignments are retained, any <code>individualParticipant</code> already assigned will be excluded from further assignment. It may be desirable to retain existing assignments if sequential assignment of different groups of <code>individualParticipants</code> is desired.</p></admonition>
<admonition type="note"><p>Modifying team assignments has &quot;global&quot; effect, meaning that if a team appears in multiple events, team membership will be changed for all events.</p></admonition>
<h3 id="example-use-with-individualparticipantids-and-scaleattributes">Example use with <code>individualParticipantIds</code> and <code>scaleAttributes</code></h3>
<pre><code class="language-js">const scaleAttributes = {
  scaleType: RANKING,
  eventType: SINGLES,
  scaleName: &#x27;U18&#x27;,
  sortOrder: ASCENDING, // defaults to ASCENDING; use case for DESCENDING is unclear!
};
tournamentEngine.scaledTeamAssignment({
  clearExistingAssignments, // optional - true by default remove all existing individualParticipantIds from targeted teams
  individualParticipantIds, // individuals to be sorted by scaleAttributes and assigned to teams (WATERFALL)
  reverseAssignmentOrder, // optional - reverses team order; useful for sequential assignment of participant groupings to ensure balanced distribution
  teamParticipantIds, // optional, IF teamsCount is provided then teams will be created
  initialTeamIndex, // optional - allows assignment to begin at a specified array index; useful for sequential assignment of groups of scaledParticipants
  scaleAttributes, // ignored if scaledParticipants are provided; { scaleName, scaleType, sortOrder, eventType }
  teamNameBase, // optional - defaults to &#x27;[categoryName] TEAM #&#x27;, where categoryName is derived from eventId (if supplied)
  teamsCount, // optional - derived from teamParticipantIds (if provided) - create # of teams if teamParticipantIds provided are insufficient
  eventId, // optional - source team participants from DIRECT_ACCEPTANCE entries for specified event
});
</code></pre>
<h3 id="example-use-with-scaledparticipants">Example use with <code>scaledParticipants</code></h3>
<pre><code class="language-js">const scaleAttributes = {
  scaleType: RANKING,
  eventType: SINGLES,
  scaleName: &#x27;U18&#x27;,
};

const scaledParticipants = individualParticipants.map((participant) =&gt; ({
  participantId: &#x27;participantId&#x27;,
  scaleValue: participantScaleItem({ participant, scaleAttributes }).scaleItem
    .scaleValue,
}));

const teamParticipantIds = teamParticipants.map(getParticipantId);

tournamentEngine.scaledTeamAssignment({
  scaledParticipants, // [{ participantId: &#x27;participantId&#x27;, scaleValue: &#x27;10&#x27; }]
  teamParticipantIds,
});
</code></pre>
<h3 id="example-use-with-sequential-assignment-where-there-are-8-teams">Example use with sequential assignment where there are 8 teams</h3>
<p>In this scenario scaled MALE participants are assigned in a waterfall pattern beginning with the first team (default behavior); scaled FEMALE participants are then assigned in a reverse waterfall pattern beginning with the last team. The goal is to balance the teams to the greatest extent possible. This pattern can be used with an arbitrary number of groups of <code>individualParticipants</code>.</p>
<pre><code class="language-js">tournamentEngine.scaledTeamAssignment({
  scaledParticipants: maleScaleParticipants,
  teamParticipantIds,
});

tournamentEngine.scaledTeamAssignment({
  scaledParticipants: femaleScaleParticipants,
  clearExistingAssignments: false,
  reverseAssignmentOrder: true,
  initialTeamIndex: 7,
  teamParticipantIds,
});
</code></pre>
<hr>
<h2 id="setdrawparticipantrepresentativeids">setDrawParticipantRepresentativeIds</h2>
<p>Set the participantIds of participants in the draw who are representing players by observing the creation of the draw.</p>
<pre><code class="language-js">tournamentEngine.setDrawParticipantRepresentativeIds({
  representativeParticipantIds,
  drawId,
});
</code></pre>
<hr>
<h2 id="setentryposition">setEntryPosition</h2>
<p>Set entry position a single event entry</p>
<pre><code class="language-js">tournamentEngine.setEntryPosition({
  entryPosition,
  participantId,
  eventId, // optional if drawId is provided
  drawId, // optional if eventId is provided
});
</code></pre>
<hr>
<h2 id="setentrypositions">setEntryPositions</h2>
<p>Set entry position for multiple event entries.</p>
<pre><code class="language-js">tournamentEngine.setEntryPositions({
  entryPositions, // array of [{ entryPosition: 1, participantId: &#x27;participantid&#x27; }]
  eventId, // optional if drawId is provided
  drawId, // optional if eventId is provided
});
</code></pre>
<hr>
<h2 id="seteventdates">setEventDates</h2>
<p>Where startDate and/or endDate are strings &#x27;YYYY-MM-DD&#x27;.</p>
<pre><code class="language-js">tournamentEngine.setEventDates({ eventId, startDate, endDate });
</code></pre>
<hr>
<h2 id="seteventenddate">setEventEndDate</h2>
<p>Where endDate is a string &#x27;YYYY-MM-DD&#x27;.</p>
<pre><code class="language-js">tournamentEngine.setEventEndDate({ eventId, endDate });
</code></pre>
<hr>
<h2 id="seteventstartdate">setEventStartDate</h2>
<p>Where startDate is a string &#x27;YYYY-MM-DD&#x27;.</p>
<pre><code class="language-js">tournamentEngine.setEventStartDate({ eventId, startDate });
</code></pre>
<hr>
<h2 id="setmatchupdailylimits">setMatchUpDailyLimits</h2>
<pre><code class="language-js">tournamentEngine.setMatchUpDailyLimits({
  dailyLimits: { SINGLES: 2, DOUBLES: 1, total: 3 },
});
</code></pre>
<hr>
<h2 id="setmatchupformat">setMatchUpFormat</h2>
<p>Sets the <code>matchUpFormat</code> for a specific <code>matchUp</code> or for any scope within the hierarchy of a <code>tournamentRecord</code>.</p>
<admonition type="info"><p>If an array of <code>scheduledDates</code> is provided then <code>matchUps</code> which have <code>matchUpStatus: TO_BE_PLAYED</code> and are scheduled to be played on the specified dates will have their <code>matchUpFormat</code> fixed rather than inherited. This means that subsequent changes to the parent <code>structure.matchUpFormat</code> will have no effect on such <code>matchUps</code>.</p><p>The <code>force</code> attribute will remove the <code>matchUpFormat</code> from all targeted <code>matchUps</code> which have <code>matchUpStatus: TO_BE_PLAYED</code>; this allows the effect of using <code>scheduledDates</code> to be reversed. Use of this attribute will have no effect if <code>scheduledDates</code> is also provided.</p></admonition>
<pre><code class="language-js">tournamentEngine.setMatchUpFormat({
  matchUpFormat, // TODS matchUpFormatCode
  eventType, // optional - restrict to SINGLES or DOUBLES

  matchUpId, // optional - set matchUpFormat for a specific matchUp
  drawId, // required only if matchUpId, structureId or structureIds is present
  force, // optional boolean - when setting for structure, draws or events, strip any defined matchUpFormat from all TO_BE_PLAYED matchUps

  // scoping options
  scheduledDates, // optional - [&#x27;2022-01-01&#x27;]
  stageSequences, // optional - [1, 2]
  structureIds, // optional - [&#x27;structureId1&#x27;, &#x27;structureId2&#x27;]
  structureId, // optional
  eventIds, // optional - [&#x27;eventId1&#x27;, &#x27;eventId2&#x27;]
  eventId, // optional
  drawIds, // optional - [&#x27;drawId1&#x27;, &#x27;drawId2&#x27;]
  stages, // optional - [&#x27;MAIN&#x27;, &#x27;CONSOLATION&#x27;]
});
</code></pre>
<hr>
<h2 id="setmatchupstatus">setMatchUpStatus</h2>
<p>Sets either <code>matchUpStatus</code> or <code>score</code> and <code>winningSide</code>; values to be set are passed in <code>outcome</code> object. Handles any winner/loser participant movements within or across <code>structures</code>.</p>
<pre><code class="language-js">const outcome = {
  matchUpStatus, // optional
  winningSide, // optional
  score, // optional
};

tournamentEngine.setMatchUpStatus({
  disableScoreValidation, // optional boolean
  allowChangePropagation, // optional boolean - allow winner/loser to be swapped and propgate change throughout draw structures
  disableAutoCalc, // optional - applies only to { matchUpType: TEAM }
  enableAutoCalc, // optional - applies only to { matchUpType: TEAM }
  matchUpTieId, // optional - if part of a TIE matchUp
  matchUpId,
  outcome, // optional
  drawId,
  schedule: {
    // optional - set schedule items
    courtIds, // applies only to TEAM matchUps
    courtId, // requires scheduledDate
    venueId,
    scheduledDate,
    scheduledTime,
    startTime,
    endTime,
  },
  notes, // optional - add note (string) to matchUp object
});
</code></pre>
<hr>
<h2 id="setorderoffinish">setOrderOfFinish</h2>
<p>Sets the <code>orderOfFinish</code> attribute for <code>matchUps</code> specified by <code>matchUpId</code> in the <code>finishingOrder</code> array.</p>
<h3 id="validation">Validation</h3>
<p>Validation is done within a <em>cohort</em> of <code>matchUps</code> which have equivalent <code>structureId</code>, <code>matchUpType</code>, <code>roundNumber</code>, and <code>matchUpTieId</code> (if applicable).</p>
<ul>
<li><code>matchUpIds</code> in <code>finishingOrder</code> must be part of the same <em>cohort</em></li>
<li><code>orderOfFinish</code> values must be unique positive integers within the <em>cohort</em></li>
</ul>
<pre><code class="language-js">tournamentEngine.setOrderOfFinish({
  finishingOrder: [{ matchUpId, orderOfFinish: 1 }],
  drawId,
});
</code></pre>
<hr>
<h2 id="setparticipantscaleitem">setParticipantScaleItem</h2>
<pre><code class="language-js">scaleItem = {
  scaleValue: 12,
  scaleName: &#x27;U16&#x27;,
  scaleType: RANKING,
  eventType: SINGLES,
  scaleDate: &#x27;2020-06-06&#x27;,
};

result = tournamentEngine.setParticipantScaleItem({
  removePriorValues, // optional boolean - when true will delete prior timeItems
  participantId,
  scaleItem,
});
</code></pre>
<hr>
<h2 id="setparticipantscaleitems">setParticipantScaleItems</h2>
<pre><code class="language-js">const scaleItemsWithParticipantIds = [
  {
    participantId: &#x27;participantId&#x27;,
    scaleItems: [
      {
        scaleValue: 8.3,
        scaleName: &#x27;WTN&#x27;,
        scaleType: RATING,
        eventType: SINGLES,
        scaleDate: &#x27;2021-01-01&#x27;,
      },
    ],
  },
];
tournamentEngine.setParticipantScaleItems({
  removePriorValues, // optional boolean - when true will delete prior timeItems
  scaleItemsWithParticipantIds,
  // optional context, primarily used when adding SEEDING, useful for structureReports
  context: {
    scaleAttributes, // e.g. { scaleType: &#x27;SEEDING&#x27; }
    scaleBasis, // e.g. { scaleType: &#x27;RANKING&#x27;, scaleDate }
    eventId,
  },
});
</code></pre>
<pre><code class="language-js">result = tournamentEngine.setParticipantScaleItems({
  scaleItemsWithParticipantIds: result.scaleItemsWithParticipantIds,
});
</code></pre>
<hr>
<h2 id="setpositionassignments">setPositionAssignments</h2>
<p>Intended to be used in conjunction with <code>automatedPlayoffPositioning</code> in deployments where a client instance gets the positioning which is then set on both the client and the server, to ensure that both client and server are identical. If <code>automatedPlayoffPositioning</code> is invoked on both client and server independently then it is likely that the positioning on client and server will be different.</p>
<pre><code class="language-js">// executed only on the client
const { structurePositionAssignments } =
  tournamentEngine.automatedPlayoffPositioning({
    applyPositioning: false, // instructs tournamentEngine to only return values, not apply them
    structureId,
    drawId,
  });

// executed on both client and server
result = tournamentEngine.setPositionAssignments({
  structurePositionAssignments,
  drawId,
});
</code></pre>
<hr>
<h2 id="setstate">setState</h2>
<p>Loads a tournament record into tournamentEngine.</p>
<pre><code class="language-js">tournamentEngine.setsState(tournamentRecord, deepCopy, deepCopyConfig);
</code></pre>
<admonition type="info"><p>By default a deep copy of the <code>tournamentRecord</code> is made so that mutations made by <code>tournamentEngine</code> do not affect the source object. An optional boolean parameter, <em>deepCopy</em> can be set to false to override this default behavior.</p></admonition>
<admonition type="note"><p><code>deepCopyConfig</code> is an optional configuration for <code>makeDeepCopy</code>. In server configurations when <code>deepCopy</code> is FALSE and <code>tournamentRecords</code> are retrieved from Mongo, for instance, there are scenarios where nodes of the JSON structure contain prototypes which cannot be converted.</p></admonition>
<pre><code class="language-js">const deepCopyConfig = {
  ignore, // optional - either an array of attributes to ignore or a function which processes attributes to determine whether to ignore them
  toJSON, // optional - an array of attributes to convert to JSON if the attribute in question is an object with .toJSON property
  stringify, // optional - an array of attributes to stringify
  modulate, // optional - function to process every attribute and return custom values, or undefined, which continues normal processing
};
</code></pre>
<hr>
<h2 id="setsuborder">setSubOrder</h2>
<p>Used to order ROUND_ROBIN participants when finishingPosition ties cannot be broken algorithmically. Assigns a <code>subOrder</code> value to a participant within a <code>structure</code> by <code>drawPosition</code>.</p>
<pre><code class="language-js">tournamentEngine.setSubOrder({
  drawPosition: 1,
  subOrder: 2,
  structureId,
  drawId,
});
</code></pre>
<hr>
<h2 id="settournamentcategories">setTournamentCategories</h2>
<p>Define categories to be used in <code>event</code> creation for tournament record.</p>
<pre><code class="language-js">const categories = [
  {
    categoryName: &#x27;U18&#x27;,
    type: eventConstants.AGE,
  },
  {
    categoryName: &#x27;U16&#x27;,
    type: eventConstants.AGE,
  },
  {
    categoryName: &#x27;WTN&#x27;,
    type: eventConstants.RATING,
  },
];
tournamentEngine.setTournamentCategories({ categories });
</code></pre>
<hr>
<h2 id="settournamentdates">setTournamentDates</h2>
<p>Set tournament <code>startDate</code> and <code>endDate</code> in one method call. Also cleans up <code>matchUp</code> schedules that are invalid due to date changes, and updates court <code>dateAvailability</code>.</p>
<pre><code class="language-js">tournamentEngine.setTournamentDates({ startDate, endDate });
</code></pre>
<hr>
<h2 id="settournamentenddate">setTournamentEndDate</h2>
<p>Accepts an ISO String Date;</p>
<pre><code class="language-js">tournamentEngine.setTournamentEndDate({ endDate });
</code></pre>
<hr>
<h2 id="settournamentid">setTournamentId</h2>
<p>Points <code>tournamentEngine</code> to a tournamentRecord that is in shared state, e.g. loaded by <code>competitionEngine</code>.</p>
<pre><code class="language-js">tournamentEngine.setTournamentId(tournamentId);
</code></pre>
<hr>
<h2 id="settournamentname">setTournamentName</h2>
<pre><code class="language-js">const tournamentName = &#x27;CourtHive Challenge&#x27;;
tournamentEngine.setTournamentName({
  tournamentName,
});
</code></pre>
<hr>
<h2 id="settournamentnotes">setTournamentNotes</h2>
<pre><code class="language-js">tournamentEngine.setTournamentNotes({ notes });
</code></pre>
<hr>
<h2 id="settournamentstartdate">setTournamentStartDate</h2>
<p>Accepts an ISO String Date;</p>
<pre><code class="language-js">tournamentEngine.setTournamentStartDate({ StartDate });
</code></pre>
<hr>
<h2 id="settournamentstatus">setTournamentStatus</h2>
<pre><code class="language-js">tournamentEngine.setTournamentStatus({ status: CANCELLED });
</code></pre>
<hr>
<h2 id="swapdrawpositionassignments">swapDrawPositionAssignments</h2>
<p>Swaps the <code>participantIds</code> of two <code>drawPositions</code>.</p>
<pre><code class="language-js">tournamentEngine.swapDrawPositionAssignments({
  drawPositions,
  structureId,
  drawId,
});
</code></pre>
<hr>
<h2 id="toggleparticipantcheckinstate">toggleParticipantCheckInState</h2>
<pre><code class="language-js">tournamentEngine.toggleParticipantCheckInState({
  participantId,
  matchUpId,
  drawId,
});
</code></pre>
<hr>
<h2 id="tournamentmatchups">tournamentMatchUps</h2>
<p>Returns tournament matchUps grouped by matchUpStatus. These matchUps are returned with <em>context</em>.</p>
<pre><code class="language-js">const {
  abandonedMatchUps,
  byeMatchUps,
  completedMatchUps,
  pendingMatchUps,
  upcomingMatchUps,
} = tournamentEngine.tournamentMatchUps({
  matchUpFilters, // optional; [ scheduledDates: [], courtIds: [], stages: [], roundNumbers: [], matchUpStatuses: [], matchUpFormats: []]
  policyDefinitions, // optional - seeding or avoidance policies to be used when placing participants
  scheduleVisibilityFilters, // { visibilityThreshold: Date, eventIds, drawIds }
});
</code></pre>
<hr>
<h2 id="unpublishevent">unPublishEvent</h2>
<p>Modifies the <code>publishState</code> of an event. <code>Subscriptions</code> or middleware can be used to trigger messaging to services which make event data visible on public websites.</p>
<pre><code class="language-js">tournamentEngine.unPublishEvent({
  removePriorValues, // optional boolean, defaults to true - when true will delete prior timeItems
  eventId,
});
</code></pre>
<hr>
<h2 id="unpublisheventseeding">unPublishEventSeeding</h2>
<pre><code class="language-js">tournamentEngine.unPublishEventSeeding({
  removePriorValues, // optional boolean, defaults to true - when true will delete prior timeItems
  stages, // optionally specify array of stages to be unpublished, otherwise unpublish all stages
  eventId,
});
</code></pre>
<hr>
<h2 id="unpublishorderofplay">unPublishOrderOfPlay</h2>
<pre><code class="language-js">tournamentEngine.unPublishOrderOfPlay({
  removePriorValues, // optional boolean, defaults to true - when true will delete prior timeItems
});
</code></pre>
<hr>
<h2 id="updatedrawidsorder">updateDrawIdsOrder</h2>
<p>Updates the <code>drawOrder</code> attribute of all <code>drawDefinitions</code> within an event. The <code>drawOrder</code> attribute can be used for sorting or for differentiating <code>drawDefinitions</code> for the award of rankings points, when &quot;flighting&quot; separates participants by some <code>scaleValue</code>.</p>
<pre><code class="language-js">tournamentEngine.updateDrawIdsOrder({
  eventId,
  orderedDrawIdsMap: {
    &#x27;id-Of-draw-1&#x27;: 1,
    &#x27;id-of-draw-2&#x27;: 2,
  },
});
</code></pre>
<hr>
<h2 id="updateteamlineup">updateTeamLineUp</h2>
<pre><code class="language-js">tournamentEngine.updateTeamLineUp({
  participantId, // id of the team for which lineUp is being updated
  tieFormat, // valid tieFormat - used to validate collectionIds
  lineUp, // valid lineUp array - see tournamentEngine.validateTeamLineUp
  drawId, // required as latest lineUp modification is stored in an extension on drawDefinition
});
</code></pre>
<hr>
<h2 id="updatetiematchupscore">updateTieMatchUpScore</h2>
<p>Trigger automatic calculation of the score of a TEAM matchUp.</p>
<pre><code class="language-js">tournamentEngine.updateTieMatchUpScore({
  matchUpId,
  drawId,
});
</code></pre>
<hr>
<h2 id="withdrawparticipantatdrawposition">withdrawParticipantAtDrawPosition</h2>
<p>Thin wrapper around <a href="#removedrawpositionassignment">removeDrawPositionAssignment</a>. This method is included in <code>validActions</code> for <a href="../policies/positionActions">positionActions</a>.</p>
<pre><code class="language-js">tournamentEngine.withdrawParticipantAtDrawPosition({
  entryStatus = WITHDRAWN,
  replaceWithBye, // optional
  drawDefinition,
  drawPosition,
  structureId,
  destroyPair, // optional - decompose PAIR participant into UNPAIRED participants
});
</code></pre>
<hr>
<h2 id="validatecollectiondefinition">validateCollectionDefinition</h2>
<pre><code class="language-js">const { valid } = validateCollectionDefinition({
  collectionDefinition, // required
  checkCollectionIds, // optional boolean - check that collectionIds are present
  referenceGender, // optional - expected gender if eventId is not provided
  checkGender, // optional boolean - defaults to true
  eventId, // required only for checking gender
});
</code></pre>
<hr>
<h2 id="validateteamlineup">validateTeamLineUp</h2>
<pre><code class="language-js">const { valid, error, errors } = tournamentEngine.validateLineUp({
  tieFormat, // required to validate collectionIds in lineUp
  lineUp,
});
</code></pre>
<hr>
<h2 id="version">version</h2>
<p>Returns NPM package version. Can be used in configurations that utilize Competition Factory engines on both client and server to ensure equivalency.</p>
<pre><code class="language-js">const version = tournamentEngine.version();
</code></pre></div></article><nav class="pagination-nav docusaurus-mt-lg" aria-label="Docs pages"><a class="pagination-nav__link pagination-nav__link--prev" href="/tods-competition-factory/docs/engines/tournament-engine-overview"><div class="pagination-nav__sublabel">Previous</div><div class="pagination-nav__label">Tournament Engine</div></a><a class="pagination-nav__link pagination-nav__link--next" href="/tods-competition-factory/docs/engines/draw-engine-overview"><div class="pagination-nav__sublabel">Next</div><div class="pagination-nav__label">Draw Engine</div></a></nav></div></div><div class="col col--3"><div class="tableOfContents_eHnk thin-scrollbar theme-doc-toc-desktop"><ul class="table-of-contents table-of-contents__left-border"><li><a href="#addadhocmatchups" class="table-of-contents__link toc-highlight">addAdHocMatchUps</a></li><li><a href="#addcollectiondefinition" class="table-of-contents__link toc-highlight">addCollectionDefinition</a></li><li><a href="#addcollectiongroup" class="table-of-contents__link toc-highlight">addCollectionGroup</a></li><li><a href="#addcourt" class="table-of-contents__link toc-highlight">addCourt</a></li><li><a href="#addcourts" class="table-of-contents__link toc-highlight">addCourts</a></li><li><a href="#adddrawdefinition" class="table-of-contents__link toc-highlight">addDrawDefinition</a></li><li><a href="#adddrawdefinitionextension" class="table-of-contents__link toc-highlight">addDrawDefinitionExtension</a></li><li><a href="#adddrawentries" class="table-of-contents__link toc-highlight">addDrawEntries</a></li><li><a href="#addevent" class="table-of-contents__link toc-highlight">addEvent</a></li><li><a href="#addevententries" class="table-of-contents__link toc-highlight">addEventEntries</a></li><li><a href="#addevententrypairs" class="table-of-contents__link toc-highlight">addEventEntryPairs</a></li><li><a href="#addeventextension" class="table-of-contents__link toc-highlight">addEventExtension</a></li><li><a href="#addflight" class="table-of-contents__link toc-highlight">addFlight</a></li><li><a href="#addindividualparticipantids" class="table-of-contents__link toc-highlight">addIndividualParticipantIds</a></li><li><a href="#addmatchupendtime" class="table-of-contents__link toc-highlight">addMatchUpEndTime</a></li><li><a href="#addmatchupofficial" class="table-of-contents__link toc-highlight">addMatchUpOfficial</a></li><li><a href="#addmatchupresumetime" class="table-of-contents__link toc-highlight">addMatchUpResumeTime</a></li><li><a href="#addmatchupscheduleddate" class="table-of-contents__link toc-highlight">addMatchUpScheduledDate</a></li><li><a href="#addmatchupscheduledtime" class="table-of-contents__link toc-highlight">addMatchUpScheduledTime</a></li><li><a href="#addmatchupscheduleitems" class="table-of-contents__link toc-highlight">addMatchUpScheduleItems</a></li><li><a href="#addmatchupstarttime" class="table-of-contents__link toc-highlight">addMatchUpStartTime</a></li><li><a href="#addmatchupstoptime" class="table-of-contents__link toc-highlight">addMatchUpStopTime</a></li><li><a href="#addmatchupcourtorder" class="table-of-contents__link toc-highlight">addMatchUpCourtOrder</a></li><li><a href="#addparticipant" class="table-of-contents__link toc-highlight">addParticipant</a></li><li><a href="#addparticipants" class="table-of-contents__link toc-highlight">addParticipants</a></li><li><a href="#addpenalty" class="table-of-contents__link toc-highlight">addPenalty</a></li><li><a href="#addpersons" class="table-of-contents__link toc-highlight">addPersons</a></li><li><a href="#addplayoffstructures" class="table-of-contents__link toc-highlight">addPlayoffStructures</a></li><li><a href="#addqualifyingstructure" class="table-of-contents__link toc-highlight">addQualifyingStructure</a></li><li><a href="#addtournamentextension" class="table-of-contents__link toc-highlight">addTournamentExtension</a></li><li><a href="#addvenue" class="table-of-contents__link toc-highlight">addVenue</a></li><li><a href="#addvoluntaryconsolationstage" class="table-of-contents__link toc-highlight">addVoluntaryConsolationStage</a></li><li><a href="#addvoluntaryconsolationstructure" class="table-of-contents__link toc-highlight">addVoluntaryConsolationStructure</a></li><li><a href="#allocateteammatchupcourts" class="table-of-contents__link toc-highlight">allocateTeamMatchUpCourts</a></li><li><a href="#alldrawmatchups" class="table-of-contents__link toc-highlight">allDrawMatchUps</a></li><li><a href="#alleventmatchups" class="table-of-contents__link toc-highlight">allEventMatchUps</a></li><li><a href="#alltournamentmatchups" class="table-of-contents__link toc-highlight">allTournamentMatchUps</a></li><li><a href="#alternatedrawpositionassignment" class="table-of-contents__link toc-highlight">alternateDrawPositionAssignment</a></li><li><a href="#applylinueups" class="table-of-contents__link toc-highlight">applyLinueUps</a></li><li><a href="#assigndrawposition" class="table-of-contents__link toc-highlight">assignDrawPosition</a></li><li><a href="#assignmatchupsideparticipant" class="table-of-contents__link toc-highlight">assignMatchUpSideParticipant</a></li><li><a href="#assignmatchupcourt" class="table-of-contents__link toc-highlight">assignMatchUpCourt</a></li><li><a href="#assignmatchupvenue" class="table-of-contents__link toc-highlight">assignMatchUpVenue</a></li><li><a href="#assignseedpositions" class="table-of-contents__link toc-highlight">assignSeedPositions</a></li><li><a href="#assigntiematchupparticipantid" class="table-of-contents__link toc-highlight">assignTieMatchUpParticipantId</a></li><li><a href="#attacheventpolicies" class="table-of-contents__link toc-highlight">attachEventPolicies</a></li><li><a href="#attachflightprofile" class="table-of-contents__link toc-highlight">attachFlightProfile</a></li><li><a href="#attachplayoffstructures" class="table-of-contents__link toc-highlight">attachPlayoffStructures</a></li><li><a href="#attachpolicies" class="table-of-contents__link toc-highlight">attachPolicies</a></li><li><a href="#attachqualifyingstructure" class="table-of-contents__link toc-highlight">attachQualifyingStructure</a></li><li><a href="#attachstructures" class="table-of-contents__link toc-highlight">attachStructures</a></li><li><a href="#automatedplayoffpositioning" class="table-of-contents__link toc-highlight">automatedPlayoffPositioning</a></li><li><a href="#automatedpositioning" class="table-of-contents__link toc-highlight">automatedPositioning</a></li><li><a href="#autoseeding" class="table-of-contents__link toc-highlight">autoSeeding</a></li><li><a href="#bulkmatchupstatusupdate" class="table-of-contents__link toc-highlight">bulkMatchUpStatusUpdate</a></li><li><a href="#bulkreschedulematchups" class="table-of-contents__link toc-highlight">bulkRescheduleMatchUps</a></li><li><a href="#bulkschedulematchups" class="table-of-contents__link toc-highlight">bulkScheduleMatchUps</a></li><li><a href="#bulkupdatepublishedeventids" class="table-of-contents__link toc-highlight">bulkUpdatePublishedEventIds</a></li><li><a href="#checkinparticipant" class="table-of-contents__link toc-highlight">checkInParticipant</a></li><li><a href="#checkoutparticipant" class="table-of-contents__link toc-highlight">checkOutParticipant</a></li><li><a href="#checkvalidentries" class="table-of-contents__link toc-highlight">checkValidEntries</a></li><li><a href="#clearmatchupschedule" class="table-of-contents__link toc-highlight">clearMatchUpSchedule</a></li><li><a href="#clearscheduledmatchups" class="table-of-contents__link toc-highlight">clearScheduledMatchUps</a></li><li><a href="#deleteadhocmatchups" class="table-of-contents__link toc-highlight">deleteAdHocMatchUps</a></li><li><a href="#deletecourt" class="table-of-contents__link toc-highlight">deleteCourt</a></li><li><a href="#deletedrawdefinitions" class="table-of-contents__link toc-highlight">deleteDrawDefinitions</a></li><li><a href="#deleteflightandflightdraw" class="table-of-contents__link toc-highlight">deleteFlightAndFlightDraw</a></li><li><a href="#deleteflightprofileandflightdraws" class="table-of-contents__link toc-highlight">deleteFlightProfileAndFlightDraws</a></li><li><a href="#deleteevents" class="table-of-contents__link toc-highlight">deleteEvents</a></li><li><a href="#deleteparticipants" class="table-of-contents__link toc-highlight">deleteParticipants</a></li><li><a href="#deletevenue" class="table-of-contents__link toc-highlight">deleteVenue</a></li><li><a href="#deletevenues" class="table-of-contents__link toc-highlight">deleteVenues</a></li><li><a href="#destroygroupentry" class="table-of-contents__link toc-highlight">destroyGroupEntry</a></li><li><a href="#destroypairentry" class="table-of-contents__link toc-highlight">destroyPairEntry</a></li><li><a href="#devcontext" class="table-of-contents__link toc-highlight">devContext</a></li><li><a href="#disablecourts" class="table-of-contents__link toc-highlight">disableCourts</a></li><li><a href="#disabletiaautocalc" class="table-of-contents__link toc-highlight">disableTiaAutoCalc</a></li><li><a href="#disablevenues" class="table-of-contents__link toc-highlight">disableVenues</a></li><li><a href="#drawmatic" class="table-of-contents__link toc-highlight">drawMatic</a></li><li><a href="#enablecourts" class="table-of-contents__link toc-highlight">enableCourts</a></li><li><a href="#enabletiaautocalc" class="table-of-contents__link toc-highlight">enableTiaAutoCalc</a></li><li><a href="#enablevenues" class="table-of-contents__link toc-highlight">enableVenues</a></li><li><a href="#eventmatchups" class="table-of-contents__link toc-highlight">eventMatchUps</a></li><li><a href="#executionqueue" class="table-of-contents__link toc-highlight">executionQueue</a></li><li><a href="#findcourt" class="table-of-contents__link toc-highlight">findCourt</a></li><li><a href="#finddrawdefinitionextension" class="table-of-contents__link toc-highlight">findDrawDefinitionExtension</a></li><li><a href="#findeventextension" class="table-of-contents__link toc-highlight">findEventExtension</a></li><li><a href="#findmatchup" class="table-of-contents__link toc-highlight">findMatchUp</a></li><li><a href="#findparticipant" class="table-of-contents__link toc-highlight">findParticipant</a></li><li><a href="#findparticipantextension" class="table-of-contents__link toc-highlight">findParticipantExtension</a></li><li><a href="#findpolicy" class="table-of-contents__link toc-highlight">findPolicy</a></li><li><a href="#findtournamentextension" class="table-of-contents__link toc-highlight">findTournamentExtension</a></li><li><a href="#findvenue" class="table-of-contents__link toc-highlight">findVenue</a></li><li><a href="#generateadhocmatchups" class="table-of-contents__link toc-highlight">generateAdHocMatchUps</a></li><li><a href="#generateandpopulateplayoffstructures" class="table-of-contents__link toc-highlight">generateAndPopulatePlayoffStructures</a></li><li><a href="#generatedrawdefinition" class="table-of-contents__link toc-highlight">generateDrawDefinition</a></li><li><a href="#generatedrawmaticround" class="table-of-contents__link toc-highlight">generateDrawMaticRound</a></li><li><a href="#generateflightprofile" class="table-of-contents__link toc-highlight">generateFlightProfile</a></li><li><a href="#generatelineups" class="table-of-contents__link toc-highlight">generateLineUps</a></li><li><a href="#generatequalifyingstructure" class="table-of-contents__link toc-highlight">generateQualifyingStructure</a></li><li><a href="#generateseedingscaleitems" class="table-of-contents__link toc-highlight">generateSeedingScaleItems</a></li><li><a href="#generateteamsfromparticipantattribute" class="table-of-contents__link toc-highlight">generateTeamsFromParticipantAttribute</a></li><li><a href="#generatevolunataryconsolation" class="table-of-contents__link toc-highlight">generateVolunataryConsolation</a></li><li><a href="#getalleventdata" class="table-of-contents__link toc-highlight">getAllEventData</a></li><li><a href="#getalloweddrawtypes" class="table-of-contents__link toc-highlight">getAllowedDrawTypes</a></li><li><a href="#getallowedmatchupformats" class="table-of-contents__link toc-highlight">getAllowedMatchUpFormats</a></li><li><a href="#getavailableplayoffprofiles" class="table-of-contents__link toc-highlight">getAvailablePlayoffProfiles</a></li><li><a href="#getcourtinfo" class="table-of-contents__link toc-highlight">getCourtInfo</a></li><li><a href="#getcourts" class="table-of-contents__link toc-highlight">getCourts</a></li><li><a href="#getdrawdata" class="table-of-contents__link toc-highlight">getDrawData</a></li><li><a href="#getdrawparticipantrepresentativeids" class="table-of-contents__link toc-highlight">getDrawParticipantRepresentativeIds</a></li><li><a href="#geteligiblevoluntaryconsolationparticipants" class="table-of-contents__link toc-highlight">getEligibleVoluntaryConsolationParticipants</a></li><li><a href="#getentriesandseedscount" class="table-of-contents__link toc-highlight">getEntriesAndSeedsCount</a></li><li><a href="#getentrystatusreports" class="table-of-contents__link toc-highlight">getEntryStatusReports</a></li><li><a href="#getevent" class="table-of-contents__link toc-highlight">getEvent</a></li><li><a href="#getevents" class="table-of-contents__link toc-highlight">getEvents</a></li><li><a href="#geteventdata" class="table-of-contents__link toc-highlight">getEventData</a></li><li><a href="#geteventtimeitem" class="table-of-contents__link toc-highlight">getEventTimeItem</a></li><li><a href="#geteventproperties" class="table-of-contents__link toc-highlight">getEventProperties</a></li><li><a href="#geteventmatchupformattiming" class="table-of-contents__link toc-highlight">getEventMatchUpFormatTiming</a></li><li><a href="#geteventstructures" class="table-of-contents__link toc-highlight">getEventStructures</a></li><li><a href="#getflightprofile" class="table-of-contents__link toc-highlight">getFlightProfile</a></li><li><a href="#getmatchupcompetitiveprofile" class="table-of-contents__link toc-highlight">getMatchUpCompetitiveProfile</a></li><li><a href="#getmatchupdependencies" class="table-of-contents__link toc-highlight">getMatchUpDependencies</a></li><li><a href="#getmatchupformat" class="table-of-contents__link toc-highlight">getMatchUpFormat</a></li><li><a href="#getmatchupformattiming" class="table-of-contents__link toc-highlight">getMatchUpFormatTiming</a></li><li><a href="#getmatchupformattimingupdate" class="table-of-contents__link toc-highlight">getMatchUpFormatTimingUpdate</a></li><li><a href="#getmatchupscheduledetails" class="table-of-contents__link toc-highlight">getMatchUpScheduleDetails</a></li><li><a href="#getmatchupsstats" class="table-of-contents__link toc-highlight">getMatchUpsStats</a></li><li><a href="#getmatchupdailylimits" class="table-of-contents__link toc-highlight">getMatchUpDailyLimits</a></li><li><a href="#getmodifiedmatchupformattiming" class="table-of-contents__link toc-highlight">getModifiedMatchUpFormatTiming</a></li><li><a href="#getpairedparticipant" class="table-of-contents__link toc-highlight">getPairedParticipant</a></li><li><a href="#getparticipanteventdetails" class="table-of-contents__link toc-highlight">getParticipantEventDetails</a></li><li><a href="#getparticipantidfinishingpositions" class="table-of-contents__link toc-highlight">getParticipantIdFinishingPositions</a></li><li><a href="#getparticipantmembership" class="table-of-contents__link toc-highlight">getParticipantMembership</a></li><li><a href="#getparticipants" class="table-of-contents__link toc-highlight">getParticipants</a><ul><li><a href="#participantfilters" class="table-of-contents__link toc-highlight">participantFilters</a></li></ul></li><li><a href="#getparticipantscaleitem" class="table-of-contents__link toc-highlight">getParticipantScaleItem</a></li><li><a href="#getparticipantschedules" class="table-of-contents__link toc-highlight">getParticipantSchedules</a></li><li><a href="#getparticipantsigninstatus" class="table-of-contents__link toc-highlight">getParticipantSignInStatus</a></li><li><a href="#getpolicydefinitions" class="table-of-contents__link toc-highlight">getPolicyDefinitions</a></li><li><a href="#getpositionassignments" class="table-of-contents__link toc-highlight">getPositionAssignments</a></li><li><a href="#getpredictiveaccuracy" class="table-of-contents__link toc-highlight">getPredictiveAccuracy</a></li><li><a href="#getroundmatchups" class="table-of-contents__link toc-highlight">getRoundMatchUps</a></li><li><a href="#getscaledentries" class="table-of-contents__link toc-highlight">getScaledEntries</a></li><li><a href="#getseedscount" class="table-of-contents__link toc-highlight">getSeedsCount</a></li><li><a href="#getstate" class="table-of-contents__link toc-highlight">getState</a></li><li><a href="#getstructurereports" class="table-of-contents__link toc-highlight">getStructureReports</a></li><li><a href="#getteamlineup" class="table-of-contents__link toc-highlight">getTeamLineUp</a></li><li><a href="#gettieformat" class="table-of-contents__link toc-highlight">getTieFormat</a></li><li><a href="#gettournamentinfo" class="table-of-contents__link toc-highlight">getTournamentInfo</a></li><li><a href="#gettournamentparticipants" class="table-of-contents__link toc-highlight">getTournamentParticipants</a><ul><li><a href="#implemented-participantfilters" class="table-of-contents__link toc-highlight">Implemented participantFilters</a></li></ul></li><li><a href="#gettournamentpersons" class="table-of-contents__link toc-highlight">getTournamentPersons</a></li><li><a href="#gettournamentpenalties" class="table-of-contents__link toc-highlight">getTournamentPenalties</a></li><li><a href="#gettournamentstructures" class="table-of-contents__link toc-highlight">getTournamentStructures</a></li><li><a href="#getvenuesandcourts" class="table-of-contents__link toc-highlight">getVenuesAndCourts</a></li><li><a href="#getvenuedata" class="table-of-contents__link toc-highlight">getVenueData</a></li><li><a href="#isvalidmatchupformat" class="table-of-contents__link toc-highlight">isValidMatchUpFormat</a></li><li><a href="#luckyloserdrawpositionassignment" class="table-of-contents__link toc-highlight">luckyLoserDrawPositionAssignment</a></li><li><a href="#matchupactions" class="table-of-contents__link toc-highlight">matchUpActions</a></li><li><a href="#mergeparticipants" class="table-of-contents__link toc-highlight">mergeParticipants</a></li><li><a href="#modifycollectiondefinition" class="table-of-contents__link toc-highlight">modifyCollectionDefinition</a></li><li><a href="#modifycourt" class="table-of-contents__link toc-highlight">modifyCourt</a></li><li><a href="#modifycourtavailability" class="table-of-contents__link toc-highlight">modifyCourtAvailability</a></li><li><a href="#modifydrawdefinition" class="table-of-contents__link toc-highlight">modifyDrawDefinition</a></li><li><a href="#modifymatchupformattiming" class="table-of-contents__link toc-highlight">modifyMatchUpFormatTiming</a></li><li><a href="#modifyentriesstatus" class="table-of-contents__link toc-highlight">modifyEntriesStatus</a></li><li><a href="#modifyevententries" class="table-of-contents__link toc-highlight">modifyEventEntries</a></li><li><a href="#modifyevent" class="table-of-contents__link toc-highlight">modifyEvent</a></li><li><a href="#modifyeventmatchupformattiming" class="table-of-contents__link toc-highlight">modifyEventMatchUpFormatTiming</a></li><li><a href="#modifyindividualparticipantids" class="table-of-contents__link toc-highlight">modifyIndividualParticipantIds</a></li><li><a href="#modifypairassignment" class="table-of-contents__link toc-highlight">modifyPairAssignment</a></li><li><a href="#modifyparticipant" class="table-of-contents__link toc-highlight">modifyParticipant</a></li><li><a href="#modifypenalty" class="table-of-contents__link toc-highlight">modifyPenalty</a></li><li><a href="#modifyparticipantssigninstatus" class="table-of-contents__link toc-highlight">modifyParticipantsSignInStatus</a></li><li><a href="#modifyseedassignment" class="table-of-contents__link toc-highlight">modifySeedAssignment</a></li><li><a href="#modifytieformat" class="table-of-contents__link toc-highlight">modifyTieFormat</a></li><li><a href="#modifyvenue" class="table-of-contents__link toc-highlight">modifyVenue</a></li><li><a href="#newtournamentrecord" class="table-of-contents__link toc-highlight">newTournamentRecord</a></li><li><a href="#ordercollectiondefinitions" class="table-of-contents__link toc-highlight">orderCollectionDefinitions</a></li><li><a href="#participantscaleitem" class="table-of-contents__link toc-highlight">participantScaleItem</a></li><li><a href="#participantscheduledmatchups" class="table-of-contents__link toc-highlight">participantScheduledMatchUps</a></li><li><a href="#positionactions" class="table-of-contents__link toc-highlight">positionActions</a></li><li><a href="#promotealternates" class="table-of-contents__link toc-highlight">promoteAlternates</a></li><li><a href="#publishevent" class="table-of-contents__link toc-highlight">publishEvent</a></li><li><a href="#publisheventseeding" class="table-of-contents__link toc-highlight">publishEventSeeding</a></li><li><a href="#publishorderofplay" class="table-of-contents__link toc-highlight">publishOrderOfPlay</a></li><li><a href="#qualifierdrawpositionassignment" class="table-of-contents__link toc-highlight">qualifierDrawPositionAssignment</a></li><li><a href="#regenerateparticipantnames" class="table-of-contents__link toc-highlight">regenerateParticipantNames</a></li><li><a href="#removecollectiondefinition" class="table-of-contents__link toc-highlight">removeCollectionDefinition</a></li><li><a href="#removecollectiongroup" class="table-of-contents__link toc-highlight">removeCollectionGroup</a></li><li><a href="#removedrawdefinitionextension" class="table-of-contents__link toc-highlight">removeDrawDefinitionExtension</a></li><li><a href="#removedrawpositionassignment" class="table-of-contents__link toc-highlight">removeDrawPositionAssignment</a></li><li><a href="#removedrawentries" class="table-of-contents__link toc-highlight">removeDrawEntries</a></li><li><a href="#removeevententries" class="table-of-contents__link toc-highlight">removeEventEntries</a></li><li><a href="#removeeventextension" class="table-of-contents__link toc-highlight">removeEventExtension</a></li><li><a href="#removeeventmatchupformattiming" class="table-of-contents__link toc-highlight">removeEventMatchUpFormatTiming</a></li><li><a href="#removeeventpolicy" class="table-of-contents__link toc-highlight">removeEventPolicy</a></li><li><a href="#removeindividualparticipantids" class="table-of-contents__link toc-highlight">removeIndividualParticipantIds</a></li><li><a href="#removematchupsideparticipant" class="table-of-contents__link toc-highlight">removeMatchUpSideParticipant</a></li><li><a href="#removeparticipantidsfromallteams" class="table-of-contents__link toc-highlight">removeParticipantIdsFromAllTeams</a></li><li><a href="#removeparticipantextension" class="table-of-contents__link toc-highlight">removeParticipantExtension</a></li><li><a href="#removepenalty" class="table-of-contents__link toc-highlight">removePenalty</a></li><li><a href="#removeroundmatchups" class="table-of-contents__link toc-highlight">removeRoundMatchUps</a></li><li><a href="#removescalevalues" class="table-of-contents__link toc-highlight">removeScaleValues</a></li><li><a href="#removeseeding" class="table-of-contents__link toc-highlight">removeSeeding</a></li><li><a href="#removestructure" class="table-of-contents__link toc-highlight">removeStructure</a></li><li><a href="#removetiematchupparticipantid" class="table-of-contents__link toc-highlight">removeTieMatchUpParticipantId</a></li><li><a href="#removetournamentextension" class="table-of-contents__link toc-highlight">removeTournamentExtension</a></li><li><a href="#renamestructures" class="table-of-contents__link toc-highlight">renameStructures</a></li><li><a href="#replacetiematchupparticipantid" class="table-of-contents__link toc-highlight">replaceTieMatchUpParticipantId</a></li><li><a href="#resetdrawdefinition" class="table-of-contents__link toc-highlight">resetDrawDefinition</a></li><li><a href="#resetscorecard" class="table-of-contents__link toc-highlight">resetScorecard</a></li><li><a href="#resettieformat" class="table-of-contents__link toc-highlight">resetTieFormat</a></li><li><a href="#resetvoluntaryconsolationstructure" class="table-of-contents__link toc-highlight">resetVoluntaryConsolationStructure</a></li><li><a href="#scaledteamassignment" class="table-of-contents__link toc-highlight">scaledTeamAssignment</a><ul><li><a href="#example-use-with-individualparticipantids-and-scaleattributes" class="table-of-contents__link toc-highlight">Example use with <code>individualParticipantIds</code> and <code>scaleAttributes</code></a></li><li><a href="#example-use-with-scaledparticipants" class="table-of-contents__link toc-highlight">Example use with <code>scaledParticipants</code></a></li><li><a href="#example-use-with-sequential-assignment-where-there-are-8-teams" class="table-of-contents__link toc-highlight">Example use with sequential assignment where there are 8 teams</a></li></ul></li><li><a href="#setdrawparticipantrepresentativeids" class="table-of-contents__link toc-highlight">setDrawParticipantRepresentativeIds</a></li><li><a href="#setentryposition" class="table-of-contents__link toc-highlight">setEntryPosition</a></li><li><a href="#setentrypositions" class="table-of-contents__link toc-highlight">setEntryPositions</a></li><li><a href="#seteventdates" class="table-of-contents__link toc-highlight">setEventDates</a></li><li><a href="#seteventenddate" class="table-of-contents__link toc-highlight">setEventEndDate</a></li><li><a href="#seteventstartdate" class="table-of-contents__link toc-highlight">setEventStartDate</a></li><li><a href="#setmatchupdailylimits" class="table-of-contents__link toc-highlight">setMatchUpDailyLimits</a></li><li><a href="#setmatchupformat" class="table-of-contents__link toc-highlight">setMatchUpFormat</a></li><li><a href="#setmatchupstatus" class="table-of-contents__link toc-highlight">setMatchUpStatus</a></li><li><a href="#setorderoffinish" class="table-of-contents__link toc-highlight">setOrderOfFinish</a><ul><li><a href="#validation" class="table-of-contents__link toc-highlight">Validation</a></li></ul></li><li><a href="#setparticipantscaleitem" class="table-of-contents__link toc-highlight">setParticipantScaleItem</a></li><li><a href="#setparticipantscaleitems" class="table-of-contents__link toc-highlight">setParticipantScaleItems</a></li><li><a href="#setpositionassignments" class="table-of-contents__link toc-highlight">setPositionAssignments</a></li><li><a href="#setstate" class="table-of-contents__link toc-highlight">setState</a></li><li><a href="#setsuborder" class="table-of-contents__link toc-highlight">setSubOrder</a></li><li><a href="#settournamentcategories" class="table-of-contents__link toc-highlight">setTournamentCategories</a></li><li><a href="#settournamentdates" class="table-of-contents__link toc-highlight">setTournamentDates</a></li><li><a href="#settournamentenddate" class="table-of-contents__link toc-highlight">setTournamentEndDate</a></li><li><a href="#settournamentid" class="table-of-contents__link toc-highlight">setTournamentId</a></li><li><a href="#settournamentname" class="table-of-contents__link toc-highlight">setTournamentName</a></li><li><a href="#settournamentnotes" class="table-of-contents__link toc-highlight">setTournamentNotes</a></li><li><a href="#settournamentstartdate" class="table-of-contents__link toc-highlight">setTournamentStartDate</a></li><li><a href="#settournamentstatus" class="table-of-contents__link toc-highlight">setTournamentStatus</a></li><li><a href="#swapdrawpositionassignments" class="table-of-contents__link toc-highlight">swapDrawPositionAssignments</a></li><li><a href="#toggleparticipantcheckinstate" class="table-of-contents__link toc-highlight">toggleParticipantCheckInState</a></li><li><a href="#tournamentmatchups" class="table-of-contents__link toc-highlight">tournamentMatchUps</a></li><li><a href="#unpublishevent" class="table-of-contents__link toc-highlight">unPublishEvent</a></li><li><a href="#unpublisheventseeding" class="table-of-contents__link toc-highlight">unPublishEventSeeding</a></li><li><a href="#unpublishorderofplay" class="table-of-contents__link toc-highlight">unPublishOrderOfPlay</a></li><li><a href="#updatedrawidsorder" class="table-of-contents__link toc-highlight">updateDrawIdsOrder</a></li><li><a href="#updateteamlineup" class="table-of-contents__link toc-highlight">updateTeamLineUp</a></li><li><a href="#updatetiematchupscore" class="table-of-contents__link toc-highlight">updateTieMatchUpScore</a></li><li><a href="#withdrawparticipantatdrawposition" class="table-of-contents__link toc-highlight">withdrawParticipantAtDrawPosition</a></li><li><a href="#validatecollectiondefinition" class="table-of-contents__link toc-highlight">validateCollectionDefinition</a></li><li><a href="#validateteamlineup" class="table-of-contents__link toc-highlight">validateTeamLineUp</a></li><li><a href="#version" class="table-of-contents__link toc-highlight">version</a></li></ul></div></div></div></div></main></div></div></div><footer class="footer footer--dark"><div class="container container-fluid"><div class="footer__bottom text--center"><div class="footer__copyright">Copyright  2023 CourtHive</div></div></div></footer></div>
</body>
</html>