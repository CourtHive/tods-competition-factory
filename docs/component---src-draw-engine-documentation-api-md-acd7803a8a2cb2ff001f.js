(window.webpackJsonp=window.webpackJsonp||[]).push([[15],{Jmwv:function(e,t,n){"use strict";n.r(t),n.d(t,"_frontmatter",(function(){return s})),n.d(t,"default",(function(){return p}));var a=n("Fcif"),i=n("+I+c"),r=n("/FXl"),c=n("TjRS"),s=(n("aD51"),{});void 0!==s&&s&&s===Object(s)&&Object.isExtensible(s)&&!s.hasOwnProperty("__filemeta")&&Object.defineProperty(s,"__filemeta",{configurable:!0,value:{name:"_frontmatter",filename:"src/drawEngine/documentation/api.md"}});var o={_frontmatter:s},l=c.a;function p(e){var t=e.components,n=Object(i.a)(e,["components"]);return Object(r.b)(l,Object(a.a)({},o,n,{components:t,mdxType:"MDXLayout"}),Object(r.b)("h1",{id:"drawengine-api-reference"},"drawEngine API Reference"),Object(r.b)("h2",{id:"adddrawentries"},"addDrawEntries"),Object(r.b)("pre",null,Object(r.b)("code",Object(a.a)({parentName:"pre"},{className:"language-js"}),"drawEngine.addDrawEntries({\n  participantIds, // an array of participantIds, should all be of the same participantType\n  entryStatus, // optional - defaults to DIRECT_ACCEPTANCE\n  stage, // optional - stage into which participantIds have been entered; defaults to MAIN\n});\n")),Object(r.b)("hr",null),Object(r.b)("h2",{id:"adddrawentry"},"addDrawEntry"),Object(r.b)("pre",null,Object(r.b)("code",Object(a.a)({parentName:"pre"},{className:"language-js"}),"drawEngine.addDrawEntry({\n  participantId,\n  entryStage, // optional - stage into which participantIds have been entered; defaults to MAIN\n  entryStatus, // optional - defaults to DIRECT_ACCEPTANCE\n  entryPosition, // optional - used to order entries, e.g. { entryPosition: 1 } for 1st alternate\n});\n")),Object(r.b)("hr",null),Object(r.b)("h2",{id:"addmatchupendtime"},"addMatchUpEndTime"),Object(r.b)("pre",null,Object(r.b)("code",Object(a.a)({parentName:"pre"},{className:"language-js"}),"const endTime = '2020-01-01T09:05:00Z';\ndrawEngine.addMatchUpEndTime({ matchUpId, endTime });\n")),Object(r.b)("hr",null),Object(r.b)("h2",{id:"addmatchupofficial"},"addMatchUpOfficial"),Object(r.b)("pre",null,Object(r.b)("code",Object(a.a)({parentName:"pre"},{className:"language-js"}),"drawEngine.addMatchUpOfficial({ matchUpId, participantId, officialType });\n")),Object(r.b)("hr",null),Object(r.b)("h2",{id:"addmatchupresumetime"},"addMatchUpResumeTime"),Object(r.b)("pre",null,Object(r.b)("code",Object(a.a)({parentName:"pre"},{className:"language-js"}),"const resumeTime = '2020-01-01T09:00:00Z';\ndrawEngine.addMatchUpResumeTime({ matchUpId, resumeTime });\n")),Object(r.b)("hr",null),Object(r.b)("h2",{id:"addmatchupscheduleddaydate"},"addMatchUpScheduledDayDate"),Object(r.b)("pre",null,Object(r.b)("code",Object(a.a)({parentName:"pre"},{className:"language-js"}),"const scheduledDayDate = '2020-01-01';\ndrawEngine.addMatchUpScheduledDayDate({ matchUpId, scheduledDayDate });\n")),Object(r.b)("hr",null),Object(r.b)("h2",{id:"addmatchupscheduledtime"},"addMatchUpScheduledTime"),Object(r.b)("pre",null,Object(r.b)("code",Object(a.a)({parentName:"pre"},{className:"language-js"}),"const scheduledTime = '08:00';\ndrawEngine.addMatchUpScheduledTime({ matchUpId, scheduledTime });\n")),Object(r.b)("hr",null),Object(r.b)("h2",{id:"addmatchupstarttime"},"addMatchUpStartTime"),Object(r.b)("pre",null,Object(r.b)("code",Object(a.a)({parentName:"pre"},{className:"language-js"}),"const startTime = '2020-01-01T08:05:00Z';\ndrawEngine.addMatchUpStartTime({ matchUpId, startTime });\n")),Object(r.b)("hr",null),Object(r.b)("h2",{id:"addmatchupstoptime"},"addMatchUpStopTime"),Object(r.b)("pre",null,Object(r.b)("code",Object(a.a)({parentName:"pre"},{className:"language-js"}),"const stopTime = '2020-01-01T08:15:00Z';\ndrawEngine.addMatchUpStopTime({ matchUpId, stopTime });\n")),Object(r.b)("hr",null),Object(r.b)("h2",{id:"addplayoffstructures"},"addPlayoffStructures"),Object(r.b)("pre",null,Object(r.b)("code",Object(a.a)({parentName:"pre"},{className:"language-js"}),"drawEngine.addPlayoffStructures({\n  structureId,\n  roundNumbers: [3], // optional if playoffPositions not provided; roundNumbers of structure to be played off.\n  playoffPositions: [3, 4], // optional if roundNumbers not provided; finishing positions to be played off.\n  playoffAttributes, // optional - mapping of exitProfile to structure names, e.g. 0-1-1 for SOUTH\n  playoffStructureNameBase, // optional - Root word for default playoff naming, e.g. 'Playoff' for 'Playoff 3-4'\n});\n")),Object(r.b)("hr",null),Object(r.b)("h2",{id:"addmatchuptimeitem"},"addMatchUpTimeItem"),Object(r.b)("pre",null,Object(r.b)("code",Object(a.a)({parentName:"pre"},{className:"language-js"}),"const timeItem = {\n  itemType: SCHEDULED_DATE,\n  itemValue: scheduledDayDate,\n};\ndrawEngine.addMatchUpTimeItem({\n  matchUpId,\n  timeItem,\n  duplicateValues: false,\n});\n")),Object(r.b)("hr",null),Object(r.b)("h2",{id:"setsuborder"},"setSubOrder"),Object(r.b)("p",null,"Assigns a subOrder value to a participant within a structure by drawPosition where participant has been assigned"),Object(r.b)("pre",null,Object(r.b)("code",Object(a.a)({parentName:"pre"},{className:"language-js"}),"drawEngine.setSubOrder({\n  structureId, // structure identifier within drawDefinition\n  drawPosition: 1, // drawPosition of the participant where subOrder is to be added\n  subOrder: 2, // order in which tied participant should receive finishing position\n});\n")),Object(r.b)("hr",null),Object(r.b)("h2",{id:"alldrawmatchups"},"allDrawMatchUps"),Object(r.b)("p",null,"Returns all matchUps from all structures within a draw."),Object(r.b)("pre",null,Object(r.b)("code",Object(a.a)({parentName:"pre"},{className:"language-js"}),"const { matchUps } = drawEngine.allDrawMatchUps({\n  context, // optional context to be added into matchUps\n  inContext, // boolean - add context { drawId, structureId, participant, individualParticipants ... }\n  roundFilter, // filter to target matchUps from specified rounds\n  nextMatchUps, // optioanl - boolean - to include winnerGoesTo and loserGoesTo\n  matchUpFilters, // attribute filters\n  contextFilters, // filters based on context attributes\n  includeByeMatchUps, // return matchUps with { matchUpStatus: BYE }\n  tournamentParticipants, // optional - provide an array of tournamentParticipants to add into matchUps\n  requireParticipants, // optional - require that participants be loaded into drawEngine or passed into method\n  tournamentAppliedPolicies, // any policies, such as privacy, to be applied to matchUps\n});\n")),Object(r.b)("hr",null),Object(r.b)("h2",{id:"allstructurematchups"},"allStructureMatchUps"),Object(r.b)("p",null,"Returns all matchUps from a single structure within a draw."),Object(r.b)("pre",null,Object(r.b)("code",Object(a.a)({parentName:"pre"},{className:"language-js"}),"const { matchUps } = drawEngine.allDrawMatchUps({\n  structureId,\n  context, // optional context to be added into matchUps\n  inContext, // boolean - add context { drawId, structureId, participant, individualParticipants ... }\n  roundFilter, // filter to target matchUps from specified rounds\n  nextMatchUps, // optioanl - boolean - to include winnerGoesTo and loserGoesTo\n  matchUpFilters, // attribute filters\n  contextFilters, // filters based on context attributes\n  includeByeMatchUps, // return matchUps with { matchUpStatus: BYE }\n  tournamentParticipants, // optional - provide an array of tournamentParticipants to add into matchUps\n  requireParticipants, // optional - require that participants be loaded into drawEngine or passed into method\n  tournamentAppliedPolicies, // any policies, such as privacy, to be applied to matchUps\n});\n")),Object(r.b)("hr",null),Object(r.b)("h2",{id:"analyzematchup"},"analyzeMatchUp"),Object(r.b)("p",null,"Method used internally by the ",Object(r.b)("inlineCode",{parentName:"p"},"scoreGovernor")," and ",Object(r.b)("inlineCode",{parentName:"p"},"keyValueScore"),"."),Object(r.b)("pre",null,Object(r.b)("code",Object(a.a)({parentName:"pre"},{className:"language-js"}),"const {\n  isActiveSet,\n  isExistingSet,\n  existingValue,\n  hasExistingValue,\n  isValidSideNumber,\n  completedSetsCount,\n  isCompletedMatchUp,\n  isLastSetWithValues,\n  validMatchUpOutcome,\n  matchUpScoringFormat,\n  calculatedWinningSide,\n  validMatchUpWinningSide,\n  completedSetsHaveValidOutcomes,\n  specifiedSetAnalysis: {\n    expectTiebreakSet,\n    expectTimedSet,\n    hasTiebreakCondition,\n    isCompletedSet,\n    isDecidingSet,\n    isTiebreakSet,\n    isValidSet,\n    isValidSetNumber,\n    isValidSetOutcome,\n    setFormat,\n    sideGameScores,\n    sideGameScoresCount,\n    sidePointScores,\n    sidePointScoresCount,\n    sideTiebreakScores,\n    sideTiebreakScoresCount,\n    winningSide,\n  },\n} = drawEngine.analyzeMatchUp({\n  matchUp,\n  sideNumber,\n  setNumber,\n  matchUpFormat,\n});\n")),Object(r.b)("hr",null),Object(r.b)("h2",{id:"analyzeset"},"analyzeSet"),Object(r.b)("pre",null,Object(r.b)("code",Object(a.a)({parentName:"pre"},{className:"language-js"}),"const {\n  expectTiebreakSet,\n  expectTimedSet,\n  hasTiebreakCondition,\n  isCompletedSet,\n  isDecidingSet,\n  isTiebreakSet,\n  isValidSet,\n  isValidSetNumber,\n  isValidSetOutcome,\n  setFormat,\n  sideGameScores,\n  sideGameScoresCount,\n  sidePointScores,\n  sidePointScoresCount,\n  sideTiebreakScores,\n  sideTiebreakScoresCount,\n  winningSide,\n} = drawEngine.analyzeSet({\n  setObject,\n  matchUpScoringFormat,\n});\n")),Object(r.b)("hr",null),Object(r.b)("h2",{id:"assigndrawposition"},"assignDrawPosition"),Object(r.b)("pre",null,Object(r.b)("code",Object(a.a)({parentName:"pre"},{className:"language-js"}),"drawEngine.assignDrawPosition({\n  structureId,\n  drawPosition,\n  participantId,\n});\n")),Object(r.b)("hr",null),Object(r.b)("h2",{id:"assigndrawpositionbye"},"assignDrawPositionBye"),Object(r.b)("pre",null,Object(r.b)("code",Object(a.a)({parentName:"pre"},{className:"language-js"}),"drawEngine.assignDrawPositionBye({\n  structureId,\n  drawPosition,\n});\n")),Object(r.b)("hr",null),Object(r.b)("h2",{id:"assignseed"},"assignSeed"),Object(r.b)("pre",null,Object(r.b)("code",Object(a.a)({parentName:"pre"},{className:"language-js"}),"result = drawEngine.assignSeed({\n  structureId,\n  seedNumber,\n  seedValue, // optional - display value, e.g. '5-8'\n  participantId,\n});\n")),Object(r.b)("hr",null),Object(r.b)("h2",{id:"attacheventpolicy"},"attachEventPolicy"),Object(r.b)("p",null,"Attaches a policy to an event within a tournamentRecord."),Object(r.b)("p",null,"See ",Object(r.b)("a",Object(a.a)({parentName:"p"},{href:"/tods-competition-factory/concepts/policies"}),"Policies"),"."),Object(r.b)("pre",null,Object(r.b)("code",Object(a.a)({parentName:"pre"},{className:"language-js"}),"drawEngine.attachEventPolicy({\n  eventId,\n  policyDefinition: SEEDING_POLICY,\n});\n")),Object(r.b)("hr",null),Object(r.b)("h2",{id:"attachpolicy"},"attachPolicy"),Object(r.b)("p",null,"Attaches a policy to a drawDefinition."),Object(r.b)("p",null,"See ",Object(r.b)("a",Object(a.a)({parentName:"p"},{href:"/tods-competition-factory/concepts/policies"}),"Policies"),"."),Object(r.b)("pre",null,Object(r.b)("code",Object(a.a)({parentName:"pre"},{className:"language-js"}),"drawEngine.attachPolicy({ policyDefinition: SEEDING_POLICY });\n")),Object(r.b)("hr",null),Object(r.b)("h2",{id:"automatedpositioning"},"automatedPositioning"),Object(r.b)("p",null,"Positions participants in a draw structure. ",Object(r.b)("inlineCode",{parentName:"p"},"drawEngine")," is agnostic about the type of participants that are placed in a draw structure, but requires tournament participants for avoidance policies to work."),Object(r.b)("p",null,"See ",Object(r.b)("a",Object(a.a)({parentName:"p"},{href:"/tods-competition-factory/concepts/policies"}),"Policies"),"."),Object(r.b)("pre",null,Object(r.b)("code",Object(a.a)({parentName:"pre"},{className:"language-js"}),"drawEngine.automatedPositioning({\n  structureId,\n  participants, // optional - participants must be passed in for Avoidance Policies to be effective\n});\n")),Object(r.b)("hr",null),Object(r.b)("h2",{id:"checkinparticipant"},"checkInParticipant"),Object(r.b)("p",null,"Set the check-in state for a participant. Used to determine when both participants in a matchUp are available to be assigned to a court."),Object(r.b)("pre",null,Object(r.b)("code",Object(a.a)({parentName:"pre"},{className:"language-js"}),"drawEngine.checkInParticipant({\n  matchUpId,\n  participantId,\n});\n")),Object(r.b)("hr",null),Object(r.b)("h2",{id:"checkoutparticipant"},"checkOutParticipant"),Object(r.b)("pre",null,Object(r.b)("code",Object(a.a)({parentName:"pre"},{className:"language-js"}),"drawEngine.checkOutParticipant({\n  matchUpId,\n  participantId,\n});\n")),Object(r.b)("hr",null),Object(r.b)("h2",{id:"cleardrawposition"},"clearDrawPosition"),Object(r.b)("p",null,"Removes a ",Object(r.b)("inlineCode",{parentName:"p"},"participantId")," or ",Object(r.b)("inlineCode",{parentName:"p"},"bye")," from a specified ",Object(r.b)("inlineCode",{parentName:"p"},"drawPosition")," within a ",Object(r.b)("inlineCode",{parentName:"p"},"structure")," or, optionally, removes a specified ",Object(r.b)("inlineCode",{parentName:"p"},"participantId")," from a ",Object(r.b)("inlineCode",{parentName:"p"},"structure"),"."),Object(r.b)("pre",null,Object(r.b)("code",Object(a.a)({parentName:"pre"},{className:"language-js"}),"drawEngine.clearDrawPosition({\n  structureId,\n  drawPosition, // optional if participantId is provided\n  participantId, // optional if drawPosition is provided\n});\n")),Object(r.b)("hr",null),Object(r.b)("h2",{id:"devcontext"},"devContext"),Object(r.b)("p",null,"Setting devContext(true) bypasses ",Object(r.b)("strong",{parentName:"p"},"try {} catch (err) {}")," code block and in some cases enables logging"),Object(r.b)("pre",null,Object(r.b)("code",Object(a.a)({parentName:"pre"},{className:"language-js"}),"drawEngine.devContext(true);\n")),Object(r.b)("hr",null),Object(r.b)("h2",{id:"drawmatchups"},"drawMatchUps"),Object(r.b)("p",null,"Returns categorized matchUps from all structures within a draw."),Object(r.b)("pre",null,Object(r.b)("code",Object(a.a)({parentName:"pre"},{className:"language-js"}),"const {\n  upcomingMatchUps,\n  pendingMatchUps,\n  completedMatchUps,\n  abandonedMatchUps,\n  byeMatchUps,\n} = drawEngine.allDrawMatchUps({\n  context, // optional context to be added into matchUps\n  inContext, // boolean - add context { drawId, structureId, participant, individualParticipants ... }\n  roundFilter, // filter to target matchUps from specified rounds\n  nextMatchUps, // optioanl - boolean - to include winnerGoesTo and loserGoesTo\n  matchUpFilters, // attribute filters\n  contextFilters, // filters based on context attributes\n  includeByeMatchUps, // return matchUps with { matchUpStatus: BYE }\n  tournamentParticipants, // optional - provide an array of tournamentParticipants to add into matchUps\n  requireParticipants, // optional - require that participants be loaded into drawEngine or passed into method\n  tournamentAppliedPolicies, // any policies, such as privacy, to be applied to matchUps\n});\n")),Object(r.b)("hr",null),Object(r.b)("h2",{id:"findmatchup"},"findMatchUp"),Object(r.b)("pre",null,Object(r.b)("code",Object(a.a)({parentName:"pre"},{className:"language-js"}),"const {\n  matchUp,\n  structure, // returned for convenience\n} = drawEngine.findMatchUp({\n  matchUpId,\n  inContext, // optional - boolean - returns matchUp with additional attributes\n  tournamentParticipants, // optional - enables inContext matchUp to contain full participant objects\n});\n")),Object(r.b)("hr",null),Object(r.b)("h2",{id:"generatedrawtype"},"generateDrawType"),Object(r.b)("p",null,"Convenience method to generate pre-defined drawTypes."),Object(r.b)("p",null,"For more information on ",Object(r.b)("inlineCode",{parentName:"p"},"feedPolicy")," see ",Object(r.b)("a",Object(a.a)({parentName:"p"},{href:"/tods-competition-factory/drawEngine/feedPolicies"}),"Feed Policies"),"."),Object(r.b)("pre",null,Object(r.b)("code",Object(a.a)({parentName:"pre"},{className:"language-js"}),"drawEngine.generateDrawType({\n  drawType, // defaults to SINGLE_ELIMINATION\n\n  matchUpFormat, // optional - default matchUpFormat\n  playoffMatchUpFormat, // optional - default playoffMatchUpFormat\n\n  seedingProfile, // optional - applies only to WATERFALL seeding in ROUND_ROBIN structures\n  feedPolicy, // optional - provides fine-grain control for FEED_IN_CONSOLATION feed links\n\n  qualifyingRound, // optional - for qualifying draw structures, roundNumber to win to qualify\n  qualifyingPositions, // optional - number of drawPositions to be filled by qualifiers\n  finishingPositionLimit, // optional - for playoff structures, limit to the number of positions to be played off\n\n  structureOptions: {\n    groupSize, // e.g. 4 participants per group\n    groupSizeLimit: 8,\n  },\n\n  goesTo, // optional - generate winnerGoesTo and loserGoesTo attributes\n  uuids, // optional - array of UUIDs to be used for structureIds and matchUpIds\n\n  stage, // optional - defaults to MAIN\n  structureName, // optional - defaults to stage\n});\n")),Object(r.b)("hr",null),Object(r.b)("h2",{id:"generatequalifyinglink"},"generateQualifyingLink"),Object(r.b)("p",null,"Generates and adds a ",Object(r.b)("inlineCode",{parentName:"p"},"link")," to ",Object(r.b)("inlineCode",{parentName:"p"},"drawDefinition.links"),"."),Object(r.b)("pre",null,Object(r.b)("code",Object(a.a)({parentName:"pre"},{className:"language-js"}),"drawEngine.generateQualifyingLink({\n  qualifyingStructureId,\n  mainStructureId,\n  qualifyingRound,\n});\n")),Object(r.b)("hr",null),Object(r.b)("h2",{id:"generatescorestring"},"generateScoreString"),Object(r.b)("pre",null,Object(r.b)("code",Object(a.a)({parentName:"pre"},{className:"language-js"}),"const sets = [\n  {\n    side1Score: 6,\n    side2Score: 7,\n    side1TiebreakScore: 3,\n    side2TiebreakScore: 7,\n    winningSide: 2,\n  },\n  {\n    side1Score: 7,\n    side2Score: 6,\n    side1TiebreakScore: 14,\n    side2TiebreakScore: 12,\n    winningSide: 1,\n  },\n  { side1Score: 3 },\n];\nlet result = generateScoreString({\n    sets, // TODS sets object\n    winningSide, // optional - 1 or 2\n    reversed, // optional - reverse the score\n    winnerFirst = true, // optional - boolean - tranform sets so that winningSide is first (on left)\n    matchUpStatus, // optional - used to annotate scoreString\n    addOutcomeString, // optional - tranform matchUpStatus into outcomeString appended to scoreString\n    autoComplete: true, // optional - complete missing set score\n  });\n")),Object(r.b)("hr",null),Object(r.b)("h2",{id:"generatetiematchupscorestring"},"generateTieMatchUpScoreString"),Object(r.b)("p",null,"Returns string representation of current tieMatchUp score."),Object(r.b)("pre",null,Object(r.b)("code",Object(a.a)({parentName:"pre"},{className:"language-js"}),"drawEngine.generateTieMatchUpScoreString({\n  matchUp,\n  separator, // optional - defaults to '-'\n});\n")),Object(r.b)("hr",null),Object(r.b)("h2",{id:"getavailableplayoffrounds"},"getAvailablePlayoffRounds"),Object(r.b)("p",null,"Returns rounds of a structure which are available for adding playoff structures."),Object(r.b)("pre",null,Object(r.b)("code",Object(a.a)({parentName:"pre"},{className:"language-js"}),"const {\n  playoffRounds,\n  playoffRoundsRanges,\n} = drawEngine.getAvailablePlayoffRounds({\n  structureId,\n});\n")),Object(r.b)("p",null,"...For a SINGLE_ELIMINATION struture with drawSize: 16 would return:"),Object(r.b)("pre",null,Object(r.b)("code",Object(a.a)({parentName:"pre"},{className:"language-js"}),"    {\n      playoffRounds: [ 1, 2, 3 ],\n      playoffRoundsRanges: [\n        { round: 1, range: '9-16' },\n        { round: 2, range: '5-8' },\n        { round: 3, range: '3-4' }\n      ]\n    }\n\n")),Object(r.b)("hr",null),Object(r.b)("h2",{id:"getcheckedinparticipantids"},"getCheckedInParticipantIds"),Object(r.b)("pre",null,Object(r.b)("code",Object(a.a)({parentName:"pre"},{className:"language-js"}),"const {\n  allParticipantsCheckedIn, // boolean\n  checkedInParticipantIds, // array of participantIds\n} = drawEngine.getCheckedInParticipantIds({ matchUp });\n")),Object(r.b)("hr",null),Object(r.b)("h2",{id:"getdrawstructures"},"getDrawStructures"),Object(r.b)("pre",null,Object(r.b)("code",Object(a.a)({parentName:"pre"},{className:"language-js"}),"const { structures } = drawEngine.getDrawStructures({\n  stage, // optional - filter by stage\n  stageSequence, // optiona - filter by stageSequence\n});\n")),Object(r.b)("hr",null),Object(r.b)("h2",{id:"getmatchupcontextids"},"getMatchUpContextIds"),Object(r.b)("p",null,"Convenience method to find a ",Object(r.b)("inlineCode",{parentName:"p"},"matchUp")," by ",Object(r.b)("inlineCode",{parentName:"p"},"matchUpId"),' and return "context ids". Does NOT require that drawEngine state be set, but does require an array of "inContext" ',Object(r.b)("inlineCode",{parentName:"p"},"matchUps"),"."),Object(r.b)("pre",null,Object(r.b)("code",Object(a.a)({parentName:"pre"},{className:"language-js"}),"const {\n  matchUpId,\n  drawId,\n  eventId,\n  structureId,\n  tournamentId,\n} = drawEngine.getMatchUpContextIds({ matchUps, matchUpId });\n")),Object(r.b)("hr",null),Object(r.b)("h2",{id:"getmatchupparticipantids"},"getMatchUpParticipantIds"),Object(r.b)("p",null,"Convenience function; requires inContext matchUp."),Object(r.b)("pre",null,Object(r.b)("code",Object(a.a)({parentName:"pre"},{className:"language-js"}),"const {\n  sideParticipantIds,\n  individualParticipantIds,\n} = drawEngine.getMatchUpParticipantIds({ matchUp });\n")),Object(r.b)("hr",null),Object(r.b)("h2",{id:"getmatchupscheduledetails"},"getMatchUpScheduleDetails"),Object(r.b)("p",null,"Returns the latest values for all ",Object(r.b)("inlineCode",{parentName:"p"},"matchUp.timeItems"),", along with calculated values, that relate to the scheduling of a ",Object(r.b)("inlineCode",{parentName:"p"},"matchUp"),"."),Object(r.b)("pre",null,Object(r.b)("code",Object(a.a)({parentName:"pre"},{className:"language-js"}),"const {\n  schedule: {\n    time,\n    courtId,\n    venueId,\n    startTime,\n    endTime,\n    milliseconds,\n    scheduledDate,\n    scheduledTime,\n  },\n} = drawEngine.getMatchUpScheduleDetails({ matchUp });\n")),Object(r.b)("hr",null),Object(r.b)("h2",{id:"getnextseedblock"},"getNextSeedBlock"),Object(r.b)("p",null,"Returns the next block of drawPositions which are to be assigned seeded participants."),Object(r.b)("pre",null,Object(r.b)("code",Object(a.a)({parentName:"pre"},{className:"language-js"}),"const {\n  nextSeedBlock,\n  unplacedSeedParticipantIds,\n  unplacedSeedNumbers,\n  unfilledPositions,\n  unplacedSeedAssignments,\n} = drawEngine.getNextSeedBlock({\n  structureId,\n});\n")),Object(r.b)("hr",null),Object(r.b)("h2",{id:"getnextunfilleddrawpositions"},"getNextUnfilledDrawPositions"),Object(r.b)("p",null,"Returns the next valid block of unfilled drawPositions. Useful for UI to give visual indication of drawPostions valid to assign."),Object(r.b)("pre",null,Object(r.b)("code",Object(a.a)({parentName:"pre"},{className:"language-js"}),"const { nextUnfilledDrawPositions } = drawEngine.getNextUnfilledDrawPositions({\n  structureId,\n});\n")),Object(r.b)("hr",null),Object(r.b)("h2",{id:"getparticipantidfinishingpositions"},"getParticipantIdFinishingPositions"),Object(r.b)("p",null,"Returns the Range of finishing positions possible for all participantIds within a draw"),Object(r.b)("pre",null,Object(r.b)("code",Object(a.a)({parentName:"pre"},{className:"language-js"}),"const idMap = drawEngine.getParticipantIdFinishingPositions({\n  byeAdvancements, // optional boolean - whether or not to consider byeAdvancements\n});\n\nconst {\n  relevantMatchUps,\n  finishingPositionRanges,\n  finishingPositionRange,\n} = idMap[participantId];\n")),Object(r.b)("hr",null),Object(r.b)("h2",{id:"getpositionsplayedoff"},"getPositionsPlayedOff"),Object(r.b)("p",null,"Determines which finishing positions will be returned by a draw. For example, a First Match Loser Consolation with a draw size of 16 will playoff possitions 1, 2, 9 and 10."),Object(r.b)("pre",null,Object(r.b)("code",Object(a.a)({parentName:"pre"},{className:"language-js"}),"const { positionsPlayedOff } = getPositionsPlayedOff({ drawDefinition });\n")),Object(r.b)("hr",null),Object(r.b)("h2",{id:"getroundmatchups"},"getRoundMatchUps"),Object(r.b)("p",null,"Organizes matchUps by roundNumber. ",Object(r.b)("strong",{parentName:"p"},"roundMatchUps")," contains matchUp objects; ",Object(r.b)("strong",{parentName:"p"},"roundProfile")," provides an overview of drawPositions which have advanced to each round, a matchUpsCount, finishingPositionRange for winners and losers, and finishingRound."),Object(r.b)("pre",null,Object(r.b)("code",Object(a.a)({parentName:"pre"},{className:"language-js"}),"const { roundMatchUps, roundProfile } = getRoundMatchUps({ matchUps });\n")),Object(r.b)("hr",null),Object(r.b)("h2",{id:"getsourcerounds"},"getSourceRounds"),Object(r.b)("p",null,"Returns the round numbers for desired playoff positions."),Object(r.b)("pre",null,Object(r.b)("code",Object(a.a)({parentName:"pre"},{className:"language-js"}),"const {\n  sourceRounds, // all source rounds for playedOff positions and specified playoffPositions\n  playoffSourceRounds,\n  playedOffSourceRounds,\n  playoffPositionsReturned,\n} = getSourceRounds({\n  drawDefinition,\n  structureId,\n  playoffPositions: [3, 4],\n});\n")),Object(r.b)("hr",null),Object(r.b)("h2",{id:"getstructureseedassignments"},"getStructureSeedAssignments"),Object(r.b)("p",null,"Returns seedAssignments for a specific structure based on structureId or structure"),Object(r.b)("p",null,"The structure of an ",Object(r.b)("strong",{parentName:"p"},Object(r.b)("em",{parentName:"strong"},"assignment object"))," is as follows:"),Object(r.b)("pre",null,Object(r.b)("code",Object(a.a)({parentName:"pre"},{className:"language-json"}),'{\n  "seedNumber": 1,\n  "seedValue": 1,\n  "participantId": "uuid-of-participant"\n}\n')),Object(r.b)("p",null,"The most basic usage is to retrieve seed assignments for a draw which has a single main stage structure"),Object(r.b)("pre",null,Object(r.b)("code",Object(a.a)({parentName:"pre"},{className:"language-js"}),"const { seedAssignments } = drawEngine.getStructureSeedAssignments({\n  structureId,\n});\n")),Object(r.b)("hr",null),Object(r.b)("h2",{id:"getstate"},"getState"),Object(r.b)("p",null,"No parameters."),Object(r.b)("p",null,"Returns a deep copy of the current drawEngine state."),Object(r.b)("pre",null,Object(r.b)("code",Object(a.a)({parentName:"pre"},{className:"language-js"}),"const { drawDefinition } = drawEngine.getState({\n  convertExtensions, // optional - convert extensions to '_' prefixed attributes\n});\n")),Object(r.b)("hr",null),Object(r.b)("h2",{id:"initializestructureseedassignments"},"initializeStructureSeedAssignments"),Object(r.b)("p",null,"Creates the ",Object(r.b)("inlineCode",{parentName:"p"},"seedAssignments")," attribute for the specified structure."),Object(r.b)("pre",null,Object(r.b)("code",Object(a.a)({parentName:"pre"},{className:"language-js"}),"drawEngine.initializeStructureSeedAssignments({\n  structureId,\n  seedsCount,\n});\n")),Object(r.b)("hr",null),Object(r.b)("h2",{id:"iscompletedstructure"},"isCompletedStructure"),Object(r.b)("p",null,"Returns boolean whether all matchUps in a given structure have been completed"),Object(r.b)("pre",null,Object(r.b)("code",Object(a.a)({parentName:"pre"},{className:"language-js"}),"const structureIsComplete = isCompletedStructure({\n  structureId,\n});\n")),Object(r.b)("hr",null),Object(r.b)("h2",{id:"matchupactions"},"matchUpActions"),Object(r.b)("p",null,"Return an array of all validActions for a specific matchUp."),Object(r.b)("pre",null,Object(r.b)("code",Object(a.a)({parentName:"pre"},{className:"language-js"}),"const {\n  isByeMatchUp, // boolean; true if matchUp includes a BYE\n  structureIsComplete, // boolean; true if structure is ready for positioning\n  validActions, // array of possible actions given current matchUpStatus\n} = drawEngine.matchUpActions({\n  matchUpId,\n});\n\nconst {\n  type, // 'REFEREE', 'SCHEDULE', 'PENALTY', 'STATUS', 'SCORE', 'START', 'END'.\n  method, // tournamentEngine method relating to action type\n  payload, // attributes to be passed to method\n  // additional method-specific options for values to be added to payload when calling method\n} = validAction;\n")),Object(r.b)("hr",null),Object(r.b)("h2",{id:"matchupduration"},"matchUpDuration"),Object(r.b)("p",null,"Calculates matchUp duration from START, STOP, RESUME, END timeItems."),Object(r.b)("pre",null,Object(r.b)("code",Object(a.a)({parentName:"pre"},{className:"language-js"}),'const {\n  milliseconds,\n  time, // string representation of elapsed time, e.g. "01:10:00" for an hour and 10 seconds\n  relevantTimeItems,\n} = drawEngine.matchUpDuration({\n  matchUp,\n});\n')),Object(r.b)("hr",null),Object(r.b)("h2",{id:"matchupsort"},"matchUpSort"),Object(r.b)("p",null,"Sorting function to arrange matchUps by stage, stageSequence, roundNumber, roundPosition (where applicable)"),Object(r.b)("p",null,"Used by ",Object(r.b)("inlineCode",{parentName:"p"},"mocksEngine")," for automatically scoring all matchUps in connected draw structures as part of test suites."),Object(r.b)("pre",null,Object(r.b)("code",Object(a.a)({parentName:"pre"},{className:"language-js"}),"const { matchUps } = drawEngine.allDrawMatchUps();\nconst sortedMatchUps = matchUps.sort(drawEngine.matchUpSort);\n")),Object(r.b)("hr",null),Object(r.b)("h2",{id:"newdrawdefinition"},"newDrawDefinition"),Object(r.b)("p",null,"Creates a new drawDefinition within drawEngine state."),Object(r.b)("pre",null,Object(r.b)("code",Object(a.a)({parentName:"pre"},{className:"language-js"}),"const { drawId } = drawEngine.newDrawDefinition();\nconst { drawDefinition } = drawEngine.getState();\n")),Object(r.b)("hr",null),Object(r.b)("h2",{id:"positionactions"},"positionActions"),Object(r.b)("pre",null,Object(r.b)("code",Object(a.a)({parentName:"pre"},{className:"language-js"}),"const positionActions = drawEngine.positionActions({\n  structureId,\n  drawPosition,\n  policyDefinition: positionActionsPolicy, // optional - policy definiting what actions are allowed in client context\n});\n\nconst {\n  isActiveDrawPosition, // boolean\n  isByePosition, // boolean\n  isDrawPosition, // boolean\n  hasPositionAssiged, // boolean\n  validActions,\n} = positionActions;\n\nconst {\n  type, // 'ASSIGN', 'LUCKY', 'SWAP', 'BYE', 'REMOVE'\n  method, // tournamentEngine method relating to action type\n  payload, // attributes to be passed to method\n  // additional method-specific options for values to be added to payload when calling method\n} = validAction;\n")),Object(r.b)("hr",null),Object(r.b)("h2",{id:"removeentry"},"removeEntry"),Object(r.b)("pre",null,Object(r.b)("code",Object(a.a)({parentName:"pre"},{className:"language-js"}),"drawEngine.removeEntry({ participantId });\n")),Object(r.b)("hr",null),Object(r.b)("h2",{id:"reset"},"reset"),Object(r.b)("p",null,"Clears the drawEngine state."),Object(r.b)("pre",null,Object(r.b)("code",Object(a.a)({parentName:"pre"},{className:"language-js"}),"drawEngine.reset();\n")),Object(r.b)("hr",null),Object(r.b)("h2",{id:"resetmatchuptimeitems"},"resetMatchUpTimeItems"),Object(r.b)("p",null,"Removes all timeItems from a specified matchUp."),Object(r.b)("pre",null,Object(r.b)("code",Object(a.a)({parentName:"pre"},{className:"language-js"}),"drawEngine.resetMatchUpTimeItems({ matchUpId });\n")),Object(r.b)("hr",null),Object(r.b)("h2",{id:"setdrawdescription"},"setDrawDescription"),Object(r.b)("pre",null,Object(r.b)("code",Object(a.a)({parentName:"pre"},{className:"language-js"}),"const drawDescription = 'Draw Description';\ndrawEngine.setDrawDescription({ description: drawDescription });\n")),Object(r.b)("hr",null),Object(r.b)("h2",{id:"setmatchupformat"},"setMatchUpFormat"),Object(r.b)("p",null,"Sets the default ",Object(r.b)("inlineCode",{parentName:"p"},"matchUpFormat")," for a ",Object(r.b)("inlineCode",{parentName:"p"},"drawDefintion")," or a ",Object(r.b)("inlineCode",{parentName:"p"},"structure"),", or for a specific ",Object(r.b)("inlineCode",{parentName:"p"},"matchUp"),"."),Object(r.b)("pre",null,Object(r.b)("code",Object(a.a)({parentName:"pre"},{className:"language-js"}),"drawEngine.setMatchUpFormat({\n  matchUpFormat,\n  matchUpType, // optional - insures that a matchUpFormat is not set on a tieMatchUp\n  tieFormat, // optional - when setting the format for a tieMatchUp\n\n  structureId, // optional - if structureId is present and not matchUpId is present, then set for structure\n  matchUpId, // optional - if matchUpId is present then only set for matchUp\n});\n")),Object(r.b)("hr",null),Object(r.b)("h2",{id:"setmatchupstatus"},"setMatchUpStatus"),Object(r.b)("p",null,"Sets either matchUpStatus or score and winningSide. Handles any winner/loser participant movements within or across structures."),Object(r.b)("pre",null,Object(r.b)("code",Object(a.a)({parentName:"pre"},{className:"language-js"}),"drawEngine.setMatchUpStatus({\n  matchUpId,\n  matchUpTieId, // optional - if part of a TIE matchUp\n  matchUpStatus, // optional - if matchUpFormat differs from event/draw/structure defaults\n  winningSide,\n});\n")),Object(r.b)("hr",null),Object(r.b)("h2",{id:"setparticipants"},"setParticipants"),Object(r.b)("p",null,"Participants are not managed by the ",Object(r.b)("inlineCode",{parentName:"p"},"drawEngine"),", but they can be used when returning 'inContext' matchUps as well as when automated positioning relies on avoidance policies."),Object(r.b)("pre",null,Object(r.b)("code",Object(a.a)({parentName:"pre"},{className:"language-js"}),"drawEngine.setParticipants(participants);\n")),Object(r.b)("hr",null),Object(r.b)("h2",{id:"setstagealternatescount"},"setStageAlternatesCount"),Object(r.b)("p",null,"Sets an (optional) limit to the number of accepted alternates."),Object(r.b)("p",null,"Modifies the 'entryProfile' of a drawDefinition before the structures have been generated."),Object(r.b)("pre",null,Object(r.b)("code",Object(a.a)({parentName:"pre"},{className:"language-js"}),"drawEngine.setStageAlternatesCount({ alternatesCount: 8 });\n")),Object(r.b)("hr",null),Object(r.b)("h2",{id:"setstagedrawsize"},"setStageDrawSize"),Object(r.b)("p",null,"Modifies the 'entryProfile' of a drawDefinition before the structures have been generated."),Object(r.b)("pre",null,Object(r.b)("code",Object(a.a)({parentName:"pre"},{className:"language-js"}),"drawEngine.setStageDrawSize({ stage: QUALIFYING, drawSize: 8 });\ndrawEngine.setStageDrawSize({ stage: MAIN, drawSize: 16 });\n")),Object(r.b)("hr",null),Object(r.b)("h2",{id:"setstagequalifierscount"},"setStageQualifiersCount"),Object(r.b)("pre",null,Object(r.b)("code",Object(a.a)({parentName:"pre"},{className:"language-js"}),"drawEngine.setStageQualifiersCount({ qualifiersCount: 4 });\n")),Object(r.b)("hr",null),Object(r.b)("h2",{id:"setstagewildcardscount"},"setStageWildcardsCount"),Object(r.b)("pre",null,Object(r.b)("code",Object(a.a)({parentName:"pre"},{className:"language-js"}),"drawEngine.setStageWildcardsCount({ wildcardsCount: 2 });\n")),Object(r.b)("hr",null),Object(r.b)("h2",{id:"setstate"},"setState"),Object(r.b)("p",null,"Loads a drawDefinition into drawEngine."),Object(r.b)("pre",null,Object(r.b)("code",Object(a.a)({parentName:"pre"},{className:"language-js"}),"drawEngine.setsState(drawDefinition, deepCopy);\n")),Object(r.b)("p",null,"By default a deep copy of the tournament record is made so that mutations made by drawEngine do not affect the source object. An optional boolean parameter, ",Object(r.b)("em",{parentName:"p"},"deepCopy")," can be set to false to override this default behavior."),Object(r.b)("hr",null),Object(r.b)("h2",{id:"setsubscriptions"},"setSubscriptions"),Object(r.b)("p",null,"Please refer to the ",Object(r.b)("a",Object(a.a)({parentName:"p"},{href:"/tods-competition-factory/concepts/subscriptions"}),"Subscriptions")," in General Concepts."),Object(r.b)("hr",null),Object(r.b)("h2",{id:"structuresort"},"structureSort"),Object(r.b)("p",null,"Sorting function to arrange structures by stage, positionAssignments count (size) then stageSequence\nUsed internally to order Compass structures"),Object(r.b)("pre",null,Object(r.b)("code",Object(a.a)({parentName:"pre"},{className:"language-js"}),"const sortedStructures = drawDefinition.structures.sort(structureSort);\n")),Object(r.b)("hr",null),Object(r.b)("h2",{id:"swapdrawpositionassignments"},"swapDrawPositionAssignments"),Object(r.b)("p",null,"Swaps the ",Object(r.b)("inlineCode",{parentName:"p"},"participantIds")," of two ",Object(r.b)("inlineCode",{parentName:"p"},"drawPositions"),"."),Object(r.b)("pre",null,Object(r.b)("code",Object(a.a)({parentName:"pre"},{className:"language-js"}),"drawEngine.swapDrawPositionAssignments({ structureId, drawPositions });\n")),Object(r.b)("hr",null),Object(r.b)("h2",{id:"getstructurematchups"},"getStructureMatchUps"),Object(r.b)("p",null,"Returns categorized matchUps from a single structure."),Object(r.b)("pre",null,Object(r.b)("code",Object(a.a)({parentName:"pre"},{className:"language-js"}),"const {\n  upcomingMatchUps,\n  pendingMatchUps,\n  completedMatchUps,\n  abandonedMatchUps,\n  byeMatchUps,\n} = drawEngine.allDrawMatchUps({\n  structureId,\n  context, // optional context to be added into matchUps\n  inContext, // boolean - add context { drawId, structureId, participant, individualParticipants ... }\n  roundFilter, // filter to target matchUps from specified rounds\n  nextMatchUps, // optioanl - boolean - to include winnerGoesTo and loserGoesTo\n  matchUpFilters, // attribute filters\n  contextFilters, // filters based on context attributes\n  includeByeMatchUps, // return matchUps with { matchUpStatus: BYE }\n  tournamentParticipants, // optional - provide an array of tournamentParticipants to add into matchUps\n  requireParticipants, // optional - require that participants be loaded into drawEngine or passed into method\n  tournamentAppliedPolicies, // any policies, such as privacy, to be applied to matchUps\n});\n")),Object(r.b)("hr",null),Object(r.b)("h2",{id:"tallyparticipantresults"},"tallyParticipantResults"),Object(r.b)("p",null,"Method used to calculate finishing positions within a ROUND_ROBIN group."),Object(r.b)("pre",null,Object(r.b)("code",Object(a.a)({parentName:"pre"},{className:"language-js"}),"const { participantResults } = drawEngine.tallyParticipantResults({\n  matchUps: structureMatchUps,\n  matchUpFormat,\n});\n")),Object(r.b)("hr",null),Object(r.b)("h2",{id:"validdrawpositions"},"validDrawPositions"),Object(r.b)("p",null,"Returns boolean indicating whether all matchUps have valid draw positions"),Object(r.b)("pre",null,Object(r.b)("code",Object(a.a)({parentName:"pre"},{className:"language-js"}),"drawEngine.validDrawPositions({ matchUps });\n")),Object(r.b)("hr",null),Object(r.b)("h2",{id:"version"},"version"),Object(r.b)("p",null,"Returns NPM package version. Can be used in configurations that utilize Competition Factory engines on both client and server to ensure equivalency."),Object(r.b)("pre",null,Object(r.b)("code",Object(a.a)({parentName:"pre"},{className:"language-js"}),"const version = drawEngine.version();\n")),Object(r.b)("hr",null))}void 0!==p&&p&&p===Object(p)&&Object.isExtensible(p)&&!p.hasOwnProperty("__filemeta")&&Object.defineProperty(p,"__filemeta",{configurable:!0,value:{name:"MDXContent",filename:"src/drawEngine/documentation/api.md"}}),p.isMDXComponent=!0}}]);
//# sourceMappingURL=component---src-draw-engine-documentation-api-md-acd7803a8a2cb2ff001f.js.map