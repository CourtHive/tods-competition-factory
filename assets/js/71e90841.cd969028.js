"use strict";(self.webpackChunkdocumentation=self.webpackChunkdocumentation||[]).push([[2608],{7942:(e,t,n)=>{n.d(t,{Zo:()=>c,kt:()=>h});var a=n(959);function i(e,t,n){return t in e?Object.defineProperty(e,t,{value:n,enumerable:!0,configurable:!0,writable:!0}):e[t]=n,e}function r(e,t){var n=Object.keys(e);if(Object.getOwnPropertySymbols){var a=Object.getOwnPropertySymbols(e);t&&(a=a.filter((function(t){return Object.getOwnPropertyDescriptor(e,t).enumerable}))),n.push.apply(n,a)}return n}function o(e){for(var t=1;t<arguments.length;t++){var n=null!=arguments[t]?arguments[t]:{};t%2?r(Object(n),!0).forEach((function(t){i(e,t,n[t])})):Object.getOwnPropertyDescriptors?Object.defineProperties(e,Object.getOwnPropertyDescriptors(n)):r(Object(n)).forEach((function(t){Object.defineProperty(e,t,Object.getOwnPropertyDescriptor(n,t))}))}return e}function s(e,t){if(null==e)return{};var n,a,i=function(e,t){if(null==e)return{};var n,a,i={},r=Object.keys(e);for(a=0;a<r.length;a++)n=r[a],t.indexOf(n)>=0||(i[n]=e[n]);return i}(e,t);if(Object.getOwnPropertySymbols){var r=Object.getOwnPropertySymbols(e);for(a=0;a<r.length;a++)n=r[a],t.indexOf(n)>=0||Object.prototype.propertyIsEnumerable.call(e,n)&&(i[n]=e[n])}return i}var l=a.createContext({}),p=function(e){var t=a.useContext(l),n=t;return e&&(n="function"==typeof e?e(t):o(o({},t),e)),n},c=function(e){var t=p(e.components);return a.createElement(l.Provider,{value:t},e.children)},d="mdxType",u={inlineCode:"code",wrapper:function(e){var t=e.children;return a.createElement(a.Fragment,{},t)}},m=a.forwardRef((function(e,t){var n=e.components,i=e.mdxType,r=e.originalType,l=e.parentName,c=s(e,["components","mdxType","originalType","parentName"]),d=p(n),m=i,h=d["".concat(l,".").concat(m)]||d[m]||u[m]||r;return n?a.createElement(h,o(o({ref:t},c),{},{components:n})):a.createElement(h,o({ref:t},c))}));function h(e,t){var n=arguments,i=t&&t.mdxType;if("string"==typeof e||i){var r=n.length,o=new Array(r);o[0]=m;var s={};for(var l in t)hasOwnProperty.call(t,l)&&(s[l]=t[l]);s.originalType=e,s[d]="string"==typeof e?e:i,o[1]=s;for(var p=2;p<r;p++)o[p]=n[p];return a.createElement.apply(null,o)}return a.createElement.apply(null,n)}m.displayName="MDXCreateElement"},1e3:(e,t,n)=>{n.r(t),n.d(t,{assets:()=>l,contentTitle:()=>o,default:()=>u,frontMatter:()=>r,metadata:()=>s,toc:()=>p});var a=n(8957),i=(n(959),n(7942));const r={title:"Query Governor"},o=void 0,s={unversionedId:"governors/query-governor",id:"governors/query-governor",title:"Query Governor",description:"allDrawMatchUps",source:"@site/docs/governors/query-governor.md",sourceDirName:"governors",slug:"/governors/query-governor",permalink:"/tods-competition-factory/docs/governors/query-governor",draft:!1,tags:[],version:"current",frontMatter:{title:"Query Governor"},sidebar:"docs",previous:{title:"Publishing Governor",permalink:"/tods-competition-factory/docs/governors/publishing-governor"},next:{title:"Report Governor",permalink:"/tods-competition-factory/docs/governors/report-governor"}},l={},p=[{value:"allDrawMatchUps",id:"alldrawmatchups",level:2},{value:"allEventMatchUps",id:"alleventmatchups",level:2},{value:"allPlayoffPositionsFilled",id:"allplayoffpositionsfilled",level:2},{value:"allTournamentMatchUps",id:"alltournamentmatchups",level:2},{value:"competitionScheduleMatchUps",id:"competitionschedulematchups",level:2},{value:"drawMatchUps",id:"drawmatchups",level:2},{value:"eventMatchUps",id:"eventmatchups",level:2},{value:"getAllEventData",id:"getalleventdata",level:2},{value:"getAllStructureMatchUps",id:"getallstructurematchups",level:2},{value:"getAllowedDrawTypes",id:"getalloweddrawtypes",level:2},{value:"getAllowedMatchUpFormats",id:"getallowedmatchupformats",level:2},{value:"getAvailableMatchUpsCount",id:"getavailablematchupscount",level:2},{value:"getAvailablePlayoffProfiles",id:"getavailableplayoffprofiles",level:2},{value:"getCheckedInParticipantIds",id:"getcheckedinparticipantids",level:2},{value:"getCompetitionDateRange",id:"getcompetitiondaterange",level:2},{value:"getCompetitionPenalties",id:"getcompetitionpenalties",level:2},{value:"getCompetitionVenues",id:"getcompetitionvenues",level:2},{value:"getCourtInfo",id:"getcourtinfo",level:2},{value:"getCourts",id:"getcourts",level:2},{value:"getDrawData",id:"getdrawdata",level:2},{value:"getDrawParticipantRepresentativeIds",id:"getdrawparticipantrepresentativeids",level:2},{value:"getEligibleVoluntaryConsolationParticipants",id:"geteligiblevoluntaryconsolationparticipants",level:2},{value:"getEntriesAndSeedsCount",id:"getentriesandseedscount",level:2},{value:"getEntryStatusReports",id:"getentrystatusreports",level:2},{value:"getEvent",id:"getevent",level:2},{value:"getEvents",id:"getevents",level:2},{value:"getEventData",id:"geteventdata",level:2},{value:"getTimeItem",id:"gettimeitem",level:2},{value:"getEventProperties",id:"geteventproperties",level:2},{value:"getEventMatchUpFormatTiming",id:"geteventmatchupformattiming",level:2},{value:"getEventStructures",id:"geteventstructures",level:2},{value:"getFlightProfile",id:"getflightprofile",level:2},{value:"getMatchUpCompetitiveProfile",id:"getmatchupcompetitiveprofile",level:2},{value:"getMatchUpContextIds",id:"getmatchupcontextids",level:2},{value:"getMatchUpDependencies",id:"getmatchupdependencies",level:2},{value:"getMatchUpFormat",id:"getmatchupformat",level:2},{value:"getMatchUpFormatTiming",id:"getmatchupformattiming",level:2},{value:"getMatchUpFormatTimingUpdate",id:"getmatchupformattimingupdate",level:2},{value:"getMatchUpScheduleDetails",id:"getmatchupscheduledetails",level:2},{value:"getMatchUpsStats",id:"getmatchupsstats",level:2},{value:"getMatchUpDailyLimits",id:"getmatchupdailylimits",level:2},{value:"getModifiedMatchUpFormatTiming",id:"getmodifiedmatchupformattiming",level:2},{value:"getPairedParticipant",id:"getpairedparticipant",level:2},{value:"getParticipantEventDetails",id:"getparticipanteventdetails",level:2},{value:"getParticipantIdFinishingPositions",id:"getparticipantidfinishingpositions",level:2},{value:"getParticipantMembership",id:"getparticipantmembership",level:2},{value:"getParticipantResults",id:"getparticipantresults",level:2},{value:"getParticipants",id:"getparticipants",level:2},{value:"getLinkedTournamentIds",id:"getlinkedtournamentids",level:2},{value:"getPositionsPlayedOff",id:"getpositionsplayedoff",level:2},{value:"getRounds",id:"getrounds",level:2},{value:"getParticipantScaleItem",id:"getparticipantscaleitem",level:2},{value:"getParticipantSchedules",id:"getparticipantschedules",level:2},{value:"getParticipantSignInStatus",id:"getparticipantsigninstatus",level:2},{value:"getParticipantStats",id:"getparticipantstats",level:2},{value:"getPersonRequests",id:"getpersonrequests",level:2},{value:"getPolicyDefinitions",id:"getpolicydefinitions",level:2},{value:"getPositionAssignments",id:"getpositionassignments",level:2},{value:"getPredictiveAccuracy",id:"getpredictiveaccuracy",level:2},{value:"getRoundMatchUps",id:"getroundmatchups",level:2},{value:"getScaledEntries",id:"getscaledentries",level:2},{value:"getSchedulingProfile",id:"getschedulingprofile",level:2},{value:"getSchedulingProfileIssues",id:"getschedulingprofileissues",level:2},{value:"getSeedsCount",id:"getseedscount",level:2},{value:"getSeedingThresholds",id:"getseedingthresholds",level:2},{value:"getStructureSeedAssignments",id:"getstructureseedassignments",level:2},{value:"getStructureReports",id:"getstructurereports",level:2},{value:"getTeamLineUp",id:"getteamlineup",level:2},{value:"getTieFormat",id:"gettieformat",level:2},{value:"getTournamentInfo",id:"gettournamentinfo",level:2},{value:"getTournamentPersons",id:"gettournamentpersons",level:2},{value:"getTournamentPenalties",id:"gettournamentpenalties",level:2},{value:"getTournamentStructures",id:"gettournamentstructures",level:2},{value:"getValidGroupSizes",id:"getvalidgroupsizes",level:2},{value:"getVenuesAndCourts",id:"getvenuesandcourts",level:2},{value:"getVenueData",id:"getvenuedata",level:2},{value:"generateBookings",id:"generatebookings",level:2},{value:"getVenuesReport",id:"getvenuesreport",level:2},{value:"isCompletedStructure",id:"iscompletedstructure",level:2},{value:"isValidForQualifying",id:"isvalidforqualifying",level:2},{value:"isValidMatchUpFormat",id:"isvalidmatchupformat",level:2},{value:"matchUpActions",id:"matchupactions",level:2},{value:"participantScaleItem",id:"participantscaleitem",level:2},{value:"positionActions",id:"positionactions",level:2},{value:"tallyParticipantResults",id:"tallyparticipantresults",level:2},{value:"tournamentMatchUps",id:"tournamentmatchups",level:2}],c={toc:p},d="wrapper";function u(e){let{components:t,...n}=e;return(0,i.kt)(d,(0,a.Z)({},c,n,{components:t,mdxType:"MDXLayout"}),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-js"},"import { queryGovernor } from 'tods-competition-factory';\n")),(0,i.kt)("h2",{id:"alldrawmatchups"},"allDrawMatchUps"),(0,i.kt)("p",null,"Returns all matchUps from all structures within a draw."),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-js"},"const { matchUps } = engine.allDrawMatchUps({\n  participantsProfile, // optional - ability to specify additions to context (see parameters of getParticipants())\n  contextFilters, // filters based on context attributes\n  matchUpFilters, // attribute filters\n  nextMatchUps, // optioanl - boolean - to include winnerTo and loserTo\n  inContext, // boolean - add context { drawId, structureId, participant, individualParticipants ... }\n  context, // optional context to be added into matchUps\n  drawId,\n});\n")),(0,i.kt)("hr",null),(0,i.kt)("h2",{id:"alleventmatchups"},"allEventMatchUps"),(0,i.kt)("p",null,"Returns all matchUps for an event."),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-js"},"const { matchUps } = allEventMatchUps({\n  participantsProfile, // optional - ability to specify additions to context (see parameters of getParticipants())\n  scheduleVisibilityFilters, // { visibilityThreshold: Date, eventIds, drawIds }\n  matchUpFilters, // optional; [ scheduledDates: [], courtIds: [], stages: [], roundNumbers: [], matchUpStatuses: [], matchUpFormats: []]\n  contextFilters, // filters based on context attributes\n  nextMatchUps: true, // include winner/loser target matchUp details\n  inContext: true, // include contextual details\n  eventId,\n});\n")),(0,i.kt)("hr",null),(0,i.kt)("h2",{id:"allplayoffpositionsfilled"},"allPlayoffPositionsFilled"),(0,i.kt)("p",null,"Returns boolean value for whether playoff positions (which have been generated) are populated with ",(0,i.kt)("inlineCode",{parentName:"p"},"participantIds")," or ",(0,i.kt)("inlineCode",{parentName:"p"},"BYEs"),"."),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-js"},"const allPositionsFilled = engine.allPlayoffPositionsFilled({\n  structureId,\n  drawid,\n});\n")),(0,i.kt)("hr",null),(0,i.kt)("h2",{id:"alltournamentmatchups"},"allTournamentMatchUps"),(0,i.kt)("p",null,"Return an array of all matchUps contained within a tournament. These matchUps are returned ",(0,i.kt)("strong",{parentName:"p"},"inContext"),"."),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-js"},"const { matchUps, groupInfo } = engine.allTournamentMatchUps({\n  scheduleVisibilityFilters, // { visibilityThreshold: Date, eventIds, drawIds }\n  participantsProfile, // optional - ability to specify additions to context (see parameters of getParticipants())\n  matchUpFilters, // optional; [ scheduledDates: [], courtIds: [], stages: [], roundNumbers: [], matchUpStatuses: [], matchUpFormats: []]\n  contextFilters, // filters based on context attributes\n  nextMatchUps, // include winnerTo and loserTo matchUps\n  contextProfile, // optional: { inferGender: true, withCompetitiveness: true, withScaleValues: true, exclude: ['attribute', 'to', 'exclude']}\n});\n")),(0,i.kt)("hr",null),(0,i.kt)("h2",{id:"competitionschedulematchups"},"competitionScheduleMatchUps"),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-js"},"const matchUpFilters = {\n  isMatchUpTie: false,\n  scheduledDate, // scheduled date of matchUps to return\n};\n\nconst { completedMatchUps, dateMatchUps, courtsData, groupInfo, venues } = engine.competitionScheduleMatchUps({\n  alwaysReturnCompleted, // boolean - when true return completed matchUps regardless of publish state\n  courtCompletedMatchUps, // boolean - include completed matchUps in court.matchUps - useful for pro-scheduling\n  participantsProfile, // optional - ability to specify additions to context (see parameters of getParticipants())\n  withCourtGridRows, // optional boolean - return { rows } of matchUps for courts layed out as a grid, with empty cells\n  minCourtGridRows, // optional integer - minimum number of rows to return (compared to auto-calculated rows)\n  sortDateMatchUps, // boolean boolean - optional - defaults to `true`\n  usePublishState, // boolean - when true filter out events and dates that have not been published\n  matchUpFilters, // optional; [ scheduledDate, scheduledDates: [], courtIds: [], stages: [], roundNumbers: [], matchUpStatuses: [], matchUpFormats: []]\n  sortCourtsData, // boolean - optional\n});\n")),(0,i.kt)("hr",null),(0,i.kt)("h2",{id:"drawmatchups"},"drawMatchUps"),(0,i.kt)("p",null,"Returns categorized matchUps from all structures within a draw."),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-js"},"const { upcomingMatchUps, pendingMatchUps, completedMatchUps, abandonedMatchUps, byeMatchUps } = engine.drawMatchUps({\n  tournamentAppliedPolicies, // any policies, such as privacy, to be applied to matchUps\n  contextFilters, // filters based on context attributes\n  matchUpFilters, // attribute filters\n  nextMatchUps, // optioanl - boolean - to include winnerTo and loserTo\n  inContext, // boolean - add context { drawId, structureId, participant, individualParticipants ... }\n  context, // optional context to be added into matchUps\n});\n")),(0,i.kt)("hr",null),(0,i.kt)("h2",{id:"eventmatchups"},"eventMatchUps"),(0,i.kt)("p",null,"Returns matchUps for an event grouped by status."),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-js"},"const { abandonedMatchUps, byeMatchUps, completedMatchUps, pendingMatchUps, upcomingMatchUps } = engine.eventMatchUps({\n  eventId,\n  nextMatchUps, // optional boolean; include winner/loser target matchUp details\n  matchUpFilters, // optional; [ scheduledDates: [], courtIds: [], stages: [], roundNumbers: [], matchUpStatuses: [], matchUpFormats: []]\n  contextFilters,\n  tournamentAppliedPolicies,\n  scheduleVisibilityFilters, // { visibilityThreshold: Date, eventIds, drawIds }\n  inContext: true, // optional - adds context details to all matchUps\n});\n")),(0,i.kt)("hr",null),(0,i.kt)("h2",{id:"getalleventdata"},"getAllEventData"),(0,i.kt)("p",null,"Returns all ",(0,i.kt)("inlineCode",{parentName:"p"},"matchUps")," for all draws in all events along with ",(0,i.kt)("inlineCode",{parentName:"p"},"tournamentInfo"),", ",(0,i.kt)("inlineCode",{parentName:"p"},"eventInfo"),", and ",(0,i.kt)("inlineCode",{parentName:"p"},"drawInfo"),"."),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-js"},"const { allEventData } = engine.getAllEventData({\n  policyDefinitions, // optional - allows participant data to be filtered via a privacy policy\n});\n\nconst { tournamentInfo, eventsData, venuesData } = allEventData;\n")),(0,i.kt)("hr",null),(0,i.kt)("h2",{id:"getallstructurematchups"},"getAllStructureMatchUps"),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-js"},"const { matchUps } = engine.getAllStructureMatchUps({ drawId, structureId });\n")),(0,i.kt)("hr",null),(0,i.kt)("h2",{id:"getalloweddrawtypes"},"getAllowedDrawTypes"),(0,i.kt)("p",null,"Returns an array of names of allowed Draw Types, if any applicable policies have been applied to the tournamentRecord."),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-js"},"const drawTypes = engine.getAllowedDrawTypes();\n")),(0,i.kt)("hr",null),(0,i.kt)("h2",{id:"getallowedmatchupformats"},"getAllowedMatchUpFormats"),(0,i.kt)("p",null,"Returns an array of TODS matchUpFormat codes for allowed scoring formats, if any applicable policies have been applied to the tournamentRecord."),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-js"},"const drawTypes = engine.getAllowedMatchUpFormats();\n")),(0,i.kt)("hr",null),(0,i.kt)("h2",{id:"getavailablematchupscount"},"getAvailableMatchUpsCount"),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-js"},"const { availableMatchUpsCount } = engine.getAvailbleMatchUpsCount({\n  structureId, // required if there is more than one structure in the drawDefinition\n  roundNumber, // optional; will default to last roundNumber\n  drawId,\n});\n")),(0,i.kt)("hr",null),(0,i.kt)("h2",{id:"getavailableplayoffprofiles"},"getAvailablePlayoffProfiles"),(0,i.kt)("p",null,"If provided a ",(0,i.kt)("inlineCode",{parentName:"p"},"structureId"),", returns rounds of the selected structure which are available for adding playoff structures."),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-js"},"const { playoffRounds, playoffRoundsRanges, positionsPlayedOff } = engine.getAvailablePlayoffProfiles({\n  structureId,\n  drawId,\n});\n")),(0,i.kt)("p",null,"...for a SINGLE_ELIMINATION struture with ",(0,i.kt)("inlineCode",{parentName:"p"},"{ drawSize: 16 }")," this would return:"),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-js"},"{\n  playoffRounds: [ 1, 2, 3 ],\n  playoffRoundsRanges: [\n    { round: 1, range: '9-16' },\n    { round: 2, range: '5-8' },\n    { round: 3, range: '3-4' }\n  ]\n}\n")),(0,i.kt)("p",null,"...for a ROUND_ROBIN struture with ",(0,i.kt)("inlineCode",{parentName:"p"},"{ drawSize: 16 }")," and ",(0,i.kt)("inlineCode",{parentName:"p"},"{ groupSize: 4 }")," this would return:"),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-js"},'{\n    "finishingPositionsAvailable": [ 1, 2, 3, 4 ],\n    "playoffFinishingPositionRanges": [\n        {\n            "finishingPosition": 1,\n            "finishingPositions": [ 1, 2, 3, 4 ],\n            "finishingPositionRange": "1-4"\n        },\n        {\n            "finishingPosition": 2,\n            "finishingPositions": [ 5, 6, 7, 8 ],\n            "finishingPositionRange": "5-8"\n        },\n        {\n            "finishingPosition": 3,\n            "finishingPositions": [ 9, 10, 11, 12 ],\n            "finishingPositionRange": "9-12"\n        },\n        {\n            "finishingPosition": 4,\n            "finishingPositions": [ 13, 14, 15, 16 ],\n            "finishingPositionRange": "13-16"\n        }\n    ],\n}\n')),(0,i.kt)("p",null,"When no ",(0,i.kt)("inlineCode",{parentName:"p"},"structureId")," is provided, returns an array of ",(0,i.kt)("inlineCode",{parentName:"p"},"availablePlayoffProfiles")," with entries for each structure in a specified ",(0,i.kt)("inlineCode",{parentName:"p"},"drawDefinition"),"."),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-js"},"const { availablePlayoffProfiles, positionsPlayedOff } = engine.getAvailablePlayoffProfiles({ drawId });\n")),(0,i.kt)("hr",null),(0,i.kt)("h2",{id:"getcheckedinparticipantids"},"getCheckedInParticipantIds"),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-js"},"const {\n  allParticipantsCheckedIn, // boolean\n  checkedInParticipantIds, // array of participantIds\n} = engine.getCheckedInParticipantIds({ matchUp });\n")),(0,i.kt)("hr",null),(0,i.kt)("h2",{id:"getcompetitiondaterange"},"getCompetitionDateRange"),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-js"},"const { startDate, endDate } = engine.getCompetitionDateRange();\n")),(0,i.kt)("hr",null),(0,i.kt)("h2",{id:"getcompetitionpenalties"},"getCompetitionPenalties"),(0,i.kt)("p",null,"Returns an array of all penalties issued for all tournaments loaded into engine."),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-js"},"const { penalties } = engine.getCompetitionPenalties();\n")),(0,i.kt)("hr",null),(0,i.kt)("h2",{id:"getcompetitionvenues"},"getCompetitionVenues"),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-js"},"const { venues, venueIds } = engine.getCompetitionVenues();\n")),(0,i.kt)("hr",null),(0,i.kt)("h2",{id:"getcourtinfo"},"getCourtInfo"),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-js"},"const {\n  altitude,\n  courtId,\n  courtName,\n  courtDimensions,\n  latitude,\n  longitude,\n  surfaceCategory,\n  surfaceType,\n  surfacedDate,\n  pace,\n  notes,\n} = engine.getCourtInfo({ courtId });\n")),(0,i.kt)("hr",null),(0,i.kt)("h2",{id:"getcourts"},"getCourts"),(0,i.kt)("p",null,"Returns courts associated with a tournaments; optionally filter by venue(s)."),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-js"},"const { courts } = engine.getCourts({\n  venueId, // optional - return courts for a specific venue\n  venueIds, // optional - return courts for specified venues\n});\n")),(0,i.kt)("hr",null),(0,i.kt)("h2",{id:"getdrawdata"},"getDrawData"),(0,i.kt)("p",null,"Primarily used by ",(0,i.kt)("inlineCode",{parentName:"p"},"getEventData")," for publishing purposes."),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-js"},"const {\n  drawInfo: {\n    drawActive, // boolean - draw has active matchUps\n    drawCompleted, // boolean - all draw matchUps are complete\n    drawGenerated, // boolean - draw has structures containing matchUps\n    participantPlacements, // boolean - whether any participants have been placed in the draw\n  },\n  structures,\n} = engine.getDrawData({\n  allParticipantResults, // optional boolean; include round statistics per structure even for elimination structures\n  drawDefinition,\n});\n")),(0,i.kt)("hr",null),(0,i.kt)("h2",{id:"getdrawparticipantrepresentativeids"},"getDrawParticipantRepresentativeIds"),(0,i.kt)("p",null,"Get the participantIds of participants in the draw who are representing players by observing the creation of the draw."),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-js"},"const { representativeParticipantIds } = engine.getDrawParticipantRepresentativeIds({\n  drawId,\n});\n")),(0,i.kt)("hr",null),(0,i.kt)("h2",{id:"geteligiblevoluntaryconsolationparticipants"},"getEligibleVoluntaryConsolationParticipants"),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-js"},"const { eligibleParticipants } = engine.getEligibleVoluntaryConsolationParticipants({\n  excludedMatchUpStatuses, // optional - array of matchUpStatuses which are excluded from matchUpsLimit\n  includeQualifyingStage, // optional - allow losers in qualifying\n  finishingRoundLimit, // optional number - limits considered matchUps by finishingRound, e.g. 3 doesn't consider past QF\n  roundNumberLimit, // optional number - limits matchUps by roundNumber\n  matchUpsLimit, // optional number - limits the number of considered matchUps; works in tandem with excludedMatchUpStatuses\n  winsLimit, // defaults to 0, meaning only participants with no wins are eligible\n  requireLoss, // optional boolean - defaults to true; if false then all participants who have played and appear in MAIN draw are considered\n  requirePlay, // optional boolean - defaults to true; if false then all participants who appear in MAIN draw are considered\n  allEntries, // optional boolean - consider all entries, regardless of whether placed in draw\n  includeEventParticipants, // optional boolean - consider event entries rather than draw entries (if event is present)\n  drawId,\n});\n")),(0,i.kt)("hr",null),(0,i.kt)("h2",{id:"getentriesandseedscount"},"getEntriesAndSeedsCount"),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-js"},"const { error, entries, seedsCount, stageEntries } = engine.getEntriesAndSeedsCount({\n  policyDefinitions, // seeding policy which determines # of seeds for # of participants/drawSize\n  eventId,\n  drawSize, // optional - overrides number calculaed from entries in either event or draw\n  drawId, // optional - scopes entries to a specific flight/drawDefinition\n  stage, // optional - scopes entries to a specific stage\n});\n")),(0,i.kt)("hr",null),(0,i.kt)("h2",{id:"getentrystatusreports"},"getEntryStatusReports"),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-js"},"const {\n  tournamentEntryReport: {\n    nonParticipatingEntriesCount,\n    individualParticipantsCount,\n    drawDefinitionsCount,\n    eventsCount,\n  },\n  entryStatusReports, // count and pct of total for all entryStatuses for each event\n  participantEntryReports, // person entryStatus, ranking, seeding, WTN and confidence for each event\n  eventReports, // primarily internal use - entries for each event with main/qualifying seeding\n} = engine.getEntryStatusReports();\n")),(0,i.kt)("p",null,"To export reports as CSV:"),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-js"},"const entryStatusCSV = tools.JSON2CSV(entryStatusReports);\nconst personEntryCSV = tools.JSON2CSV(participantEntryReports);\n")),(0,i.kt)("hr",null),(0,i.kt)("h2",{id:"getevent"},"getEvent"),(0,i.kt)("p",null,"Get an event by either its ",(0,i.kt)("inlineCode",{parentName:"p"},"eventId")," or by a ",(0,i.kt)("inlineCode",{parentName:"p"},"drawId")," which it contains. Also returns ",(0,i.kt)("inlineCode",{parentName:"p"},"drawDefinition")," if a ",(0,i.kt)("inlineCode",{parentName:"p"},"drawId")," is specified."),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-js"},"const {\n  event,\n  drawDefinition, // only returned if drawId is specified\n} = engine.getEvent({\n  eventId, // optional - find event by eventId\n  drawId, // optional - find the event which contains specified drawId\n});\n")),(0,i.kt)("hr",null),(0,i.kt)("h2",{id:"getevents"},"getEvents"),(0,i.kt)("p",null,"Return ",(0,i.kt)("strong",{parentName:"p"},"deepCopies")," of all events in a tournament record."),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-js"},"const { events } = engine.getEvents({\n  withScaleValues, // optional boolean\n  scaleEventType, // override event.eventType for accessing scales, e.g. SINGLES override for DOUBLES events\n  inContext, // optional boolean hydrates with tournamentId\n  eventIds, // optional array\n  drawIds, // optional array\n  context, // optional object to spread into all targeted events\n});\n")),(0,i.kt)("hr",null),(0,i.kt)("h2",{id:"geteventdata"},"getEventData"),(0,i.kt)("p",null,"Returns event information optimized for publishing: ",(0,i.kt)("inlineCode",{parentName:"p"},"matchUps")," have context and separated into rounds for consumption by visualization libraries such as ",(0,i.kt)("inlineCode",{parentName:"p"},"tods-react-draws"),"."),(0,i.kt)("p",null,"See ",(0,i.kt)("a",{parentName:"p",href:"../concepts/policies"},"Policies")," for more details on ",(0,i.kt)("inlineCode",{parentName:"p"},"policyDefinitions"),"."),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-js"},"const { eventData } = engine.getEventData({\n  allParticipantResults, // optional boolean; include round statistics per structure even for elimination structures\n  participantsProfile, // optional - ability to specify additions to context (see parameters of getParticipants())\n  policyDefinitions, // optional\n  usePublishState, // optional - filter out draws which are not published\n  eventId,\n});\nconst { drawsData, venuesData, eventInfo, tournamentInfo } = eventData;\n")),(0,i.kt)("hr",null),(0,i.kt)("h2",{id:"gettimeitem"},"getTimeItem"),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-js"},"const { timeItem } = engine.getTimeItem({\n  itemType: ADD_SCALE_ITEMS,\n  itemSubTypes: [SEEDING], // optional\n  participantId, // optional\n  eventId, // optional\n  drawId, // optional\n});\n")),(0,i.kt)("p",null,"Or call without engine:"),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-js"},"getTimeItem({\n  tournamentRecord, // optional\n  drawDefinition, // optional\n  itemSubTypes, // optional\n  itemType, // required\n  element, // optional - arbitrary element, e.g. participant\n  event, // optional\n});\n")),(0,i.kt)("hr",null),(0,i.kt)("h2",{id:"geteventproperties"},"getEventProperties"),(0,i.kt)("p",null,"Gather attributes of events which come from other tournament elements, e.g. participants which have rankings/ratings/seedings for a given event."),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-js"},"const { entryScaleAttributes, hasSeededParticipants, hasRankedParticipants, hasRatedParticipants } =\n  engine.getEventProperties({ eventId });\n")),(0,i.kt)("p",null,"... where ",(0,i.kt)("strong",{parentName:"p"},"entryScaleAttributes")," is an array of ",(0,i.kt)("inlineCode",{parentName:"p"},"{ participantId, participantName, seed, ranking, rating }")),(0,i.kt)("hr",null),(0,i.kt)("h2",{id:"geteventmatchupformattiming"},"getEventMatchUpFormatTiming"),(0,i.kt)("p",null,"Method is used internally in advanced scheduling to determine averageMatchUp times for matchUps within an event."),(0,i.kt)("p",null,"Requires an array of ",(0,i.kt)("inlineCode",{parentName:"p"},"matchUpFormats")," either be defined in scoring policy that is attached to the tournamentRecord or an event, or passed in as parameter. ",(0,i.kt)("inlineCode",{parentName:"p"},"matchUpFormats")," can be passed either as an array of strings, or an array of ",(0,i.kt)("inlineCode",{parentName:"p"},"[{ matchUpFormat }]"),"."),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-js"},"const { eventMatchUpFormatTiming } = engine.getEventMatchUpFormatTiming({\n  matchUpFormats, // optional - can be retrieved from policy\n  categoryType, // optional - categoryType is not part of TODS or event attributes, but can be defined in a policy\n  eventId,\n});\n")),(0,i.kt)("hr",null),(0,i.kt)("h2",{id:"geteventstructures"},"getEventStructures"),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-js"},"const { structures, stageStructures } = engine.getEventStructures({\n  withStageGrouping: true, // optional return structures grouped by stages\n  stageSequences, // optional - specify stageSequences to include\n  stageSequence, // optional - filter by stageSequence\n  stages, // optional - specify stageSequences to include\n  stage, // optional - filter by stage\n  eventId, // REQUIRED\n});\n")),(0,i.kt)("hr",null),(0,i.kt)("h2",{id:"getflightprofile"},"getFlightProfile"),(0,i.kt)("p",null,"A ",(0,i.kt)("inlineCode",{parentName:"p"},"flightProfile")," is an extension on an ",(0,i.kt)("inlineCode",{parentName:"p"},"event")," detailing the parameters that will be used to generate ",(0,i.kt)("inlineCode",{parentName:"p"},"drawDefinitions")," within the ",(0,i.kt)("inlineCode",{parentName:"p"},"event"),". There is an array of ",(0,i.kt)("inlineCode",{parentName:"p"},"flights")," which specify attributes of a draw such as ",(0,i.kt)("inlineCode",{parentName:"p"},"drawEntries, drawName, drawId, flightNumber")," as well as ",(0,i.kt)("inlineCode",{parentName:"p"},"stage"),', which is significant for flights which are only intended to reflect VOLUNTARY_CONSOLATION structures. A Voluntary Consolation flight is "linked" to the flight from which competitors originate and will be automatically deleted if the source flight is deleted.'),(0,i.kt)("p",null,"If a ",(0,i.kt)("inlineCode",{parentName:"p"},"flight")," has already been used to generate a draw, the ",(0,i.kt)("inlineCode",{parentName:"p"},"drawDefinition")," will be returned with the profile."),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-js"},"const { flightProfile } = engine.getFlightProfile({ eventId });\n")),(0,i.kt)("hr",null),(0,i.kt)("h2",{id:"getmatchupcompetitiveprofile"},"getMatchUpCompetitiveProfile"),(0,i.kt)("p",null,'Returns a categorization of a matchUp as "Competitive", "Routine" or "Decisive"'),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-js"},"const {\n  competitiveness, // [COMPETITIVE, DECISIVE, ROUTINE]\n  pctSpread, // 0-100 - rounded loser's percent of games required to win\n} = engine.getMatchUpCompetitiveProfile({\n  profileBands, // optional { [DECISIVE]: 20, [ROUTINE]: 50 } // can be attached to tournamentRecord as a policy\n  matchUp,\n});\n")),(0,i.kt)("hr",null),(0,i.kt)("h2",{id:"getmatchupcontextids"},"getMatchUpContextIds"),(0,i.kt)("p",null,'Convenience method to get "context" ids for a ',(0,i.kt)("inlineCode",{parentName:"p"},"matchUp")," by ",(0,i.kt)("inlineCode",{parentName:"p"},"matchUpId"),'. Requires an array of "inContext" ',(0,i.kt)("inlineCode",{parentName:"p"},"matchUps"),"."),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-js"},"const { matchUpId, drawId, eventId, structureId, tournamentId } = engine.getMatchUpContextIds({\n  matchUpId,\n  matchUps,\n});\n")),(0,i.kt)("hr",null),(0,i.kt)("h2",{id:"getmatchupdependencies"},"getMatchUpDependencies"),(0,i.kt)("p",null,"For each ",(0,i.kt)("inlineCode",{parentName:"p"},"matchUpId")," returns an array of other ",(0,i.kt)("inlineCode",{parentName:"p"},"matchUpIds")," which occur earlier in the draw."),(0,i.kt)("p",null,"Optionally returns an array of ",(0,i.kt)("inlineCode",{parentName:"p"},"participantIds")," which could potentially appear in each ",(0,i.kt)("inlineCode",{parentName:"p"},"matchUp"),";\nused internally to ensure that auto scheduling respects the ",(0,i.kt)("inlineCode",{parentName:"p"},"timeAfterRecovery")," of all potential participants."),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-js"},"const {\n  matchUpDependencies: {\n    [matchUpId]: {\n      matchUpIds: [matchUpIdDependency], // array of all matchUpIds which occur prior to this matchUpId in the draw; crosses all structures\n      participantIds: [potentialParticipantIds], // array of all participantIds which could potentially appear in this matchUp\n      dependentMatchUpIds: [dependentMatchUpId], // array of matchUpIds which occur after this matchUpId in the draw; crosses all structures\n    },\n  },\n} = engine.getMatchUpDependencies({\n  includeParticipantDependencies, // boolean - defaults to false\n  drawIds, // optional array of drawIds to scope the analysis\n});\n")),(0,i.kt)("hr",null),(0,i.kt)("h2",{id:"getmatchupformat"},"getMatchUpFormat"),(0,i.kt)("p",null,"Returns ",(0,i.kt)("inlineCode",{parentName:"p"},"matchUpFormat")," codes for specified context(s). Refer to ",(0,i.kt)("inlineCode",{parentName:"p"},"getMatchUpFormat.test.js")," for specfic use cases."),(0,i.kt)("p",null,(0,i.kt)("inlineCode",{parentName:"p"},"matchUpFormat")," for each matchUp is determined by traversing the hierarchy: ",(0,i.kt)("inlineCode",{parentName:"p"},"matchUp => stucture => drawDefinition => event")),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-js"},"const { matchUpFormat, structureDefaultMatchUpFormat, drawDefaultMatchUpFormat, eventDefaultMatchUpFormat } =\n  engine.getMatchUpFormat({\n    eventId,\n    drawId,\n    structureId,\n    matchUpId,\n  });\n")),(0,i.kt)("hr",null),(0,i.kt)("h2",{id:"getmatchupformattiming"},"getMatchUpFormatTiming"),(0,i.kt)("p",null,"Searches for policy definitions or extensions to determine the ",(0,i.kt)("inlineCode",{parentName:"p"},"averageMinutes")," and ",(0,i.kt)("inlineCode",{parentName:"p"},"recoveryMinutes")," for a given ",(0,i.kt)("inlineCode",{parentName:"p"},"matchUpFormat"),". Extensions are considered to be overrides of policy definitions."),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-js"},"const { averageMinutes, recoveryMinutes } = engine.getMatchUpFormatTiming({\n  defaultAverageMinutes, // optional setting if no matching definition found\n  defaultRecoveryMinutes, // optional setting if no matching definition found\n  matchUpFormat,\n  categoryName, // optional\n  categoryType, // optional\n  eventType, // optional - defaults to SINGLES; SINGLES, DOUBLES\n  eventId, // optional - prioritizes policy definition attached to event before tournament record\n});\n")),(0,i.kt)("hr",null),(0,i.kt)("h2",{id:"getmatchupformattimingupdate"},"getMatchUpFormatTimingUpdate"),(0,i.kt)("p",null,'Returns an array of methods/params necessary for updating a remote instance of a tournamentRecord to match a local instance. This method enables multiple "provisional" updates to be made on a local document without contacting a server; support deployments where a server is considered "master".'),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-js"},"const { methods } = engine.getMatchUpFormatTimingUpdate();\n")),(0,i.kt)("hr",null),(0,i.kt)("h2",{id:"getmatchupscheduledetails"},"getMatchUpScheduleDetails"),(0,i.kt)("p",null,"Returns the latest values for all ",(0,i.kt)("inlineCode",{parentName:"p"},"matchUp.timeItems"),", along with calculated values, that relate to the scheduling of a ",(0,i.kt)("inlineCode",{parentName:"p"},"matchUp"),"."),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-js"},"const {\n  schedule: {\n    time,\n    courtId,\n    venueId,\n    startTime,\n    endTime,\n    milliseconds,\n    scheduledDate,\n    scheduledTime,\n    allocatedCourts: [{ venueId, courtid }], // applies only to TEAM matchUps\n  },\n} = engine.getMatchUpScheduleDetails({\n  scheduleVisibilityFilters, // { visibilityThreshold: Date, eventIds, drawIds }\n  matchUp,\n});\n")),(0,i.kt)("hr",null),(0,i.kt)("h2",{id:"getmatchupsstats"},"getMatchUpsStats"),(0,i.kt)("p",null,"Returns percentages of matchUps which fall into ",(0,i.kt)("inlineCode",{parentName:"p"},"cmpetitiveBands"),' defined as "Competitive", "Routine", and "Decisive".'),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-js"},"const { competitiveBands } = engine.getMatchUpsStats({\n  profileBands, // optional { [DECISIVE]: 20, [ROUTINE]: 50 } // can also be set in policyDefinitions\n  matchUps,\n});\n")),(0,i.kt)("hr",null),(0,i.kt)("h2",{id:"getmatchupdailylimits"},"getMatchUpDailyLimits"),(0,i.kt)("p",null,"Returns player daily match limits for singles/doubles/total matches."),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-js"},"const { matchUpDailyLimits } = tournamentId.getMatchUpDailyLimits();\nconst { DOUBLES, SINGLES, total } = matchUpDailyLimits;\n")),(0,i.kt)("hr",null),(0,i.kt)("h2",{id:"getmodifiedmatchupformattiming"},"getModifiedMatchUpFormatTiming"),(0,i.kt)("p",null,"Returns ",(0,i.kt)("inlineCode",{parentName:"p"},"averageTimes")," and ",(0,i.kt)("inlineCode",{parentName:"p"},"recoveryTimes")," configuration objects for specified ",(0,i.kt)("inlineCode",{parentName:"p"},"matchUpFormat"),". Useful before calling ",(0,i.kt)("inlineCode",{parentName:"p"},"modifyMatchUpFormatTiming")," to preserve existing modifications."),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-js"},"const { matchUpFormat, averageTimes, recoveryTimes } = engine.getModifiedMatchUpFormatTiming({\n  matchUpFormat, // TODS matchUpFormat code\n  event, // optional - include event in scope for search\n});\n")),(0,i.kt)("hr",null),(0,i.kt)("h2",{id:"getpairedparticipant"},"getPairedParticipant"),(0,i.kt)("p",null,"Returns the ",(0,i.kt)("inlineCode",{parentName:"p"},"{ participantType: PAIR }"),", if any, which contains the specified ",(0,i.kt)("inlineCode",{parentName:"p"},"individualParticipantIds"),"."),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-js"},"const { participant } = engine.getPairedParticipant({\n  participantIds: individualParticipantIds,\n});\n")),(0,i.kt)("hr",null),(0,i.kt)("h2",{id:"getparticipanteventdetails"},"getParticipantEventDetails"),(0,i.kt)("p",null,"Returns an array of eventDetails in which a specified ",(0,i.kt)("inlineCode",{parentName:"p"},"participantId")," appears. For details on draw entry within events use ",(0,i.kt)("inlineCode",{parentName:"p"},"engine.getParticipants({ inContext: true })"),"."),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-js"},"const { eventDetails } = engine.getParticipantEventDetails({\n  participantId,\n});\n\nconst [{ eventName, eventId }] = eventDetails;\n")),(0,i.kt)("hr",null),(0,i.kt)("h2",{id:"getparticipantidfinishingpositions"},"getParticipantIdFinishingPositions"),(0,i.kt)("p",null,"Returns the Range of finishing positions possible for all participantIds within a draw"),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-js"},"const idMap = engine.getParticipantIdFinishingPositions({\n  byeAdvancements, // optional boolean - whether or not to consider byeAdvancements\n  drawId,\n});\n\nconst { relevantMatchUps, finishingPositionRanges, finishingPositionRange } = idMap['participantId'];\n")),(0,i.kt)("hr",null),(0,i.kt)("h2",{id:"getparticipantmembership"},"getParticipantMembership"),(0,i.kt)("p",null,"Returns all grouping participants which include ",(0,i.kt)("inlineCode",{parentName:"p"},"participantId")," in ",(0,i.kt)("inlineCode",{parentName:"p"},"{ individualParticipantIds }"),"."),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-js"},"const {\n  [PAIR]: doublesParticipantIds,\n  [GROUP]: groupParticipantIds,\n  [TEAM]: teamParticipantIds,\n} = engine.getParticipantMembership({\n  participantId,\n});\n")),(0,i.kt)("hr",null),(0,i.kt)("h2",{id:"getparticipantresults"},"getParticipantResults"),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-js"},"const { participantResults } = engine.getParticipantResuls({\n  participantIds, // optional array to filter results; used in ROUND_ROBIN for groups\n  tallyPolicy, // policyDefinition for tallying results\n  matcUps, // must be inContext matchUps\n});\n")),(0,i.kt)("hr",null),(0,i.kt)("h2",{id:"getparticipants"},"getParticipants"),(0,i.kt)("p",null,"Returns ",(0,i.kt)("strong",{parentName:"p"},"deepCopies")," of competition participants filtered by participantFilters which are arrays of desired participant attribute values. This method is an optimization of ",(0,i.kt)("inlineCode",{parentName:"p"},"getCompetitionParticipants")," and will replace it going forward."),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-js"},"const participantFilters = {\n  accessorValues: [{ accessor, value }], // optional - see Accessors in Concepts\n  eventEntryStatuses, // boolean\n  participantTypes: [INDIVIDUAL],\n  participantRoles, [COMPETITOR],\n  signInStatus, // specific signIn status\n  eventIds, // events in which participants appear\n};\nconst {\n  participantIdsWithConflicts, // returns array of participantIds which have scheduling conflicts\n  competitionParticipants,\n  eventsPublishStatuses,\n  derivedEventInfo,\n  derivedDrawInfo,\n  participantsMap, // object { ['participantId']: participant }\n  mappedMatchUps, // object { [matchUpId]: matchUp }; when { withMatchUps: true }\n  participants, // array of participants\n  matchUps, // array of all matchUps; when { withMatchUps: true }\n } =\n  engine.getParticipants({\n    convertExtensions, // optional - BOOLEAN - convert extensions so _extensionName attributes\n    participantFilters, // optional - filters\n    policyDefinitions, // optional - can accept a privacy policy to filter participant attributes\n    usePublishState, // optional - BOOLEAN - don't add seeding information when not published\n    scheduleAnalysis: {\n      scheduledMinutesDifference // optional - scheduling conflicts determined by scheduledTime difference between matchUps\n    },\n    withDraws, // optional - defaults to true if any other context options are specified\n    withEvents, // optional - defaults to true if any other context options are specified\n    withIndividualParticipants, // optional - boolean or attributeFilter template - include hydrated individualParticiapnts for TEAM/PAIR participants\n    withIOC, // optional - will add IOC country code and countryName to participant persons\n    withISO2, // optional - will add ISO2 country code and countryName to participant persons\n    withMatchUps, // optional - include all matchUps in which the participant appears, as well as potentialMatchUps\n    withOpponents, // optional - include opponent participantIds\n    withPotentialMatchUps, // optional boolean\n    withRankingProfile, // optional boolean - include details necessary for point awards\n    withScaleValues, // optional - include { ratings, rankings } attributes extracted from timeItems\n    withSeeding, // optional - add event seeding\n    withScheduleItems, // optional boolean - include array of scheduled matchUp details\n    withSignInStatus, // optional boolean\n    withStatistics, // optional - adds events, matchUps and statistics, e.g. 'winRatio'\n    withTeamMatchUps // optional boolean\n  });\n")),(0,i.kt)("h2",{id:"getlinkedtournamentids"},"getLinkedTournamentIds"),(0,i.kt)("p",null,"Returns ",(0,i.kt)("inlineCode",{parentName:"p"},"linkedTournamentIds")," for each tournamentRecord loaded in ",(0,i.kt)("inlineCode",{parentName:"p"},"compeitionEngine"),"."),(0,i.kt)("p",null,'Caters for the possibility that, for instance, two "linked" tournaments and one "unlinked" tournament could be loaded.'),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-js"},"const { linkedTournamentIds } = engine.getLinkedTournamentIds();\n/*\n{\n  'tournamentId-1': ['tournamentId-2', 'tournamentId-3'],\n  'tournamentId-2': ['tournamentId-1', 'touranmentId-3'],\n  'tournamentId-3': ['tournamentId-1', 'tournamentId-2']\n}\n*/\n")),(0,i.kt)("hr",null),(0,i.kt)("h2",{id:"getpositionsplayedoff"},"getPositionsPlayedOff"),(0,i.kt)("p",null,"Determines which finishing positions will be returned by a draw. For example, a First Match Loser Consolation with a draw size of 16 will playoff possitions 1, 2, 9 and 10."),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-js"},"const { positionsPlayedOff } = engine.getPositionsPlayedOff({\n  drawDefinition,\n});\n")),(0,i.kt)("hr",null),(0,i.kt)("h2",{id:"getrounds"},"getRounds"),(0,i.kt)("p",null,"Returns all rounds of all ",(0,i.kt)("inlineCode",{parentName:"p"},"structures")," in all ",(0,i.kt)("inlineCode",{parentName:"p"},"tournamentRecords"),"."),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-js"},"const { rounds, excludedRounds } = engine.getRounds({\n  excludeScheduleDateProfileRounds, // optional date string - exclude rounds which appear in schedulingProfile on given date\n  excludeCompletedRounds, // optional boolean - exclude rounds where all matchUps are completed\n  excludeScheduledRounds, // optional boolean - exclude rounds where all matchUps are scheduled\n  inContextMatchUps, // optional - if not provided will be read from tournamentRecords\n  schedulingProfile, // optional - if not provided will be read from tournamentRecords (where applicable)\n  withSplitRounds, // optional boolean - read schedulingProfile and split rounds where defined\n  matchUpFilters, // optional - filter competition matchUps before deriving rounds\n  withRoundId, // optional boolean - return a unique id for each derived round\n  scheduleDate, // optional - filters out events which are not valid on specified date\n  venueId, // optional - filters out events which are not valid for specified venue\n  context, // optional - object to be spread into derived rounds\n});\n")),(0,i.kt)("p",null,"Returns the following detail for each round:"),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-js"},"  {\n    roundSegment: { segmentsCount, segmentNumber }, // if the round has been split in schedulingProfile\n    winnerFinishingPositionRange,\n    unscheduledCount,\n    incompleteCount,\n    minFinishingSum,\n    matchUpsCount,\n    stageSequence,\n    segmentsCount, // when { withSplitRounds: true } and a round split is defined in schedulingProfile\n    structureName,\n    tournamentId,\n    isScheduled, // whether every matchUp in the round has been scheduled (does not consider matchUpStatus: BYE)\n    isComplete, // whether every matchUp in the round has been COMPLETED or ABANDONED/CANCELLED\n    matchUpType,\n    roundNumber,\n    structureId,\n    eventName,\n    roundName,\n    drawName,\n    matchUps,\n    byeCount\n    eventId,\n    drawId,\n    id, // unique id provided when { withRoundId: true }\n  } = round;\n")),(0,i.kt)("hr",null),(0,i.kt)("h2",{id:"getparticipantscaleitem"},"getParticipantScaleItem"),(0,i.kt)("p",null,"Return a ranking or rating or seeding value for a participant, referenced by participantId."),(0,i.kt)("p",null,"See ",(0,i.kt)("a",{parentName:"p",href:"../concepts/scaleItems"},"Scale Items"),"."),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-js"},"const scaleAttributes = {\n  scaleType: RATING,\n  eventType: SINGLES,\n  scaleName: 'WTN',\n  accessor, // optional - string determining how to access attribute if scaleValue is an object\n};\nconst {\n  scaleItem: { scaleValue },\n  tournamentId,\n} = engine.getParticipantScaleItem({\n  scaleAttributes,\n  participantId,\n});\n")),(0,i.kt)("hr",null),(0,i.kt)("h2",{id:"getparticipantschedules"},"getParticipantSchedules"),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-js"},"const { participantSchedules } = engine.getParticipantSchedules({\n  participantFilters: { participantIds, participantTypes, eventIds },\n});\n")),(0,i.kt)("hr",null),(0,i.kt)("h2",{id:"getparticipantsigninstatus"},"getParticipantSignInStatus"),(0,i.kt)("p",null,"Participant signInStatus can be either 'SIGNED_IN' or 'SIGNED_OUT' (or undefined). See ",(0,i.kt)("a",{parentName:"p",href:"/docs/governors/participant-governor#modifyparticipantssigninstatus"},"modifyParticipantsSignInStatus"),"."),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-js"},"const signInStatus = engine.getParticipantSignInStatus({\n  participantId,\n});\n")),(0,i.kt)("hr",null),(0,i.kt)("h2",{id:"getparticipantstats"},"getParticipantStats"),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-js"},"const result = engine.getParticipantStats({\n  withCompetitiveProfiles, // optional boolean\n  opponentParticipantId, // optional team opponent participantId, otherwise stats vs. all opponents\n  withIndividualStats, // optional boolean\n  teamParticipantId, // optional - when not provided all teams are processed\n  tallyPolicy, // optional\n  matchUps, // optional - specifiy or allow engine to get all\n});\n\nconst {\n  participatingTeamsCount, // only if no teamPartiicpantId has been specified\n  allParticipantStats, // only if no teamParticipantId has been specified\n  relevantMatchUps, // matchUps which were relevant to the calculations\n  opponentStats, // only if opponentParticipantId has been provided\n  teamStats, // only if teamParticipantId has been provided\n  success, // when no error\n  error, // if error\n} = result;\n")),(0,i.kt)("hr",null),(0,i.kt)("h2",{id:"getpersonrequests"},"getPersonRequests"),(0,i.kt)("p",null,"Returns an object with array of requests for each relevant ",(0,i.kt)("inlineCode",{parentName:"p"},"personId"),". Request objects are returned with a ",(0,i.kt)("inlineCode",{parentName:"p"},"requestId")," which can be used to call ",(0,i.kt)("a",{parentName:"p",href:"/docs/governors/participant-governor#modifypersonrequests"},"modifyPersonRequests"),"."),(0,i.kt)("p",null,"See ",(0,i.kt)("a",{parentName:"p",href:"/docs/governors/participant-governor#addpersonrequests"},"addPersonRequests")," for request object structure."),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-js"},"const { personRequests } = engine.getPersonRequests({\n  requestType, // optional filter\n});\n")),(0,i.kt)("hr",null),(0,i.kt)("h2",{id:"getpolicydefinitions"},"getPolicyDefinitions"),(0,i.kt)("p",null,"Finds policies which have been attached to the tournamentRecord, or to a target event, or target drawDefinition, in reverse order.\nOnce a matching ",(0,i.kt)("inlineCode",{parentName:"p"},"policyType")," has been found, higher level policies of the same type are ignored, enabling a default policy to be attached to the tournamentRecord and for event-specific or draw-specific policies to override the default(s)."),(0,i.kt)("p",null,"The constructed ",(0,i.kt)("inlineCode",{parentName:"p"},"policyDefinitions")," object contains targeted policies from all levels, scoped to the lowest level specified."),(0,i.kt)("p",null,"See ",(0,i.kt)("a",{parentName:"p",href:"../concepts/policies"},"Policies"),"."),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-js"},"const { policyDefinitions } = engine.getPolicyDefinitions({\n  policyTypes: [POLICY_TYPE_SEEDING],\n  eventId, // optional\n  drawId, // optional\n});\n")),(0,i.kt)("hr",null),(0,i.kt)("h2",{id:"getpositionassignments"},"getPositionAssignments"),(0,i.kt)("p",null,"Returns an array of ",(0,i.kt)("inlineCode",{parentName:"p"},"positionAssignments")," for a structure. Combines ",(0,i.kt)("inlineCode",{parentName:"p"},"positionAssginments")," for child structures in the case of ROUND_ROBIN where ",(0,i.kt)("inlineCode",{parentName:"p"},"{ structureType: CONTAINER }"),"."),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-js"},"let { positionAssignments } = engine.getPositionAssignments({\n  structureId, // optional if { structure } is provided\n  structure, // optional if { drawId, structureId } are provided\n  drawId, // optional if { structure } is provided\n});\n\nconst [{ drawPosition, participantId, qualifier, bye }] = positionAssignments;\n")),(0,i.kt)("hr",null),(0,i.kt)("h2",{id:"getpredictiveaccuracy"},"getPredictiveAccuracy"),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-js"},"const { accuracy, zoneDistribution } = engine.getPredictiveAccuracy({\n  exclusionRule: { valueAccessor: 'confidence', range: [0, 70] }, // exclude low confidence values\n\n  zoneMargin: 3, // optional - creates +/- range and report competitiveness distribution\n  zonePct: 20, // optional - precedence over zoneMargin, defaults to 100% of rating range\n\n  valueAccessor: 'wtnRating', // optional if `scaleName` is defined in factory `ratingsParameters`\n  ascending: false, // optional - scale goes from low to high with high being the \"best\"\n  scaleName: WTN,\n});\n")),(0,i.kt)("hr",null),(0,i.kt)("h2",{id:"getroundmatchups"},"getRoundMatchUps"),(0,i.kt)("p",null,"Organizes matchUps by roundNumber. ",(0,i.kt)("strong",{parentName:"p"},"roundMatchUps")," contains matchUp objects; ",(0,i.kt)("strong",{parentName:"p"},"roundProfile")," provides an overview of drawPositions which have advanced to each round, a matchUpsCount, finishingPositionRange for winners and losers, and finishingRound."),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-js"},"const { roundMatchUps, roundProfile } = engine.getRoundMatchUps({\n  matchUps,\n});\n")),(0,i.kt)("hr",null),(0,i.kt)("h2",{id:"getscaledentries"},"getScaledEntries"),(0,i.kt)("p",null,"See ",(0,i.kt)("a",{parentName:"p",href:"../concepts/scaleItems"},"Scale Items"),"."),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-js"},"const { scaledEntries } = engine.getScaledEntries({\n  eventId, // optional - not required if provided array of entries\n  entries, // optional - overrides use of event.entries\n  stage, // optional - filter entries by stage\n\n  scaleAttributes,\n  scaleSortMethod, // optional - function(a, b) {} sort method, useful when scaleValue is an object or further proessing is required\n  sortDescending, // optional - default sorting is ASCENDING; only applies to default sorting method.\n});\n")),(0,i.kt)("hr",null),(0,i.kt)("h2",{id:"getschedulingprofile"},"getSchedulingProfile"),(0,i.kt)("p",null,"Returns a ",(0,i.kt)("inlineCode",{parentName:"p"},"schedulingProfile")," (if present). Checks the integrity of the profile to account for any ",(0,i.kt)("inlineCode",{parentName:"p"},"venues")," or ",(0,i.kt)("inlineCode",{parentName:"p"},"drawDefinitions")," which have been deleted."),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-js"},"const { schedulingProfile } = engine.getSchedulingProfile();\n")),(0,i.kt)("hr",null),(0,i.kt)("h2",{id:"getschedulingprofileissues"},"getSchedulingProfileIssues"),(0,i.kt)("p",null,"Analyzes the ",(0,i.kt)("inlineCode",{parentName:"p"},"schedulingProfile")," (if any) that is attached to the ",(0,i.kt)("inlineCode",{parentName:"p"},"tournamentRecord(s)")," and reports any issues with the ordering of rounds."),(0,i.kt)("p",null,"The analysis for each ",(0,i.kt)("inlineCode",{parentName:"p"},"scheduleDate")," only includes ",(0,i.kt)("inlineCode",{parentName:"p"},"matchUps")," to be scheduled on that date.\nIn other words, the method only reports on scheduling issues relative to the group of ",(0,i.kt)("inlineCode",{parentName:"p"},"matchUpIds")," derived from rounds which are being scheduled for each date."),(0,i.kt)("admonition",{type:"note"},(0,i.kt)("p",{parentName:"admonition"},"In some cases it is valid to schedule a second round, for instance, before a first round, because there may be some second round ",(0,i.kt)("inlineCode",{parentName:"p"},"matchUps")," which are ready to be played... possibly due to ",(0,i.kt)("inlineCode",{parentName:"p"},"participants")," advancing via first round BYEs or WALKOVERs."),(0,i.kt)("p",{parentName:"admonition"},"Regardless of issues reported, ",(0,i.kt)("inlineCode",{parentName:"p"},"engine.scheduleProfileRounds()")," will attempt to follow the desired order, but will not schedule ",(0,i.kt)("inlineCode",{parentName:"p"},"matchUps")," before dependencies.")),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-js"},"const {\n  profileIssues: {\n    // object includes matchUpIds which are out of order\n    matchUpIdsShouldBeAfter: {\n      [matchUpId]: {\n        earlierRoundIndices: [index], // indices of scheduled rounds which must be scheduled before matchUpId\n        shouldBeAfter: [matchUpId], // array of matchUpIds which must be scheduled before matchUpId\n      },\n    },\n  },\n  // roundIndex is the index of the round to be scheduled within the schedulingProfile for a givn date\n  roundIndexShouldBeAfter: {\n    [scheduleDate]: {\n      [index]: [indexOfEarlierRound], // maps the index of the round within a date's scheduled rounds to those rounds which should be scheduled first\n    },\n  },\n} = engine.getSchedulingProfileIssues({\n  dates, // optional array of target dates\n});\n")),(0,i.kt)("hr",null),(0,i.kt)("h2",{id:"getseedscount"},"getSeedsCount"),(0,i.kt)("p",null,"Takes a policyDefinition, drawSize and participantsCount and returrns the number of seeds valid for the specified drawSize"),(0,i.kt)("admonition",{type:"note"},(0,i.kt)("p",{parentName:"admonition"},(0,i.kt)("inlineCode",{parentName:"p"},"drawSizeProgression")," will be overridden by a ",(0,i.kt)("inlineCode",{parentName:"p"},"{ drawSizeProgression }")," value in a policyDefinition.")),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-js"},"const { seedsCount, error } = engine.getSeedsCount({\n  drawSizeProgression, // optional - fits the seedsCount to the participantsCount rather than the drawSize\n  policyDefinitions: SEEDING_USTA,\n  participantsCount: 15,\n  drawSize: 128,\n});\n")),(0,i.kt)("hr",null),(0,i.kt)("h2",{id:"getseedingthresholds"},"getSeedingThresholds"),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-js"},"const { seedingThresholds } = engine.getSeedingThresholds({\n  roundRobinGroupsCount,\n  participantsCount,\n});\n")),(0,i.kt)("hr",null),(0,i.kt)("h2",{id:"getstructureseedassignments"},"getStructureSeedAssignments"),(0,i.kt)("p",null,"Returns seedAssignments for a specific structure based on structureId or structure"),(0,i.kt)("p",null,"The structure of an ",(0,i.kt)("strong",{parentName:"p"},(0,i.kt)("em",{parentName:"strong"},"assignment object"))," is as follows:"),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-json"},'{\n  "seedNumber": 1,\n  "seedValue": "1",\n  "participantId": "uuid-of-participant"\n}\n')),(0,i.kt)("p",null,"The most basic usage is to retrieve seed assignments for a draw which has a single main stage structure"),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-js"},"const { seedAssignments } = engine.getStructureSeedAssignments({\n  structureId,\n  drawId,\n});\n")),(0,i.kt)("hr",null),(0,i.kt)("h2",{id:"getstructurereports"},"getStructureReports"),(0,i.kt)("p",null,"Returns details of all structures within a tournamentRecord, as well as aggregated details per event."),(0,i.kt)("p",null,(0,i.kt)("inlineCode",{parentName:"p"},"tournamentId, eventId, structureId, drawId, eventType, category: subType, categoryName, ageCategoryCode, flightNumber, drawType, stage, winningPersonId, winningPersonWTNrating, winningPersonWTNconfidence, winningPerson2Id, winningPerson2WTNrating, winningPerson2WTNconfidence, positionManipulations, pctNoRating, matchUpFormat, pctInitialMatchUpFormat, matchUpsCount, tieFormatDesc, tieFormatName, avgConfidence, avgWTN")),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-js"},"const {\n  structureReports,\n  eventStructureReports: {\n    totalPositionManipulations,\n    maxPositionManipulations,\n    generatedDrawsCount,\n    drawDeletionsCount,\n  },\n} = engine.getStructureReports({\n  firstFlightOnly, // boolean - defaults to true - only return first flight when multiple drawDefinitions per event\n  extensionProfiles: [\n    {\n      name, // extension name\n      label, // label for generated attribute\n      accessor, // dot-notation accessor for extension value, e.g. 'attribute.attribute'\n    },\n  ],\n});\n")),(0,i.kt)("p",null,"To export report as CSV:"),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-js"},"const csv = tools.JSON2CSV(structureReports);\n")),(0,i.kt)("hr",null),(0,i.kt)("h2",{id:"getteamlineup"},"getTeamLineUp"),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-js"},"const { lineUp } = engine.getTeamLineUp({ drawId, participantId });\n")),(0,i.kt)("hr",null),(0,i.kt)("h2",{id:"gettieformat"},"getTieFormat"),(0,i.kt)("p",null,"Returns ",(0,i.kt)("inlineCode",{parentName:"p"},"tieFormat")," definition objects for specified context(s)."),(0,i.kt)("p",null,(0,i.kt)("inlineCode",{parentName:"p"},"tieFormat")," for each matchUp is determined by traversing the hierarchy: ",(0,i.kt)("inlineCode",{parentName:"p"},"matchUp => stucture => drawDefinition => event")),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-js"},"const { tieFormat, structureDefaultTieFormat, drawDefaultTieFormat, eventDefaultTieFormat } = engine.getTieFormat({\n  structureId,\n  matchUpId,\n  eventId,\n  drawId,\n});\n")),(0,i.kt)("hr",null),(0,i.kt)("h2",{id:"gettournamentinfo"},"getTournamentInfo"),(0,i.kt)("p",null,"Returns tournament attributes. Used to attach details to publishing payload by ",(0,i.kt)("inlineCode",{parentName:"p"},"getEventData"),"."),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-js"},"const { tournamentInfo } = getTournamentInfo({ tournamentRecord });\nconst {\n  tournamentId,\n  tournamentRank,\n\n  formalName,\n  tournamentName,\n  promotionalName,\n  onlineResources,\n\n  localTimeZone,\n  startDate,\n  endDate,\n\n  hostCountryCode,\n  tournamentStatus,\n} = tournamentInfo;\n")),(0,i.kt)("hr",null),(0,i.kt)("h2",{id:"gettournamentpersons"},"getTournamentPersons"),(0,i.kt)("p",null,"Returns ",(0,i.kt)("strong",{parentName:"p"},"deepCopies")," of persons extracted from tournament participants. Each person includes an array of ",(0,i.kt)("inlineCode",{parentName:"p"},"participantIds")," from which person data was retrieved."),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-js"},"const { tournamentPersons } = engine.getTournamentPersons({\n  participantFilters: { participantRoles: [COMPETITOR] }, // optional - filters\n});\n")),(0,i.kt)("hr",null),(0,i.kt)("h2",{id:"gettournamentpenalties"},"getTournamentPenalties"),(0,i.kt)("p",null,"Returns an array of all penalties issued during a tournament."),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-js"},"const { penalties } = engine.getTournamentPenalties();\n")),(0,i.kt)("hr",null),(0,i.kt)("h2",{id:"gettournamentstructures"},"getTournamentStructures"),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-js"},"const { structures, stageStructures } = engine.getTournamentStructures({\n  withStageGrouping: true, // optional return structures grouped by stages\n  stageSequences, // optional - specify stageSequences to include\n  stageSequence, // optional - filter by stageSequence\n  stages, // optional - specify stageSequences to include\n  stage, // optional - filter by stage\n});\n")),(0,i.kt)("hr",null),(0,i.kt)("h2",{id:"getvalidgroupsizes"},"getValidGroupSizes"),(0,i.kt)("p",null,"Returns valid Round Robin group sizes for specified ",(0,i.kt)("inlineCode",{parentName:"p"},"drawSize"),"."),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-js"},"const { validGroupSizes } = engine.getValidGroupSies({\n  groupSizeLimit, // optional - defaults to 10\n  drawSize,\n});\n")),(0,i.kt)("hr",null),(0,i.kt)("h2",{id:"getvenuesandcourts"},"getVenuesAndCourts"),(0,i.kt)("p",null,"Returns an array of all Venues which are part of a tournamentRecord and an aggregation of courts across all venues."),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-js"},"const { venues, courts } = engine.getVenuesAndCourts({\n  convertExtensions, // optional boolean\n  ignoreDisabled, // optional boolean\n  dates, // optional - used with ignoreDisabled - applies to courts\n});\n")),(0,i.kt)("hr",null),(0,i.kt)("h2",{id:"getvenuedata"},"getVenueData"),(0,i.kt)("p",null,"Returns restricted venue attributes along with information for all associated courts. Used primarily by ",(0,i.kt)("inlineCode",{parentName:"p"},"getEventData")," to return a subset of venue/courts information for publishing purposes."),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-js"},"const {\n  venueName,\n  venueAbbreviation,\n  courtsInfo, // array of courts and associated attributes\n} = engine.getVenueData({ venueId });\n")),(0,i.kt)("hr",null),(0,i.kt)("h2",{id:"generatebookings"},"generateBookings"),(0,i.kt)("p",null,'This methods is used internally for creating a "virtual" view of court availability.'),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-js"},"const { bookings, relevantMatchUps } = engine.generateBookings({\n  defaultRecoveryMinutes, // optional\n  averageMatchUpMinutes, // optional\n  periodLength, // optional - scheduling period in minutes\n  scheduleDate, // optional - only consider matchUps scheduled on scheduleDate\n  venueIds, // optional - only consider matchUps at specific venue(s)\n  matchUps,\n});\n")),(0,i.kt)("hr",null),(0,i.kt)("h2",{id:"getvenuesreport"},"getVenuesReport"),(0,i.kt)("p",null,"Returns a ",(0,i.kt)("inlineCode",{parentName:"p"},"venueReports")," array which provides details for each targt ",(0,i.kt)("inlineCode",{parentName:"p"},"venue")," for targt date(s)."),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-js"},"const { venuesReport } = engine.getVenuesReport({\n  dates, // optional array of target dates\n  venueIds, // optional array of target venueIds\n  ignoreDisabled, // optional boolean, defaults to true - ignore disabled venues/courts\n});\n\nconst {\n  availableCourts, // how many courts are available for date\n  availableMinutes, // total courts minutes available for date\n  scheduledMinutes, // minutes of court time that are scheduled for matchUps\n  scheduledMatchUpsCount, // number of scheduled matchUps\n  percentUtilization, // percent of available minutes utilized by scheduled matchUps\n} = venuesReport[0].venueReport[date];\n")),(0,i.kt)("hr",null),(0,i.kt)("h2",{id:"iscompletedstructure"},"isCompletedStructure"),(0,i.kt)("p",null,"Returns boolean whether all matchUps in a given structure have been completed"),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-js"},"const structureIsComplete = engine.isCompletedStructure({\n  structureId,\n});\n")),(0,i.kt)("hr",null),(0,i.kt)("h2",{id:"isvalidforqualifying"},"isValidForQualifying"),(0,i.kt)("p",null,"Provides determination of whether qualifying structure(s) may be added to the structure specified by ",(0,i.kt)("inlineCode",{parentName:"p"},"structureId"),"."),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-js"},"const { valid } = engine.isValidForQualifiying({\n  structureId,\n  drawId,\n});\n")),(0,i.kt)("hr",null),(0,i.kt)("h2",{id:"isvalidmatchupformat"},"isValidMatchUpFormat"),(0,i.kt)("p",null,"Returns boolean indicating whether matchUpFormat code is valid."),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-js"},"const valid = engine.isValidMatchUpFormat({ matchUpFormat });\n")),(0,i.kt)("hr",null),(0,i.kt)("h2",{id:"matchupactions"},"matchUpActions"),(0,i.kt)("p",null,"Return an array of all validActions for a specific matchUp."),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-js"},"const {\n  isByeMatchUp, // boolean; true if matchUp includes a BYE\n  structureIsComplete, // boolean; true if structure is ready for positioning\n  validActions, // array of possible actions given current matchUpStatus\n} = engine.matchUpActions({\n  restrictAdHocRoundParticipants, // optional - true by default; applies to AD_HOC; disallow the same participant being in the same round multiple times\n  sideNumber, // optional - select side to which action should apply; applies to AD_HOC position assignments\n  matchUpId, // required - reference to targeted matchUp\n  drawId, // optional - not strictly required; method will find matchUp by brute force without it\n});\n\nconst {\n  type, // 'REFEREE', 'SCHEDULE', 'PENALTY', 'STATUS', 'SCORE', 'START', 'END', 'SUBSTITUTION'.\n  method, // engine method relating to action type\n  payload, // attributes to be passed to method\n  // additional method-specific options for values to be added to payload when calling method\n} = validAction;\n")),(0,i.kt)("hr",null),(0,i.kt)("h2",{id:"participantscaleitem"},"participantScaleItem"),(0,i.kt)("p",null,"Similar to ",(0,i.kt)("a",{parentName:"p",href:"#getparticipantscaleitem"},"getParticipantScaleItem")," but takes a ",(0,i.kt)("inlineCode",{parentName:"p"},"participant")," object and doesn't require ",(0,i.kt)("inlineCode",{parentName:"p"},"engine.setState(tournamentRecord)"),"."),(0,i.kt)("p",null,"See ",(0,i.kt)("a",{parentName:"p",href:"../concepts/scaleItems"},"Scale Items"),"."),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-js"},"const scaleAttributes = {\n  scaleType: RATING,\n  eventType: SINGLES,\n  scaleName: 'WTN',\n  accessor, // optional - string determining how to access attribute if scaleValue is an object\n};\nconst {\n  scaleItem: { scaleValue },\n} = engine.participantScaleItem({\n  scaleAttributes,\n  participant,\n});\n")),(0,i.kt)("hr",null),(0,i.kt)("h2",{id:"positionactions"},"positionActions"),(0,i.kt)("p",null,"Returns valid actions for a given ",(0,i.kt)("inlineCode",{parentName:"p"},"drawPosition"),". If params includes ",(0,i.kt)("inlineCode",{parentName:"p"},"matchUpId")," will pass through to ",(0,i.kt)("a",{parentName:"p",href:"#matchupactions"},"matchUpActions")," when called for ",(0,i.kt)("strong",{parentName:"p"},"AD_HOC")," structures."),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-js"},"const positionActions = engine.positionActions({\n  policyDefinitions: positionActionsPolicy, // optional - policy defining what actions are allowed in client context\n  returnParticipants, // optional boolean; defaults to true; performance optimization when false requires client to provide participants.\n  drawPosition,\n  structureId,\n  drawId,\n});\n\nconst {\n  isActiveDrawPosition, // boolean\n  isByePosition, // boolean\n  isDrawPosition, // boolean\n  hasPositionAssiged, // boolean\n  validActions,\n} = positionActions;\n\nconst {\n  type, // 'ASSIGN', 'LUCKY', 'SWAP', 'BYE', 'REMOVE'\n  method, // engine method relating to action type\n  payload, // attributes to be passed to method\n  // additional method-specific options for values to be added to payload when calling method\n} = validAction;\n")),(0,i.kt)("hr",null),(0,i.kt)("h2",{id:"tallyparticipantresults"},"tallyParticipantResults"),(0,i.kt)("admonition",{type:"tip"},(0,i.kt)("p",{parentName:"admonition"},"Setting ",(0,i.kt)("inlineCode",{parentName:"p"},"engine.devContext({ tally: true })")," will log ",(0,i.kt)("inlineCode",{parentName:"p"},"readableReport")," to the console. In browser consoles of client applications use: ",(0,i.kt)("inlineCode",{parentName:"p"},"dev.context({ tally: true })")," where available.")),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-js"},"const { participantResults } = tallyParticipantResults({\n  policyDefinitions: mockProfile.policyDefinitions,\n  generateReport, // optional boolean; attaches { readableReport } to returned values\n  matchUps,\n});\n")),(0,i.kt)("hr",null),(0,i.kt)("h2",{id:"tournamentmatchups"},"tournamentMatchUps"),(0,i.kt)("p",null,"Returns tournament matchUps grouped by matchUpStatus. These matchUps are returned with ",(0,i.kt)("em",{parentName:"p"},"context"),"."),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-js"},"const { abandonedMatchUps, completedMatchUps, upcomingMatchUps, pendingMatchUps, byeMatchUps, groupInfo } =\n  engine.tournamentMatchUps({\n    matchUpFilters, // optional; [ scheduledDates: [], courtIds: [], stages: [], roundNumbers: [], matchUpStatuses: [], matchUpFormats: []]\n    policyDefinitions, // optional - seeding or avoidance policies to be used when placing participants\n    scheduleVisibilityFilters, // { visibilityThreshold: Date, eventIds, drawIds }\n  });\n")),(0,i.kt)("hr",null))}u.isMDXComponent=!0}}]);