"use strict";(self.webpackChunkdocumentation=self.webpackChunkdocumentation||[]).push([[2228],{9276:(e,t,n)=>{n.d(t,{Zo:()=>d,kt:()=>m});var a=n(5271);function i(e,t,n){return t in e?Object.defineProperty(e,t,{value:n,enumerable:!0,configurable:!0,writable:!0}):e[t]=n,e}function r(e,t){var n=Object.keys(e);if(Object.getOwnPropertySymbols){var a=Object.getOwnPropertySymbols(e);t&&(a=a.filter((function(t){return Object.getOwnPropertyDescriptor(e,t).enumerable}))),n.push.apply(n,a)}return n}function s(e){for(var t=1;t<arguments.length;t++){var n=null!=arguments[t]?arguments[t]:{};t%2?r(Object(n),!0).forEach((function(t){i(e,t,n[t])})):Object.getOwnPropertyDescriptors?Object.defineProperties(e,Object.getOwnPropertyDescriptors(n)):r(Object(n)).forEach((function(t){Object.defineProperty(e,t,Object.getOwnPropertyDescriptor(n,t))}))}return e}function l(e,t){if(null==e)return{};var n,a,i=function(e,t){if(null==e)return{};var n,a,i={},r=Object.keys(e);for(a=0;a<r.length;a++)n=r[a],t.indexOf(n)>=0||(i[n]=e[n]);return i}(e,t);if(Object.getOwnPropertySymbols){var r=Object.getOwnPropertySymbols(e);for(a=0;a<r.length;a++)n=r[a],t.indexOf(n)>=0||Object.prototype.propertyIsEnumerable.call(e,n)&&(i[n]=e[n])}return i}var o=a.createContext({}),u=function(e){var t=a.useContext(o),n=t;return e&&(n="function"==typeof e?e(t):s(s({},t),e)),n},d=function(e){var t=u(e.components);return a.createElement(o.Provider,{value:t},e.children)},p="mdxType",c={inlineCode:"code",wrapper:function(e){var t=e.children;return a.createElement(a.Fragment,{},t)}},g=a.forwardRef((function(e,t){var n=e.components,i=e.mdxType,r=e.originalType,o=e.parentName,d=l(e,["components","mdxType","originalType","parentName"]),p=u(n),g=i,m=p["".concat(o,".").concat(g)]||p[g]||c[g]||r;return n?a.createElement(m,s(s({ref:t},d),{},{components:n})):a.createElement(m,s({ref:t},d))}));function m(e,t){var n=arguments,i=t&&t.mdxType;if("string"==typeof e||i){var r=n.length,s=new Array(r);s[0]=g;var l={};for(var o in t)hasOwnProperty.call(t,o)&&(l[o]=t[o]);l.originalType=e,l[p]="string"==typeof e?e:i,s[1]=l;for(var u=2;u<r;u++)s[u]=n[u];return a.createElement.apply(null,s)}return a.createElement.apply(null,n)}g.displayName="MDXCreateElement"},4757:(e,t,n)=>{n.r(t),n.d(t,{assets:()=>o,contentTitle:()=>s,default:()=>c,frontMatter:()=>r,metadata:()=>l,toc:()=>u});var a=n(8957),i=(n(5271),n(9276));const r={title:"drawEngine API"},s=void 0,l={unversionedId:"apis/draw-engine-api",id:"apis/draw-engine-api",title:"drawEngine API",description:"// NOTEXPORTED: should it be?",source:"@site/docs/apis/draw-engine-api.md",sourceDirName:"apis",slug:"/apis/draw-engine-api",permalink:"/tods-competition-factory/docs/apis/draw-engine-api",draft:!1,tags:[],version:"current",frontMatter:{title:"drawEngine API"}},o={},u=[{value:"addFinishingRounds",id:"addfinishingrounds",level:2},{value:"allStructureMatchUps",id:"allstructurematchups",level:2},{value:"assignSeed",id:"assignseed",level:2},{value:"clearDrawPosition",id:"cleardrawposition",level:2},{value:"generateQualifyingLink",id:"generatequalifyinglink",level:2},{value:"getDrawStructures",id:"getdrawstructures",level:2},{value:"getEliminationDrawSize",id:"geteliminationdrawsize",level:2},{value:"getMatchUpParticipantIds",id:"getmatchupparticipantids",level:2},{value:"getNextSeedBlock",id:"getnextseedblock",level:2},{value:"getNextUnfilledDrawPositions",id:"getnextunfilleddrawpositions",level:2},{value:"getSourceRounds",id:"getsourcerounds",level:2},{value:"initializeStructureSeedAssignments",id:"initializestructureseedassignments",level:2},{value:"matchUpDuration",id:"matchupduration",level:2},{value:"newDrawDefinition",id:"newdrawdefinition",level:2},{value:"resetMatchUpTimeItems",id:"resetmatchuptimeitems",level:2},{value:"setDrawDescription",id:"setdrawdescription",level:2},{value:"setStageAlternatesCount",id:"setstagealternatescount",level:2},{value:"setStageDrawSize",id:"setstagedrawsize",level:2},{value:"setStageQualifiersCount",id:"setstagequalifierscount",level:2},{value:"setStageWildcardsCount",id:"setstagewildcardscount",level:2},{value:"getStructureMatchUps",id:"getstructurematchups",level:2},{value:"validDrawPositions",id:"validdrawpositions",level:2}],d={toc:u},p="wrapper";function c(e){let{components:t,...n}=e;return(0,i.kt)(p,(0,a.Z)({},d,n,{components:t,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"// NOTEXPORTED: should it be?"),(0,i.kt)("h2",{id:"addfinishingrounds"},"addFinishingRounds"),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-js"},"addFinishingRounds({\n  finishingPositionOffset = 0, // required for sub-structures; e.g. consolation fed from R32 would have { finishingPositionOffset: 16 }\n  roundLimit, // for qualifying, offset the final round so that qualifyinground is finishingRound\n  matchUps, // required - matchUps belonging to a single structure\n});\n")),(0,i.kt)("hr",null),(0,i.kt)("p",null,"// NOTEXPORTED: should it be?"),(0,i.kt)("h2",{id:"allstructurematchups"},"allStructureMatchUps"),(0,i.kt)("p",null,"Returns all matchUps from a single structure within a draw."),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-js"},"const { matchUps } = drawEngine.allStructureMatchUps({\n  structureId,\n  context, // optional context to be added into matchUps\n  inContext, // boolean - add context { drawId, structureId, participant, individualParticipants ... }\n  nextMatchUps, // optioanl - boolean - to include winnerTo and loserTo\n  matchUpFilters, // attribute filters\n  contextFilters, // filters based on context attributes\n  tournamentParticipants, // optional - provide an array of tournamentParticipants to add into matchUps\n  requireParticipants, // optional - require that participants be loaded into drawEngine or passed into method\n  tournamentAppliedPolicies, // any policies, such as privacy, to be applied to matchUps\n});\n")),(0,i.kt)("hr",null),(0,i.kt)("p",null,"// NOTEXPORTED: should it be?"),(0,i.kt)("h2",{id:"assignseed"},"assignSeed"),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-js"},"result = drawEngine.assignSeed({\n  structureId,\n  seedNumber,\n  seedValue, // optional - display value, e.g. '5-8'\n  participantId,\n});\n")),(0,i.kt)("hr",null),(0,i.kt)("p",null,"// NOTEXPORTED: should it be?"),(0,i.kt)("h2",{id:"cleardrawposition"},"clearDrawPosition"),(0,i.kt)("p",null,"Removes a ",(0,i.kt)("inlineCode",{parentName:"p"},"participantId")," or ",(0,i.kt)("inlineCode",{parentName:"p"},"bye")," from a specified ",(0,i.kt)("inlineCode",{parentName:"p"},"drawPosition")," within a ",(0,i.kt)("inlineCode",{parentName:"p"},"structure")," or, optionally, removes a specified ",(0,i.kt)("inlineCode",{parentName:"p"},"participantId")," from a ",(0,i.kt)("inlineCode",{parentName:"p"},"structure"),"."),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-js"},"drawEngine.clearDrawPosition({\n  structureId,\n  drawPosition, // optional if participantId is provided\n  participantId, // optional if drawPosition is provided\n});\n")),(0,i.kt)("hr",null),(0,i.kt)("p",null,"// NOTEXPORTED: should it be?"),(0,i.kt)("h2",{id:"generatequalifyinglink"},"generateQualifyingLink"),(0,i.kt)("p",null,"Generates and adds a ",(0,i.kt)("inlineCode",{parentName:"p"},"link")," to ",(0,i.kt)("inlineCode",{parentName:"p"},"drawDefinition.links"),"."),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-js"},"drawEngine.generateQualifyingLink({\n  qualifyingStructureId,\n  mainStructureId,\n});\n")),(0,i.kt)("hr",null),(0,i.kt)("p",null,"// NOTEXPORTED: should it be?"),(0,i.kt)("h2",{id:"getdrawstructures"},"getDrawStructures"),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-js"},"const { structures, stageStructures } = drawEngine.getDrawStructures({\n  withStageGrouping, // optinal, return structures collated by stage\n  stageSequences, // optional - specify stageSequences to include\n  stageSequence, // optional - filter by stageSequence\n  stages, // optional - specify stageSequences to include\n  stage, // optional - filter by stage\n});\n")),(0,i.kt)("hr",null),(0,i.kt)("p",null,"// NOTEXPORTED: should it be?"),(0,i.kt)("h2",{id:"geteliminationdrawsize"},"getEliminationDrawSize"),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-js"},"const { drawSize } = drawEngine.getEliminationDrawSize({ participantsCount });\n")),(0,i.kt)("hr",null),(0,i.kt)("p",null,"// NOTEXPORTED: should it be?"),(0,i.kt)("h2",{id:"getmatchupparticipantids"},"getMatchUpParticipantIds"),(0,i.kt)("p",null,"Convenience function; requires inContext matchUp."),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-js"},"const { sideParticipantIds, individualParticipantIds } = drawEngine.getMatchUpParticipantIds({ matchUp });\n")),(0,i.kt)("hr",null),(0,i.kt)("p",null,"// NOTEXPORTED: should it be?"),(0,i.kt)("h2",{id:"getnextseedblock"},"getNextSeedBlock"),(0,i.kt)("p",null,"Returns the next block of drawPositions which are to be assigned seeded participants."),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-js"},"const { nextSeedBlock, unplacedSeedParticipantIds, unplacedSeedNumbers, unfilledPositions, unplacedSeedAssignments } =\n  drawEngine.getNextSeedBlock({\n    structureId,\n  });\n")),(0,i.kt)("hr",null),(0,i.kt)("p",null,"// NOTEXPORTED: should it be?"),(0,i.kt)("h2",{id:"getnextunfilleddrawpositions"},"getNextUnfilledDrawPositions"),(0,i.kt)("p",null,"Returns the next valid block of unfilled drawPositions. Useful for UI to give visual indication of drawPostions valid to assign."),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-js"},"const { nextUnfilledDrawPositions } = drawEngine.getNextUnfilledDrawPositions({\n  structureId,\n});\n")),(0,i.kt)("hr",null),(0,i.kt)("p",null,"// NOTEXPORTED: should it be?"),(0,i.kt)("h2",{id:"getsourcerounds"},"getSourceRounds"),(0,i.kt)("p",null,"Returns the round numbers for desired playoff positions."),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-js"},"const {\n  sourceRounds, // all source rounds for playedOff positions and specified playoffPositions\n  playoffSourceRounds,\n  playedOffSourceRounds,\n  playoffPositionsReturned,\n} = drawEngine.getSourceRounds({\n  structureId,\n  playoffPositions: [3, 4],\n});\n")),(0,i.kt)("hr",null),(0,i.kt)("p",null,"// NOTEXPORTED: should it be?"),(0,i.kt)("h2",{id:"initializestructureseedassignments"},"initializeStructureSeedAssignments"),(0,i.kt)("p",null,"Creates the ",(0,i.kt)("inlineCode",{parentName:"p"},"seedAssignments")," attribute for the specified structure."),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-js"},"drawEngine.initializeStructureSeedAssignments({\n  structureId,\n  seedsCount,\n});\n")),(0,i.kt)("hr",null),(0,i.kt)("p",null,"// NOTEXPORTED: should it be?"),(0,i.kt)("h2",{id:"matchupduration"},"matchUpDuration"),(0,i.kt)("p",null,"Calculates matchUp duration from START, STOP, RESUME, END timeItems."),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-js"},'const {\n  milliseconds,\n  time, // string representation of elapsed time, e.g. "01:10:00" for an hour and 10 seconds\n  relevantTimeItems,\n} = drawEngine.matchUpDuration({\n  matchUp,\n});\n')),(0,i.kt)("hr",null),(0,i.kt)("p",null,"// NOTEXPORTED: should it be?"),(0,i.kt)("h2",{id:"newdrawdefinition"},"newDrawDefinition"),(0,i.kt)("p",null,"Creates a new drawDefinition within drawEngine state."),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-js"},"const { drawId } = drawEngine.newDrawDefinition();\nconst { drawDefinition } = drawEngine.getState();\n")),(0,i.kt)("hr",null),(0,i.kt)("p",null,"// NOTEXPORTED: should it be?"),(0,i.kt)("h2",{id:"resetmatchuptimeitems"},"resetMatchUpTimeItems"),(0,i.kt)("p",null,"Removes all timeItems from a specified matchUp."),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-js"},"drawEngine.resetMatchUpTimeItems({ matchUpId });\n")),(0,i.kt)("hr",null),(0,i.kt)("p",null,"// NOTEXPORTED: should it be?"),(0,i.kt)("h2",{id:"setdrawdescription"},"setDrawDescription"),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-js"},"const drawDescription = 'Draw Description';\ndrawEngine.setDrawDescription({ description: drawDescription });\n")),(0,i.kt)("hr",null),(0,i.kt)("p",null,"// NOTEXPORTED: should it be?"),(0,i.kt)("h2",{id:"setstagealternatescount"},"setStageAlternatesCount"),(0,i.kt)("p",null,"Sets an (optional) limit to the number of accepted alternates."),(0,i.kt)("p",null,"Modifies the 'entryProfile' of a drawDefinition before the structures have been generated."),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-js"},"drawEngine.setStageAlternatesCount({ alternatesCount: 8 });\n")),(0,i.kt)("hr",null),(0,i.kt)("p",null,"// NOTEXPORTED: should it be?"),(0,i.kt)("h2",{id:"setstagedrawsize"},"setStageDrawSize"),(0,i.kt)("p",null,"Modifies the 'entryProfile' of a drawDefinition before the structures have been generated."),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-js"},"drawEngine.setStageDrawSize({ stage: QUALIFYING, stageSequence, drawSize: 8 });\ndrawEngine.setStageDrawSize({ stage: MAIN, drawSize: 16 });\n")),(0,i.kt)("hr",null),(0,i.kt)("p",null,"// NOTEXPORTED: should it be?"),(0,i.kt)("h2",{id:"setstagequalifierscount"},"setStageQualifiersCount"),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-js"},"drawEngine.setStageQualifiersCount({\n  qualifiersCount: 4,\n  stageSequence,\n  stage,\n});\n")),(0,i.kt)("hr",null),(0,i.kt)("p",null,"// NOTEXPORTED: should it be?"),(0,i.kt)("h2",{id:"setstagewildcardscount"},"setStageWildcardsCount"),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-js"},"drawEngine.setStageWildcardsCount({ stage, stageSequence, wildcardsCount: 2 });\n")),(0,i.kt)("hr",null),(0,i.kt)("p",null,"// NOTEXPORTED: should it be?"),(0,i.kt)("h2",{id:"getstructurematchups"},"getStructureMatchUps"),(0,i.kt)("p",null,"Returns categorized matchUps from a single structure."),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-js"},"const { upcomingMatchUps, pendingMatchUps, completedMatchUps, abandonedMatchUps, byeMatchUps } =\n  drawEngine.getStructureMatchUps({\n    tournamentAppliedPolicies, // any policies, such as privacy, to be applied to matchUps\n    scheduleVisibilityFilters, // { visibilityThreshold: Date, eventIds, drawIds }\n    tournamentParticipants, // optional - provide an array of tournamentParticipants to add into matchUps\n    requireParticipants, // optional - require that participants be loaded into drawEngine or passed into method\n    contextFilters, // filters based on context attributes\n    matchUpFilters, // attribute filters\n    structureId,\n    nextMatchUps, // optioanl - boolean - to include winnerTo and loserTo\n    inContext, // boolean - add context { drawId, structureId, participant, individualParticipants ... }\n    context, // optional context to be added into matchUps\n  });\n")),(0,i.kt)("hr",null),(0,i.kt)("p",null,"// NOTEXPORTED: should it be?"),(0,i.kt)("h2",{id:"validdrawpositions"},"validDrawPositions"),(0,i.kt)("p",null,"Returns boolean indicating whether all matchUps have valid draw positions"),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-js"},"drawEngine.validDrawPositions({ matchUps });\n")),(0,i.kt)("hr",null))}c.isMDXComponent=!0}}]);