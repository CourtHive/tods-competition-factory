"use strict";(globalThis.webpackChunkdocumentation=globalThis.webpackChunkdocumentation||[]).push([[7875],{6897(e,n,l){l.r(n),l.d(n,{assets:()=>c,contentTitle:()=>r,default:()=>u,frontMatter:()=>s,metadata:()=>a,toc:()=>d});const a=JSON.parse('{"id":"temporal-engine/temporal-engine-api","title":"Core API Reference","description":"Complete method reference for the TemporalEngine class.","source":"@site/docs/temporal-engine/temporal-engine-api.md","sourceDirName":"temporal-engine","slug":"/temporal-engine/temporal-engine-api","permalink":"/competition-factory/docs/temporal-engine/temporal-engine-api","draft":false,"unlisted":false,"tags":[],"version":"current","frontMatter":{"title":"Core API Reference"},"sidebar":"docs","previous":{"title":"Overview","permalink":"/competition-factory/docs/temporal-engine/temporal-engine-overview"},"next":{"title":"Event System & Validation","permalink":"/competition-factory/docs/temporal-engine/event-system-and-validation"}}');var t=l(6070),i=l(8322);const s={title:"Core API Reference"},r=void 0,c={},d=[{value:"Lifecycle",id:"lifecycle",level:2},{value:"init",id:"init",level:3},{value:"updateTournamentRecord",id:"updatetournamentrecord",level:3},{value:"getConfig",id:"getconfig",level:3},{value:"getResolvedGranularityMinutes",id:"getresolvedgranularityminutes",level:3},{value:"Block CRUD",id:"block-crud",level:2},{value:"applyBlock",id:"applyblock",level:3},{value:"moveBlock",id:"moveblock",level:3},{value:"resizeBlock",id:"resizeblock",level:3},{value:"removeBlock",id:"removeblock",level:3},{value:"applyTemplate",id:"applytemplate",level:3},{value:"importScheduledMatchUps",id:"importscheduledmatchups",level:3},{value:"Court &amp; Venue Availability",id:"court--venue-availability",level:2},{value:"getCourtAvailability",id:"getcourtavailability",level:3},{value:"setCourtAvailability",id:"setcourtavailability",level:3},{value:"setCourtAvailabilityAllDays",id:"setcourtavailabilityalldays",level:3},{value:"setAllCourtsDefaultAvailability",id:"setallcourtsdefaultavailability",level:3},{value:"getVenueAvailability",id:"getvenueavailability",level:3},{value:"setVenueDefaultAvailability",id:"setvenuedefaultavailability",level:3},{value:"setVenueDayAvailability",id:"setvenuedayavailability",level:3},{value:"Timeline Queries",id:"timeline-queries",level:2},{value:"getTournamentDays",id:"gettournamentdays",level:3},{value:"getDayTimeline",id:"getdaytimeline",level:3},{value:"getVenueTimeline",id:"getvenuetimeline",level:3},{value:"getCourtRail",id:"getcourtrail",level:3},{value:"getCapacityCurve",id:"getcapacitycurve",level:3},{value:"getVisibleTimeRange",id:"getvisibletimerange",level:3},{value:"getDayBlocks",id:"getdayblocks",level:3},{value:"getAllBlocks",id:"getallblocks",level:3},{value:"Plan State",id:"plan-state",level:2},{value:"addPlanItem",id:"addplanitem",level:3},{value:"removePlanItem",id:"removeplanitem",level:3},{value:"updatePlanItem",id:"updateplanitem",level:3},{value:"movePlanItem",id:"moveplanitem",level:3},{value:"getDayPlan",id:"getdayplan",level:3},{value:"getAllPlans",id:"getallplans",level:3},{value:"Templates &amp; Rules",id:"templates--rules",level:2},{value:"getTemplates",id:"gettemplates",level:3},{value:"getTemplate",id:"gettemplate",level:3},{value:"getRules",id:"getrules",level:3},{value:"getRule",id:"getrule",level:3},{value:"Simulation",id:"simulation",level:2},{value:"simulateBlocks",id:"simulateblocks",level:3},{value:"Court Metadata",id:"court-metadata",level:2},{value:"listCourtMeta",id:"listcourtmeta",level:3},{value:"Event System",id:"event-system",level:2},{value:"subscribe",id:"subscribe",level:3},{value:"Related Documentation",id:"related-documentation",level:2}];function o(e){const n={a:"a",admonition:"admonition",code:"code",h2:"h2",h3:"h3",hr:"hr",li:"li",p:"p",pre:"pre",strong:"strong",ul:"ul",...(0,i.R)(),...e.components};return(0,t.jsxs)(t.Fragment,{children:[(0,t.jsxs)(n.p,{children:["Complete method reference for the ",(0,t.jsx)(n.code,{children:"TemporalEngine"})," class."]}),"\n",(0,t.jsx)(n.admonition,{type:"info",children:(0,t.jsxs)(n.p,{children:["The TemporalEngine uses ",(0,t.jsx)(n.strong,{children:"ISO 8601 datetime strings"})," (e.g., ",(0,t.jsx)(n.code,{children:"'2026-06-15T08:00:00'"}),") for block time ranges, ",(0,t.jsx)(n.strong,{children:(0,t.jsx)(n.code,{children:"YYYY-MM-DD"})})," strings for day IDs, and ",(0,t.jsx)(n.strong,{children:(0,t.jsx)(n.code,{children:"HH:MM"})})," strings for time-of-day values (availability windows, plan times)."]})}),"\n",(0,t.jsx)(n.h2,{id:"lifecycle",children:"Lifecycle"}),"\n",(0,t.jsx)(n.h3,{id:"init",children:"init"}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-ts",children:"init(tournamentRecord: any, config?: Partial<EngineConfig>): void\n"})}),"\n",(0,t.jsxs)(n.p,{children:["Initialize the engine with a tournament record and optional configuration. Merges config with defaults, loads blocks from the tournament record's venue/court structures, and emits ",(0,t.jsx)(n.code,{children:"STATE_CHANGED"}),"."]}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-js",children:"const engine = new TemporalEngine();\nengine.init(tournamentRecord, {\n  dayStartTime: '08:00',\n  dayEndTime: '20:00',\n  slotMinutes: 15,\n  conflictEvaluators: defaultEvaluators,\n});\n"})}),"\n",(0,t.jsx)(n.h3,{id:"updatetournamentrecord",children:"updateTournamentRecord"}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-ts",children:"updateTournamentRecord(tournamentRecord: any): void\n"})}),"\n",(0,t.jsxs)(n.p,{children:["Replace the tournament record and reload all blocks from it. Clears existing block state and re-imports from the new record. Emits ",(0,t.jsx)(n.code,{children:"STATE_CHANGED"})," with reason ",(0,t.jsx)(n.code,{children:"'TOURNAMENT_RECORD_UPDATED'"}),"."]}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-js",children:"// After external changes to the tournament\nengine.updateTournamentRecord(updatedRecord);\n"})}),"\n",(0,t.jsx)(n.h3,{id:"getconfig",children:"getConfig"}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-ts",children:"getConfig(): EngineConfig\n"})}),"\n",(0,t.jsx)(n.p,{children:"Returns a shallow copy of the current engine configuration."}),"\n",(0,t.jsx)(n.h3,{id:"getresolvedgranularityminutes",children:"getResolvedGranularityMinutes"}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-ts",children:"getResolvedGranularityMinutes(): number\n"})}),"\n",(0,t.jsxs)(n.p,{children:["Returns the resolved canonical granularity in minutes. Resolution order: ",(0,t.jsx)(n.code,{children:"granularityMinutes"})," \u2192 ",(0,t.jsx)(n.code,{children:"slotMinutes"})," \u2192 ",(0,t.jsx)(n.code,{children:"15"}),"."]}),"\n",(0,t.jsx)(n.hr,{}),"\n",(0,t.jsx)(n.h2,{id:"block-crud",children:"Block CRUD"}),"\n",(0,t.jsx)(n.h3,{id:"applyblock",children:"applyBlock"}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-ts",children:"applyBlock(opts: ApplyBlockOptions): MutationResult\n"})}),"\n",(0,t.jsx)(n.p,{children:"Create blocks on one or more courts for a time range. Blocks are clamped to each court's availability window. Unique block IDs are generated automatically."}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-js",children:"const result = engine.applyBlock({\n  courts: [court1Ref, court2Ref],\n  timeRange: { start: '2026-06-15T09:00:00', end: '2026-06-15T10:30:00' },\n  type: 'MAINTENANCE',\n  reason: 'Court resurfacing',\n  hardSoft: 'HARD',\n  source: 'USER',\n});\n\nif (result.conflicts.length > 0) {\n  console.warn('Conflicts:', result.conflicts);\n}\n"})}),"\n",(0,t.jsx)(n.p,{children:(0,t.jsxs)(n.strong,{children:[(0,t.jsx)(n.code,{children:"ApplyBlockOptions"}),":"]})}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-ts",children:"interface ApplyBlockOptions {\n  courts: CourtRef[];          // Target courts\n  timeRange: TimeRange;        // { start: string, end: string } \u2014 ISO 8601\n  type: BlockType;             // Block type (e.g., 'MAINTENANCE', 'PRACTICE')\n  reason?: string;             // Human-readable reason\n  hardSoft?: BlockHardness;    // 'HARD' | 'SOFT'\n  source?: BlockSource;        // 'USER' | 'TEMPLATE' | 'RULE' | 'SYSTEM'\n}\n"})}),"\n",(0,t.jsx)(n.h3,{id:"moveblock",children:"moveBlock"}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-ts",children:"moveBlock(opts: MoveBlockOptions): MutationResult\n"})}),"\n",(0,t.jsx)(n.p,{children:"Move an existing block to a new time range and optionally a new court. The block is clamped to the target court's availability window."}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-js",children:"const result = engine.moveBlock({\n  blockId: 'block-42',\n  newTimeRange: { start: '2026-06-15T14:00:00', end: '2026-06-15T15:30:00' },\n  newCourt: court3Ref, // optional \u2014 move to a different court\n});\n"})}),"\n",(0,t.jsx)(n.p,{children:(0,t.jsxs)(n.strong,{children:[(0,t.jsx)(n.code,{children:"MoveBlockOptions"}),":"]})}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-ts",children:"interface MoveBlockOptions {\n  blockId: BlockId;\n  newTimeRange: TimeRange;\n  newCourt?: CourtRef;        // If omitted, stays on current court\n}\n"})}),"\n",(0,t.jsx)(n.h3,{id:"resizeblock",children:"resizeBlock"}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-ts",children:"resizeBlock(opts: ResizeBlockOptions): MutationResult\n"})}),"\n",(0,t.jsx)(n.p,{children:"Resize an existing block's time range. Clamped to the court's availability window."}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-js",children:"engine.resizeBlock({\n  blockId: 'block-42',\n  newTimeRange: { start: '2026-06-15T14:00:00', end: '2026-06-15T16:00:00' },\n});\n"})}),"\n",(0,t.jsx)(n.p,{children:(0,t.jsxs)(n.strong,{children:[(0,t.jsx)(n.code,{children:"ResizeBlockOptions"}),":"]})}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-ts",children:"interface ResizeBlockOptions {\n  blockId: BlockId;\n  newTimeRange: TimeRange;\n}\n"})}),"\n",(0,t.jsx)(n.h3,{id:"removeblock",children:"removeBlock"}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-ts",children:"removeBlock(blockId: BlockId): MutationResult\n"})}),"\n",(0,t.jsx)(n.p,{children:"Remove a block by ID."}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-js",children:"engine.removeBlock('block-42');\n"})}),"\n",(0,t.jsx)(n.h3,{id:"applytemplate",children:"applyTemplate"}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-ts",children:"applyTemplate(opts: ApplyTemplateOptions): MutationResult\n"})}),"\n",(0,t.jsx)(n.p,{children:"Apply a registered template to create blocks across a scope of venues, courts, and days."}),"\n",(0,t.jsx)(n.p,{children:(0,t.jsxs)(n.strong,{children:[(0,t.jsx)(n.code,{children:"ApplyTemplateOptions"}),":"]})}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-ts",children:"interface ApplyTemplateOptions {\n  templateId: TemplateId;\n  scope?: {\n    venues?: VenueId[];\n    courts?: CourtRef[];\n    days?: DayId[];\n  };\n}\n"})}),"\n",(0,t.jsx)(n.h3,{id:"importscheduledmatchups",children:"importScheduledMatchUps"}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-ts",children:"importScheduledMatchUps(matchUps: Array<{\n  matchUpId: string;\n  courtId: string;\n  venueId: string;\n  date: string;\n  startTime: string;\n  durationMinutes: number;\n}>): MutationResult\n"})}),"\n",(0,t.jsxs)(n.p,{children:["Import factory-scheduled matchUps as visual ",(0,t.jsx)(n.code,{children:"SCHEDULED"})," blocks. First removes all existing ",(0,t.jsx)(n.code,{children:"SCHEDULED"})," + ",(0,t.jsx)(n.code,{children:"SYSTEM"})," blocks (bypassing conflict checks), then creates new blocks through the normal mutation pipeline."]}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-js",children:"// After running automated scheduling\nconst scheduled = matchUps\n  .filter((m) => m.schedule)\n  .map((m) => ({\n    matchUpId: m.matchUpId,\n    courtId: m.schedule.courtId,\n    venueId: m.schedule.venueId,\n    date: m.schedule.scheduledDate,\n    startTime: m.schedule.scheduledTime,\n    durationMinutes: m.schedule.averageMinutes || 60,\n  }));\n\nengine.importScheduledMatchUps(scheduled);\n"})}),"\n",(0,t.jsx)(n.p,{children:(0,t.jsxs)(n.strong,{children:[(0,t.jsx)(n.code,{children:"MutationResult"}),":"]})}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-ts",children:"interface MutationResult {\n  applied: BlockMutation[];      // Mutations that were applied\n  rejected: BlockMutation[];     // Mutations rejected by conflict evaluators\n  warnings: EngineWarning[];     // Non-blocking warnings\n  conflicts: EngineConflict[];   // Detected conflicts (may include WARN/INFO severity)\n}\n"})}),"\n",(0,t.jsx)(n.hr,{}),"\n",(0,t.jsx)(n.h2,{id:"court--venue-availability",children:"Court & Venue Availability"}),"\n",(0,t.jsx)(n.h3,{id:"getcourtavailability",children:"getCourtAvailability"}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-ts",children:"getCourtAvailability(court: CourtRef, day: DayId): CourtDayAvailability\n"})}),"\n",(0,t.jsx)(n.p,{children:"Resolve the effective availability window for a court on a day. Uses a layered cascade:"}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{children:"court + day  \u2192  court DEFAULT  \u2192  (intersect with)  venue + day  \u2192  venue DEFAULT  \u2192  GLOBAL DEFAULT  \u2192  engine config\n"})}),"\n",(0,t.jsxs)(n.p,{children:["When both court-level and venue-level availability exist, the engine returns their ",(0,t.jsx)(n.strong,{children:"intersection"})," (the tighter window)."]}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-js",children:"const avail = engine.getCourtAvailability(courtRef, '2026-06-15');\n// { startTime: '08:00', endTime: '20:00' }\n"})}),"\n",(0,t.jsx)(n.h3,{id:"setcourtavailability",children:"setCourtAvailability"}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-ts",children:"setCourtAvailability(court: CourtRef, day: DayId, avail: CourtDayAvailability): void\n"})}),"\n",(0,t.jsxs)(n.p,{children:["Set availability for a specific court on a specific day. Emits ",(0,t.jsx)(n.code,{children:"AVAILABILITY_CHANGED"}),"."]}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-js",children:"engine.setCourtAvailability(courtRef, '2026-06-15', {\n  startTime: '10:00',\n  endTime: '18:00',\n});\n"})}),"\n",(0,t.jsx)(n.h3,{id:"setcourtavailabilityalldays",children:"setCourtAvailabilityAllDays"}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-ts",children:"setCourtAvailabilityAllDays(court: CourtRef, avail: CourtDayAvailability): void\n"})}),"\n",(0,t.jsxs)(n.p,{children:["Set default availability for a court across all days. Used as fallback when no day-specific availability is set. Emits ",(0,t.jsx)(n.code,{children:"AVAILABILITY_CHANGED"}),"."]}),"\n",(0,t.jsx)(n.h3,{id:"setallcourtsdefaultavailability",children:"setAllCourtsDefaultAvailability"}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-ts",children:"setAllCourtsDefaultAvailability(avail: CourtDayAvailability): void\n"})}),"\n",(0,t.jsxs)(n.p,{children:["Set global default availability for all courts. Lowest priority in the cascade. Emits ",(0,t.jsx)(n.code,{children:"AVAILABILITY_CHANGED"}),"."]}),"\n",(0,t.jsx)(n.h3,{id:"getvenueavailability",children:"getVenueAvailability"}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-ts",children:"getVenueAvailability(\n  tournamentId: TournamentId,\n  venueId: VenueId,\n  day?: DayId,\n): CourtDayAvailability | null\n"})}),"\n",(0,t.jsxs)(n.p,{children:["Get venue-level availability. Checks day-specific first, then DEFAULT. Returns ",(0,t.jsx)(n.code,{children:"null"})," if no venue-level availability is set."]}),"\n",(0,t.jsx)(n.h3,{id:"setvenuedefaultavailability",children:"setVenueDefaultAvailability"}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-ts",children:"setVenueDefaultAvailability(\n  tournamentId: TournamentId,\n  venueId: VenueId,\n  avail: CourtDayAvailability,\n): void\n"})}),"\n",(0,t.jsxs)(n.p,{children:["Set default venue-level availability (all days unless overridden). Emits ",(0,t.jsx)(n.code,{children:"AVAILABILITY_CHANGED"}),"."]}),"\n",(0,t.jsx)(n.h3,{id:"setvenuedayavailability",children:"setVenueDayAvailability"}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-ts",children:"setVenueDayAvailability(\n  tournamentId: TournamentId,\n  venueId: VenueId,\n  day: DayId,\n  avail: CourtDayAvailability,\n): void\n"})}),"\n",(0,t.jsxs)(n.p,{children:["Set venue-level availability for a specific day. Emits ",(0,t.jsx)(n.code,{children:"AVAILABILITY_CHANGED"}),"."]}),"\n",(0,t.jsx)(n.p,{children:(0,t.jsxs)(n.strong,{children:[(0,t.jsx)(n.code,{children:"CourtDayAvailability"}),":"]})}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-ts",children:"interface CourtDayAvailability {\n  startTime: string;   // 'HH:MM'\n  endTime: string;     // 'HH:MM'\n}\n"})}),"\n",(0,t.jsx)(n.hr,{}),"\n",(0,t.jsx)(n.h2,{id:"timeline-queries",children:"Timeline Queries"}),"\n",(0,t.jsx)(n.h3,{id:"gettournamentdays",children:"getTournamentDays"}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-ts",children:"getTournamentDays(): DayId[]\n"})}),"\n",(0,t.jsxs)(n.p,{children:["Returns an array of ",(0,t.jsx)(n.code,{children:"'YYYY-MM-DD'"})," strings from the tournament's ",(0,t.jsx)(n.code,{children:"startDate"})," to ",(0,t.jsx)(n.code,{children:"endDate"}),"."]}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-js",children:"const days = engine.getTournamentDays();\n// ['2026-06-15', '2026-06-16', '2026-06-17', ...]\n"})}),"\n",(0,t.jsx)(n.h3,{id:"getdaytimeline",children:"getDayTimeline"}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-ts",children:"getDayTimeline(day: DayId): VenueDayTimeline[]\n"})}),"\n",(0,t.jsxs)(n.p,{children:["Returns the complete timeline for a day \u2014 all venues, all courts. Groups courts by venue, then derives a ",(0,t.jsx)(n.code,{children:"CourtRail"})," for each court."]}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-js",children:"const timelines = engine.getDayTimeline('2026-06-15');\nfor (const venue of timelines) {\n  for (const rail of venue.rails) {\n    console.log(rail.court.courtId, rail.segments.length, 'segments');\n  }\n}\n"})}),"\n",(0,t.jsx)(n.h3,{id:"getvenuetimeline",children:"getVenueTimeline"}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-ts",children:"getVenueTimeline(day: DayId, venueId: VenueId): VenueDayTimeline | null\n"})}),"\n",(0,t.jsx)(n.p,{children:"Returns the timeline for a specific venue on a day."}),"\n",(0,t.jsx)(n.h3,{id:"getcourtrail",children:"getCourtRail"}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-ts",children:"getCourtRail(day: DayId, court: CourtRef): CourtRail | null\n"})}),"\n",(0,t.jsxs)(n.p,{children:["Returns the derived rail (non-overlapping ",(0,t.jsx)(n.code,{children:"RailSegment[]"}),") for a specific court on a day."]}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-js",children:"const rail = engine.getCourtRail('2026-06-15', courtRef);\nfor (const seg of rail.segments) {\n  console.log(`${seg.start} \u2013 ${seg.end}: ${seg.status}`);\n}\n"})}),"\n",(0,t.jsx)(n.h3,{id:"getcapacitycurve",children:"getCapacityCurve"}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-ts",children:"getCapacityCurve(day: DayId): CapacityCurve\n"})}),"\n",(0,t.jsx)(n.p,{children:"Returns the capacity curve \u2014 a time-series of available/blocked court counts for a day."}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-js",children:"const curve = engine.getCapacityCurve('2026-06-15');\nfor (const pt of curve.points) {\n  console.log(`${pt.time}: ${pt.courtsAvailable} available`);\n}\n"})}),"\n",(0,t.jsx)(n.h3,{id:"getvisibletimerange",children:"getVisibleTimeRange"}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-ts",children:"getVisibleTimeRange(day: DayId, courtRefs?: CourtRef[]): {\n  startTime: string;\n  endTime: string;\n}\n"})}),"\n",(0,t.jsx)(n.p,{children:"Returns the union (earliest start, latest end) of court availability across given courts, or all courts if none specified. Useful for configuring timeline viewport bounds."}),"\n",(0,t.jsx)(n.h3,{id:"getdayblocks",children:"getDayBlocks"}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-ts",children:"getDayBlocks(day: DayId): Block[]\n"})}),"\n",(0,t.jsx)(n.p,{children:"Returns all blocks that start on a specific day across all courts."}),"\n",(0,t.jsx)(n.h3,{id:"getallblocks",children:"getAllBlocks"}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-ts",children:"getAllBlocks(): Block[]\n"})}),"\n",(0,t.jsx)(n.p,{children:"Returns all blocks across all days."}),"\n",(0,t.jsx)(n.hr,{}),"\n",(0,t.jsx)(n.h2,{id:"plan-state",children:"Plan State"}),"\n",(0,t.jsx)(n.p,{children:"Plan state tracks which tournament rounds are assigned to which days and venues \u2014 used by the scheduling profile builder."}),"\n",(0,t.jsx)(n.h3,{id:"addplanitem",children:"addPlanItem"}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-ts",children:"addPlanItem(item: Omit<PlanItem, 'planItemId'>): PlanItem\n"})}),"\n",(0,t.jsxs)(n.p,{children:["Add a plan item to a day's plan. The ",(0,t.jsx)(n.code,{children:"planItemId"})," is computed automatically. If an item with the same computed ID already exists, it is replaced. Emits ",(0,t.jsx)(n.code,{children:"PLAN_CHANGED"})," and ",(0,t.jsx)(n.code,{children:"STATE_CHANGED"}),"."]}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-js",children:"const item = engine.addPlanItem({\n  day: '2026-06-15',\n  venueId: 'venue-1',\n  eventId: 'event-ms',\n  drawId: 'draw-1',\n  roundNumber: 1,\n  matchUpType: 'SINGLES',\n  estimatedDurationMinutes: 90,\n});\n"})}),"\n",(0,t.jsx)(n.h3,{id:"removeplanitem",children:"removePlanItem"}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-ts",children:"removePlanItem(planItemId: string): boolean\n"})}),"\n",(0,t.jsxs)(n.p,{children:["Remove a plan item by ID. Returns ",(0,t.jsx)(n.code,{children:"true"})," if found and removed. Empty day plans are cleaned up automatically. Emits ",(0,t.jsx)(n.code,{children:"PLAN_CHANGED"})," and ",(0,t.jsx)(n.code,{children:"STATE_CHANGED"}),"."]}),"\n",(0,t.jsx)(n.h3,{id:"updateplanitem",children:"updatePlanItem"}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-ts",children:"updatePlanItem(\n  planItemId: string,\n  updates: Partial<Pick<PlanItem,\n    'notBeforeTime' | 'estimatedDurationMinutes' | 'matchUpType' | 'roundSegment'\n  >>,\n): PlanItem | null\n"})}),"\n",(0,t.jsxs)(n.p,{children:["Update mutable fields on an existing plan item. Key fields (",(0,t.jsx)(n.code,{children:"day"}),", ",(0,t.jsx)(n.code,{children:"venueId"}),", ",(0,t.jsx)(n.code,{children:"eventId"}),", ",(0,t.jsx)(n.code,{children:"drawId"}),", ",(0,t.jsx)(n.code,{children:"roundNumber"}),") cannot be changed \u2014 use ",(0,t.jsx)(n.code,{children:"movePlanItem"})," to change the day. Returns the updated item or ",(0,t.jsx)(n.code,{children:"null"}),"."]}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-js",children:"engine.updatePlanItem('2026-06-15|venue-1|event-ms|draw-1|R1', {\n  notBeforeTime: '10:00',\n  estimatedDurationMinutes: 120,\n});\n"})}),"\n",(0,t.jsx)(n.h3,{id:"moveplanitem",children:"movePlanItem"}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-ts",children:"movePlanItem(planItemId: string, newDay: DayId): PlanItem | null\n"})}),"\n",(0,t.jsxs)(n.p,{children:["Move a plan item to a different day. Recomputes the ",(0,t.jsx)(n.code,{children:"planItemId"})," with the new day. Returns the updated item or ",(0,t.jsx)(n.code,{children:"null"}),"."]}),"\n",(0,t.jsx)(n.h3,{id:"getdayplan",children:"getDayPlan"}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-ts",children:"getDayPlan(day: DayId): DayPlan | null\n"})}),"\n",(0,t.jsx)(n.p,{children:"Returns the plan for a specific day."}),"\n",(0,t.jsx)(n.h3,{id:"getallplans",children:"getAllPlans"}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-ts",children:"getAllPlans(): DayPlan[]\n"})}),"\n",(0,t.jsx)(n.p,{children:"Returns all plans across all days."}),"\n",(0,t.jsx)(n.p,{children:(0,t.jsxs)(n.strong,{children:[(0,t.jsx)(n.code,{children:"PlanItem"}),":"]})}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-ts",children:"interface PlanItem {\n  planItemId: string;          // Computed: day|venueId|eventId[|drawId]|R{roundNumber}\n  day: DayId;\n  venueId: VenueId;\n  eventId: string;\n  drawId?: string;\n  structureId?: string;\n  roundNumber: number;\n  roundSegment?: { segmentNumber: number; segmentsCount: number };\n  matchUpType?: string;\n  notBeforeTime?: string;      // 'HH:MM'\n  estimatedDurationMinutes?: number;\n}\n"})}),"\n",(0,t.jsx)(n.p,{children:(0,t.jsxs)(n.strong,{children:[(0,t.jsx)(n.code,{children:"DayPlan"}),":"]})}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-ts",children:"interface DayPlan {\n  day: DayId;\n  items: PlanItem[];\n}\n"})}),"\n",(0,t.jsx)(n.hr,{}),"\n",(0,t.jsx)(n.h2,{id:"templates--rules",children:"Templates & Rules"}),"\n",(0,t.jsx)(n.h3,{id:"gettemplates",children:"getTemplates"}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-ts",children:"getTemplates(): Template[]\n"})}),"\n",(0,t.jsx)(n.p,{children:"Returns all registered templates."}),"\n",(0,t.jsx)(n.h3,{id:"gettemplate",children:"getTemplate"}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-ts",children:"getTemplate(templateId: TemplateId): Template | null\n"})}),"\n",(0,t.jsx)(n.p,{children:"Returns a specific template by ID."}),"\n",(0,t.jsx)(n.h3,{id:"getrules",children:"getRules"}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-ts",children:"getRules(): Rule[]\n"})}),"\n",(0,t.jsx)(n.p,{children:"Returns all registered rules."}),"\n",(0,t.jsx)(n.h3,{id:"getrule",children:"getRule"}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-ts",children:"getRule(ruleId: RuleId): Rule | null\n"})}),"\n",(0,t.jsx)(n.p,{children:"Returns a specific rule by ID."}),"\n",(0,t.jsx)(n.hr,{}),"\n",(0,t.jsx)(n.h2,{id:"simulation",children:"Simulation"}),"\n",(0,t.jsx)(n.h3,{id:"simulateblocks",children:"simulateBlocks"}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-ts",children:"simulateBlocks(mutations: BlockMutation[], day?: DayId): SimulationResult\n"})}),"\n",(0,t.jsx)(n.p,{children:"Simulate mutations without applying them. Creates a disposable snapshot of the engine, applies mutations to it, and returns preview data. The real engine state is untouched \u2014 subscribers are not notified."}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-js",children:"const preview = engine.simulateBlocks(\n  [\n    {\n      kind: 'ADD_BLOCK',\n      block: {\n        id: 'preview-1',\n        court: courtRef,\n        type: 'MAINTENANCE',\n        start: '2026-06-15T12:00:00',\n        end: '2026-06-15T13:00:00',\n      },\n    },\n  ],\n  '2026-06-15',\n);\n\nconsole.log('Preview rails:', preview.previewRails);\nconsole.log('Capacity impact:', preview.capacityImpact);\nconsole.log('Would cause conflicts:', preview.conflicts);\n"})}),"\n",(0,t.jsx)(n.p,{children:(0,t.jsxs)(n.strong,{children:[(0,t.jsx)(n.code,{children:"SimulationResult"}),":"]})}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-ts",children:"interface SimulationResult {\n  previewRails: VenueDayTimeline[];   // Full derived timeline with mutations applied\n  capacityImpact?: CapacityCurve;     // Capacity curve reflecting simulated state\n  conflicts: EngineConflict[];        // Conflicts the mutations would cause\n}\n"})}),"\n",(0,t.jsx)(n.hr,{}),"\n",(0,t.jsx)(n.h2,{id:"court-metadata",children:"Court Metadata"}),"\n",(0,t.jsx)(n.h3,{id:"listcourtmeta",children:"listCourtMeta"}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-ts",children:"listCourtMeta(): CourtMeta[]\n"})}),"\n",(0,t.jsx)(n.p,{children:"Returns metadata for all courts in the tournament record."}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-js",children:"const courts = engine.listCourtMeta();\nfor (const court of courts) {\n  console.log(`${court.name}: ${court.surface}, lights=${court.hasLights}`);\n}\n"})}),"\n",(0,t.jsx)(n.p,{children:(0,t.jsxs)(n.strong,{children:[(0,t.jsx)(n.code,{children:"CourtMeta"}),":"]})}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-ts",children:"interface CourtMeta {\n  ref: CourtRef;\n  name: string;\n  surface: string;\n  indoor: boolean;\n  hasLights: boolean;\n  tags: string[];\n  openTime?: string;\n  closeTime?: string;\n  closedDays?: string[];\n  extendedProps?: Record<string, any>;\n}\n"})}),"\n",(0,t.jsx)(n.hr,{}),"\n",(0,t.jsx)(n.h2,{id:"event-system",children:"Event System"}),"\n",(0,t.jsx)(n.h3,{id:"subscribe",children:"subscribe"}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-ts",children:"subscribe(listener: (event: EngineEvent) => void): () => void\n"})}),"\n",(0,t.jsx)(n.p,{children:"Subscribe to engine events. Returns an unsubscribe function."}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-js",children:"const unsubscribe = engine.subscribe((event) => {\n  if (event.type === 'BLOCKS_CHANGED') {\n    renderTimeline();\n  }\n});\n\n// Later: clean up\nunsubscribe();\n"})}),"\n",(0,t.jsxs)(n.p,{children:["See ",(0,t.jsx)(n.strong,{children:(0,t.jsx)(n.a,{href:"./event-system-and-validation",children:"Event System & Validation"})})," for full event type documentation."]}),"\n",(0,t.jsx)(n.hr,{}),"\n",(0,t.jsx)(n.h2,{id:"related-documentation",children:"Related Documentation"}),"\n",(0,t.jsxs)(n.ul,{children:["\n",(0,t.jsxs)(n.li,{children:[(0,t.jsx)(n.strong,{children:(0,t.jsx)(n.a,{href:"./temporal-engine-overview",children:"Overview"})})," \u2014 Introduction and architecture"]}),"\n",(0,t.jsxs)(n.li,{children:[(0,t.jsx)(n.strong,{children:(0,t.jsx)(n.a,{href:"./event-system-and-validation",children:"Event System & Validation"})})," \u2014 Events, conflict evaluators, and validation pipeline"]}),"\n",(0,t.jsxs)(n.li,{children:[(0,t.jsx)(n.strong,{children:(0,t.jsx)(n.a,{href:"./block-types-and-algorithms",children:"Block Types & Algorithms"})})," \u2014 Block types, rail derivation, capacity curves, collision detection"]}),"\n",(0,t.jsxs)(n.li,{children:[(0,t.jsx)(n.strong,{children:(0,t.jsx)(n.a,{href:"./ui-integration-scenarios",children:"UI Integration Scenarios"})})," \u2014 Building UIs with engine data"]}),"\n"]})]})}function u(e={}){const{wrapper:n}={...(0,i.R)(),...e.components};return n?(0,t.jsx)(n,{...e,children:(0,t.jsx)(o,{...e})}):o(e)}},8322(e,n,l){l.d(n,{R:()=>s,x:()=>r});var a=l(758);const t={},i=a.createContext(t);function s(e){const n=a.useContext(i);return a.useMemo(function(){return"function"==typeof e?e(n):{...n,...e}},[n,e])}function r(e){let n;return n=e.disableParentContext?"function"==typeof e.components?e.components(t):e.components||t:s(e.components),a.createElement(i.Provider,{value:n},e.children)}}}]);