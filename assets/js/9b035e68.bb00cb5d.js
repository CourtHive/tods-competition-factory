"use strict";(globalThis.webpackChunkdocumentation=globalThis.webpackChunkdocumentation||[]).push([[7765],{8322(e,n,i){i.d(n,{R:()=>a,x:()=>d});var r=i(758);const s={},t=r.createContext(s);function a(e){const n=r.useContext(t);return r.useMemo(function(){return"function"==typeof e?e(n):{...n,...e}},[n,e])}function d(e){let n;return n=e.disableParentContext?"function"==typeof e.components?e.components(s):e.components||s:a(e.components),r.createElement(t.Provider,{value:n},e.children)}},9323(e,n,i){i.r(n),i.d(n,{assets:()=>o,contentTitle:()=>d,default:()=>u,frontMatter:()=>a,metadata:()=>r,toc:()=>l});const r=JSON.parse('{"id":"governors/draws-governor","title":"Draws Governor","description":"addAdHocMatchUps","source":"@site/docs/governors/draws-governor.md","sourceDirName":"governors","slug":"/governors/draws-governor","permalink":"/competition-factory/docs/governors/draws-governor","draft":false,"unlisted":false,"tags":[],"version":"current","frontMatter":{"title":"Draws Governor"},"sidebar":"docs","previous":{"title":"Competition Governor","permalink":"/competition-factory/docs/governors/competition-governor"},"next":{"title":"Entries Governor","permalink":"/competition-factory/docs/governors/entries-governor"}}');var s=i(6070),t=i(8322);const a={title:"Draws Governor"},d=void 0,o={},l=[{value:"addAdHocMatchUps",id:"addadhocmatchups",level:2},{value:"addDrawDefinitionTimeItem",id:"adddrawdefinitiontimeitem",level:2},{value:"addFinishingRounds",id:"addfinishingrounds",level:2},{value:"addGoesTo",id:"addgoesto",level:2},{value:"adHocPositionSwap",id:"adhocpositionswap",level:2},{value:"addPlayoffStructures",id:"addplayoffstructures",level:2},{value:"addQualifyingStructure",id:"addqualifyingstructure",level:2},{value:"addVoluntaryConsolationStage",id:"addvoluntaryconsolationstage",level:2},{value:"addVoluntaryConsolationStructure",id:"addvoluntaryconsolationstructure",level:2},{value:"allPlayoffPositionsFilled",id:"allplayoffpositionsfilled",level:2},{value:"alternateDrawPositionAssignment",id:"alternatedrawpositionassignment",level:2},{value:"assignDrawPosition",id:"assigndrawposition",level:2},{value:"assignDrawPositionBye",id:"assigndrawpositionbye",level:2},{value:"attachQualifyingStructure",id:"attachqualifyingstructure",level:2},{value:"automatedPlayoffPositioning",id:"automatedplayoffpositioning",level:2},{value:"automatedPositioning",id:"automatedpositioning",level:2},{value:"autoSeeding",id:"autoseeding",level:2},{value:"checkValidEntries",id:"checkvalidentries",level:2},{value:"drawMatic",id:"drawmatic",level:2},{value:"generateAdHocMatchUps",id:"generateadhocmatchups",level:2},{value:"generateAdHocRounds",id:"generateadhocrounds",level:2},{value:"generateAndPopulatePlayoffStructures",id:"generateandpopulateplayoffstructures",level:2},{value:"generateDrawDefinition",id:"generatedrawdefinition",level:2},{value:"generateDrawMaticRound",id:"generatedrawmaticround",level:2},{value:"generateDrawStructuresAndLinks",id:"generatedrawstructuresandlinks",level:2},{value:"generateDrawTypeAndModifyDrawDefinition",id:"generatedrawtypeandmodifydrawdefinition",level:2},{value:"generateQualifyingStructure",id:"generatequalifyingstructure",level:2},{value:"generateVoluntaryConsolation",id:"generatevoluntaryconsolation",level:2},{value:"deleteAdHocMatchUps",id:"deleteadhocmatchups",level:2},{value:"luckyLoserDrawPositionAssignment",id:"luckyloserdrawpositionassignment",level:2},{value:"getAssignedParticipantIds",id:"getassignedparticipantids",level:2},{value:"getAvailableMatchUpsCount",id:"getavailablematchupscount",level:2},{value:"getAvailablePlayoffProfiles",id:"getavailableplayoffprofiles",level:2},{value:"getDrawDefinitionTimeItem",id:"getdrawdefinitiontimeitem",level:2},{value:"getDrawParticipantRepresentativeIds",id:"getdrawparticipantrepresentativeids",level:2},{value:"getDrawStructures",id:"getdrawstructures",level:2},{value:"getDrawTypeCoercion",id:"getdrawtypecoercion",level:2},{value:"getEligibleVoluntaryConsolationParticipants",id:"geteligiblevoluntaryconsolationparticipants",level:2},{value:"getMatchUpsMap",id:"getmatchupsmap",level:2},{value:"getParticipantIdFinishingPositions",id:"getparticipantidfinishingpositions",level:2},{value:"getPositionAssignments",id:"getpositionassignments",level:2},{value:"getPositionsPlayedOff",id:"getpositionsplayedoff",level:2},{value:"getRandomQualifierList",id:"getrandomqualifierlist",level:2},{value:"getSeedingThresholds",id:"getseedingthresholds",level:2},{value:"getSeedsCount",id:"getseedscount",level:2},{value:"getStructureSeedAssignments",id:"getstructureseedassignments",level:2},{value:"getTeamLineUp",id:"getteamlineup",level:2},{value:"getValidGroupSizes",id:"getvalidgroupsizes",level:2},{value:"isAdHoc",id:"isadhoc",level:2},{value:"isCompletedStructure",id:"iscompletedstructure",level:2},{value:"isValidForQualifying",id:"isvalidforqualifying",level:2},{value:"modifyDrawDefinition",id:"modifydrawdefinition",level:2},{value:"modifySeedAssignment",id:"modifyseedassignment",level:2},{value:"modifyDrawName",id:"modifydrawname",level:2},{value:"positionActions",id:"positionactions",level:2},{value:"pruneDrawDefinition",id:"prunedrawdefinition",level:2},{value:"publicFindDrawDefinition",id:"publicfinddrawdefinition",level:2},{value:"qualifierDrawPositionAssignment",id:"qualifierdrawpositionassignment",level:2},{value:"qualifierProgression",id:"qualifierprogression",level:2},{value:"removeDrawPositionAssignment",id:"removedrawpositionassignment",level:2},{value:"removeDrawEntries",id:"removedrawentries",level:2},{value:"removeRoundMatchUps",id:"removeroundmatchups",level:2},{value:"removeStructure",id:"removestructure",level:2},{value:"removeSeededParticipant",id:"removeseededparticipant",level:2},{value:"renameStructures",id:"renamestructures",level:2},{value:"resetDrawDefinition",id:"resetdrawdefinition",level:2},{value:"resetQualifyingStructure",id:"resetqualifyingstructure",level:2},{value:"resetVoluntaryConsolationStructure",id:"resetvoluntaryconsolationstructure",level:2},{value:"resetQualifyingStructure",id:"resetqualifyingstructure-1",level:2},{value:"setDrawParticipantRepresentativeIds",id:"setdrawparticipantrepresentativeids",level:2},{value:"setPositionAssignments",id:"setpositionassignments",level:2},{value:"setSubOrder",id:"setsuborder",level:2},{value:"setStructureOrder",id:"setstructureorder",level:2},{value:"shiftAdHocRounds",id:"shiftadhocrounds",level:2},{value:"swapAdHocRounds",id:"swapadhocrounds",level:2},{value:"swapDrawPositionAssignments",id:"swapdrawpositionassignments",level:2},{value:"updateTeamLineUp",id:"updateteamlineup",level:2},{value:"withdrawParticipantAtDrawPosition",id:"withdrawparticipantatdrawposition",level:2}];function c(e){const n={a:"a",admonition:"admonition",code:"code",h2:"h2",hr:"hr",p:"p",pre:"pre",strong:"strong",...(0,t.R)(),...e.components};return(0,s.jsxs)(s.Fragment,{children:[(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-js",children:"import { drawsGovernor } from 'tods-competition-factory';\n"})}),"\n",(0,s.jsx)(n.h2,{id:"addadhocmatchups",children:"addAdHocMatchUps"}),"\n",(0,s.jsxs)(n.p,{children:["Adds ",(0,s.jsx)(n.code,{children:"matchUps"})," generated by ",(0,s.jsx)(n.a,{href:"/docs/governors/generation-governor/#generateadhocmatchups",children:"generateAdHocMatchUps"})," to specified structure within an AD_HOC ",(0,s.jsx)(n.code,{children:"drawDefinition"}),"."]}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-js",children:"engine.addAdHocMatchUps({\n  structureId, // optional if there is only one structure in drawDefinition\n  matchUps,\n  drawId,\n});\n"})}),"\n",(0,s.jsx)(n.hr,{}),"\n",(0,s.jsx)(n.h2,{id:"adddrawdefinitiontimeitem",children:"addDrawDefinitionTimeItem"}),"\n",(0,s.jsx)(n.p,{children:"Adds a time item to a drawDefinition."}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-js",children:"engine.addDrawDefinitionTimeItem({\n  drawId, // required\n  timeItem, // required - time item object\n  itemType, // required - time item type\n});\n"})}),"\n",(0,s.jsxs)(n.p,{children:[(0,s.jsx)(n.strong,{children:"Purpose:"})," Attach time-based metadata to draws."]}),"\n",(0,s.jsx)(n.hr,{}),"\n",(0,s.jsx)(n.h2,{id:"addfinishingrounds",children:"addFinishingRounds"}),"\n",(0,s.jsx)(n.p,{children:"Adds finishing rounds to an existing structure for placement matchUps."}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-js",children:"engine.addFinishingRounds({\n  drawId, // required\n  structureId, // required\n  finishingPositions, // required - array of positions to play off\n});\n"})}),"\n",(0,s.jsxs)(n.p,{children:[(0,s.jsx)(n.strong,{children:"Purpose:"})," Add placement matchUps for specific finishing positions."]}),"\n",(0,s.jsx)(n.hr,{}),"\n",(0,s.jsx)(n.h2,{id:"addgoesto",children:"addGoesTo"}),"\n",(0,s.jsx)(n.p,{children:"Adds a link between structures indicating progression path."}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-js",children:"engine.addGoesTo({\n  drawId, // required\n  sourceStructureId, // required\n  targetStructureId, // required\n  roundNumber, // optional - specific round\n});\n"})}),"\n",(0,s.jsxs)(n.p,{children:[(0,s.jsx)(n.strong,{children:"Purpose:"})," Define progression paths between structures."]}),"\n",(0,s.jsx)(n.hr,{}),"\n",(0,s.jsx)(n.h2,{id:"adhocpositionswap",children:"adHocPositionSwap"}),"\n",(0,s.jsxs)(n.p,{children:["Swaps ",(0,s.jsx)(n.code,{children:"participant"})," assignments in two unscored ",(0,s.jsx)(n.code,{children:"matchUps"})," that are part of the same ",(0,s.jsx)(n.code,{children:"roundNumber"})," in and AD_HOC ",(0,s.jsx)(n.code,{children:"structure"}),".\nThis method and one of the two ",(0,s.jsx)(n.code,{children:"participantIds"})," are returned in ",(0,s.jsx)(n.code,{children:"validActions"})," by ",(0,s.jsx)(n.code,{children:"positionActions"})," which calls ",(0,s.jsx)(n.code,{children:"adHocMatchUpActions"}),", meaning this method is not normally called directly."]}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-js",children:"engine.adHocPositionSwap({\n  participantIds,\n  structureId,\n  roundNumber,\n  drawId,\n});\n"})}),"\n",(0,s.jsx)(n.hr,{}),"\n",(0,s.jsx)(n.h2,{id:"addplayoffstructures",children:"addPlayoffStructures"}),"\n",(0,s.jsx)(n.p,{children:"Adds playoff structures to an existing drawDefinition."}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-js",children:"engine.addPlayoffStructures({\n  drawId,\n  structureId,\n  roundNumbers: [3], // required if no playoffPositions - source roundNumbers which will feed target structures, e.g. [1, 2]\n  roundProfiles, // optional - source roundNumbers as Object.keys with depth as Object.values, e.g. [{ 1: 2}, {2: 1}]\n  playoffPositions: [3, 4], // required if not provided roundNumbers\n  playoffAttributes, // optional - mapping of either exitProfile or finishingPositionRange to structure names, e.g. 0-1-1 for South\n  exitProfileLimit, // limit playoff rounds generated by the attributes present in playoffAttributes\n  playoffStructureNameBase, // optional - base word for default playoff naming, e.g. 'Playoff'\n});\n\n// example use of playoffAttributes - will generated playoff structure from 2nd round with structureName: 'BRONZE'\nconst playoffAttributes = {\n  '0-2': { name: 'BRONZE', abbreviation: 'B' },\n};\n"})}),"\n",(0,s.jsx)(n.hr,{}),"\n",(0,s.jsx)(n.h2,{id:"addqualifyingstructure",children:"addQualifyingStructure"}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-js",children:"engine.addQualifyingStructure({\n  targetStructureId, // required: structure for which participants will qualify\n  qualifyingPositions, // optional: specify the # of qualifyingPositions\n  qualifyingRoundNumber, // optional: determine qualifyingPositions by # of matchUps in specified round; does not apply to ROUND_ROBIN\n  structureOptions, // optional: specific to ROUND_ROBIN generation\n  structureName, // optional\n  drawSize,\n  drawType, // optional: defaults to SINGLE_ELIMINATION\n  drawId, // required: draw within which target structure appears\n});\n"})}),"\n",(0,s.jsx)(n.hr,{}),"\n",(0,s.jsx)(n.h2,{id:"addvoluntaryconsolationstage",children:"addVoluntaryConsolationStage"}),"\n",(0,s.jsxs)(n.p,{children:["Modifies the entryProfile for a draw to allow ",(0,s.jsx)(n.code,{children:"{ entryStage: VOLUNTARY_CONSOLATION }"})]}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-js",children:"engine.addVoluntaryConsolationStage({\n  drawSize,\n  drawId,\n});\n"})}),"\n",(0,s.jsx)(n.hr,{}),"\n",(0,s.jsx)(n.h2,{id:"addvoluntaryconsolationstructure",children:"addVoluntaryConsolationStructure"}),"\n",(0,s.jsxs)(n.p,{children:["Generates a new structure within a ",(0,s.jsx)(n.code,{children:"drawDefinition"})," if any draw entries are present for ",(0,s.jsx)(n.code,{children:"{ entryStage: VOLUNTARY_CONSOLATION }"}),"."]}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-js",children:"engine.addVoluntaryConsolationStructure({\n  structureAbbreviation, // optional\n  structureName, // optional - defaults to 'VOLUNTARY_CONSOLATION'\n  drawId,\n});\n"})}),"\n",(0,s.jsx)(n.hr,{}),"\n",(0,s.jsx)(n.h2,{id:"allplayoffpositionsfilled",children:"allPlayoffPositionsFilled"}),"\n",(0,s.jsx)(n.p,{children:"Checks if all playoff positions for a structure have been filled."}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-js",children:"const { allFilled } = engine.allPlayoffPositionsFilled({\n  drawId, // required\n  structureId, // required\n});\n"})}),"\n",(0,s.jsxs)(n.p,{children:[(0,s.jsx)(n.strong,{children:"Returns:"})," Boolean indicating if all playoff positions are assigned."]}),"\n",(0,s.jsx)(n.hr,{}),"\n",(0,s.jsx)(n.h2,{id:"alternatedrawpositionassignment",children:"alternateDrawPositionAssignment"}),"\n",(0,s.jsxs)(n.p,{children:["Replaces an existing drawPosition assignment with an alternateParticipantId. This method is included in ",(0,s.jsx)(n.code,{children:"validActions"})," for ",(0,s.jsx)(n.a,{href:"../policies/positionActions",children:"positionActions"})]}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-js",children:"engine.alternateDrawPositionAssignment({\n  alternateParticipantId,\n  drawPosition,\n  structureId,\n  drawId,\n});\n"})}),"\n",(0,s.jsx)(n.hr,{}),"\n",(0,s.jsx)(n.h2,{id:"assigndrawposition",children:"assignDrawPosition"}),"\n",(0,s.jsx)(n.p,{children:"Low level function normally called by higher order convenience functions."}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-js",children:"engine.assignDrawPosition({\n  participantId, // optional - if assigning position to a participant\n  drawPosition,\n  structureId,\n  qualifier, // optional boolean, if assigning a space for a qualifier\n  drawId,\n  bye, // optional boolean, if assigning a bye\n});\n"})}),"\n",(0,s.jsx)(n.hr,{}),"\n",(0,s.jsx)(n.h2,{id:"assigndrawpositionbye",children:"assignDrawPositionBye"}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-js",children:"engine.assignDrawPositionBye({\n  structureId,\n  drawId,\n});\n"})}),"\n",(0,s.jsx)(n.hr,{}),"\n",(0,s.jsx)(n.h2,{id:"attachqualifyingstructure",children:"attachQualifyingStructure"}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-js",children:"engine.attachQualifyingStructure({\n  structure, // required: structure object; see `generateQualifyingStructure`\n  drawId, // required: id of drawDedfinition to which structure will be attached\n  link, // required\n});\n"})}),"\n",(0,s.jsx)(n.hr,{}),"\n",(0,s.jsx)(n.h2,{id:"automatedplayoffpositioning",children:"automatedPlayoffPositioning"}),"\n",(0,s.jsx)(n.p,{children:"For Round Robin structures, uses Round Robin Tallies to position participants in playoff structure(s)."}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-js",children:"engine.automatedPlayoffPositioning({\n  structureId: mainStructure.structureId,\n  provisionalPositioning, // optional boolean, defaults to false; when true will honor provisionalOrder if no groupOrder is found in tallyResults\n  applyPositioning, // optional boolean, defaults to true; when false will return positioning but not apply it to playoff structures\n  drawId,\n});\n"})}),"\n",(0,s.jsx)(n.hr,{}),"\n",(0,s.jsx)(n.h2,{id:"automatedpositioning",children:"automatedPositioning"}),"\n",(0,s.jsxs)(n.p,{children:["Positions participants in a draw structure. See examples: ",(0,s.jsx)(n.a,{href:"/competition-factory/docs/engines/engine-middleware#draw-operations",children:"Draw Operations"}),", ",(0,s.jsx)(n.a,{href:"/competition-factory/docs/engines/mutation-engines#basic-rollback",children:"Basic Rollback"}),"."]}),"\n",(0,s.jsxs)(n.p,{children:["See ",(0,s.jsx)(n.a,{href:"../concepts/policies",children:"Policies"}),"."]}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-js",children:"engine.automatedPositioning({ drawId, structureId });\n"})}),"\n",(0,s.jsx)(n.hr,{}),"\n",(0,s.jsx)(n.h2,{id:"autoseeding",children:"autoSeeding"}),"\n",(0,s.jsxs)(n.admonition,{type:"note",children:[(0,s.jsxs)(n.p,{children:["Only generates seeding. To apply ",(0,s.jsx)(n.code,{children:"engine.setParticipantScaleItems({ scaleItemsWithParticipantIds }"}),".\n:::. See examples: ",(0,s.jsx)(n.a,{href:"/competition-factory/docs/concepts/scaleItems#using-factory-autoseeding",children:"Using Factory autoSeeding()"}),", ",(0,s.jsx)(n.a,{href:"/competition-factory/docs/concepts/scaleItems#seeding-from-rankings",children:"Seeding from Rankings"}),", ",(0,s.jsx)(n.a,{href:"/competition-factory/docs/concepts/scaleItems#event-type-alignment",children:"Event Type Alignment"}),"."]}),(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-js",children:"const { scaleItemsWithParticipantIds } = engine.autoSeeding({\n  policyDefinitions, // seeding policyDefinition determines the # of seeds for given participantsCount/drawSize\n  scaleAttributes, // { scaleType, scaleName, eventType, accessor }\n  scaleName, // Optional - defaults to scaleAttributes.scaleName\n  drawSize, // Optional - defaults to calculation based on # of entries\n  eventId, // required - necessary for resolving entries\n  drawId, // Optional - will use flight.drawEntries or drawDefinition.entries rather than event.entries\n  stage, // Optional - filters entries by specified stage\n\n  scaleSortMethod, // Optional - user defined sorting method\n  sortDescending, // Optional - defaults to false\n});\n\nengine.setParticipantScaleItems({\n  scaleItemsWithParticipantIds,\n});\n"})}),(0,s.jsx)(n.hr,{}),(0,s.jsx)(n.h2,{id:"checkvalidentries",children:"checkValidEntries"}),(0,s.jsx)(n.p,{children:"Validates that entries are eligible for a draw based on event category constraints."}),(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-js",children:"const { valid, errors } = engine.checkValidEntries({\n  eventId, // required\n  drawId, // optional\n  entries, // optional - validate specific entries\n});\n"})}),(0,s.jsxs)(n.p,{children:[(0,s.jsx)(n.strong,{children:"Purpose:"})," Validate entry eligibility before draw generation."]}),(0,s.jsx)(n.hr,{}),(0,s.jsx)(n.h2,{id:"drawmatic",children:"drawMatic"}),(0,s.jsx)(n.p,{children:"Automated draw positioning system that intelligently assigns participants to draw positions based on seeding, geographic distribution, and conflict avoidance policies."}),(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-js",children:"const result = engine.drawMatic({\n  drawId, // required\n  structureId, // optional - specific structure\n  policyDefinitions, // optional - positioning policies\n  useExistingAdjustments, // optional boolean - preserve manual adjustments\n  participants, // optional - override participant data\n});\n"})}),(0,s.jsxs)(n.p,{children:[(0,s.jsx)(n.strong,{children:"Purpose:"})," AI-driven draw positioning for optimal tournament structure."]}),(0,s.jsx)(n.hr,{}),(0,s.jsx)(n.h2,{id:"generateadhocmatchups",children:"generateAdHocMatchUps"}),(0,s.jsx)(n.p,{children:"Generates adhoc matchUps for custom tournament structures."}),(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-js",children:"const { matchUps } = engine.generateAdHocMatchUps({\n  participants, // required - array of participant IDs\n  matchUpsPerFlight, // optional - matchUps per round\n  uuids, // optional - specific matchUp IDs\n});\n"})}),(0,s.jsxs)(n.p,{children:[(0,s.jsx)(n.strong,{children:"Purpose:"})," Create custom matchUp structures outside standard draw types."]}),(0,s.jsx)(n.hr,{}),(0,s.jsx)(n.h2,{id:"generateadhocrounds",children:"generateAdHocRounds"}),(0,s.jsx)(n.p,{children:"Generates multiple rounds of adhoc matchUps."}),(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-js",children:"const { rounds } = engine.generateAdHocRounds({\n  participants, // required\n  roundsCount, // required - number of rounds\n});\n"})}),(0,s.jsxs)(n.p,{children:[(0,s.jsx)(n.strong,{children:"Purpose:"})," Create multi-round custom structures."]}),(0,s.jsx)(n.hr,{}),(0,s.jsx)(n.h2,{id:"generateandpopulateplayoffstructures",children:"generateAndPopulatePlayoffStructures"}),(0,s.jsx)(n.p,{children:"Generates and automatically populates playoff structures in one operation."}),(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-js",children:"engine.generateAndPopulatePlayoffStructures({\n  drawId, // required\n  structureId, // required\n  roundNumbers, // required - source rounds for playoffs\n  playoffAttributes, // optional\n});\n"})}),(0,s.jsxs)(n.p,{children:[(0,s.jsx)(n.strong,{children:"Purpose:"})," Automate playoff structure creation and population."]}),(0,s.jsx)(n.hr,{}),(0,s.jsx)(n.h2,{id:"generatedrawdefinition",children:"generateDrawDefinition"}),(0,s.jsx)(n.p,{children:"Generates a complete draw definition from parameters."}),(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-js",children:"const { drawDefinition } = engine.generateDrawDefinition({\n  drawSize, // required\n  drawType, // required - SINGLE_ELIMINATION, etc.\n  seedsCount, // optional\n  drawName, // optional\n  entries, // optional\n  matchUpFormat, // optional\n  automated, // optional boolean - auto-position participants\n});\n"})}),(0,s.jsxs)(n.p,{children:[(0,s.jsx)(n.strong,{children:"Purpose:"})," Core draw generation method."]}),(0,s.jsx)(n.hr,{}),(0,s.jsx)(n.h2,{id:"generatedrawmaticround",children:"generateDrawMaticRound"}),(0,s.jsx)(n.p,{children:"Generates positioning for a specific round using drawMatic algorithm."}),(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-js",children:"engine.generateDrawMaticRound({\n  drawId, // required\n  structureId, // required\n  roundNumber, // required\n  policyDefinitions, // optional\n});\n"})}),(0,s.jsxs)(n.p,{children:[(0,s.jsx)(n.strong,{children:"Purpose:"})," AI positioning for specific draw rounds."]}),(0,s.jsx)(n.hr,{}),(0,s.jsx)(n.h2,{id:"generatedrawstructuresandlinks",children:"generateDrawStructuresAndLinks"}),(0,s.jsx)(n.p,{children:"Generates multiple structures with linking for complex draw formats."}),(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-js",children:"const { structures, links } = engine.generateDrawStructuresAndLinks({\n  structuresCount, // required\n  drawType, // required\n  drawSize, // required\n  stageSequence, // optional\n});\n"})}),(0,s.jsxs)(n.p,{children:[(0,s.jsx)(n.strong,{children:"Purpose:"})," Create multi-structure draws with automatic linking."]}),(0,s.jsx)(n.hr,{}),(0,s.jsx)(n.h2,{id:"generatedrawtypeandmodifydrawdefinition",children:"generateDrawTypeAndModifyDrawDefinition"}),(0,s.jsx)(n.p,{children:"Modifies an existing draw to change its type/structure."}),(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-js",children:"engine.generateDrawTypeAndModifyDrawDefinition({\n  drawId, // required\n  drawType, // required - new draw type\n  drawSize, // optional\n});\n"})}),(0,s.jsxs)(n.p,{children:[(0,s.jsx)(n.strong,{children:"Purpose:"})," Convert draw to different format."]}),(0,s.jsx)(n.hr,{}),(0,s.jsx)(n.h2,{id:"generatequalifyingstructure",children:"generateQualifyingStructure"}),(0,s.jsx)(n.p,{children:"Generates a qualifying structure for a main draw."}),(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-js",children:"const { structure } = engine.generateQualifyingStructure({\n  drawSize, // required\n  qualifyingPositions, // required\n  structureName, // optional\n});\n"})}),(0,s.jsxs)(n.p,{children:[(0,s.jsx)(n.strong,{children:"Purpose:"})," Create qualifying rounds for tournaments."]}),(0,s.jsx)(n.hr,{}),(0,s.jsx)(n.h2,{id:"generatevoluntaryconsolation",children:"generateVoluntaryConsolation"}),(0,s.jsx)(n.p,{children:"Generates a voluntary consolation draw structure."}),(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-js",children:"const { structure } = engine.generateVoluntaryConsolation({\n  drawId, // required\n  drawSize, // required\n  structureName, // optional\n});\n"})}),(0,s.jsxs)(n.p,{children:[(0,s.jsx)(n.strong,{children:"Purpose:"})," Create consolation draws for eliminated players."]}),(0,s.jsx)(n.hr,{}),(0,s.jsx)(n.h2,{id:"deleteadhocmatchups",children:"deleteAdHocMatchUps"}),(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-js",children:"const result = engine.deleteAdHocMatchUps({\n  structureId, // optional optimization - structureId of structure from which matchUps are being deleted\n  matchUpIds, // array of matchUpIds identifying matchUps to be deleted\n  drawId, // required - drawId of drawDefinition in which target structure is found\n});\n"})}),(0,s.jsx)(n.hr,{}),(0,s.jsx)(n.h2,{id:"luckyloserdrawpositionassignment",children:"luckyLoserDrawPositionAssignment"}),(0,s.jsxs)(n.p,{children:["Replaces an existing drawPosition assignment with a luckyLoserParticipantId. This method is included in ",(0,s.jsx)(n.code,{children:"validActions"})," for ",(0,s.jsx)(n.a,{href:"../policies/positionActions",children:"positionActions"})]}),(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-js",children:"engine.luckyLoserDrawPositionAssignment({\n  luckyLoserParticipantId,\n  drawPosition,\n  structureId,\n  drawId,\n});\n"})}),(0,s.jsx)(n.hr,{}),(0,s.jsx)(n.h2,{id:"getassignedparticipantids",children:"getAssignedParticipantIds"}),(0,s.jsx)(n.p,{children:"Returns all participant IDs assigned to positions in a draw."}),(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-js",children:"const { participantIds } = engine.getAssignedParticipantIds({\n  drawId, // required\n  structureId, // optional - specific structure\n});\n"})}),(0,s.jsxs)(n.p,{children:[(0,s.jsx)(n.strong,{children:"Purpose:"})," Get all participants currently in draw."]}),(0,s.jsx)(n.hr,{}),(0,s.jsx)(n.h2,{id:"getavailablematchupscount",children:"getAvailableMatchUpsCount"}),(0,s.jsx)(n.p,{children:"Returns count of available matchUps that can be scheduled."}),(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-js",children:"const { count } = engine.getAvailableMatchUpsCount({\n  drawId, // required\n});\n"})}),(0,s.jsxs)(n.p,{children:[(0,s.jsx)(n.strong,{children:"Purpose:"})," Determine scheduling capacity."]}),(0,s.jsx)(n.hr,{}),(0,s.jsx)(n.h2,{id:"getavailableplayoffprofiles",children:"getAvailablePlayoffProfiles"}),(0,s.jsx)(n.p,{children:"Returns available playoff configurations based on draw structure."}),(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-js",children:"const { profiles } = engine.getAvailablePlayoffProfiles({\n  drawId, // required\n  structureId, // required\n});\n"})}),(0,s.jsxs)(n.p,{children:[(0,s.jsx)(n.strong,{children:"Purpose:"})," Get playoff options for structure."]}),(0,s.jsx)(n.hr,{}),(0,s.jsx)(n.h2,{id:"getdrawdefinitiontimeitem",children:"getDrawDefinitionTimeItem"}),(0,s.jsx)(n.p,{children:"Returns time items attached to a draw definition."}),(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-js",children:"const { timeItem } = engine.getDrawDefinitionTimeItem({\n  drawId, // required\n  itemType, // required - time item type\n});\n"})}),(0,s.jsxs)(n.p,{children:[(0,s.jsx)(n.strong,{children:"Purpose:"})," Query draw-level time metadata."]}),(0,s.jsx)(n.hr,{}),(0,s.jsx)(n.h2,{id:"getdrawparticipantrepresentativeids",children:"getDrawParticipantRepresentativeIds"}),(0,s.jsx)(n.p,{children:"Returns representative participant IDs for team draws."}),(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-js",children:"const { representativeIds } = engine.getDrawParticipantRepresentativeIds({\n  drawId, // required\n  participantId, // required\n});\n"})}),(0,s.jsxs)(n.p,{children:[(0,s.jsx)(n.strong,{children:"Purpose:"})," Get team representatives in team competitions."]}),(0,s.jsx)(n.hr,{}),(0,s.jsx)(n.h2,{id:"getdrawstructures",children:"getDrawStructures"}),(0,s.jsx)(n.p,{children:"Returns all structures in a draw."}),(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-js",children:"const { structures } = engine.getDrawStructures({\n  drawId, // required\n  stage, // optional - filter by stage\n});\n"})}),(0,s.jsxs)(n.p,{children:[(0,s.jsx)(n.strong,{children:"Purpose:"})," Get draw structure details."]}),(0,s.jsx)(n.hr,{}),(0,s.jsx)(n.h2,{id:"getdrawtypecoercion",children:"getDrawTypeCoercion"}),(0,s.jsx)(n.p,{children:"Determines if a draw type can be coerced to another type."}),(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-js",children:"const { valid, targetDrawType } = engine.getDrawTypeCoercion({\n  drawId, // required\n  drawSize, // required\n});\n"})}),(0,s.jsxs)(n.p,{children:[(0,s.jsx)(n.strong,{children:"Purpose:"})," Validate draw type conversions."]}),(0,s.jsx)(n.hr,{}),(0,s.jsx)(n.h2,{id:"geteligiblevoluntaryconsolationparticipants",children:"getEligibleVoluntaryConsolationParticipants"}),(0,s.jsx)(n.p,{children:"Returns participants eligible for voluntary consolation."}),(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-js",children:"const { participants } = engine.getEligibleVoluntaryConsolationParticipants({\n  drawId, // required\n});\n"})}),(0,s.jsxs)(n.p,{children:[(0,s.jsx)(n.strong,{children:"Purpose:"})," Find participants for consolation draws."]}),(0,s.jsx)(n.hr,{}),(0,s.jsx)(n.h2,{id:"getmatchupsmap",children:"getMatchUpsMap"}),(0,s.jsx)(n.p,{children:"Returns a map of matchUps indexed by matchUpId."}),(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-js",children:"const { matchUpsMap } = engine.getMatchUpsMap({\n  drawId, // required\n});\n"})}),(0,s.jsxs)(n.p,{children:[(0,s.jsx)(n.strong,{children:"Purpose:"})," Quick matchUp lookup by ID."]}),(0,s.jsx)(n.hr,{}),(0,s.jsx)(n.h2,{id:"getparticipantidfinishingpositions",children:"getParticipantIdFinishingPositions"}),(0,s.jsx)(n.p,{children:"Returns finishing positions for all participants in draw."}),(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-js",children:"const { participantResults } = engine.getParticipantIdFinishingPositions({\n  drawId, // required\n});\n"})}),(0,s.jsxs)(n.p,{children:[(0,s.jsx)(n.strong,{children:"Purpose:"})," Get final standings from draw."]}),(0,s.jsx)(n.hr,{}),(0,s.jsx)(n.h2,{id:"getpositionassignments",children:"getPositionAssignments"}),(0,s.jsx)(n.p,{children:"Returns position assignments for a structure."}),(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-js",children:"const { positionAssignments } = engine.getPositionAssignments({\n  drawId, // required\n  structureId, // required\n});\n"})}),(0,s.jsxs)(n.p,{children:[(0,s.jsx)(n.strong,{children:"Purpose:"})," Get participant-to-position mappings."]}),(0,s.jsx)(n.hr,{}),(0,s.jsx)(n.h2,{id:"getpositionsplayedoff",children:"getPositionsPlayedOff"}),(0,s.jsx)(n.p,{children:"Returns positions that have playoff matchUps."}),(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-js",children:"const { positions } = engine.getPositionsPlayedOff({\n  drawId, // required\n  structureId, // required\n});\n"})}),(0,s.jsxs)(n.p,{children:[(0,s.jsx)(n.strong,{children:"Purpose:"})," Identify playoff positions in structure."]}),(0,s.jsx)(n.hr,{}),(0,s.jsx)(n.h2,{id:"getrandomqualifierlist",children:"getRandomQualifierList"}),(0,s.jsx)(n.p,{children:"Generates randomized list of qualifiers."}),(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-js",children:"const { qualifiers } = engine.getRandomQualifierList({\n  qualifyingCount, // required\n  participantIds, // required\n});\n"})}),(0,s.jsxs)(n.p,{children:[(0,s.jsx)(n.strong,{children:"Purpose:"})," Random selection for qualifying positions."]}),(0,s.jsx)(n.hr,{}),(0,s.jsx)(n.h2,{id:"getseedingthresholds",children:"getSeedingThresholds"}),(0,s.jsx)(n.p,{children:"Returns seeding threshold values based on draw size."}),(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-js",children:"const { thresholds } = engine.getSeedingThresholds({\n  drawSize, // required\n  policyDefinitions, // optional\n});\n"})}),(0,s.jsxs)(n.p,{children:[(0,s.jsx)(n.strong,{children:"Purpose:"})," Determine valid seed counts for draw."]}),(0,s.jsx)(n.hr,{}),(0,s.jsx)(n.h2,{id:"getseedscount",children:"getSeedsCount"}),(0,s.jsx)(n.p,{children:"Returns the number of seeds for a draw."}),(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-js",children:"const { seedsCount } = engine.getSeedsCount({\n  drawId, // required\n  policyDefinitions, // optional\n});\n"})}),(0,s.jsxs)(n.p,{children:[(0,s.jsx)(n.strong,{children:"Purpose:"})," Get seed count from draw or policy."]}),(0,s.jsx)(n.hr,{}),(0,s.jsx)(n.h2,{id:"getstructureseedassignments",children:"getStructureSeedAssignments"}),(0,s.jsx)(n.p,{children:"Returns seed assignments for a structure."}),(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-js",children:"const { seedAssignments } = engine.getStructureSeedAssignments({\n  drawId, // required\n  structureId, // required\n});\n"})}),(0,s.jsxs)(n.p,{children:[(0,s.jsx)(n.strong,{children:"Purpose:"})," Get seeding information for structure."]}),(0,s.jsx)(n.hr,{}),(0,s.jsx)(n.h2,{id:"getteamlineup",children:"getTeamLineUp"}),(0,s.jsx)(n.p,{children:"Returns the lineup for a team matchUp."}),(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-js",children:"const { lineup } = engine.getTeamLineUp({\n  drawId, // required\n  matchUpId, // required\n});\n"})}),(0,s.jsxs)(n.p,{children:[(0,s.jsx)(n.strong,{children:"Purpose:"})," Get team member assignments for matchUp."]}),(0,s.jsx)(n.hr,{}),(0,s.jsx)(n.h2,{id:"getvalidgroupsizes",children:"getValidGroupSizes"}),(0,s.jsx)(n.p,{children:"Returns valid group size options for round robin draws."}),(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-js",children:"const { groupSizes } = engine.getValidGroupSizes({\n  drawSize, // required\n});\n"})}),(0,s.jsxs)(n.p,{children:[(0,s.jsx)(n.strong,{children:"Purpose:"})," Determine valid round robin configurations."]}),(0,s.jsx)(n.hr,{}),(0,s.jsx)(n.h2,{id:"isadhoc",children:"isAdHoc"}),(0,s.jsx)(n.p,{children:"Checks if a structure is adhoc format."}),(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-js",children:"const { isAdHoc } = engine.isAdHoc({\n  drawId, // required\n  structureId, // required\n});\n"})}),(0,s.jsxs)(n.p,{children:[(0,s.jsx)(n.strong,{children:"Returns:"})," Boolean indicating adhoc structure."]}),(0,s.jsx)(n.hr,{}),(0,s.jsx)(n.h2,{id:"iscompletedstructure",children:"isCompletedStructure"}),(0,s.jsx)(n.p,{children:"Checks if a structure has all matchUps completed."}),(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-js",children:"const { isCompleted } = engine.isCompletedStructure({\n  drawId, // required\n  structureId, // required\n});\n"})}),(0,s.jsxs)(n.p,{children:[(0,s.jsx)(n.strong,{children:"Returns:"})," Boolean indicating structure completion."]}),(0,s.jsx)(n.hr,{}),(0,s.jsx)(n.h2,{id:"isvalidforqualifying",children:"isValidForQualifying"}),(0,s.jsx)(n.p,{children:"Checks if a structure can have qualifying added."}),(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-js",children:"const { valid } = engine.isValidForQualifying({\n  drawId, // required\n  structureId, // required\n});\n"})}),(0,s.jsxs)(n.p,{children:[(0,s.jsx)(n.strong,{children:"Purpose:"})," Validate qualifying structure eligibility."]}),(0,s.jsx)(n.hr,{}),(0,s.jsx)(n.h2,{id:"modifydrawdefinition",children:"modifyDrawDefinition"}),(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-js",children:"engine.modifyDrawDefinition({\n  drawUpdates: { policyDefinitions: { ...policies } },\n  drawName: 'League Play',\n  drawId,\n});\n"})}),(0,s.jsx)(n.hr,{}),(0,s.jsx)(n.h2,{id:"modifyseedassignment",children:"modifySeedAssignment"}),(0,s.jsxs)(n.p,{children:["Change the display representation of a seedNumber for a specified ",(0,s.jsx)(n.code,{children:"participantId"}),". This method is included in ",(0,s.jsx)(n.code,{children:"validActions"})," for ",(0,s.jsx)(n.a,{href:"../policies/positionActions",children:"positionActions"}),"."]}),(0,s.jsxs)(n.p,{children:["The rationale for ",(0,s.jsx)(n.code,{children:"seedValue"})," is to be able to, for instance, represent the fifth through the eighth seed as ",(0,s.jsx)(n.code,{children:"5-8"}),", or simply as ",(0,s.jsx)(n.code,{children:"5"}),". When there are no restrictions on seed positioning ",(0,s.jsx)(n.code,{children:"seedValue"})," allows assigning seeding to arbitrary ",(0,s.jsx)(n.code,{children:"participants"}),"."]}),(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-js",children:"engine.modifySeedAssignment({\n  participantId,\n  structureId,\n  seedValue, // display representation such as '5-8'\n  drawId,\n});\n"})}),(0,s.jsx)(n.hr,{}),(0,s.jsx)(n.h2,{id:"modifydrawname",children:"modifyDrawName"}),(0,s.jsx)(n.p,{children:"Changes the name of a draw."}),(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-js",children:"engine.modifyDrawName({\n  drawId, // required\n  drawName, // required - new name\n});\n"})}),(0,s.jsxs)(n.p,{children:[(0,s.jsx)(n.strong,{children:"Purpose:"})," Update draw display name."]}),(0,s.jsx)(n.hr,{}),(0,s.jsx)(n.h2,{id:"positionactions",children:"positionActions"}),(0,s.jsx)(n.p,{children:"Returns available positioning actions for a draw position."}),(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-js",children:"const { validActions } = engine.positionActions({\n  drawId, // required\n  structureId, // required\n  drawPosition, // required\n  policyDefinitions, // optional\n});\n"})}),(0,s.jsxs)(n.p,{children:[(0,s.jsx)(n.strong,{children:"Purpose:"})," Get valid participant assignment operations."]}),(0,s.jsx)(n.hr,{}),(0,s.jsx)(n.h2,{id:"prunedrawdefinition",children:"pruneDrawDefinition"}),(0,s.jsx)(n.p,{children:"Removes empty or unused structures from a draw."}),(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-js",children:"engine.pruneDrawDefinition({\n  drawId, // required\n});\n"})}),(0,s.jsxs)(n.p,{children:[(0,s.jsx)(n.strong,{children:"Purpose:"})," Clean up draw by removing unused structures."]}),(0,s.jsx)(n.hr,{}),(0,s.jsx)(n.h2,{id:"publicfinddrawdefinition",children:"publicFindDrawDefinition"}),(0,s.jsx)(n.p,{children:"Finds a draw definition with privacy policies applied."}),(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-js",children:"const { drawDefinition } = engine.publicFindDrawDefinition({\n  drawId, // required\n  policyDefinitions, // optional\n});\n"})}),(0,s.jsxs)(n.p,{children:[(0,s.jsx)(n.strong,{children:"Purpose:"})," Get draw data for public APIs."]}),(0,s.jsx)(n.hr,{}),(0,s.jsx)(n.h2,{id:"qualifierdrawpositionassignment",children:"qualifierDrawPositionAssignment"}),(0,s.jsxs)(n.p,{children:["Replaces an existing drawPosition assignment with a qualifierParticipantId. This method is included in ",(0,s.jsx)(n.code,{children:"validActions"})," for ",(0,s.jsx)(n.a,{href:"../policies/positionActions",children:"positionActions"})]}),(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-js",children:"engine.qualifierDrawPositionAssignment({\n  qualifierParticipantId,\n  drawPosition,\n  structureId,\n  drawId,\n});\n"})}),(0,s.jsx)(n.hr,{}),(0,s.jsx)(n.h2,{id:"qualifierprogression",children:"qualifierProgression"}),(0,s.jsx)(n.p,{children:"Handles progression of qualifiers from qualifying to main draw."}),(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-js",children:"engine.qualifierProgression({\n  drawId, // required\n  structureId, // optional - target structure\n});\n"})}),(0,s.jsxs)(n.p,{children:[(0,s.jsx)(n.strong,{children:"Purpose:"})," Move qualifiers to main draw after qualifying completes."]}),(0,s.jsx)(n.hr,{}),(0,s.jsx)(n.h2,{id:"removedrawpositionassignment",children:"removeDrawPositionAssignment"}),(0,s.jsx)(n.p,{children:"Clear draw position and optionally replace with a BYE, change entryStatus, or decompose a PAIR participant into UNGROUPED participants (DOUBLES only)."}),(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-js",children:"engine.removeDrawPositionAssignment({\n  drawDefinition,\n  structureId,\n  drawPosition,\n  replaceWithBye, // optional\n  entryStatus, // optional - change the entryStatus of the removed participant\n  destroyPair, // optional - decompose PAIR participant into UNGROUPED participants\n});\n"})}),(0,s.jsx)(n.hr,{}),(0,s.jsx)(n.h2,{id:"removedrawentries",children:"removeDrawEntries"}),(0,s.jsxs)(n.p,{children:["Removes participantIds from ",(0,s.jsx)(n.code,{children:"drawDefinition.entries"})," (if generated) as well as any relevent ",(0,s.jsx)(n.code,{children:"flightProfile.flights"}),"."]}),(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-js",children:"engine.removeDrawEntries({\n  autoEntryPositions, // optional - keeps entries ordered by entryStage/entryStatus and auto-increments\n  participantIds\n  eventId,\n  stages, // optional array of stages to consider, e.g. [VOLUNTARY_CONSOLATION]\n  drawId,\n  });\n"})}),(0,s.jsx)(n.hr,{}),(0,s.jsx)(n.h2,{id:"removeroundmatchups",children:"removeRoundMatchUps"}),(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-js",children:"const {\n  deltedMatchUpsCount, // number\n  roundRemoved, // boolean\n  success, // boolean\n  error, // if any\n} = engine.removeRoundMatchUps({\n  removeCompletedMatchUps, // optional boolean - whether to remove completed matchUps\n  roundNumber, // required - roundNumber to remove\n  structureId, // required\n  drawId, // required\n});\n"})}),(0,s.jsx)(n.hr,{}),(0,s.jsx)(n.h2,{id:"removestructure",children:"removeStructure"}),(0,s.jsxs)(n.p,{children:["Removes targeted ",(0,s.jsx)(n.code,{children:"drawDefinition.structure"})," and all other child ",(0,s.jsx)(n.code,{children:"structures"})," along with all associated ",(0,s.jsx)(n.code,{children:"drawDefinition.links"}),"."]}),(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-js",children:"const { removedMatchUpIds } = engine.removeStructure({\n  structureId,\n  drawId,\n});\n"})}),(0,s.jsx)(n.hr,{}),(0,s.jsx)(n.h2,{id:"removeseededparticipant",children:"removeSeededParticipant"}),(0,s.jsx)(n.p,{children:"Removes a seeded participant from draw and adjusts seeding."}),(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-js",children:"engine.removeSeededParticipant({\n  drawId, // required\n  structureId, // required\n  participantId, // required\n});\n"})}),(0,s.jsxs)(n.p,{children:[(0,s.jsx)(n.strong,{children:"Purpose:"})," Remove participant and rebalance seeds."]}),(0,s.jsx)(n.hr,{}),(0,s.jsx)(n.h2,{id:"renamestructures",children:"renameStructures"}),(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-js",children:"engine.renameStructures({\n  structureDetails: [{ structureId, structureName }],\n  drawId,\n});\n"})}),(0,s.jsx)(n.hr,{}),(0,s.jsx)(n.h2,{id:"resetdrawdefinition",children:"resetDrawDefinition"}),(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-js",children:"engine.resetDrawDefinition({ drawId });\n"})}),(0,s.jsx)(n.hr,{}),(0,s.jsx)(n.h2,{id:"resetqualifyingstructure",children:"resetQualifyingStructure"}),(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-js",children:"engine.resetQualifyingStructure({ structureId, drawId });\n"})}),(0,s.jsx)(n.p,{children:"--"}),(0,s.jsx)(n.h2,{id:"resetvoluntaryconsolationstructure",children:"resetVoluntaryConsolationStructure"}),(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-js",children:"engine.resetVoluntaryConsolationStructure({\n  resetEntries, // optional - remove all { entryStage: VOLUNTARY_CONSOLATION }\n  drawId,\n});\n"})}),(0,s.jsx)(n.hr,{}),(0,s.jsx)(n.h2,{id:"resetqualifyingstructure-1",children:"resetQualifyingStructure"}),(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-js",children:"engine.resetQualifyingStructure({\n  drawId,\n  structureId,\n});\n"})}),(0,s.jsx)(n.hr,{}),(0,s.jsx)(n.h2,{id:"setdrawparticipantrepresentativeids",children:"setDrawParticipantRepresentativeIds"}),(0,s.jsx)(n.p,{children:"Set the participantIds of participants in the draw who are representing players by observing the creation of the draw."}),(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-js",children:"engine.setDrawParticipantRepresentativeIds({\n  representativeParticipantIds,\n  drawId,\n});\n"})}),(0,s.jsx)(n.hr,{}),(0,s.jsx)(n.h2,{id:"setpositionassignments",children:"setPositionAssignments"}),(0,s.jsxs)(n.p,{children:["Intended to be used in conjunction with ",(0,s.jsx)(n.code,{children:"automatedPlayoffPositioning"})," in deployments where a client instance gets the positioning which is then set on both the client and the server, to ensure that both client and server are identical. If ",(0,s.jsx)(n.code,{children:"automatedPlayoffPositioning"})," is invoked on both client and server independently then it is likely that the positioning on client and server will be different."]}),(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-js",children:"// executed only on the client\nconst { structurePositionAssignments } = engine.automatedPlayoffPositioning({\n  applyPositioning: false, // instructs factory engine to only return values, not apply them\n  structureId,\n  drawId,\n});\n\n// executed on both client and server\nresult = engine.setPositionAssignments({\n  structurePositionAssignments,\n  drawId,\n});\n"})}),(0,s.jsx)(n.hr,{}),(0,s.jsx)(n.h2,{id:"setsuborder",children:"setSubOrder"}),(0,s.jsxs)(n.p,{children:["Used to order ROUND_ROBIN participants when finishingPosition ties cannot be broken algorithmically. Assigns a ",(0,s.jsx)(n.code,{children:"subOrder"})," value to a participant within a ",(0,s.jsx)(n.code,{children:"structure"})," by ",(0,s.jsx)(n.code,{children:"drawPosition"}),"."]}),(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-js",children:"engine.setSubOrder({\n  drawPosition: 1,\n  subOrder: 2,\n  structureId,\n  drawId,\n});\n"})}),(0,s.jsx)(n.hr,{}),(0,s.jsx)(n.h2,{id:"setstructureorder",children:"setStructureOrder"}),(0,s.jsx)(n.p,{children:"Sets the display order of structures within a draw."}),(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-js",children:"engine.setStructureOrder({\n  drawId, // required\n  structureId, // required\n  orderNumber, // required - new order position\n});\n"})}),(0,s.jsxs)(n.p,{children:[(0,s.jsx)(n.strong,{children:"Purpose:"})," Control structure display sequence."]}),(0,s.jsx)(n.hr,{}),(0,s.jsx)(n.h2,{id:"shiftadhocrounds",children:"shiftAdHocRounds"}),(0,s.jsxs)(n.p,{children:["Move ",(0,s.jsx)(n.code,{children:"roundNumber"})," to ",(0,s.jsx)(n.code,{children:"targetRoundNumber"}),"."]}),(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-js",children:"tournamentEngine.shiftAdHocRounds({\n  targetRoundNumber,\n  roundNumber,\n  structureId,\n  drawId,\n});\n"})}),(0,s.jsx)(n.hr,{}),(0,s.jsx)(n.h2,{id:"swapadhocrounds",children:"swapAdHocRounds"}),(0,s.jsxs)(n.p,{children:["Swap ",(0,s.jsx)(n.code,{children:"roundNumbers"}),". Must provide an array of two valid ",(0,s.jsx)(n.code,{children:"roundNumbers"}),"."]}),(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-js",children:"tournamentEngine.swapAdHocRounds({\n  roundNumbers: [2, 4],\n  structureId,\n  drawId,\n});\n"})}),(0,s.jsx)(n.hr,{}),(0,s.jsx)(n.h2,{id:"swapdrawpositionassignments",children:"swapDrawPositionAssignments"}),(0,s.jsxs)(n.p,{children:["Swaps the ",(0,s.jsx)(n.code,{children:"participantIds"})," of two ",(0,s.jsx)(n.code,{children:"drawPositions"}),"."]}),(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-js",children:"engine.swapDrawPositionAssignments({\n  drawPositions,\n  structureId,\n  drawId,\n});\n"})}),(0,s.jsx)(n.hr,{}),(0,s.jsx)(n.h2,{id:"updateteamlineup",children:"updateTeamLineUp"}),(0,s.jsxs)(n.p,{children:["See ",(0,s.jsx)(n.a,{href:"/docs/governors/participant-governor#validatelineup",children:"validateLineUp"})]}),(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-js",children:"engine.updateTeamLineUp({\n  participantId, // id of the team for which lineUp is being updated\n  tieFormat, // valid tieFormat - used to validate collectionIds\n  lineUp, // valid lineUp array\n  drawId, // required as latest lineUp modification is stored in an extension on drawDefinition\n});\n"})}),(0,s.jsx)(n.hr,{}),(0,s.jsx)(n.h2,{id:"withdrawparticipantatdrawposition",children:"withdrawParticipantAtDrawPosition"}),(0,s.jsxs)(n.p,{children:["Thin wrapper around ",(0,s.jsx)(n.a,{href:"#removedrawpositionassignment",children:"removeDrawPositionAssignment"}),". This method is included in ",(0,s.jsx)(n.code,{children:"validActions"})," for ",(0,s.jsx)(n.a,{href:"../policies/positionActions",children:"positionActions"}),"."]}),(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-js",children:"engine.withdrawParticipantAtDrawPosition({\n  entryStatus = WITHDRAWN,\n  replaceWithBye, // optional\n  drawDefinition,\n  drawPosition,\n  structureId,\n  destroyPair, // optional - decompose PAIR participant into UNPAIRED participants\n});\n"})}),(0,s.jsx)(n.hr,{})]})]})}function u(e={}){const{wrapper:n}={...(0,t.R)(),...e.components};return n?(0,s.jsx)(n,{...e,children:(0,s.jsx)(c,{...e})}):c(e)}}}]);