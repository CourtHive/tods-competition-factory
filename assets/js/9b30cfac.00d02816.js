"use strict";(self.webpackChunkdocumentation=self.webpackChunkdocumentation||[]).push([[178],{9276:(e,t,a)=>{a.d(t,{Zo:()=>d,kt:()=>g});var n=a(5271);function i(e,t,a){return t in e?Object.defineProperty(e,t,{value:a,enumerable:!0,configurable:!0,writable:!0}):e[t]=a,e}function r(e,t){var a=Object.keys(e);if(Object.getOwnPropertySymbols){var n=Object.getOwnPropertySymbols(e);t&&(n=n.filter((function(t){return Object.getOwnPropertyDescriptor(e,t).enumerable}))),a.push.apply(a,n)}return a}function s(e){for(var t=1;t<arguments.length;t++){var a=null!=arguments[t]?arguments[t]:{};t%2?r(Object(a),!0).forEach((function(t){i(e,t,a[t])})):Object.getOwnPropertyDescriptors?Object.defineProperties(e,Object.getOwnPropertyDescriptors(a)):r(Object(a)).forEach((function(t){Object.defineProperty(e,t,Object.getOwnPropertyDescriptor(a,t))}))}return e}function p(e,t){if(null==e)return{};var a,n,i=function(e,t){if(null==e)return{};var a,n,i={},r=Object.keys(e);for(n=0;n<r.length;n++)a=r[n],t.indexOf(a)>=0||(i[a]=e[a]);return i}(e,t);if(Object.getOwnPropertySymbols){var r=Object.getOwnPropertySymbols(e);for(n=0;n<r.length;n++)a=r[n],t.indexOf(a)>=0||Object.prototype.propertyIsEnumerable.call(e,a)&&(i[a]=e[a])}return i}var l=n.createContext({}),o=function(e){var t=n.useContext(l),a=t;return e&&(a="function"==typeof e?e(t):s(s({},t),e)),a},d=function(e){var t=o(e.components);return n.createElement(l.Provider,{value:t},e.children)},c="mdxType",u={inlineCode:"code",wrapper:function(e){var t=e.children;return n.createElement(n.Fragment,{},t)}},m=n.forwardRef((function(e,t){var a=e.components,i=e.mdxType,r=e.originalType,l=e.parentName,d=p(e,["components","mdxType","originalType","parentName"]),c=o(a),m=i,g=c["".concat(l,".").concat(m)]||c[m]||u[m]||r;return a?n.createElement(g,s(s({ref:t},d),{},{components:a})):n.createElement(g,s({ref:t},d))}));function g(e,t){var a=arguments,i=t&&t.mdxType;if("string"==typeof e||i){var r=a.length,s=new Array(r);s[0]=m;var p={};for(var l in t)hasOwnProperty.call(t,l)&&(p[l]=t[l]);p.originalType=e,p[c]="string"==typeof e?e:i,s[1]=p;for(var o=2;o<r;o++)s[o]=a[o];return n.createElement.apply(null,s)}return n.createElement.apply(null,a)}m.displayName="MDXCreateElement"},6653:(e,t,a)=>{a.r(t),a.d(t,{assets:()=>l,contentTitle:()=>s,default:()=>u,frontMatter:()=>r,metadata:()=>p,toc:()=>o});var n=a(8957),i=(a(5271),a(9276));const r={title:"Participant Governor"},s=void 0,p={unversionedId:"governors/participant-governor",id:"governors/participant-governor",title:"Participant Governor",description:"participantFilters",source:"@site/docs/governors/participant-governor.md",sourceDirName:"governors",slug:"/governors/participant-governor",permalink:"/tods-competition-factory/docs/governors/participant-governor",draft:!1,tags:[],version:"current",frontMatter:{title:"Participant Governor"},sidebar:"docs",previous:{title:"Mocks Governor",permalink:"/tods-competition-factory/docs/governors/mocks-governor"},next:{title:"Policy Governor",permalink:"/tods-competition-factory/docs/governors/policy-governor"}},l={},o=[{value:"participantFilters",id:"participantfilters",level:2},{value:"addDynamicRatings",id:"adddynamicratings",level:2},{value:"addParticipant",id:"addparticipant",level:2},{value:"addParticipants",id:"addparticipants",level:2},{value:"addPenalty",id:"addpenalty",level:2},{value:"addPersons",id:"addpersons",level:2},{value:"addPersonRequests",id:"addpersonrequests",level:2},{value:"addIndividualParticipantIds",id:"addindividualparticipantids",level:2},{value:"createTeamsFromParticipantAttributes",id:"createteamsfromparticipantattributes",level:2},{value:"deleteParticipants",id:"deleteparticipants",level:2},{value:"findParticipant",id:"findparticipant",level:2},{value:"mergeParticipants",id:"mergeparticipants",level:2},{value:"modifyIndividualParticipantIds",id:"modifyindividualparticipantids",level:2},{value:"modifyParticipant",id:"modifyparticipant",level:2},{value:"modifyPersonRequests",id:"modifypersonrequests",level:2},{value:"modifyPenalty",id:"modifypenalty",level:2},{value:"modifyParticipantsSignInStatus",id:"modifyparticipantssigninstatus",level:2},{value:"regenerateParticipantNames",id:"regenerateparticipantnames",level:2},{value:"removeIndividualParticipantIds",id:"removeindividualparticipantids",level:2},{value:"removeParticipantIdsFromAllTeams",id:"removeparticipantidsfromallteams",level:2},{value:"removeParticipantExtension",id:"removeparticipantextension",level:2},{value:"removePenalty",id:"removepenalty",level:2},{value:"removePersonRequests",id:"removepersonrequests",level:2},{value:"removeRatings",id:"removeratings",level:2},{value:"scaledTeamAssignment",id:"scaledteamassignment",level:2},{value:"Example use with <code>individualParticipantIds</code> and <code>scaleAttributes</code>",id:"example-use-with-individualparticipantids-and-scaleattributes",level:3},{value:"Example use with <code>scaledParticipants</code>",id:"example-use-with-scaledparticipants",level:3},{value:"Example use with sequential assignment where there are 8 teams",id:"example-use-with-sequential-assignment-where-there-are-8-teams",level:3},{value:"setParticipantScaleItem",id:"setparticipantscaleitem",level:2},{value:"setParticipantScaleItems",id:"setparticipantscaleitems",level:2},{value:"validateLineUp",id:"validatelineup",level:2}],d={toc:o},c="wrapper";function u(e){let{components:t,...a}=e;return(0,i.kt)(c,(0,n.Z)({},d,a,{components:t,mdxType:"MDXLayout"}),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-js"},"import { participantGovernor } from 'tods-competition-factory';\n")),(0,i.kt)("h2",{id:"participantfilters"},"participantFilters"),(0,i.kt)("ul",null,(0,i.kt)("li",{parentName:"ul"},"enableOrFiltering: boolean - use OR logic instead of default AND"),(0,i.kt)("li",{parentName:"ul"},"accessorValues: array of accessors and targeted value ",(0,i.kt)("inlineCode",{parentName:"li"},"[{ accessor, value }]")),(0,i.kt)("li",{parentName:"ul"},"drawEntryStatuses: array of ",(0,i.kt)("inlineCode",{parentName:"li"},"entryStatus")," values for participantIds found in draw.entries"),(0,i.kt)("li",{parentName:"ul"},"eventEntryStatuses: array of ",(0,i.kt)("inlineCode",{parentName:"li"},"entryStatus")," values for participantIds found in event.entries"),(0,i.kt)("li",{parentName:"ul"},"eventIds: array of targeted eventIds"),(0,i.kt)("li",{parentName:"ul"},"participantIds: array of targeted participantIds"),(0,i.kt)("li",{parentName:"ul"},"participantRoles: array of targeted participantRoles"),(0,i.kt)("li",{parentName:"ul"},"participantTypes: array of targeted participantTypes"),(0,i.kt)("li",{parentName:"ul"},"positionedParticipants: participantIds positioned in structures ",(0,i.kt)("inlineCode",{parentName:"li"},"[true, false, undefined]")),(0,i.kt)("li",{parentName:"ul"},"signInStatus: SIGNED_IN or SIGNED_OUT")),(0,i.kt)("hr",null),(0,i.kt)("h2",{id:"adddynamicratings"},"addDynamicRatings"),(0,i.kt)("p",null,"Attaches dynamic ratings generated by ",(0,i.kt)("inlineCode",{parentName:"p"},"drawMatic")," to ",(0,i.kt)("inlineCode",{parentName:"p"},"participants"),"."),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-js"},"engine.addDynamicRatings({\n  modifiedScaleValues, // output of drawMatic; necessary in client/server scenarios\n  removePriorValues, // optional boolean\n});\n")),(0,i.kt)("hr",null),(0,i.kt)("h2",{id:"addparticipant"},"addParticipant"),(0,i.kt)("p",null,"Adds an INDIVIDUAL, PAIR or TEAM participant to tournament participants. Includes integrity checks for ",(0,i.kt)("inlineCode",{parentName:"p"},"{ participantType: PAIR }")," to ensure ",(0,i.kt)("inlineCode",{parentName:"p"},"participant.individualParticipantIds")," are valid."),(0,i.kt)("admonition",{type:"note"},(0,i.kt)("p",{parentName:"admonition"},"To add PAIR participants it is only necessary to provide an array of 2 valid individualParticipantIds, participantType and participantRole.")),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-js"},"const participant = {\n  participantId, // automatically generated if not provided\n  participantRole: COMPETITOR,\n  participantType: INDIVIDUAL,\n  person: {\n    standardFamilyName: 'Family',\n    standardGivenName: 'Given',\n    nationalityCode, // optional\n    sex, // optional\n  },\n};\n\nengine.addParticipant({ participant });\n")),(0,i.kt)("hr",null),(0,i.kt)("h2",{id:"addparticipants"},"addParticipants"),(0,i.kt)("p",null,"Bulk add participants to a tournamentRecord."),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-js"},"engine.addParticipants({ participants });\n")),(0,i.kt)("hr",null),(0,i.kt)("h2",{id:"addpenalty"},"addPenalty"),(0,i.kt)("p",null,"Add a penaltyItem to one or more participants."),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-js"},"const createdAt = new Date().toISOString();\nconst penaltyData = {\n  refereeParticipantId, // optional\n  participantIds: ['participantId'],\n  penaltyCode: 'Organization specific code', // optional\n  penaltyType: BALL_ABUSE,\n  matchUpId,\n  issuedAt, // optional ISO timeStamp for time issued to participant\n  createdAt,\n  notes: 'Hit ball into sea',\n};\nlet result = engine.addPenalty(penaltyData);\n")),(0,i.kt)("hr",null),(0,i.kt)("h2",{id:"addpersons"},"addPersons"),(0,i.kt)("p",null,"Creates tournament ",(0,i.kt)("inlineCode",{parentName:"p"},"participants")," from an array of defined persons. Useful for adding registered persons to a tournament record.\nSee ",(0,i.kt)("strong",{parentName:"p"},"person")," under ",(0,i.kt)("strong",{parentName:"p"},"participant")," in ",(0,i.kt)("a",{parentName:"p",href:"../types/typedefs#participant"},"Type Definitions")," for additional ",(0,i.kt)("inlineCode",{parentName:"p"},"person")," attributes."),(0,i.kt)("admonition",{type:"note"},(0,i.kt)("ul",{parentName:"admonition"},(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("inlineCode",{parentName:"li"},"participantIds")," are unique within a tournament"),(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("inlineCode",{parentName:"li"},"personIds")," are unique to an individual, and should be identical across tournaments."))),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-js"},"const persons = [\n  {\n    personId, // optional - providing a personId allows person to be tracked across tournaments\n    participantExtensions, // optional - any relevant extensions for created participant\n    participantTimeItems, // optional - any relevant timeItems (e.g. rankings/ratings) for created participant\n    standardFamilyName,\n    standardGivenName,\n    nationalityCode,\n    sex,\n\n    // optional - will create pair participants\n    pairedPersons: [\n      {\n        participantExtensions, // optional - any relevant extensions for created participant\n        participantTimeItems, // optional - any relevant timeItems (e.g. rankings/ratings) for created participant\n        personId,\n      },\n    ],\n  },\n];\n\nengine.addPersons({\n  participantRole, // optional - defaults to COMPETITOR\n  persons,\n});\n")),(0,i.kt)("hr",null),(0,i.kt)("h2",{id:"addpersonrequests"},"addPersonRequests"),(0,i.kt)("p",null,"Validates and adds person requests."),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-js"},"const requests = [\n  {\n    date, // 'YYYY-MM-DD' date string\n    startTime, // '00:00' time string\n    endTime, // '00:00' time string\n    requestType: 'DO_NOT_SCHEDULE',\n  },\n];\nengine.addPersonRequests({ personId, requests });\n")),(0,i.kt)("hr",null),(0,i.kt)("h2",{id:"addindividualparticipantids"},"addIndividualParticipantIds"),(0,i.kt)("p",null,"Adds individualParticipantIds to GROUP or TEAM participants"),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-js"},"engine.addIndividualParticipantIds({\n  individualParticipantIds,\n  groupingParticipantId,\n  removeFromOtherTeams, // optional boolean\n});\n")),(0,i.kt)("hr",null),(0,i.kt)("h2",{id:"createteamsfromparticipantattributes"},"createTeamsFromParticipantAttributes"),(0,i.kt)("p",null,"Uses attributes of individual participnts or persons to generate ",(0,i.kt)("inlineCode",{parentName:"p"},"{ participantType: TEAM }")," participants."),(0,i.kt)("p",null,"Returns count of # of TEAM participants added;"),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-js"},"const { participantsAdded } = engine.createTeamsFromParticipantAttributes({\n  participantAttribute, // optional -- attribute of participant object\n  addParticipants, // optional boolean; defaults to true; when false return new participants\n  personAttribute, // optional - attribute of person object\n  accessor, // optional - use accessor string to retrieve nested value (even from person address arrays)\n  uuids, // optional - uuids to assign to generated participants\n});\n")),(0,i.kt)("hr",null),(0,i.kt)("h2",{id:"deleteparticipants"},"deleteParticipants"),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-js"},"engine.deleteParticipants({\n  addIndividualParticipantsToEvents, // optional boolean\n  paricipantIds,\n});\n")),(0,i.kt)("hr",null),(0,i.kt)("h2",{id:"findparticipant"},"findParticipant"),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-js"},"const { participant } = engine.findParticipant({\n  participantId, // required only if no personId provided\n  personId, // required only if no participantId provided\n});\n")),(0,i.kt)("hr",null),(0,i.kt)("h2",{id:"mergeparticipants"},"mergeParticipants"),(0,i.kt)("p",null,"Merge ",(0,i.kt)("inlineCode",{parentName:"p"},"participants")," array with existing tournament participants. Useful when synchronizing with a remote registration service, for example."),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-js"},"engine.mergeParticipants({ participants });\n")),(0,i.kt)("hr",null),(0,i.kt)("h2",{id:"modifyindividualparticipantids"},"modifyIndividualParticipantIds"),(0,i.kt)("p",null,"Modify ",(0,i.kt)("inlineCode",{parentName:"p"},"individualParticipantIds")," of a grouping participant ",(0,i.kt)("inlineCode",{parentName:"p"},"{ participantType: TEAM || GROUP }"),"."),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-js"},"engine.devContext(true).modifyIndividualParticipantIds({\n  groupingParticipantId, // participant (TEAM or GROUP) to which participantIds are to be added\n  individualParticipantIds: newIndividualParticipantIds,\n});\n")),(0,i.kt)("hr",null),(0,i.kt)("h2",{id:"modifyparticipant"},"modifyParticipant"),(0,i.kt)("p",null,"Modifies attributes of a participant with integrity checks to ensure valid values for e.g. ",(0,i.kt)("inlineCode",{parentName:"p"},"{ participantType, participantRole }"),". Adds participant if not found."),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-js"},"engine.modifyParticipant({\n  participant: updatedIndividualParticipant,\n});\n")),(0,i.kt)("hr",null),(0,i.kt)("h2",{id:"modifypersonrequests"},"modifyPersonRequests"),(0,i.kt)("p",null,"Modifies existing person requests."),(0,i.kt)("p",null,"Any requests without a ",(0,i.kt)("inlineCode",{parentName:"p"},"requestId")," will be ",(0,i.kt)("strong",{parentName:"p"},"added"),". Any requests without ",(0,i.kt)("inlineCode",{parentName:"p"},"requestType")," will be ",(0,i.kt)("strong",{parentName:"p"},"removed"),"."),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-js"},"engine.modifyPersonRequests({\n  personId, // optional - scope to single personId; avoid brute-force updates\n  requests: [\n    {\n      requestType,\n      requestId, // if requestId is not present, will attempt to added\n      startTime,\n      endTime,\n      date,\n    },\n  ],\n});\n")),(0,i.kt)("hr",null),(0,i.kt)("h2",{id:"modifypenalty"},"modifyPenalty"),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-js"},"const penaltyData = {\n  participantIds: ['participantId'],\n  notes: 'Hit ball into sea',\n  penaltyType: BALL_ABUSE,\n  matchUpId,\n  issuedAt,\n};\nlet result = engine.addPenalty(penaltyData);\nconst { penaltyId } = result;\n\nconst notes = 'Hit ball into spectator';\nconst modifications = { notes };\nengine.modifyPenalty({ penaltyId, modifications });\n")),(0,i.kt)("hr",null),(0,i.kt)("h2",{id:"modifyparticipantssigninstatus"},"modifyParticipantsSignInStatus"),(0,i.kt)("p",null,"Modify the signInStatus of multiple participants, referenced by participantId."),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-js"},"engine.modifyParticipantsSignInStatus({\n  participantIds: ['participantId'],\n  signInState: SIGNED_IN,\n});\n")),(0,i.kt)("hr",null),(0,i.kt)("h2",{id:"regenerateparticipantnames"},"regenerateParticipantNames"),(0,i.kt)("p",null,"Regenerate ",(0,i.kt)("inlineCode",{parentName:"p"},".participantName")," for SINGLES and DOUBLES ",(0,i.kt)("inlineCode",{parentName:"p"},"participants"),"."),(0,i.kt)("p",null,"Upper/lower case and order are derived from ",(0,i.kt)("inlineCode",{parentName:"p"},"personFormat"),' string which must contain "last" and may contain "first" or "f", for first initial.'),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-js"},"const formats = {\n  PAIR: { personFormat: 'LAST', doublesJointer: '/' },\n  INDIVIDUAL: { personFormat: 'LAST, First' },\n};\nengine.regenerateParticipantNames({ formats });\n")),(0,i.kt)("hr",null),(0,i.kt)("h2",{id:"removeindividualparticipantids"},"removeIndividualParticipantIds"),(0,i.kt)("p",null,"Remove an array of individualParticipantIds from a grouping participant ","[TEAM, GROUP]",".\nIf an individualParticipant is in a matchUp with a result they cannot be removed."),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-js"},"const { removed, notRemoved, cannotRemove } = engine.removeIndividualParticipantIds({\n  addIndividualParticipantsToEvents, // optional boolean\n  individualParticipantIds,\n  groupingParticipantId,\n  suppressErrors, // optional boolean - do not throw an error if an individualParticipant cannot be removed\n});\n")),(0,i.kt)("hr",null),(0,i.kt)("h2",{id:"removeparticipantidsfromallteams"},"removeParticipantIdsFromAllTeams"),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-js"},"engine.removeParticipantIdsFromAllTeams({\n  individualParticipantIds,\n  groupingType, // optional - restrict to removing from only specified groupingType\n});\n")),(0,i.kt)("hr",null),(0,i.kt)("h2",{id:"removeparticipantextension"},"removeParticipantExtension"),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-js"},"engine.removeParticipantExtension({ participantId, name });\n")),(0,i.kt)("hr",null),(0,i.kt)("h2",{id:"removepenalty"},"removePenalty"),(0,i.kt)("p",null,"Removes a penalty from all relevant tournament participants."),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-js"},"engine.removePenalty({ penaltyId });\n")),(0,i.kt)("hr",null),(0,i.kt)("h2",{id:"removepersonrequests"},"removePersonRequests"),(0,i.kt)("p",null,"Removes person requests matching passed values. If no paramaters are provided, removes ",(0,i.kt)("strong",{parentName:"p"},"all")," person requests."),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-js"},"result = engine.removePersonRequests({\n  personId, // optional - scope to personId\n  requestType, // optioanl - scope to requestType\n  requestId, // optional - scope to a single requestId\n  date, // optional - scope to a specific date\n});\n")),(0,i.kt)("hr",null),(0,i.kt)("h2",{id:"removeratings"},"removeRatings"),(0,i.kt)("p",null,"Remove specified ratings from participants."),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-js"},"engine.removeRatings({\n  ratingType, // e.g. WTN, UTR\n  asDynamic, // optional boolean; remove DYNAMIC version of specified scaleName\n  eventType, // SINGLES or DOUBLES\n});\n")),(0,i.kt)("hr",null),(0,i.kt)("h2",{id:"scaledteamassignment"},"scaledTeamAssignment"),(0,i.kt)("p",null,"Assigns individual participants to teams using a waterfall pattern; removes UNGROUPED entries as appropriate for TEAM events. May be called with either ",(0,i.kt)("inlineCode",{parentName:"p"},"individualParticipantIds")," and ",(0,i.kt)("inlineCode",{parentName:"p"},"scaleAttributes")," or with an array of ",(0,i.kt)("inlineCode",{parentName:"p"},"scaledParticipants"),"."),(0,i.kt)("admonition",{type:"info"},(0,i.kt)("p",{parentName:"admonition"},"By default existing ",(0,i.kt)("inlineCode",{parentName:"p"},"individualParticipant")," assignments are cleared. If existing assignments are retained, any ",(0,i.kt)("inlineCode",{parentName:"p"},"individualParticipant")," already assigned will be excluded from further assignment. It may be desirable to retain existing assignments if sequential assignment of different groups of ",(0,i.kt)("inlineCode",{parentName:"p"},"individualParticipants")," is desired.")),(0,i.kt)("admonition",{type:"note"},(0,i.kt)("p",{parentName:"admonition"},'Modifying team assignments has "global" effect, meaning that if a team appears in multiple events, team membership will be changed for all events.')),(0,i.kt)("h3",{id:"example-use-with-individualparticipantids-and-scaleattributes"},"Example use with ",(0,i.kt)("inlineCode",{parentName:"h3"},"individualParticipantIds")," and ",(0,i.kt)("inlineCode",{parentName:"h3"},"scaleAttributes")),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-js"},"const scaleAttributes = {\n  sortOrder: ASCENDING, // defaults to ASCENDING; use case for DESCENDING is unclear!\n  scaleType: RANKING,\n  eventType: SINGLES,\n  scaleName: 'U18',\n};\nengine.scaledTeamAssignment({\n  clearExistingAssignments, // optional - true by default remove all existing individualParticipantIds from targeted teams\n  individualParticipantIds, // individuals to be sorted by scaleAttributes and assigned to teams (WATERFALL)\n  reverseAssignmentOrder, // optional - reverses team order; useful for sequential assignment of participant groupings to ensure balanced distribution\n  teamParticipantIds, // optional, IF teamsCount is provided then teams will be created\n  initialTeamIndex, // optional - allows assignment to begin at a specified array index; useful for sequential assignment of groups of scaledParticipants\n  scaleAttributes, // ignored if scaledParticipants are provided; { scaleName, scaleType, sortOrder, eventType }\n  teamNameBase, // optional - defaults to '[categoryName] TEAM #', where categoryName is derived from eventId (if supplied)\n  teamsCount, // optional - derived from teamParticipantIds (if provided) - create # of teams if teamParticipantIds provided are insufficient\n  eventId, // optional - source team participants from DIRECT_ACCEPTANCE entries for specified event\n});\n")),(0,i.kt)("h3",{id:"example-use-with-scaledparticipants"},"Example use with ",(0,i.kt)("inlineCode",{parentName:"h3"},"scaledParticipants")),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-js"},"const scaleAttributes = {\n  scaleType: RANKING,\n  eventType: SINGLES,\n  scaleName: 'U18',\n};\n\nconst scaledParticipants = individualParticipants.map((participant) => ({\n  scaleValue: participantScaleItem({ participant, scaleAttributes }).scaleItem.scaleValue,\n  participantId: 'participantId',\n}));\n\nconst teamParticipantIds = teamParticipants.map(getParticipantId);\n\nengine.scaledTeamAssignment({\n  scaledParticipants, // [{ participantId: 'participantId', scaleValue: '10' }]\n  teamParticipantIds,\n});\n")),(0,i.kt)("h3",{id:"example-use-with-sequential-assignment-where-there-are-8-teams"},"Example use with sequential assignment where there are 8 teams"),(0,i.kt)("p",null,"In this scenario scaled MALE participants are assigned in a waterfall pattern beginning with the first team (default behavior); scaled FEMALE participants are then assigned in a reverse waterfall pattern beginning with the last team. The goal is to balance the teams to the greatest extent possible. This pattern can be used with an arbitrary number of groups of ",(0,i.kt)("inlineCode",{parentName:"p"},"individualParticipants"),"."),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-js"},"engine.scaledTeamAssignment({\n  scaledParticipants: maleScaleParticipants,\n  teamParticipantIds,\n});\n\nengine.scaledTeamAssignment({\n  scaledParticipants: femaleScaleParticipants,\n  clearExistingAssignments: false,\n  reverseAssignmentOrder: true,\n  initialTeamIndex: 7,\n  teamParticipantIds,\n});\n")),(0,i.kt)("hr",null),(0,i.kt)("h2",{id:"setparticipantscaleitem"},"setParticipantScaleItem"),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-js"},"scaleItem = {\n  scaleValue: 12,\n  scaleName: 'U16',\n  scaleType: RANKING,\n  eventType: SINGLES,\n  scaleDate: '2020-06-06',\n};\n\nresult = engine.setParticipantScaleItem({\n  removePriorValues, // optional boolean - when true will delete prior timeItems\n  participantId,\n  scaleItem,\n});\n")),(0,i.kt)("hr",null),(0,i.kt)("h2",{id:"setparticipantscaleitems"},"setParticipantScaleItems"),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-js"},"const scaleItemsWithParticipantIds = [\n  {\n    participantId: 'participantId',\n    scaleItems: [\n      {\n        scaleValue: 8.3,\n        scaleName: 'WTN',\n        scaleType: RATING,\n        eventType: SINGLES,\n        scaleDate: '2021-01-01',\n      },\n    ],\n  },\n];\nengine.setParticipantScaleItems({\n  removePriorValues, // optional boolean - when true will delete prior timeItems\n  scaleItemsWithParticipantIds,\n  // optional context, primarily used when adding SEEDING, useful for structureReports\n  context: {\n    scaleAttributes, // e.g. { scaleType: 'SEEDING' }\n    scaleBasis, // e.g. { scaleType: 'RANKING', scaleDate }\n    eventId,\n  },\n});\n")),(0,i.kt)("hr",null),(0,i.kt)("h2",{id:"validatelineup"},"validateLineUp"),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-js"},"const { valid, error, errors } = engine.validateLineUp({\n  tieFormat, // required to validate collectionIds in lineUp\n  lineUp,\n});\n")),(0,i.kt)("hr",null))}u.isMDXComponent=!0}}]);