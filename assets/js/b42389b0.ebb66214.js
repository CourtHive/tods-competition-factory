"use strict";(globalThis.webpackChunkdocumentation=globalThis.webpackChunkdocumentation||[]).push([[7147],{7442(e,n,t){t.r(n),t.d(n,{assets:()=>c,contentTitle:()=>r,default:()=>p,frontMatter:()=>o,metadata:()=>i,toc:()=>l});const i=JSON.parse('{"id":"scoring-engine/visualization-applications","title":"Visualization Applications","description":"The ScoringEngine serves as the data backbone for match visualization applications. Its structured state, episode system, and statistics API provide the data needed to build rich, interactive match visualizations.","source":"@site/docs/scoring-engine/visualization-applications.md","sourceDirName":"scoring-engine","slug":"/scoring-engine/visualization-applications","permalink":"/competition-factory/docs/scoring-engine/visualization-applications","draft":false,"unlisted":false,"tags":[],"version":"current","frontMatter":{"title":"Visualization Applications"},"sidebar":"docs","previous":{"title":"Multi-Sport Format Support","permalink":"/competition-factory/docs/scoring-engine/format-support"},"next":{"title":"Overview","permalink":"/competition-factory/docs/temporal-engine/temporal-engine-overview"}}');var s=t(6070),a=t(8322);const o={title:"Visualization Applications"},r=void 0,c={},l=[{value:"Episode System",id:"episode-system",level:2},{value:"Types of Visualizations",id:"types-of-visualizations",level:2},{value:"Point Progression",id:"point-progression",level:3},{value:"Momentum Tracking",id:"momentum-tracking",level:3},{value:"Grid-Based Point Layouts",id:"grid-based-point-layouts",level:3},{value:"Statistics Dashboards",id:"statistics-dashboards",level:3},{value:"Real-Time Score Display",id:"real-time-score-display",level:3},{value:"Live Scoring Applications",id:"live-scoring-applications",level:2},{value:"Related Documentation",id:"related-documentation",level:2}];function d(e){const n={a:"a",code:"code",h2:"h2",h3:"h3",li:"li",p:"p",pre:"pre",strong:"strong",ul:"ul",...(0,a.R)(),...e.components};return(0,s.jsxs)(s.Fragment,{children:[(0,s.jsx)(n.p,{children:"The ScoringEngine serves as the data backbone for match visualization applications. Its structured state, episode system, and statistics API provide the data needed to build rich, interactive match visualizations."}),"\n",(0,s.jsx)(n.h2,{id:"episode-system",children:"Episode System"}),"\n",(0,s.jsxs)(n.p,{children:["The ",(0,s.jsx)(n.code,{children:"getEpisodes()"})," method transforms match state into a per-point timeline enriched with game/set/match context. Each episode represents a single point with its surrounding scoring context."]}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-js",children:"const engine = new ScoringEngine({ matchUpFormat: 'SET3-S:6/TB7' });\n\n// ... score points ...\n\nconst episodes = engine.getEpisodes();\n// Returns an array of Episode objects, one per point:\n// {\n//   point,         // Original point data (winner, server, result, etc.)\n//   gameScore,     // Game score at this point\n//   setScore,      // Set score at this point\n//   matchScore,    // Match score at this point\n//   gameNumber,    // Current game number within the set\n//   setNumber,     // Current set number\n//   isBreakPoint,  // Whether this point was a break point\n//   isGamePoint,   // Whether this point was a game point\n//   isSetPoint,    // Whether this point was a set point\n//   isMatchPoint,  // Whether this point was a match point\n//   ...\n// }\n"})}),"\n",(0,s.jsx)(n.p,{children:"Episodes are the primary data source for building point-by-point visualizations. They provide the narrative arc of a match in a format ready for charting libraries."}),"\n",(0,s.jsx)(n.h2,{id:"types-of-visualizations",children:"Types of Visualizations"}),"\n",(0,s.jsx)(n.p,{children:"The ScoringEngine enables several categories of match visualization:"}),"\n",(0,s.jsx)(n.h3,{id:"point-progression",children:"Point Progression"}),"\n",(0,s.jsx)(n.p,{children:"Visualize the flow of a match as a tree or Sankey diagram showing probability at each branching point. Each node represents a score state, and branches show outcomes."}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-js",children:"const episodes = engine.getEpisodes();\n\n// Build a tree structure from episodes\nconst tree = episodes.reduce((nodes, episode) => {\n  // Map each point to a node with game/set context\n  return buildProgressionNode(nodes, episode);\n}, []);\n"})}),"\n",(0,s.jsx)(n.h3,{id:"momentum-tracking",children:"Momentum Tracking"}),"\n",(0,s.jsx)(n.p,{children:"Plot point-by-point score differential to show momentum swings."}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-js",children:"const episodes = engine.getEpisodes();\nlet cumulativeDiff = 0;\n\nconst momentumData = episodes.map((ep, i) => {\n  cumulativeDiff += ep.point.winner === 0 ? 1 : -1;\n  return { pointIndex: i, momentum: cumulativeDiff };\n});\n"})}),"\n",(0,s.jsx)(n.h3,{id:"grid-based-point-layouts",children:"Grid-Based Point Layouts"}),"\n",(0,s.jsx)(n.p,{children:"Arrange points in a grid layout where cell size represents rally length and color represents the winner."}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-js",children:"const episodes = engine.getEpisodes();\n\nconst grid = episodes.map((ep) => ({\n  size: ep.point.rallyLength || 1,\n  color: ep.point.winner === 0 ? 'blue' : 'red',\n  game: ep.gameNumber,\n  set: ep.setNumber,\n}));\n"})}),"\n",(0,s.jsx)(n.h3,{id:"statistics-dashboards",children:"Statistics Dashboards"}),"\n",(0,s.jsxs)(n.p,{children:["Combine ",(0,s.jsx)(n.code,{children:"getStatistics()"})," with ",(0,s.jsx)(n.code,{children:"getEpisodes()"})," to build multi-panel dashboards."]}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-js",children:"const stats = engine.getStatistics();\nconst set1Stats = engine.getStatistics({ setFilter: 1 });\n\n// Render statistics panels\nrenderAceCount(stats);\nrenderBreakPointConversion(stats);\nrenderFirstServePercentage(stats);\n"})}),"\n",(0,s.jsx)(n.h3,{id:"real-time-score-display",children:"Real-Time Score Display"}),"\n",(0,s.jsx)(n.p,{children:"Use event handlers to update visualizations in real-time as points are scored."}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-js",children:"const engine = new ScoringEngine({\n  matchUpFormat: 'SET3-S:6/TB7',\n  eventHandlers: {\n    onPoint: ({ score }) => {\n      updateScoreDisplay(score);\n      updateMomentumChart(engine.getEpisodes());\n    },\n    onGameComplete: () => {\n      updateStatisticsPanel(engine.getStatistics());\n    },\n    onSetComplete: () => {\n      refreshAllCharts(engine);\n    },\n    onMatchComplete: ({ state }) => {\n      showFinalReport(state, engine.getStatistics());\n    },\n  },\n});\n"})}),"\n",(0,s.jsx)(n.h2,{id:"live-scoring-applications",children:"Live Scoring Applications"}),"\n",(0,s.jsx)(n.p,{children:"The ScoringEngine's combination of state management, undo/redo, and event handlers makes it suitable for mobile match tracker applications."}),"\n",(0,s.jsx)(n.p,{children:"A typical live scoring app architecture:"}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{children:"\u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510\n\u2502   Input UI (point buttons)  \u2502\n\u251c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2524\n\u2502       ScoringEngine         \u2502\n\u2502  - addPoint / undo / redo   \u2502\n\u2502  - event handlers           \u2502\n\u251c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2524\n\u2502   Visualization Layer       \u2502\n\u2502  - Scoreboard               \u2502\n\u2502  - Momentum chart           \u2502\n\u2502  - Statistics panel         \u2502\n\u251c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2524\n\u2502   Persistence               \u2502\n\u2502  - getState / setState      \u2502\n\u2502  - getSupplementaryState    \u2502\n\u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518\n"})}),"\n",(0,s.jsxs)(n.p,{children:["The engine's persistence methods (",(0,s.jsx)(n.code,{children:"getState"}),", ",(0,s.jsx)(n.code,{children:"setState"}),", ",(0,s.jsx)(n.code,{children:"getSupplementaryState"}),", ",(0,s.jsx)(n.code,{children:"loadSupplementaryState"}),") enable saving and restoring match state across app restarts, making it suitable for mobile applications where the app may be backgrounded."]}),"\n",(0,s.jsx)(n.h2,{id:"related-documentation",children:"Related Documentation"}),"\n",(0,s.jsxs)(n.ul,{children:["\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.strong,{children:(0,s.jsx)(n.a,{href:"./scoring-engine-overview",children:"Overview"})})," \u2014 Introduction and architecture"]}),"\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.strong,{children:(0,s.jsx)(n.a,{href:"./scoring-engine-api",children:"Core API Reference"})})," \u2014 Complete method reference with ",(0,s.jsx)(n.code,{children:"getEpisodes()"})," and ",(0,s.jsx)(n.code,{children:"getStatistics()"})]}),"\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.strong,{children:(0,s.jsx)(n.a,{href:"./event-handlers",children:"Event Handlers & Integration"})})," \u2014 Real-time event callbacks"]}),"\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.strong,{children:(0,s.jsx)(n.a,{href:"./format-support",children:"Multi-Sport Format Support"})})," \u2014 Format strings for different sports"]}),"\n"]})]})}function p(e={}){const{wrapper:n}={...(0,a.R)(),...e.components};return n?(0,s.jsx)(n,{...e,children:(0,s.jsx)(d,{...e})}):d(e)}},8322(e,n,t){t.d(n,{R:()=>o,x:()=>r});var i=t(758);const s={},a=i.createContext(s);function o(e){const n=i.useContext(a);return i.useMemo(function(){return"function"==typeof e?e(n):{...n,...e}},[n,e])}function r(e){let n;return n=e.disableParentContext?"function"==typeof e.components?e.components(s):e.components||s:o(e.components),i.createElement(a.Provider,{value:n},e.children)}}}]);