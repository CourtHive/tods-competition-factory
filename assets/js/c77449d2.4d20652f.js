"use strict";(self.webpackChunkdocumentation=self.webpackChunkdocumentation||[]).push([[3447],{3805:(e,n,t)=>{t.d(n,{xA:()=>s,yg:()=>g});var o=t(758);function i(e,n,t){return n in e?Object.defineProperty(e,n,{value:t,enumerable:!0,configurable:!0,writable:!0}):e[n]=t,e}function r(e,n){var t=Object.keys(e);if(Object.getOwnPropertySymbols){var o=Object.getOwnPropertySymbols(e);n&&(o=o.filter((function(n){return Object.getOwnPropertyDescriptor(e,n).enumerable}))),t.push.apply(t,o)}return t}function a(e){for(var n=1;n<arguments.length;n++){var t=null!=arguments[n]?arguments[n]:{};n%2?r(Object(t),!0).forEach((function(n){i(e,n,t[n])})):Object.getOwnPropertyDescriptors?Object.defineProperties(e,Object.getOwnPropertyDescriptors(t)):r(Object(t)).forEach((function(n){Object.defineProperty(e,n,Object.getOwnPropertyDescriptor(t,n))}))}return e}function l(e,n){if(null==e)return{};var t,o,i=function(e,n){if(null==e)return{};var t,o,i={},r=Object.keys(e);for(o=0;o<r.length;o++)t=r[o],n.indexOf(t)>=0||(i[t]=e[t]);return i}(e,n);if(Object.getOwnPropertySymbols){var r=Object.getOwnPropertySymbols(e);for(o=0;o<r.length;o++)t=r[o],n.indexOf(t)>=0||Object.prototype.propertyIsEnumerable.call(e,t)&&(i[t]=e[t])}return i}var c=o.createContext({}),p=function(e){var n=o.useContext(c),t=n;return e&&(t="function"==typeof e?e(n):a(a({},n),e)),t},s=function(e){var n=p(e.components);return o.createElement(c.Provider,{value:n},e.children)},y="mdxType",u={inlineCode:"code",wrapper:function(e){var n=e.children;return o.createElement(o.Fragment,{},n)}},m=o.forwardRef((function(e,n){var t=e.components,i=e.mdxType,r=e.originalType,c=e.parentName,s=l(e,["components","mdxType","originalType","parentName"]),y=p(t),m=i,g=y["".concat(c,".").concat(m)]||y[m]||u[m]||r;return t?o.createElement(g,a(a({ref:n},s),{},{components:t})):o.createElement(g,a({ref:n},s))}));function g(e,n){var t=arguments,i=n&&n.mdxType;if("string"==typeof e||i){var r=t.length,a=new Array(r);a[0]=m;var l={};for(var c in n)hasOwnProperty.call(n,c)&&(l[c]=n[c]);l.originalType=e,l[y]="string"==typeof e?e:i,a[1]=l;for(var p=2;p<r;p++)a[p]=t[p];return o.createElement.apply(null,a)}return o.createElement.apply(null,t)}m.displayName="MDXCreateElement"},5200:(e,n,t)=>{t.r(n),t.d(n,{assets:()=>c,contentTitle:()=>a,default:()=>u,frontMatter:()=>r,metadata:()=>l,toc:()=>p});var o=t(2232),i=(t(758),t(3805));const r={title:"Policy Governor"},a=void 0,l={unversionedId:"governors/policy-governor",id:"governors/policy-governor",title:"Policy Governor",description:"The policyGovernor manages policy definitions that control tournament behavior, including seeding, scoring, avoidance rules, and position actions. Policies can be attached at tournament, event, or draw levels with hierarchical inheritance.",source:"@site/docs/governors/policy-governor.md",sourceDirName:"governors",slug:"/governors/policy-governor",permalink:"/tods-competition-factory/docs/governors/policy-governor",draft:!1,tags:[],version:"current",frontMatter:{title:"Policy Governor"},sidebar:"docs",previous:{title:"Participant Governor",permalink:"/tods-competition-factory/docs/governors/participant-governor"},next:{title:"Publishing Governor",permalink:"/tods-competition-factory/docs/governors/publishing-governor"}},c={},p=[{value:"attachPolicies",id:"attachpolicies",level:2},{value:"findPolicy",id:"findpolicy",level:2},{value:"removePolicy",id:"removepolicy",level:2}],s={toc:p},y="wrapper";function u(e){let{components:n,...t}=e;return(0,i.yg)(y,(0,o.A)({},s,t,{components:n,mdxType:"MDXLayout"}),(0,i.yg)("pre",null,(0,i.yg)("code",{parentName:"pre",className:"language-js"},"import { policyGovernor } from 'tods-competition-factory';\n")),(0,i.yg)("p",null,"The ",(0,i.yg)("strong",{parentName:"p"},"policyGovernor")," manages policy definitions that control tournament behavior, including seeding, scoring, avoidance rules, and position actions. Policies can be attached at tournament, event, or draw levels with hierarchical inheritance."),(0,i.yg)("p",null,(0,i.yg)("strong",{parentName:"p"},"Policy Types Include:")),(0,i.yg)("ul",null,(0,i.yg)("li",{parentName:"ul"},(0,i.yg)("inlineCode",{parentName:"li"},"POLICY_TYPE_SEEDING")," - Seeding placement rules"),(0,i.yg)("li",{parentName:"ul"},(0,i.yg)("inlineCode",{parentName:"li"},"POLICY_TYPE_SCORING")," - Scoring and completion requirements"),(0,i.yg)("li",{parentName:"ul"},(0,i.yg)("inlineCode",{parentName:"li"},"POLICY_TYPE_AVOIDANCE")," - Participant separation rules"),(0,i.yg)("li",{parentName:"ul"},(0,i.yg)("inlineCode",{parentName:"li"},"POLICY_TYPE_POSITION_ACTIONS")," - Available position actions"),(0,i.yg)("li",{parentName:"ul"},(0,i.yg)("inlineCode",{parentName:"li"},"POLICY_TYPE_SCORING_USTA")," - USTA-specific scoring rules"),(0,i.yg)("li",{parentName:"ul"},(0,i.yg)("inlineCode",{parentName:"li"},"POLICY_TYPE_SCHEDULING")," - Scheduling constraints")),(0,i.yg)("p",null,"See ",(0,i.yg)("a",{parentName:"p",href:"/docs/concepts/policies"},"Policies Documentation")," for detailed policy specifications."),(0,i.yg)("hr",null),(0,i.yg)("h2",{id:"attachpolicies"},"attachPolicies"),(0,i.yg)("p",null,"Attaches policy definitions to tournaments, events, or draws. Policies control various aspects of tournament behavior and are inherited hierarchically (draw policies override event policies, which override tournament policies)."),(0,i.yg)("p",null,(0,i.yg)("strong",{parentName:"p"},"Purpose:")," Apply competition rules and behavioral policies to tournament structures. Enables customization of seeding algorithms, scoring requirements, participant separation rules, and available administrative actions."),(0,i.yg)("p",null,(0,i.yg)("strong",{parentName:"p"},"When to Use:")),(0,i.yg)("ul",null,(0,i.yg)("li",{parentName:"ul"},"Setting tournament-wide default policies"),(0,i.yg)("li",{parentName:"ul"},"Applying event-specific scoring rules"),(0,i.yg)("li",{parentName:"ul"},"Configuring draw-level seeding policies"),(0,i.yg)("li",{parentName:"ul"},"Establishing avoidance policies (e.g., same country/club)"),(0,i.yg)("li",{parentName:"ul"},"Controlling available position actions for tournament staff"),(0,i.yg)("li",{parentName:"ul"},"Applying federation-specific rules (ITF, USTA, etc.)")),(0,i.yg)("p",null,(0,i.yg)("strong",{parentName:"p"},"Parameters:")),(0,i.yg)("pre",null,(0,i.yg)("code",{parentName:"pre",className:"language-ts"},"{\n  policyDefinitions: PolicyDefinitions;   // Required - policies to attach\n  tournamentRecords?: TournamentRecords;  // Apply to multiple tournaments\n  tournamentRecord?: Tournament;          // Apply to single tournament\n  event?: Event;                          // Apply to specific event\n  drawDefinition?: DrawDefinition;        // Apply to specific draw\n  tournamentId?: string;                  // Tournament ID for notifications\n  eventId?: string;                       // Event ID (alternative to event object)\n  drawId?: string;                        // Draw ID (alternative to drawDefinition object)\n  allowReplacement?: boolean;             // Allow replacing existing policies (default: false)\n}\n\n// PolicyDefinitions structure\ntype PolicyDefinitions = {\n  [policyType: string]: {\n    policyName?: string;                  // Optional policy name/description\n    [key: string]: any;                   // Policy-specific configuration\n  };\n};\n")),(0,i.yg)("p",null,(0,i.yg)("strong",{parentName:"p"},"Returns:")),(0,i.yg)("pre",null,(0,i.yg)("code",{parentName:"pre",className:"language-ts"},"{\n  success: boolean;\n  applied?: string[];                     // Array of applied policy types\n  error?: ErrorType;                      // EXISTING_POLICY_TYPE, INVALID_VALUES, etc.\n}\n")),(0,i.yg)("p",null,(0,i.yg)("strong",{parentName:"p"},"Examples:")),(0,i.yg)("pre",null,(0,i.yg)("code",{parentName:"pre",className:"language-js"},"import { tournamentEngine } from 'tods-competition-factory';\nimport { POLICY_TYPE_SEEDING, POLICY_TYPE_SCORING } from 'tods-competition-factory';\n\ntournamentEngine.setState(tournamentRecord);\n\n// Attach tournament-level policy\nconst seedingPolicy = {\n  [POLICY_TYPE_SEEDING]: {\n    policyName: 'ITF Seeding',\n    seedingProfile: 'ITF'\n  }\n};\n\nlet result = tournamentEngine.attachPolicies({\n  policyDefinitions: seedingPolicy\n});\nconsole.log(result.applied); // ['seeding']\n\n// Attach event-specific policy\nconst scoringPolicy = {\n  [POLICY_TYPE_SCORING]: {\n    policyName: 'USTA Scoring',\n    requireParticipantsForScoring: true,    // Require participants present\n    requireAllPositionsAssigned: false\n  }\n};\n\nresult = tournamentEngine.attachPolicies({\n  policyDefinitions: scoringPolicy,\n  eventId: 'event-1'\n});\n\n// Attach draw-specific policy (overrides event/tournament policies)\nconst avoidancePolicy = {\n  [POLICY_TYPE_AVOIDANCE]: {\n    policyName: 'Country Avoidance',\n    policyAttributes: [\n      {\n        key: 'person.nationalityCode',      // Path to attribute to check\n        value: true                         // Avoid matching values\n      }\n    ]\n  }\n};\n\nresult = tournamentEngine.attachPolicies({\n  policyDefinitions: avoidancePolicy,\n  drawId: 'draw-1'\n});\n\n// Replace existing policy\nresult = tournamentEngine.attachPolicies({\n  policyDefinitions: seedingPolicy,\n  allowReplacement: true  // Allows updating existing policy\n});\n\n// Attach multiple policies at once\nconst multiplePolicies = {\n  [POLICY_TYPE_SEEDING]: {\n    policyName: 'Custom Seeding',\n    seedingProfile: 'WATERFALL'\n  },\n  [POLICY_TYPE_SCORING]: {\n    policyName: 'Custom Scoring',\n    requireParticipantsForScoring: false\n  }\n};\n\nresult = tournamentEngine.attachPolicies({\n  policyDefinitions: multiplePolicies\n});\nconsole.log(result.applied); // ['seeding', 'scoring']\n\n// Apply to all tournaments in competition\nimport { competitionEngine } from 'tods-competition-factory';\n\ncompetitionEngine.setState(tournamentRecords);\nresult = competitionEngine.attachPolicies({\n  tournamentRecords,\n  policyDefinitions: seedingPolicy\n});\n\n// Error handling\nresult = tournamentEngine.attachPolicies({\n  policyDefinitions: seedingPolicy  // Already attached\n});\nconsole.log(result.error); // EXISTING_POLICY_TYPE\n\nresult = tournamentEngine.attachPolicies({\n  policyDefinitions: {\n    [POLICY_TYPE_SEEDING]: { policyName: 'Invalid' } // Missing required attributes\n  }\n});\nconsole.log(result.error); // INVALID_VALUES\n")),(0,i.yg)("p",null,(0,i.yg)("strong",{parentName:"p"},"Notes:")),(0,i.yg)("ul",null,(0,i.yg)("li",{parentName:"ul"},"Policies are stored in APPLIED_POLICIES extension"),(0,i.yg)("li",{parentName:"ul"},"Lower-level policies override higher-level (draw > event > tournament)"),(0,i.yg)("li",{parentName:"ul"},(0,i.yg)("inlineCode",{parentName:"li"},"allowReplacement: true")," required to update existing policy of same type"),(0,i.yg)("li",{parentName:"ul"},"Policy definitions must include at least one attribute beyond ",(0,i.yg)("inlineCode",{parentName:"li"},"policyName")),(0,i.yg)("li",{parentName:"ul"},"Invalid policy structures return INVALID_VALUES error"),(0,i.yg)("li",{parentName:"ul"},"Attempting to attach existing policy without ",(0,i.yg)("inlineCode",{parentName:"li"},"allowReplacement")," returns EXISTING_POLICY_TYPE"),(0,i.yg)("li",{parentName:"ul"},"Policy changes at draw level trigger draw modification notifications"),(0,i.yg)("li",{parentName:"ul"},"See ",(0,i.yg)("a",{parentName:"li",href:"/docs/concepts/policies"},"Policy Documentation")," for specific policy schemas"),(0,i.yg)("li",{parentName:"ul"},"Common policy types defined in ",(0,i.yg)("inlineCode",{parentName:"li"},"@Constants/policyConstants"))),(0,i.yg)("hr",null),(0,i.yg)("h2",{id:"findpolicy"},"findPolicy"),(0,i.yg)("p",null,"Finds and returns a specific policy type from the hierarchical policy structure (draw \u2192 event \u2192 tournament), returning the most specific policy found."),(0,i.yg)("p",null,(0,i.yg)("strong",{parentName:"p"},"Purpose:")," Retrieve active policy configuration for a specific policy type, respecting the hierarchical override system. Essential for understanding which rules are currently in effect."),(0,i.yg)("p",null,(0,i.yg)("strong",{parentName:"p"},"When to Use:")),(0,i.yg)("ul",null,(0,i.yg)("li",{parentName:"ul"},"Checking active policy configuration before operations"),(0,i.yg)("li",{parentName:"ul"},"Validating policy settings for specific contexts"),(0,i.yg)("li",{parentName:"ul"},"Debugging policy inheritance and overrides"),(0,i.yg)("li",{parentName:"ul"},"Building UI that displays current policy settings"),(0,i.yg)("li",{parentName:"ul"},"Verifying policy application in tests")),(0,i.yg)("p",null,(0,i.yg)("strong",{parentName:"p"},"Parameters:")),(0,i.yg)("pre",null,(0,i.yg)("code",{parentName:"pre",className:"language-ts"},"{\n  policyType: string;                     // Required - type of policy to find\n  tournamentRecord?: Tournament;          // Tournament to search\n  tournamentId?: string;                  // Tournament ID (alternative)\n  event?: Event;                          // Event to search\n  eventId?: string;                       // Event ID (alternative)\n  drawDefinition?: DrawDefinition;        // Draw to search\n  drawId?: string;                        // Draw ID (alternative)\n  structure?: Structure;                  // Structure to search\n}\n")),(0,i.yg)("p",null,(0,i.yg)("strong",{parentName:"p"},"Returns:")),(0,i.yg)("pre",null,(0,i.yg)("code",{parentName:"pre",className:"language-ts"},"{\n  policy?: PolicyDefinition;              // Found policy object\n  error?: ErrorType;                      // POLICY_NOT_FOUND if not found\n}\n")),(0,i.yg)("p",null,(0,i.yg)("strong",{parentName:"p"},"Hierarchy Resolution:"),"\nThe method searches in order: structure \u2192 draw \u2192 event \u2192 tournament, returning the first match found (most specific policy wins)."),(0,i.yg)("p",null,(0,i.yg)("strong",{parentName:"p"},"Examples:")),(0,i.yg)("pre",null,(0,i.yg)("code",{parentName:"pre",className:"language-js"},"import { tournamentEngine } from 'tods-competition-factory';\nimport { POLICY_TYPE_SEEDING } from 'tods-competition-factory';\n\ntournamentEngine.setState(tournamentRecord);\n\n// Find tournament-level policy\nconst { policy } = tournamentEngine.findPolicy({\n  policyType: POLICY_TYPE_SEEDING\n});\n\nconsole.log(policy);\n// {\n//   policyName: 'ITF Seeding',\n//   seedingProfile: 'ITF'\n// }\n\n// Find event-specific policy (may override tournament policy)\nconst { policy } = tournamentEngine.findPolicy({\n  policyType: POLICY_TYPE_SCORING,\n  eventId: 'event-1'\n});\n\n// Find draw-specific policy (highest priority)\nconst { policy } = tournamentEngine.findPolicy({\n  policyType: POLICY_TYPE_AVOIDANCE,\n  eventId: 'event-1',\n  drawId: 'draw-1'\n});\n\n// Policy not found\nconst { policy, error } = tournamentEngine.findPolicy({\n  policyType: 'NONEXISTENT_POLICY'\n});\nconsole.log(error); // POLICY_NOT_FOUND\n\n// Check for policy existence before using\nconst { policy: scoringPolicy } = tournamentEngine.findPolicy({\n  policyType: POLICY_TYPE_SCORING,\n  drawId: 'draw-1'\n});\n\nif (scoringPolicy) {\n  console.log(`Scoring policy active: ${scoringPolicy.policyName}`);\n  if (scoringPolicy.requireParticipantsForScoring) {\n    console.log('Participants must be present to record scores');\n  }\n}\n\n// Hierarchical override example\n// Tournament has seeding policy A\ntournamentEngine.attachPolicies({\n  policyDefinitions: {\n    [POLICY_TYPE_SEEDING]: { policyName: 'Tournament Default', seedingProfile: 'WATERFALL' }\n  }\n});\n\n// Event has seeding policy B\ntournamentEngine.attachPolicies({\n  policyDefinitions: {\n    [POLICY_TYPE_SEEDING]: { policyName: 'Event Override', seedingProfile: 'ITF' }\n  },\n  eventId: 'event-1'\n});\n\n// Find policy at event level returns event policy (not tournament)\nconst { policy } = tournamentEngine.findPolicy({\n  policyType: POLICY_TYPE_SEEDING,\n  eventId: 'event-1'\n});\nconsole.log(policy.policyName); // \"Event Override\"\n\n// Find policy at tournament level returns tournament policy\nconst { policy: tournamentPolicy } = tournamentEngine.findPolicy({\n  policyType: POLICY_TYPE_SEEDING\n});\nconsole.log(tournamentPolicy.policyName); // \"Tournament Default\"\n")),(0,i.yg)("p",null,(0,i.yg)("strong",{parentName:"p"},"Notes:")),(0,i.yg)("ul",null,(0,i.yg)("li",{parentName:"ul"},"Returns the most specific policy (draw overrides event, event overrides tournament)"),(0,i.yg)("li",{parentName:"ul"},"Searches upward in hierarchy: structure \u2192 draw \u2192 event \u2192 tournament"),(0,i.yg)("li",{parentName:"ul"},"Returns POLICY_NOT_FOUND error if policy type not found at any level"),(0,i.yg)("li",{parentName:"ul"},"Use ",(0,i.yg)("inlineCode",{parentName:"li"},"getAppliedPolicies()")," to retrieve all policies at a specific level"),(0,i.yg)("li",{parentName:"ul"},"Policy object is deep-copied to prevent external modifications"),(0,i.yg)("li",{parentName:"ul"},"Useful for pre-flight checks before operations that depend on policies"),(0,i.yg)("li",{parentName:"ul"},"Does not search across multiple tournaments (tournament-scoped)")),(0,i.yg)("hr",null),(0,i.yg)("h2",{id:"removepolicy"},"removePolicy"),(0,i.yg)("p",null,"Removes a specific policy type from tournaments, events, or draws. If removing the last policy from an element, the entire APPLIED_POLICIES extension is removed."),(0,i.yg)("p",null,(0,i.yg)("strong",{parentName:"p"},"Purpose:")," Remove policy definitions to restore default behavior or remove outdated policies. Allows selective policy removal while preserving other policies."),(0,i.yg)("p",null,(0,i.yg)("strong",{parentName:"p"},"When to Use:")),(0,i.yg)("ul",null,(0,i.yg)("li",{parentName:"ul"},"Removing event-specific policies to fall back to tournament defaults"),(0,i.yg)("li",{parentName:"ul"},"Cleaning up test policies after tests"),(0,i.yg)("li",{parentName:"ul"},"Reverting to system defaults"),(0,i.yg)("li",{parentName:"ul"},"Removing outdated or incorrect policies"),(0,i.yg)("li",{parentName:"ul"},"Preparing elements for new policy attachments"),(0,i.yg)("li",{parentName:"ul"},"Bulk policy removal across multiple tournaments")),(0,i.yg)("p",null,(0,i.yg)("strong",{parentName:"p"},"Parameters:")),(0,i.yg)("pre",null,(0,i.yg)("code",{parentName:"pre",className:"language-ts"},"{\n  policyType: string;                     // Required - type of policy to remove\n  tournamentRecords?: TournamentRecords;  // Remove from multiple tournaments\n  tournamentRecord?: Tournament;          // Remove from single tournament\n  event?: Event;                          // Remove from specific event\n  eventId?: string;                       // Event ID (alternative)\n  drawDefinition?: DrawDefinition;        // Remove from specific draw\n  drawId?: string;                        // Draw ID (alternative)\n  tournamentId?: string;                  // Tournament ID for context\n}\n")),(0,i.yg)("p",null,(0,i.yg)("strong",{parentName:"p"},"Returns:")),(0,i.yg)("pre",null,(0,i.yg)("code",{parentName:"pre",className:"language-ts"},"{\n  success: boolean;\n  error?: ErrorType;                      // POLICY_NOT_FOUND if policy doesn't exist\n}\n")),(0,i.yg)("p",null,(0,i.yg)("strong",{parentName:"p"},"Examples:")),(0,i.yg)("pre",null,(0,i.yg)("code",{parentName:"pre",className:"language-js"},"import { tournamentEngine } from 'tods-competition-factory';\nimport { POLICY_TYPE_SEEDING, POLICY_TYPE_SCORING } from 'tods-competition-factory';\n\ntournamentEngine.setState(tournamentRecord);\n\n// Remove policy from tournament\nlet result = tournamentEngine.removePolicy({\n  policyType: POLICY_TYPE_SEEDING\n});\nconsole.log(result.success); // true\n\n// Remove policy from event\nresult = tournamentEngine.removePolicy({\n  policyType: POLICY_TYPE_SCORING,\n  eventId: 'event-1'\n});\n\n// Remove policy from draw\nresult = tournamentEngine.removePolicy({\n  policyType: POLICY_TYPE_AVOIDANCE,\n  drawId: 'draw-1'\n});\n\n// Error when policy doesn't exist\nresult = tournamentEngine.removePolicy({\n  policyType: 'NONEXISTENT_POLICY'\n});\nconsole.log(result.error); // POLICY_NOT_FOUND\n\n// Remove from all tournaments in competition\nimport { competitionEngine } from 'tods-competition-factory';\n\ncompetitionEngine.setState(tournamentRecords);\nresult = competitionEngine.removePolicy({\n  tournamentRecords,\n  policyType: POLICY_TYPE_SEEDING\n});\n\n// Hierarchical removal - remove event override, fall back to tournament policy\n// 1. Attach tournament policy\ntournamentEngine.attachPolicies({\n  policyDefinitions: {\n    [POLICY_TYPE_SEEDING]: { policyName: 'Tournament Default', seedingProfile: 'WATERFALL' }\n  }\n});\n\n// 2. Attach event override\ntournamentEngine.attachPolicies({\n  policyDefinitions: {\n    [POLICY_TYPE_SEEDING]: { policyName: 'Event Override', seedingProfile: 'ITF' }\n  },\n  eventId: 'event-1'\n});\n\n// 3. Remove event override - tournament policy now applies to event\ntournamentEngine.removePolicy({\n  policyType: POLICY_TYPE_SEEDING,\n  eventId: 'event-1'\n});\n\n// Now findPolicy returns tournament-level policy\nconst { policy } = tournamentEngine.findPolicy({\n  policyType: POLICY_TYPE_SEEDING,\n  eventId: 'event-1'\n});\nconsole.log(policy.policyName); // \"Tournament Default\"\n\n// Cleanup pattern for tests\nafterEach(() => {\n  tournamentEngine.removePolicy({ policyType: POLICY_TYPE_SEEDING });\n  tournamentEngine.removePolicy({ policyType: POLICY_TYPE_SCORING });\n  tournamentEngine.removePolicy({ policyType: POLICY_TYPE_AVOIDANCE });\n});\n\n// Remove all policies from event (one at a time)\nconst policyTypes = [\n  POLICY_TYPE_SEEDING,\n  POLICY_TYPE_SCORING,\n  POLICY_TYPE_AVOIDANCE,\n  POLICY_TYPE_POSITION_ACTIONS\n];\n\npolicyTypes.forEach(policyType => {\n  const result = tournamentEngine.removePolicy({\n    policyType,\n    eventId: 'event-1'\n  });\n  if (result.success) {\n    console.log(`Removed ${policyType}`);\n  }\n});\n")),(0,i.yg)("p",null,(0,i.yg)("strong",{parentName:"p"},"Notes:")),(0,i.yg)("ul",null,(0,i.yg)("li",{parentName:"ul"},"Removes policy only from specified level (does not cascade)"),(0,i.yg)("li",{parentName:"ul"},"If last policy removed, entire APPLIED_POLICIES extension is deleted"),(0,i.yg)("li",{parentName:"ul"},"Returns POLICY_NOT_FOUND if policy type doesn't exist at specified level"),(0,i.yg)("li",{parentName:"ul"},"Does not affect policies at other levels (e.g., removing from event doesn't affect tournament policy)"),(0,i.yg)("li",{parentName:"ul"},"Removing event policy causes fallback to tournament policy (if exists)"),(0,i.yg)("li",{parentName:"ul"},"Removing draw policy causes fallback to event/tournament policy"),(0,i.yg)("li",{parentName:"ul"},"Use ",(0,i.yg)("inlineCode",{parentName:"li"},"attachPolicies")," with ",(0,i.yg)("inlineCode",{parentName:"li"},"allowReplacement: true")," to replace rather than remove+add"),(0,i.yg)("li",{parentName:"ul"},"No undo functionality - policies must be re-attached if removed in error"),(0,i.yg)("li",{parentName:"ul"},"Tournament ID parameter used for context but doesn't limit scope"),(0,i.yg)("li",{parentName:"ul"},"Safe to call on non-existent policies in cleanup code (check return value)")),(0,i.yg)("hr",null))}u.isMDXComponent=!0}}]);