"use strict";(self.webpackChunkdocumentation=self.webpackChunkdocumentation||[]).push([[528],{4022:(e,n,t)=>{t.r(n),t.d(n,{assets:()=>l,contentTitle:()=>a,default:()=>p,frontMatter:()=>r,metadata:()=>c,toc:()=>s});var i=t(1527),o=t(7942);const r={title:"matchUpEngine API"},a=void 0,c={id:"apis/matchup-engine-api",title:"matchUpEngine API",description:"All matchUpEngine methods which make a mutation return either { success: true } or { error }",source:"@site/docs/apis/matchup-engine-api.md",sourceDirName:"apis",slug:"/apis/matchup-engine-api",permalink:"/tods-competition-factory/docs/apis/matchup-engine-api",draft:!1,unlisted:!1,tags:[],version:"current",frontMatter:{title:"matchUpEngine API"},sidebar:"docs",previous:{title:"MatchUp Engine",permalink:"/tods-competition-factory/docs/engines/matchup-engine-overview"},next:{title:"Overview",permalink:"/tods-competition-factory/docs/engines/scale-engine-overview"}},l={},s=[{value:"addCollectionDefinition",id:"addcollectiondefinition",level:2},{value:"addCollectionGroup",id:"addcollectiongroup",level:2},{value:"analyzeMatchUp",id:"analyzematchup",level:3},{value:"modifyCollectionDefinition",id:"modifycollectiondefinition",level:2},{value:"orderCollectionDefinitions",id:"ordercollectiondefinitions",level:2},{value:"removeCollectionDefinition",id:"removecollectiondefinition",level:2},{value:"removeCollectionGroup",id:"removecollectiongroup",level:2},{value:"reverseScore",id:"reversescore",level:2},{value:"scoreHasValue",id:"scorehasvalue",level:2},{value:"tallyParticipantResults",id:"tallyparticipantresults",level:2},{value:"validateScore",id:"validatescore",level:2}];function d(e){const n={code:"code",h2:"h2",h3:"h3",hr:"hr",p:"p",pre:"pre",strong:"strong",...(0,o.ah)(),...e.components};return(0,i.jsxs)(i.Fragment,{children:[(0,i.jsxs)(n.p,{children:["All ",(0,i.jsx)(n.strong,{children:"matchUpEngine"})," methods which make a mutation return either ",(0,i.jsx)(n.code,{children:"{ success: true }"})," or ",(0,i.jsx)(n.code,{children:"{ error }"})]}),"\n",(0,i.jsx)(n.hr,{}),"\n",(0,i.jsx)(n.h2,{id:"addcollectiondefinition",children:"addCollectionDefinition"}),"\n",(0,i.jsxs)(n.p,{children:["Adds a ",(0,i.jsx)(n.code,{children:"collectionDefinition"})," to the specified target, either ",(0,i.jsx)(n.code,{children:"matchUp"}),", ",(0,i.jsx)(n.code,{children:"structure"}),", ",(0,i.jsx)(n.code,{children:"drawDefinition"})," or ",(0,i.jsx)(n.code,{children:"event"}),"."]}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-js",children:"matchUpEngine.addCollectionDefinition({\n  updateInProgressMatchUps, // defaults to true; in progress matchUps have matchUpStatus: IN_PROGRESS\n  collectionDefinition, // will be validated\n  tieFormatName, // if not provided, existing tieFormatName will be deleted\n  uuids, // optional - array of UUIDs to use for newly created matchUps\n});\n"})}),"\n",(0,i.jsx)(n.hr,{}),"\n",(0,i.jsx)(n.h2,{id:"addcollectiongroup",children:"addCollectionGroup"}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-js",children:"matchUpEngine.addCollectionGroup({\n  tieFormatName: 'Swelled',\n  groupDefinition,\n  collectionIds,\n});\n"})}),"\n",(0,i.jsx)(n.hr,{}),"\n",(0,i.jsx)(n.h3,{id:"analyzematchup",children:"analyzeMatchUp"}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-js",children:"let analysis = matchUpEngine.analyzeMatchUp({ matchUp });\n\nconst {\n  isActiveSet,\n  isExistingSet,\n  existingValue,\n  hasExistingValue,\n  isValidSideNumber,\n  completedSetsCount,\n  isCompletedMatchUp,\n  isLastSetWithValues,\n  validMatchUpOutcome,\n  matchUpScoringFormat: {\n    bestOf,\n    setFormat: { setTo, tiebreakFormat, tiebreakAt },\n  },\n  calculatedWinningSide,\n  validMatchUpWinningSide,\n  completedSetsHaveValidOutcomes,\n  specifiedSetAnalysis: {\n    expectTiebreakSet,\n    expectTimedSet,\n    hasTiebreakCondition,\n    isCompletedSet,\n    isDecidingSet,\n    isTiebreakSet,\n    isValidSet,\n    isValidSetNumber,\n    isValidSetOutcome,\n    setFormat,\n    sideGameScores,\n    sideGameScoresCount,\n    sidePointScores,\n    sidePointScoresCount,\n    sideTiebreakScores,\n    sideTiebreakScoresCount,\n    winningSide,\n  },\n} = analysis;\n"})}),"\n",(0,i.jsx)(n.hr,{}),"\n",(0,i.jsx)(n.h2,{id:"modifycollectiondefinition",children:"modifyCollectionDefinition"}),"\n",(0,i.jsxs)(n.p,{children:["Modifies the ",(0,i.jsx)(n.code,{children:"collectionName"})," and/or ",(0,i.jsx)(n.code,{children:"matchUpFormat"})," for targeted ",(0,i.jsx)(n.code,{children:"collectionId"})," within ",(0,i.jsx)(n.code,{children:"matchUp.tieFormat"}),"."]}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-js",children:"matchUpEngine.modifyCollectionDefinition({\n  collectionName, // optional\n  matchUpFormat, // optional\n  collectionId, // required\n\n  // value assignment, only one is allowed to have a value\n  collectionValueProfiles, // optional - [{ collectionPosition: 1, value: 2 }] - there must be a value provided for all matchUp positions\n  collectionValue, // optional - value awarded for winning more than half of the matchUps in the collection\n  matchUpValue, // optional - value awarded for each matchUp won\n  scoreValue, // optional - value awarded for each game or point won (points for tiebreak sets)\n  setValue, // optional - value awarded for each set won\n  gender, // optional\n});\n"})}),"\n",(0,i.jsx)(n.hr,{}),"\n",(0,i.jsx)(n.h2,{id:"ordercollectiondefinitions",children:"orderCollectionDefinitions"}),"\n",(0,i.jsxs)(n.p,{children:["Modify the array order of ",(0,i.jsx)(n.code,{children:"tieFormat.collectionDefinitions"})," for an ",(0,i.jsx)(n.code,{children:"event"}),", a ",(0,i.jsx)(n.code,{children:"drawDefinition"}),", ",(0,i.jsx)(n.code,{children:"structure"}),", or ",(0,i.jsx)(n.code,{children:"matchUp"}),"."]}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-js",children:"matchUpEngine.orderCollectionDefinitions({\n  orderMap: { collectionId1: 1, collectionId2: 2 },\n});\n"})}),"\n",(0,i.jsx)(n.hr,{}),"\n",(0,i.jsx)(n.h2,{id:"removecollectiondefinition",children:"removeCollectionDefinition"}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-js",children:"matchUpEngine.removeCollectionDefinition({\n  updateInProgressMatchUps, // optional; defaults to true\n  tieFormatComparison, // optional; defaults to false; when true will not delete unique collections on unscored matchUps\n  tieFormatName, // any time a collectionDefinition is modified a new name must be provided\n  collectionId, // required - id of collectionDefinition to be removed\n  structureId, // optional - if removing from tieFormat associated with a specific structure\n  matchUpId, // optional - if removing from tieFormat asscoiated with a specific matchUp\n});\n"})}),"\n",(0,i.jsx)(n.hr,{}),"\n",(0,i.jsx)(n.h2,{id:"removecollectiongroup",children:"removeCollectionGroup"}),"\n",(0,i.jsxs)(n.p,{children:["Removes a ",(0,i.jsx)(n.code,{children:"collectionGroup"})," from the ",(0,i.jsx)(n.code,{children:"tieFormat"})," found for the ",(0,i.jsx)(n.code,{children:"event"}),", ",(0,i.jsx)(n.code,{children:"drawDefinition"}),", ",(0,i.jsx)(n.code,{children:"structure"})," or ",(0,i.jsx)(n.code,{children:"matchUp"}),"; recalculates"]}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-js",children:"matchUpEngine.removeCollectionGroup({\n  updateInProgressMatchUps, // optional - defaults to true\n  tieFormatName: 'New tieFormat', // if no name is provided then there will be no name\n  collectionGroupNumber: 1,\n});\n"})}),"\n",(0,i.jsx)(n.hr,{}),"\n",(0,i.jsx)(n.h2,{id:"reversescore",children:"reverseScore"}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-js",children:"const { reversedScore } = machUpEngine.reverseScore({ score });\n"})}),"\n",(0,i.jsx)(n.hr,{}),"\n",(0,i.jsx)(n.h2,{id:"scorehasvalue",children:"scoreHasValue"}),"\n",(0,i.jsxs)(n.p,{children:["Returns boolean whether or not a ",(0,i.jsx)(n.code,{children:"matchUp.score"})," contains a point, game or set value."]}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-js",children:"const result = matchUpEngine.scoreHasValue(); // use matchUp that is in state\nconst result = matchUpEngine.scoreHasValue({ matchUp }); // pass matchUp\nconst result = matchUpEngine.scoreHasValue({ score }); // pass score\n"})}),"\n",(0,i.jsx)(n.hr,{}),"\n",(0,i.jsx)(n.h2,{id:"tallyparticipantresults",children:"tallyParticipantResults"}),"\n",(0,i.jsxs)(n.p,{children:["Processes ",(0,i.jsx)(n.code,{children:"matchUps"})," of ",(0,i.jsx)(n.code,{children:"{ drawType: 'ROUND_ROBIN' }"})," from a single grouping within a ROUND_ROBIN structure and produces a detailed tally of particpant metrics."]}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-js",children:"const { participantResults } = matchUpEngine.tallyParticipantResults({\n  matchUpFormat, // required for accurate calculations\n  tallyPolicy, // optional - can configure determination of winner when tied values\n  subOrderMap, // map { [participantId]: subOrder } // manual determination of order when ties cannot be broken\n  matchUps, // optional - array of Group matchUps; will use matchUps in state when not provided\n});\n"})}),"\n",(0,i.jsx)(n.hr,{}),"\n",(0,i.jsx)(n.h2,{id:"validatescore",children:"validateScore"}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-js",children:"const { valid, error } = validateScore({\n  matchUpFormat,\n  matchUpStatus,\n  winningSide,\n  score,\n});\n"})}),"\n",(0,i.jsx)(n.hr,{})]})}function p(e={}){const{wrapper:n}={...(0,o.ah)(),...e.components};return n?(0,i.jsx)(n,{...e,children:(0,i.jsx)(d,{...e})}):d(e)}},7942:(e,n,t)=>{t.d(n,{ah:()=>s});var i=t(959);function o(e,n,t){return n in e?Object.defineProperty(e,n,{value:t,enumerable:!0,configurable:!0,writable:!0}):e[n]=t,e}function r(e,n){var t=Object.keys(e);if(Object.getOwnPropertySymbols){var i=Object.getOwnPropertySymbols(e);n&&(i=i.filter((function(n){return Object.getOwnPropertyDescriptor(e,n).enumerable}))),t.push.apply(t,i)}return t}function a(e){for(var n=1;n<arguments.length;n++){var t=null!=arguments[n]?arguments[n]:{};n%2?r(Object(t),!0).forEach((function(n){o(e,n,t[n])})):Object.getOwnPropertyDescriptors?Object.defineProperties(e,Object.getOwnPropertyDescriptors(t)):r(Object(t)).forEach((function(n){Object.defineProperty(e,n,Object.getOwnPropertyDescriptor(t,n))}))}return e}function c(e,n){if(null==e)return{};var t,i,o=function(e,n){if(null==e)return{};var t,i,o={},r=Object.keys(e);for(i=0;i<r.length;i++)t=r[i],n.indexOf(t)>=0||(o[t]=e[t]);return o}(e,n);if(Object.getOwnPropertySymbols){var r=Object.getOwnPropertySymbols(e);for(i=0;i<r.length;i++)t=r[i],n.indexOf(t)>=0||Object.prototype.propertyIsEnumerable.call(e,t)&&(o[t]=e[t])}return o}var l=i.createContext({}),s=function(e){var n=i.useContext(l),t=n;return e&&(t="function"==typeof e?e(n):a(a({},n),e)),t},d={inlineCode:"code",wrapper:function(e){var n=e.children;return i.createElement(i.Fragment,{},n)}},p=i.forwardRef((function(e,n){var t=e.components,o=e.mdxType,r=e.originalType,l=e.parentName,p=c(e,["components","mdxType","originalType","parentName"]),h=s(t),u=o,m=h["".concat(l,".").concat(u)]||h[u]||d[u]||r;return t?i.createElement(m,a(a({ref:n},p),{},{components:t})):i.createElement(m,a({ref:n},p))}));p.displayName="MDXCreateElement"}}]);