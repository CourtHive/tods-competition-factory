"use strict";(globalThis.webpackChunkdocumentation=globalThis.webpackChunkdocumentation||[]).push([[6709],{3805:(e,n,a)=>{a.d(n,{xA:()=>p,yg:()=>g});var i=a(758);function t(e,n,a){return n in e?Object.defineProperty(e,n,{value:a,enumerable:!0,configurable:!0,writable:!0}):e[n]=a,e}function o(e,n){var a=Object.keys(e);if(Object.getOwnPropertySymbols){var i=Object.getOwnPropertySymbols(e);n&&(i=i.filter((function(n){return Object.getOwnPropertyDescriptor(e,n).enumerable}))),a.push.apply(a,i)}return a}function r(e){for(var n=1;n<arguments.length;n++){var a=null!=arguments[n]?arguments[n]:{};n%2?o(Object(a),!0).forEach((function(n){t(e,n,a[n])})):Object.getOwnPropertyDescriptors?Object.defineProperties(e,Object.getOwnPropertyDescriptors(a)):o(Object(a)).forEach((function(n){Object.defineProperty(e,n,Object.getOwnPropertyDescriptor(a,n))}))}return e}function s(e,n){if(null==e)return{};var a,i,t=function(e,n){if(null==e)return{};var a,i,t={},o=Object.keys(e);for(i=0;i<o.length;i++)a=o[i],n.indexOf(a)>=0||(t[a]=e[a]);return t}(e,n);if(Object.getOwnPropertySymbols){var o=Object.getOwnPropertySymbols(e);for(i=0;i<o.length;i++)a=o[i],n.indexOf(a)>=0||Object.prototype.propertyIsEnumerable.call(e,a)&&(t[a]=e[a])}return t}var c=i.createContext({}),l=function(e){var n=i.useContext(c),a=n;return e&&(a="function"==typeof e?e(n):r(r({},n),e)),a},p=function(e){var n=l(e.components);return i.createElement(c.Provider,{value:n},e.children)},d="mdxType",y={inlineCode:"code",wrapper:function(e){var n=e.children;return i.createElement(i.Fragment,{},n)}},u=i.forwardRef((function(e,n){var a=e.components,t=e.mdxType,o=e.originalType,c=e.parentName,p=s(e,["components","mdxType","originalType","parentName"]),d=l(a),u=t,g=d["".concat(c,".").concat(u)]||d[u]||y[u]||o;return a?i.createElement(g,r(r({ref:n},p),{},{components:a})):i.createElement(g,r({ref:n},p))}));function g(e,n){var a=arguments,t=n&&n.mdxType;if("string"==typeof e||t){var o=a.length,r=new Array(o);r[0]=u;var s={};for(var c in n)hasOwnProperty.call(n,c)&&(s[c]=n[c]);s.originalType=e,s[d]="string"==typeof e?e:t,r[1]=s;for(var l=2;l<o;l++)r[l]=a[l];return i.createElement.apply(null,r)}return i.createElement.apply(null,a)}u.displayName="MDXCreateElement"},880:(e,n,a)=>{a.r(n),a.d(n,{assets:()=>c,contentTitle:()=>r,default:()=>y,frontMatter:()=>o,metadata:()=>s,toc:()=>l});var i=a(2232),t=(a(758),a(3805));const o={title:"Avoidance Policies"},r=void 0,s={unversionedId:"policies/avoidance",id:"policies/avoidance",title:"Avoidance Policies",description:"Overview",source:"@site/docs/policies/avoidance.md",sourceDirName:"policies",slug:"/policies/avoidance",permalink:"/tods-competition-factory/docs/policies/avoidance",draft:!1,tags:[],version:"current",frontMatter:{title:"Avoidance Policies"},sidebar:"docs",previous:{title:"Round Robin Tally Policy",permalink:"/tods-competition-factory/docs/policies/roundRobinTallyPolicy"},next:{title:"Position Actions Policy",permalink:"/tods-competition-factory/docs/policies/positionActions"}},c={},l=[{value:"Overview",id:"overview",level:2},{value:"Key Concepts",id:"key-concepts",level:3},{value:"Avoidance Strategies",id:"avoidance-strategies",level:2},{value:"Single Round Avoidance",id:"single-round-avoidance",level:3},{value:"Multiple Round Avoidance",id:"multiple-round-avoidance",level:3},{value:"Target Divisions",id:"target-divisions",level:3},{value:"Policy Structure",id:"policy-structure",level:2},{value:"Complete Avoidance Policy",id:"complete-avoidance-policy",level:3},{value:"Basic Usage",id:"basic-usage",level:3},{value:"Policy Properties",id:"policy-properties",level:3},{value:"Understanding Accessors in Avoidance Policies",id:"understanding-accessors-in-avoidance-policies",level:2},{value:"How Accessors Work",id:"how-accessors-work",level:3},{value:"Multiple Accessor Paths",id:"multiple-accessor-paths",level:3},{value:"Accessor Attributes",id:"accessor-attributes",level:3},{value:"key (required)",id:"key-required",level:4},{value:"significantCharacters (optional)",id:"significantcharacters-optional",level:4},{value:"Policy Directives vs Accessors",id:"policy-directives-vs-accessors",level:2},{value:"Directives for Relationship Avoidance",id:"directives-for-relationship-avoidance",level:3},{value:"includeIds Filtering",id:"includeids-filtering",level:3},{value:"Extension-Based Avoidance",id:"extension-based-avoidance",level:3},{value:"Practical Examples",id:"practical-examples",level:2},{value:"Nationality Avoidance",id:"nationality-avoidance",level:3},{value:"Club/Organization Avoidance",id:"cluborganization-avoidance",level:3},{value:"Regional Avoidance with Partial Matching",id:"regional-avoidance-with-partial-matching",level:3},{value:"Combined Avoidance Policies",id:"combined-avoidance-policies",level:3},{value:"Custom Extension Avoidance",id:"custom-extension-avoidance",level:3},{value:"Related Documentation",id:"related-documentation",level:2}],p={toc:l},d="wrapper";function y({components:e,...n}){return(0,t.yg)(d,(0,i.A)({},p,n,{components:e,mdxType:"MDXLayout"}),(0,t.yg)("h2",{id:"overview"},"Overview"),(0,t.yg)("p",null,(0,t.yg)("strong",{parentName:"p"},"Avoidance Policies")," prevent participants with shared attributes (nationality, club, region, etc.) from meeting in early rounds of elimination draws, or ensure they're evenly distributed across round robin brackets. Avoidance helps create fairer, more competitive draws by separating players with common characteristics."),(0,t.yg)("h3",{id:"key-concepts"},"Key Concepts"),(0,t.yg)("p",null,(0,t.yg)("strong",{parentName:"p"},"Avoidance"),": Separating participants with matching attributes across draw sections",(0,t.yg)("br",{parentName:"p"}),"\n",(0,t.yg)("strong",{parentName:"p"},"Accessors"),": Dot-notation paths to participant attributes (see ",(0,t.yg)("a",{parentName:"p",href:"/docs/concepts/accessors"},"Accessors"),")",(0,t.yg)("br",{parentName:"p"}),"\n",(0,t.yg)("strong",{parentName:"p"},"Rounds to Separate"),": Number of rounds to keep matching participants apart",(0,t.yg)("br",{parentName:"p"}),"\n",(0,t.yg)("strong",{parentName:"p"},"Policy Attributes"),": Array of accessors defining which participant data to match",(0,t.yg)("br",{parentName:"p"}),"\n",(0,t.yg)("strong",{parentName:"p"},"Single Round Avoidance"),": Prevent first-round matchups between grouped players",(0,t.yg)("br",{parentName:"p"}),"\n",(0,t.yg)("strong",{parentName:"p"},"Multiple Round Avoidance"),": Maximize separation throughout the draw"),(0,t.yg)("p",null,"Avoidance can be applied to ",(0,t.yg)("a",{parentName:"p",href:"./seedingPolicy#seed-positioning-patterns"},"Seed Blocks")," as well as unseeded players, though Seeded players may only be moved to other positions valid for the Seed Block within which they are placed."),(0,t.yg)("h2",{id:"avoidance-strategies"},"Avoidance Strategies"),(0,t.yg)("h3",{id:"single-round-avoidance"},"Single Round Avoidance"),(0,t.yg)("p",null,(0,t.yg)("strong",{parentName:"p"},"Goal"),": Prevent grouped players from meeting in the first round only."),(0,t.yg)("p",null,(0,t.yg)("strong",{parentName:"p"},"roundsToSeparate"),": ",(0,t.yg)("inlineCode",{parentName:"p"},"1")),(0,t.yg)("p",null,(0,t.yg)("strong",{parentName:"p"},"Implementation"),": Random placement followed by iterative shuffling to minimize first-round conflicts. In some cases, it's specifically forbidden to maximize separation beyond the first round."),(0,t.yg)("pre",null,(0,t.yg)("code",{parentName:"pre",className:"language-js"},"const firstRoundAvoidance = {\n  avoidance: {\n    policyName: 'First Round Nationality',\n    roundsToSeparate: 1,\n    policyAttributes: [{ key: 'person.nationalityCode' }],\n  },\n};\n")),(0,t.yg)("p",null,(0,t.yg)("strong",{parentName:"p"},"Use Cases:")),(0,t.yg)("ul",null,(0,t.yg)("li",{parentName:"ul"},"Large draws with many players from same groups"),(0,t.yg)("li",{parentName:"ul"},"When draw seeding takes priority over avoidance"),(0,t.yg)("li",{parentName:"ul"},"Events with time constraints on draw generation")),(0,t.yg)("h3",{id:"multiple-round-avoidance"},"Multiple Round Avoidance"),(0,t.yg)("p",null,(0,t.yg)("strong",{parentName:"p"},"Goal"),": Place players as far apart in the draw structure as possible."),(0,t.yg)("p",null,(0,t.yg)("strong",{parentName:"p"},"roundsToSeparate"),": ",(0,t.yg)("inlineCode",{parentName:"p"},"2+")," or ",(0,t.yg)("inlineCode",{parentName:"p"},"undefined")," (maximum)"),(0,t.yg)("p",null,(0,t.yg)("strong",{parentName:"p"},"Implementation"),": Divides draw into sections based on group sizes, distributing players evenly across sections. Processes largest groups first, with shuffling to accommodate smaller groups."),(0,t.yg)("pre",null,(0,t.yg)("code",{parentName:"pre",className:"language-js"},"const maxSeparation = {\n  avoidance: {\n    policyName: 'Maximum Nationality Separation',\n    roundsToSeparate: undefined, // Maximum possible separation\n    policyAttributes: [{ key: 'person.nationalityCode' }],\n  },\n};\n")),(0,t.yg)("p",null,(0,t.yg)("strong",{parentName:"p"},"Use Cases:")),(0,t.yg)("ul",null,(0,t.yg)("li",{parentName:"ul"},"ITF/ATP/WTA events with nationality restrictions"),(0,t.yg)("li",{parentName:"ul"},"National championships with regional distribution"),(0,t.yg)("li",{parentName:"ul"},"Events where player distribution quality is critical")),(0,t.yg)("h3",{id:"target-divisions"},"Target Divisions"),(0,t.yg)("p",null,"Alternative to ",(0,t.yg)("inlineCode",{parentName:"p"},"roundsToSeparate")," - specify desired number of draw sections:"),(0,t.yg)("pre",null,(0,t.yg)("code",{parentName:"pre",className:"language-js"},"const divisionBased = {\n  avoidance: {\n    policyName: 'Division-Based Avoidance',\n    targetDivisions: 4, // Divide draw into 4 sections\n    policyAttributes: [{ key: 'person.nationalityCode' }],\n  },\n};\n")),(0,t.yg)("p",null,"The system calculates ",(0,t.yg)("inlineCode",{parentName:"p"},"roundsToSeparate")," based on draw size and target divisions."),(0,t.yg)("h2",{id:"policy-structure"},"Policy Structure"),(0,t.yg)("h3",{id:"complete-avoidance-policy"},"Complete Avoidance Policy"),(0,t.yg)("pre",null,(0,t.yg)("code",{parentName:"pre",className:"language-typescript"},"type AvoidancePolicy = {\n  avoidance: {\n    policyName?: string; // Optional identifier\n    roundsToSeparate?: number; // Rounds to separate (undefined = max)\n    targetDivisions?: number; // Alternative to roundsToSeparate\n    policyAttributes: Array<{\n      key?: string; // Accessor path\n      directive?: string; // For relationships (pairParticipants, etc.)\n      significantCharacters?: number; // Partial matching\n      includeIds?: string[]; // Restrict to specific participants\n    }>;\n  };\n};\n")),(0,t.yg)("h3",{id:"basic-usage"},"Basic Usage"),(0,t.yg)("pre",null,(0,t.yg)("code",{parentName:"pre",className:"language-js"},"const AVOIDANCE_COUNTRY = {\n  avoidance: {\n    policyName: 'Nationality Code',\n    roundsToSeparate: undefined, // Maximum separation\n    policyAttributes: [{ key: 'person.nationalityCode' }, { key: 'individualParticipants.person.nationalityCode' }],\n  },\n};\n\nconst { drawDefinition } = tournamentEngine.generateDrawDefinition({\n  policyDefinitions: AVOIDANCE_COUNTRY,\n  automated: true,\n  drawSize: 32,\n  eventId: 'singles-main',\n});\n")),(0,t.yg)("h3",{id:"policy-properties"},"Policy Properties"),(0,t.yg)("p",null,(0,t.yg)("strong",{parentName:"p"},"policyName")," (optional)",(0,t.yg)("br",{parentName:"p"}),"\n","Identifier for the policy. Useful when multiple policies are attached or for debugging."),(0,t.yg)("p",null,(0,t.yg)("strong",{parentName:"p"},"roundsToSeparate")," (optional)",(0,t.yg)("br",{parentName:"p"}),"\n","Number of rounds to keep matching participants apart:"),(0,t.yg)("ul",null,(0,t.yg)("li",{parentName:"ul"},(0,t.yg)("inlineCode",{parentName:"li"},"1"),": First round only"),(0,t.yg)("li",{parentName:"ul"},(0,t.yg)("inlineCode",{parentName:"li"},"2"),", ",(0,t.yg)("inlineCode",{parentName:"li"},"3"),", etc.: Specific number of rounds"),(0,t.yg)("li",{parentName:"ul"},(0,t.yg)("inlineCode",{parentName:"li"},"undefined"),": Maximum possible separation (default)")),(0,t.yg)("p",null,(0,t.yg)("strong",{parentName:"p"},"targetDivisions")," (optional)",(0,t.yg)("br",{parentName:"p"}),"\n","Alternative to ",(0,t.yg)("inlineCode",{parentName:"p"},"roundsToSeparate"),". Specifies number of draw sections. System calculates separation based on draw size."),(0,t.yg)("p",null,(0,t.yg)("strong",{parentName:"p"},"policyAttributes")," (required)",(0,t.yg)("br",{parentName:"p"}),"\n","Array of accessor objects defining which participant attributes to match. Each object must have either ",(0,t.yg)("inlineCode",{parentName:"p"},"key")," (accessor) or ",(0,t.yg)("inlineCode",{parentName:"p"},"directive")," (relationship)."),(0,t.yg)("h2",{id:"understanding-accessors-in-avoidance-policies"},"Understanding Accessors in Avoidance Policies"),(0,t.yg)("p",null,(0,t.yg)("strong",{parentName:"p"},"policyAttributes")," is an array of ",(0,t.yg)("a",{parentName:"p",href:"/docs/concepts/accessors"},"accessor")," objects that specify which participant attributes to match for avoidance. Accessors use dot notation to navigate nested participant data structures."),(0,t.yg)("h3",{id:"how-accessors-work"},"How Accessors Work"),(0,t.yg)("p",null,"Accessors are path strings that extract values from participant objects:"),(0,t.yg)("pre",null,(0,t.yg)("code",{parentName:"pre",className:"language-js"},"// INDIVIDUAL participant structure\n{\n  participantId: 'player-1',\n  participantType: 'INDIVIDUAL',\n  person: {\n    nationalityCode: 'USA',\n    club: 'Tennis Club America'\n  }\n}\n\n// Accessor to nationality\n{ key: 'person.nationalityCode' }\n// Extracts: 'USA'\n\n// Accessor to club\n{ key: 'person.club' }\n// Extracts: 'Tennis Club America'\n")),(0,t.yg)("h3",{id:"multiple-accessor-paths"},"Multiple Accessor Paths"),(0,t.yg)("p",null,"Participant attributes may be located in different places depending on participant type (INDIVIDUAL vs PAIR):"),(0,t.yg)("pre",null,(0,t.yg)("code",{parentName:"pre",className:"language-js"},"// For INDIVIDUAL participants\n{\n  person: {\n    nationalityCode: 'FRA';\n  }\n}\n\n// For PAIR participants\n{\n  individualParticipants: [{ person: { nationalityCode: 'GBR' } }, { person: { nationalityCode: 'AUS' } }];\n}\n\n// Policy handles both structures\nconst policyAttributes = [\n  { key: 'person.nationalityCode' }, // For INDIVIDUAL\n  { key: 'individualParticipants.person.nationalityCode' }, // For PAIR\n];\n")),(0,t.yg)("p",null,"When processing PAIR participants, the accessor ",(0,t.yg)("inlineCode",{parentName:"p"},"individualParticipants.person.nationalityCode")," extracts both nationality codes (",(0,t.yg)("inlineCode",{parentName:"p"},"['GBR', 'AUS']"),"), allowing the system to avoid matching pairs that share any nationality."),(0,t.yg)("h3",{id:"accessor-attributes"},"Accessor Attributes"),(0,t.yg)("h4",{id:"key-required"},"key (required)"),(0,t.yg)("p",null,"The dot-notation path to the participant attribute:"),(0,t.yg)("pre",null,(0,t.yg)("code",{parentName:"pre",className:"language-js"},"{\n  key: 'person.nationalityCode';\n}\n{\n  key: 'person.addresses.city';\n}\n{\n  key: 'individualParticipants.person.club';\n}\n")),(0,t.yg)("p",null,(0,t.yg)("strong",{parentName:"p"},"See:")," ",(0,t.yg)("a",{parentName:"p",href:"/docs/concepts/accessors"},"Accessors")," for complete accessor syntax documentation."),(0,t.yg)("h4",{id:"significantcharacters-optional"},"significantCharacters (optional)"),(0,t.yg)("p",null,"Limits comparison to first N characters of the extracted value:"),(0,t.yg)("pre",null,(0,t.yg)("code",{parentName:"pre",className:"language-js"},"// Avoid participants from same country region\npolicyAttributes: [\n  {\n    key: 'person.nationalityCode',\n    significantCharacters: 2, // 'USA-CA' and 'USA-NY' both match on 'US'\n  },\n];\n\n// Full comparison (default)\npolicyAttributes: [\n  {\n    key: 'person.nationalityCode', // 'USA-CA' != 'USA-NY'\n  },\n];\n")),(0,t.yg)("p",null,"This is useful for hierarchical codes where partial matching is desired (regions, districts, postal codes)."),(0,t.yg)("h2",{id:"policy-directives-vs-accessors"},"Policy Directives vs Accessors"),(0,t.yg)("h3",{id:"directives-for-relationship-avoidance"},"Directives for Relationship Avoidance"),(0,t.yg)("p",null,"INDIVIDUAL participants may be members of PAIR, TEAM, and GROUP participants. Since these relationships aren't stored as simple attributes, they use ",(0,t.yg)("strong",{parentName:"p"},"directives")," instead of ",(0,t.yg)("strong",{parentName:"p"},"key")," accessors:"),(0,t.yg)("pre",null,(0,t.yg)("code",{parentName:"pre",className:"language-js"},"// Avoid matching doubles partners in singles draw\nconst pairAvoidancePolicy = {\n  roundsToSeparate: undefined,\n  policyName: 'Doubles Partner Avoidance',\n  policyAttributes: [{ directive: 'pairParticipants' }],\n};\n\n// Avoid matching teammates in singles draw\nconst teamAvoidancePolicy = {\n  roundsToSeparate: 2,\n  policyName: 'Team Member Avoidance',\n  policyAttributes: [{ directive: 'teamParticipants' }],\n};\n")),(0,t.yg)("p",null,"Before avoidance processing, these context attributes are added to INDIVIDUAL participants:"),(0,t.yg)("ul",null,(0,t.yg)("li",{parentName:"ul"},(0,t.yg)("inlineCode",{parentName:"li"},"pairParticipantIds")," - IDs of pairs this player is part of"),(0,t.yg)("li",{parentName:"ul"},(0,t.yg)("inlineCode",{parentName:"li"},"teamParticipantIds")," - IDs of teams this player is part of"),(0,t.yg)("li",{parentName:"ul"},(0,t.yg)("inlineCode",{parentName:"li"},"groupParticipantIds")," - IDs of groups this player is part of")),(0,t.yg)("h3",{id:"includeids-filtering"},"includeIds Filtering"),(0,t.yg)("p",null,"Restrict avoidance to specific participants:"),(0,t.yg)("pre",null,(0,t.yg)("code",{parentName:"pre",className:"language-js"},"policyAttributes: [\n  {\n    key: 'person.nationalityCode',\n    includeIds: ['player-1', 'player-2', 'player-3'],\n  },\n];\n// Only these three participants are considered for nationality avoidance\n")),(0,t.yg)("h3",{id:"extension-based-avoidance"},"Extension-Based Avoidance"),(0,t.yg)("p",null,"Custom attributes stored as ",(0,t.yg)("a",{parentName:"p",href:"/docs/concepts/extensions"},"extensions")," can be used for avoidance. Extensions are automatically converted to underscore-prefixed attributes before processing:"),(0,t.yg)("pre",null,(0,t.yg)("code",{parentName:"pre",className:"language-js"},"// Participant with custom region extension\n{\n  participantId: 'player-1',\n  person: { standardFamilyName: 'Smith' },\n  extensions: [\n    {\n      name: 'region',\n      value: 'Northern California'\n    }\n  ]\n}\n\n// Avoidance policy using extension\npolicyAttributes: [\n  { key: '_region' }  // Extensions become underscore-prefixed attributes\n]\n\n// After processing, participant has:\n// { ..., _region: 'Northern California' }\n")),(0,t.yg)("h2",{id:"practical-examples"},"Practical Examples"),(0,t.yg)("h3",{id:"nationality-avoidance"},"Nationality Avoidance"),(0,t.yg)("p",null,"Prevent same-country matchups in early rounds:"),(0,t.yg)("pre",null,(0,t.yg)("code",{parentName:"pre",className:"language-js"},"const nationalityAvoidance = {\n  avoidance: {\n    policyName: 'Nationality Code',\n    roundsToSeparate: 3, // Separate for 3 rounds\n    policyAttributes: [{ key: 'person.nationalityCode' }, { key: 'individualParticipants.person.nationalityCode' }],\n  },\n};\n\ntournamentEngine.generateDrawDefinition({\n  eventId: 'singles-main',\n  drawSize: 32,\n  automated: true,\n  policyDefinitions: nationalityAvoidance,\n});\n")),(0,t.yg)("h3",{id:"cluborganization-avoidance"},"Club/Organization Avoidance"),(0,t.yg)("p",null,"Separate players from same club or organization:"),(0,t.yg)("pre",null,(0,t.yg)("code",{parentName:"pre",className:"language-js"},"const clubAvoidance = {\n  avoidance: {\n    policyName: 'Club Separation',\n    roundsToSeparate: 2,\n    policyAttributes: [\n      { key: 'person.organisation.organisationName' },\n      { key: 'individualParticipants.person.organisation.organisationName' },\n    ],\n  },\n};\n")),(0,t.yg)("h3",{id:"regional-avoidance-with-partial-matching"},"Regional Avoidance with Partial Matching"),(0,t.yg)("p",null,"Use ",(0,t.yg)("inlineCode",{parentName:"p"},"significantCharacters")," for hierarchical codes:"),(0,t.yg)("pre",null,(0,t.yg)("code",{parentName:"pre",className:"language-js"},"// Postal codes: '94301', '94305', '10001', '10002'\nconst regionalAvoidance = {\n  avoidance: {\n    policyName: 'Regional Separation',\n    roundsToSeparate: 1,\n    policyAttributes: [\n      {\n        key: 'person.addresses.postalCode',\n        significantCharacters: 3, // Match on first 3 digits\n      },\n    ],\n  },\n};\n// '94301' and '94305' match on '943'\n// '10001' and '10002' match on '100'\n")),(0,t.yg)("h3",{id:"combined-avoidance-policies"},"Combined Avoidance Policies"),(0,t.yg)("p",null,"Apply multiple avoidance criteria:"),(0,t.yg)("pre",null,(0,t.yg)("code",{parentName:"pre",className:"language-js"},"const multipleAvoidance = {\n  avoidance: {\n    policyName: 'Combined Avoidance',\n    roundsToSeparate: 2,\n    policyAttributes: [\n      // Nationality avoidance\n      { key: 'person.nationalityCode' },\n      { key: 'individualParticipants.person.nationalityCode' },\n\n      // Club avoidance\n      { key: 'person.organisation.organisationName' },\n      { key: 'individualParticipants.person.organisation.organisationName' },\n\n      // Doubles partner avoidance\n      { directive: 'pairParticipants' },\n    ],\n  },\n};\n")),(0,t.yg)("p",null,"Players matching on ANY of these criteria will be separated."),(0,t.yg)("h3",{id:"custom-extension-avoidance"},"Custom Extension Avoidance"),(0,t.yg)("p",null,"Use tournament-specific groupings:"),(0,t.yg)("pre",null,(0,t.yg)("code",{parentName:"pre",className:"language-js"},"// Players have custom 'academy' extension\nconst academyAvoidance = {\n  avoidance: {\n    policyName: 'Academy Separation',\n    roundsToSeparate: undefined, // Maximum separation\n    policyAttributes: [\n      { key: '_academy' }, // Extension-based accessor\n    ],\n  },\n};\n\n// Before generating draw, add extensions\nparticipants.forEach((participant) => {\n  tournamentEngine.addParticipantExtension({\n    participantId: participant.participantId,\n    extension: {\n      name: 'academy',\n      value: participant.trainingAcademy,\n    },\n  });\n});\n\ntournamentEngine.generateDrawDefinition({\n  eventId: 'singles-main',\n  policyDefinitions: academyAvoidance,\n});\n")),(0,t.yg)("h2",{id:"related-documentation"},"Related Documentation"),(0,t.yg)("ul",null,(0,t.yg)("li",{parentName:"ul"},(0,t.yg)("strong",{parentName:"li"},(0,t.yg)("a",{parentName:"strong",href:"/docs/concepts/accessors"},"Accessors"))," - Complete accessor syntax and usage"),(0,t.yg)("li",{parentName:"ul"},(0,t.yg)("strong",{parentName:"li"},(0,t.yg)("a",{parentName:"strong",href:"/docs/concepts/participants"},"Participants"))," - Participant data structures"),(0,t.yg)("li",{parentName:"ul"},(0,t.yg)("strong",{parentName:"li"},(0,t.yg)("a",{parentName:"strong",href:"/docs/concepts/extensions"},"Extensions"))," - Custom participant attributes"),(0,t.yg)("li",{parentName:"ul"},(0,t.yg)("strong",{parentName:"li"},(0,t.yg)("a",{parentName:"strong",href:"./seedingPolicy"},"Seeding Policy"))," - Seed blocks and positioning patterns"),(0,t.yg)("li",{parentName:"ul"},(0,t.yg)("strong",{parentName:"li"},(0,t.yg)("a",{parentName:"strong",href:"/docs/governors/draws-governor#generatedrawdefinition"},"Draws Governor"))," - Draw generation with policies")))}y.isMDXComponent=!0}}]);