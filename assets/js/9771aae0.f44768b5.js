"use strict";(globalThis.webpackChunkdocumentation=globalThis.webpackChunkdocumentation||[]).push([[4978],{6213(n,e,t){t.r(e),t.d(e,{assets:()=>c,contentTitle:()=>o,default:()=>u,frontMatter:()=>r,metadata:()=>s,toc:()=>d});const s=JSON.parse('{"id":"testing/mocks-engine-patterns","title":"Advanced Patterns & Best Practices","description":"This guide covers common testing patterns, best practices, and advanced techniques for using the mocksEngine effectively.","source":"@site/docs/testing/mocks-engine-patterns.md","sourceDirName":"testing","slug":"/testing/mocks-engine-patterns","permalink":"/tods-competition-factory/docs/testing/mocks-engine-patterns","draft":false,"unlisted":false,"tags":[],"version":"current","frontMatter":{"title":"Advanced Patterns & Best Practices"},"sidebar":"docs","previous":{"title":"Outcome Generation","permalink":"/tods-competition-factory/docs/testing/mocks-engine-outcomes"},"next":{"title":"Factory Server","permalink":"/tods-competition-factory/docs/testing/factory-server"}}');var a=t(6070),i=t(8439);const r={title:"Advanced Patterns & Best Practices"},o="Advanced Patterns & Best Practices",c={},d=[{value:"Test Organization",id:"test-organization",level:2},{value:"Shared Tournament Setup",id:"shared-tournament-setup",level:3},{value:"Factory Functions",id:"factory-functions",level:3},{value:"Testing Draw Structures",id:"testing-draw-structures",level:2},{value:"Complete Draw Generation",id:"complete-draw-generation",level:3},{value:"Testing Playoff Structures",id:"testing-playoff-structures",level:3},{value:"Testing Scheduling Scenarios",id:"testing-scheduling-scenarios",level:2},{value:"Auto-Scheduling with Conflict Detection",id:"auto-scheduling-with-conflict-detection",level:3},{value:"Time-based Scheduling",id:"time-based-scheduling",level:3},{value:"Testing Match Completion",id:"testing-match-completion",level:2},{value:"Progressive Completion",id:"progressive-completion",level:3},{value:"Different Match Outcomes",id:"different-match-outcomes",level:3},{value:"Testing Participant Scenarios",id:"testing-participant-scenarios",level:2},{value:"Entry Status Testing",id:"entry-status-testing",level:3},{value:"Seeding Tests",id:"seeding-tests",level:3},{value:"Testing Team Events",id:"testing-team-events",level:2},{value:"Team Creation from Attributes",id:"team-creation-from-attributes",level:3},{value:"Understanding inContext: Hydrated vs Basic MatchUps",id:"understanding-incontext-hydrated-vs-basic-matchups",level:2},{value:"Basic MatchUps (inContext: false or omitted)",id:"basic-matchups-incontext-false-or-omitted",level:3},{value:"Fully Hydrated MatchUps (inContext: true)",id:"fully-hydrated-matchups-incontext-true",level:3},{value:"When inContext is REQUIRED",id:"when-incontext-is-required",level:3},{value:"1. Scheduling Operations",id:"1-scheduling-operations",level:4},{value:"2. Conflict Detection",id:"2-conflict-detection",level:4},{value:"3. Display/Reporting",id:"3-displayreporting",level:4},{value:"Performance Considerations",id:"performance-considerations",level:3},{value:"Best Practice Pattern",id:"best-practice-pattern",level:3},{value:"Debugging Patterns",id:"debugging-patterns",level:2},{value:"Use ID Prefixes",id:"use-id-prefixes",level:3},{value:"DevContext for Detailed Errors",id:"devcontext-for-detailed-errors",level:3},{value:"Integration Testing",id:"integration-testing",level:2},{value:"Full Tournament Lifecycle",id:"full-tournament-lifecycle",level:3},{value:"Best Practices Summary",id:"best-practices-summary",level:2},{value:"Next Steps",id:"next-steps",level:2}];function l(n){const e={a:"a",code:"code",h1:"h1",h2:"h2",h3:"h3",h4:"h4",header:"header",li:"li",ol:"ol",p:"p",pre:"pre",strong:"strong",ul:"ul",...(0,i.R)(),...n.components};return(0,a.jsxs)(a.Fragment,{children:[(0,a.jsx)(e.header,{children:(0,a.jsx)(e.h1,{id:"advanced-patterns--best-practices",children:"Advanced Patterns & Best Practices"})}),"\n",(0,a.jsx)(e.p,{children:"This guide covers common testing patterns, best practices, and advanced techniques for using the mocksEngine effectively."}),"\n",(0,a.jsx)(e.h2,{id:"test-organization",children:"Test Organization"}),"\n",(0,a.jsx)(e.h3,{id:"shared-tournament-setup",children:"Shared Tournament Setup"}),"\n",(0,a.jsx)(e.p,{children:"Create reusable tournament setups:"}),"\n",(0,a.jsx)(e.pre,{children:(0,a.jsx)(e.code,{className:"language-js",children:"import { mocksEngine } from 'tods-competition-factory';\nimport { describe, beforeEach, it, expect } from 'vitest';\n\ndescribe('Tournament Scheduling', () => {\n  beforeEach(() => {\n    // Use setState: true for convenience - no need to call setState in each test\n    mocksEngine.generateTournamentRecord({\n      drawProfiles: [{ drawSize: 16 }],\n      venueProfiles: [{ courtsCount: 4 }],\n      setState: true, // Auto-loads into tournamentEngine\n    });\n  });\n\n  it('can schedule matches', () => {\n    // Tournament already loaded - can use engine methods directly\n    const { matchUps } = tournamentEngine.allCompetitionMatchUps({\n      inContext: true, // Fully hydrated matchUps for scheduling\n      nextMatchUps: true,\n    });\n    // Test scheduling logic...\n  });\n\n  it('detects scheduling conflicts', () => {\n    // Tournament already loaded\n    const { matchUps } = tournamentEngine.allCompetitionMatchUps({\n      inContext: true, // Required for conflict detection\n      nextMatchUps: true,\n    });\n    const { rowIssues } = tournamentEngine.proConflicts({ matchUps });\n    // Test conflict detection...\n  });\n});\n"})}),"\n",(0,a.jsx)(e.h3,{id:"factory-functions",children:"Factory Functions"}),"\n",(0,a.jsx)(e.p,{children:"Create factory functions for common scenarios:"}),"\n",(0,a.jsx)(e.pre,{children:(0,a.jsx)(e.code,{className:"language-js",children:"// test/helpers/tournamentFactory.js\nexport function createTournamentWithScheduling(options = {}) {\n  const defaults = {\n    drawProfiles: [{ drawSize: 16 }],\n    venueProfiles: [{ courtsCount: 4 }],\n    startDate: '2024-06-01',\n  };\n\n  return mocksEngine.generateTournamentRecord({\n    ...defaults,\n    ...options,\n  });\n}\n\nexport function createDoublesAndSinglesTournament() {\n  return mocksEngine.generateTournamentRecord({\n    participantsProfile: { participantsCount: 64 },\n    drawProfiles: [\n      { drawSize: 32, eventType: 'SINGLES' },\n      { drawSize: 16, eventType: 'DOUBLES' },\n    ],\n  });\n}\n\n// In tests:\nimport { createTournamentWithScheduling } from './helpers/tournamentFactory';\n\ntest('scheduling test', () => {\n  const { tournamentRecord } = createTournamentWithScheduling({\n    drawProfiles: [{ drawSize: 32 }],\n  });\n  // ...\n});\n"})}),"\n",(0,a.jsx)(e.h2,{id:"testing-draw-structures",children:"Testing Draw Structures"}),"\n",(0,a.jsx)(e.h3,{id:"complete-draw-generation",children:"Complete Draw Generation"}),"\n",(0,a.jsx)(e.p,{children:"Test a complete draw with qualifying structure. Note that qualifying is a stage within the draw, not a separate draw:"}),"\n",(0,a.jsx)(e.pre,{children:(0,a.jsx)(e.code,{className:"language-js",children:"test('generates complete championship draw with qualifying', () => {\n  const { tournamentRecord, drawIds } = mocksEngine.generateTournamentRecord({\n    participantsProfile: {\n      participantsCount: 128,\n      sex: 'FEMALE',\n      category: { categoryName: 'Open', ratingType: 'WTN' },\n      scaleAllParticipants: true,\n    },\n    drawProfiles: [\n      {\n        drawSize: 64,\n        drawName: \"Women's Singles Championship\",\n        seedsCount: 16,\n        qualifiersCount: 8, // 8 positions for qualifiers\n        qualifyingProfiles: [\n          {\n            roundTarget: 1, // Qualifiers enter round 1 of main draw\n            structureProfiles: [\n              {\n                stageSequence: 1,\n                drawSize: 16, // 16 players compete for 8 spots\n                seedsCount: 4,\n              },\n            ],\n          },\n        ],\n        completionGoal: 40, // Complete 40 matchUps total\n      },\n    ],\n  });\n\n  tournamentEngine.setState(tournamentRecord);\n\n  const { matchUps } = tournamentEngine.allTournamentMatchUps();\n  const qualifyingMatches = matchUps.filter((m) => m.stage === 'QUALIFYING');\n  const mainDrawMatches = matchUps.filter((m) => m.stage === 'MAIN');\n\n  expect(qualifyingMatches.length).toBe(8); // 16 players = 8 matches\n  expect(mainDrawMatches.length).toBe(63); // 64-draw = 63 matches\n  expect(drawIds.length).toBe(1); // Single draw with qualifying stage\n});\n"})}),"\n",(0,a.jsx)(e.h3,{id:"testing-playoff-structures",children:"Testing Playoff Structures"}),"\n",(0,a.jsx)(e.pre,{children:(0,a.jsx)(e.code,{className:"language-js",children:"test('generates playoffs for positions', () => {\n  const { tournamentRecord } = mocksEngine.generateTournamentRecord({\n    drawProfiles: [\n      {\n        drawSize: 16,\n        withPlayoffs: {\n          roundProfiles: [{ 4: 1 }], // Playoffs from round 4\n          playoffPositions: [3, 4], // 3rd/4th place playoff\n          playoffAttributes: {\n            '0-4': { name: 'Bronze Medal Match', abbreviation: 'BM' },\n          },\n        },\n      },\n    ],\n  });\n\n  tournamentEngine.setState(tournamentRecord);\n  const { drawDefinition } = tournamentEngine.getEvent();\n\n  const playoffStructures = drawDefinition.structures.filter((s) => s.stage === 'PLAY_OFF');\n\n  expect(playoffStructures.length).toBeGreaterThan(0);\n});\n"})}),"\n",(0,a.jsx)(e.h2,{id:"testing-scheduling-scenarios",children:"Testing Scheduling Scenarios"}),"\n",(0,a.jsx)(e.h3,{id:"auto-scheduling-with-conflict-detection",children:"Auto-Scheduling with Conflict Detection"}),"\n",(0,a.jsx)(e.pre,{children:(0,a.jsx)(e.code,{className:"language-js",children:"test('detects participant conflicts in scheduling', () => {\n  const { tournamentRecord } = mocksEngine.generateTournamentRecord({\n    participantsProfile: { participantsCount: 32 },\n    drawProfiles: [\n      { drawSize: 16, eventType: 'SINGLES', idPrefix: 'singles' },\n      { drawSize: 8, eventType: 'DOUBLES', idPrefix: 'doubles' },\n    ],\n    venueProfiles: [{ courtsCount: 5 }],\n  });\n\n  tournamentEngine.setState(tournamentRecord);\n\n  // Schedule all matches\n  let { matchUps } = tournamentEngine.allCompetitionMatchUps({\n    inContext: true,\n    nextMatchUps: true,\n  });\n\n  const result = tournamentEngine.proAutoSchedule({\n    scheduledDate: '2024-06-01',\n    matchUps,\n  });\n\n  expect(result.success).toBe(true);\n\n  // Verify no conflicts\n  ({ matchUps } = tournamentEngine.allCompetitionMatchUps({\n    inContext: true,\n    nextMatchUps: true,\n    matchUpFilters: { scheduledDate: '2024-06-01' },\n  }));\n\n  const { rowIssues } = tournamentEngine.proConflicts({ matchUps });\n  const conflicts = Object.values(rowIssues)\n    .flat()\n    .filter((issue) => issue.issue === 'CONFLICT');\n\n  expect(conflicts.length).toBe(0);\n});\n"})}),"\n",(0,a.jsx)(e.h3,{id:"time-based-scheduling",children:"Time-based Scheduling"}),"\n",(0,a.jsx)(e.pre,{children:(0,a.jsx)(e.code,{className:"language-js",children:"test('schedules matches with time slots', () => {\n  const { tournamentRecord, venueIds } = mocksEngine.generateTournamentRecord({\n    drawProfiles: [{ drawSize: 16 }],\n    venueProfiles: [\n      {\n        courtsCount: 4,\n        startTime: '08:00',\n        endTime: '20:00',\n      },\n    ],\n  });\n\n  tournamentEngine.setState(tournamentRecord);\n\n  const { matchUps } = tournamentEngine.allTournamentMatchUps();\n\n  matchUps.slice(0, 4).forEach((matchUp, index) => {\n    const scheduledTime = `${8 + index * 2}:00`;\n\n    tournamentEngine.addMatchUpScheduleItems({\n      matchUpId: matchUp.matchUpId,\n      drawId: matchUp.drawId,\n      schedule: {\n        scheduledDate: '2024-06-01',\n        scheduledTime,\n      },\n    });\n  });\n\n  const { dateMatchUps } = tournamentEngine.competitionScheduleMatchUps({\n    matchUpFilters: { scheduledDate: '2024-06-01' },\n  });\n\n  expect(dateMatchUps.length).toBe(4);\n  expect(dateMatchUps[0].schedule.scheduledTime).toBeDefined();\n});\n"})}),"\n",(0,a.jsx)(e.h2,{id:"testing-match-completion",children:"Testing Match Completion"}),"\n",(0,a.jsx)(e.h3,{id:"progressive-completion",children:"Progressive Completion"}),"\n",(0,a.jsx)(e.p,{children:"Test draw advancement through rounds:"}),"\n",(0,a.jsx)(e.pre,{children:(0,a.jsx)(e.code,{className:"language-js",children:"test('advances draw through rounds', () => {\n  const { tournamentRecord } = mocksEngine.generateTournamentRecord({\n    drawProfiles: [{ drawSize: 8, idPrefix: 'match' }],\n  });\n\n  tournamentEngine.setState(tournamentRecord);\n\n  // Complete first round\n  let { matchUps } = tournamentEngine.allTournamentMatchUps();\n  const firstRoundMatches = matchUps.filter((m) => m.roundNumber === 1);\n\n  firstRoundMatches.forEach((matchUp) => {\n    const { outcome } = mocksEngine.generateOutcome({\n      matchUpFormat: matchUp.matchUpFormat,\n      winningSide: 1,\n    });\n\n    tournamentEngine.setMatchUpStatus({\n      matchUpId: matchUp.matchUpId,\n      drawId: matchUp.drawId,\n      outcome,\n    });\n  });\n\n  // Verify second round is ready\n  ({ matchUps } = tournamentEngine.allTournamentMatchUps());\n  const secondRoundMatches = matchUps.filter((m) => m.roundNumber === 2);\n\n  expect(secondRoundMatches.every((m) => m.sides.every((s) => s.participantId))).toBe(true);\n});\n"})}),"\n",(0,a.jsx)(e.h3,{id:"different-match-outcomes",children:"Different Match Outcomes"}),"\n",(0,a.jsx)(e.p,{children:"Test various outcome scenarios:"}),"\n",(0,a.jsx)(e.pre,{children:(0,a.jsx)(e.code,{className:"language-js",children:"test('handles various match outcomes', () => {\n  const { tournamentRecord } = mocksEngine.generateTournamentRecord({\n    drawProfiles: [\n      {\n        drawSize: 8,\n        outcomes: [\n          { roundNumber: 1, roundPosition: 1, matchUpStatus: 'COMPLETED', scoreString: '6-4 6-2', winningSide: 1 },\n          { roundNumber: 1, roundPosition: 2, matchUpStatus: 'RETIRED', winningSide: 1 },\n          { roundNumber: 1, roundPosition: 3, matchUpStatus: 'WALKOVER', winningSide: 2 },\n          { roundNumber: 1, roundPosition: 4, matchUpStatus: 'DEFAULTED', winningSide: 1 },\n        ],\n      },\n    ],\n  });\n\n  tournamentEngine.setState(tournamentRecord);\n  const { completedMatchUps } = tournamentEngine.tournamentMatchUps();\n\n  expect(completedMatchUps.length).toBe(4);\n  expect(completedMatchUps.map((m) => m.matchUpStatus).sort()).toEqual([\n    'COMPLETED',\n    'DEFAULTED',\n    'RETIRED',\n    'WALKOVER',\n  ]);\n});\n"})}),"\n",(0,a.jsx)(e.h2,{id:"testing-participant-scenarios",children:"Testing Participant Scenarios"}),"\n",(0,a.jsx)(e.h3,{id:"entry-status-testing",children:"Entry Status Testing"}),"\n",(0,a.jsx)(e.pre,{children:(0,a.jsx)(e.code,{className:"language-js",children:"test('manages alternates and direct acceptances', () => {\n  const { tournamentRecord } = mocksEngine.generateTournamentRecord({\n    participantsProfile: { participantsCount: 50 },\n    drawProfiles: [\n      {\n        drawSize: 32,\n        // 32 get DIRECT_ACCEPTANCE, 18 remain as potential alternates\n      },\n    ],\n  });\n\n  tournamentEngine.setState(tournamentRecord);\n\n  const { participants } = tournamentEngine.getParticipants();\n  const { event } = tournamentEngine.getEvent();\n  const { entries } = event;\n\n  const directAcceptance = entries.filter((e) => e.entryStatus === 'DIRECT_ACCEPTANCE');\n  const remaining = participants.length - directAcceptance.length;\n\n  expect(directAcceptance.length).toBe(32);\n  expect(remaining).toBe(18);\n});\n"})}),"\n",(0,a.jsx)(e.h3,{id:"seeding-tests",children:"Seeding Tests"}),"\n",(0,a.jsx)(e.pre,{children:(0,a.jsx)(e.code,{className:"language-js",children:"test('seeds participants by rating', () => {\n  const { tournamentRecord } = mocksEngine.generateTournamentRecord({\n    participantsProfile: {\n      participantsCount: 64,\n      category: { categoryName: 'Open', ratingType: 'WTN' },\n      scaleAllParticipants: true,\n    },\n    drawProfiles: [\n      {\n        drawSize: 32,\n        seedsCount: 8,\n      },\n    ],\n  });\n\n  tournamentEngine.setState(tournamentRecord);\n\n  const { seedAssignments } = tournamentEngine.getEvent();\n  expect(Object.keys(seedAssignments).length).toBe(8);\n\n  // Verify top seeds are in expected positions\n  const { positionAssignments } = tournamentEngine.getPositionAssignments();\n  const topSeedPosition = positionAssignments.find((pa) => pa.seedNumber === 1);\n\n  expect(topSeedPosition.drawPosition).toBe(1);\n});\n"})}),"\n",(0,a.jsx)(e.h2,{id:"testing-team-events",children:"Testing Team Events"}),"\n",(0,a.jsx)(e.h3,{id:"team-creation-from-attributes",children:"Team Creation from Attributes"}),"\n",(0,a.jsx)(e.pre,{children:(0,a.jsx)(e.code,{className:"language-js",children:"test('creates teams from participant attributes', () => {\n  const { tournamentRecord } = mocksEngine.generateTournamentRecord({\n    participantsProfile: {\n      participantsCount: 64,\n      teamKey: 'person.addresses[0].state', // Group by state\n      addressProps: {\n        statesProfile: {\n          CA: 16,\n          TX: 16,\n          NY: 16,\n          FL: 16,\n        },\n      },\n    },\n    drawProfiles: [\n      {\n        drawSize: 4,\n        eventType: 'TEAM',\n      },\n    ],\n  });\n\n  tournamentEngine.setState(tournamentRecord);\n\n  const { participants } = tournamentEngine.getParticipants({\n    participantFilters: { participantTypes: ['TEAM'] },\n  });\n\n  expect(participants.length).toBe(4);\n  participants.forEach((team) => {\n    expect(team.individualParticipantIds.length).toBeGreaterThan(0);\n  });\n});\n"})}),"\n",(0,a.jsx)(e.h2,{id:"understanding-incontext-hydrated-vs-basic-matchups",children:"Understanding inContext: Hydrated vs Basic MatchUps"}),"\n",(0,a.jsx)(e.p,{children:"A critical concept when working with matchUps is the difference between basic and fully hydrated matchUps."}),"\n",(0,a.jsx)(e.h3,{id:"basic-matchups-incontext-false-or-omitted",children:"Basic MatchUps (inContext: false or omitted)"}),"\n",(0,a.jsx)(e.pre,{children:(0,a.jsx)(e.code,{className:"language-js",children:"const { matchUps } = tournamentEngine.allTournamentMatchUps();\n\n// Basic matchUp contains:\n{\n  matchUpId: 'abc-123',\n  roundNumber: 1,\n  roundPosition: 1,\n  sides: [\n    { participantId: 'player-1' },  // Only ID, not full participant\n    { participantId: 'player-2' }\n  ],\n  // Missing: event details, participant details, venue info, etc.\n}\n"})}),"\n",(0,a.jsx)(e.h3,{id:"fully-hydrated-matchups-incontext-true",children:"Fully Hydrated MatchUps (inContext: true)"}),"\n",(0,a.jsx)(e.pre,{children:(0,a.jsx)(e.code,{className:"language-js",children:"const { matchUps } = tournamentEngine.allTournamentMatchUps({\n  inContext: true,  // Fully hydrate with contextual data\n});\n\n// Hydrated matchUp contains everything from basic, PLUS:\n{\n  // ... basic fields ...\n\n  // Event context\n  eventName: 'Singles Championship',\n  eventType: 'SINGLES',\n  gender: 'FEMALE',\n  category: { categoryName: 'U18' },\n\n  // Draw context\n  drawName: 'Main Draw',\n  drawType: 'SINGLE_ELIMINATION',\n  stage: 'MAIN',\n  structureName: 'Main',\n  roundName: 'Round of 16',\n\n  // Full participant details\n  sides: [\n    {\n      participantId: 'player-1',\n      participant: {\n        participantName: 'Jane Doe',\n        person: {\n          standardGivenName: 'Jane',\n          standardFamilyName: 'Doe',\n          nationalityCode: 'USA',\n          // ... full person details\n        },\n        // ... rankings, ratings, etc.\n      }\n    },\n    // ... side 2 with full details\n  ],\n\n  // Scheduling context (if scheduled)\n  schedule: {\n    venueId: 'venue-1',\n    venueName: 'Main Stadium',\n    venueAbbreviation: 'MS',\n    courtId: 'court-1',\n    courtName: 'Center Court',\n    scheduledDate: '2024-06-01',\n    scheduledTime: '10:00',\n  },\n\n  // Potential participants for future rounds\n  potentialParticipants: [[...], [...]],\n\n  // Dependency information\n  winnerTo: { /* next matchUp info */ },\n  loserTo: { /* consolation matchUp info */ },\n}\n"})}),"\n",(0,a.jsx)(e.h3,{id:"when-incontext-is-required",children:"When inContext is REQUIRED"}),"\n",(0,a.jsxs)(e.p,{children:["Certain operations require ",(0,a.jsx)(e.code,{children:"inContext: true"}),":"]}),"\n",(0,a.jsx)(e.h4,{id:"1-scheduling-operations",children:"1. Scheduling Operations"}),"\n",(0,a.jsx)(e.pre,{children:(0,a.jsx)(e.code,{className:"language-js",children:"// \u274c WRONG: Will fail or produce incorrect results\nconst { matchUps } = tournamentEngine.allCompetitionMatchUps();\ntournamentEngine.proAutoSchedule({ matchUps, scheduledDate: '2024-06-01' });\n\n// \u2705 CORRECT: Scheduling needs participant context\nconst { matchUps } = tournamentEngine.allCompetitionMatchUps({\n  inContext: true,\n  nextMatchUps: true, // Also needed for dependency info\n});\ntournamentEngine.proAutoSchedule({ matchUps, scheduledDate: '2024-06-01' });\n"})}),"\n",(0,a.jsx)(e.h4,{id:"2-conflict-detection",children:"2. Conflict Detection"}),"\n",(0,a.jsx)(e.pre,{children:(0,a.jsx)(e.code,{className:"language-js",children:"// \u274c WRONG: Can't detect participant conflicts without context\nconst { matchUps } = tournamentEngine.allCompetitionMatchUps();\nconst { rowIssues } = tournamentEngine.proConflicts({ matchUps });\n\n// \u2705 CORRECT: Needs participant details to detect conflicts\nconst { matchUps } = tournamentEngine.allCompetitionMatchUps({\n  inContext: true,\n  nextMatchUps: true,\n});\nconst { rowIssues } = tournamentEngine.proConflicts({ matchUps });\n"})}),"\n",(0,a.jsx)(e.h4,{id:"3-displayreporting",children:"3. Display/Reporting"}),"\n",(0,a.jsx)(e.pre,{children:(0,a.jsx)(e.code,{className:"language-js",children:'// \u274c WRONG: Can\'t display names, only IDs\nconst { matchUps } = tournamentEngine.allTournamentMatchUps();\nconsole.log(matchUps[0].sides[0].participantId); // Just an ID\n\n// \u2705 CORRECT: Has full names and details for display\nconst { matchUps } = tournamentEngine.allTournamentMatchUps({\n  inContext: true,\n});\nconsole.log(matchUps[0].sides[0].participant.participantName); // "Jane Doe"\n'})}),"\n",(0,a.jsx)(e.h3,{id:"performance-considerations",children:"Performance Considerations"}),"\n",(0,a.jsx)(e.pre,{children:(0,a.jsx)(e.code,{className:"language-js",children:"// For large datasets, consider performance tradeoff\ntest('performance-critical operation', () => {\n  // \u274c SLOW: Hydrating 1000+ matchUps is expensive\n  const { matchUps } = tournamentEngine.allTournamentMatchUps({\n    inContext: true,\n  });\n\n  // Just checking IDs\n  const matchUpIds = matchUps.map((m) => m.matchUpId);\n\n  // \u2705 FASTER: Only get what you need\n  const { matchUps: basicMatchUps } = tournamentEngine.allTournamentMatchUps();\n  const matchUpIds = basicMatchUps.map((m) => m.matchUpId);\n\n  // \u2705 BEST: Get full context only when needed\n  const matchUpId = basicMatchUps[0].matchUpId;\n  const { matchUp } = tournamentEngine.findMatchUp({\n    matchUpId,\n    inContext: true, // Hydrate just this one\n  });\n});\n"})}),"\n",(0,a.jsx)(e.h3,{id:"best-practice-pattern",children:"Best Practice Pattern"}),"\n",(0,a.jsx)(e.pre,{children:(0,a.jsx)(e.code,{className:"language-js",children:"test('efficient matchUp operations', () => {\n  mocksEngine.generateTournamentRecord({\n    drawProfiles: [{ drawSize: 32 }],\n    setState: true,\n  });\n\n  // Phase 1: Find what you need (fast, no hydration)\n  const { matchUps } = tournamentEngine.allTournamentMatchUps();\n  const firstRoundMatches = matchUps.filter((m) => m.roundNumber === 1);\n\n  // Phase 2: Get full details only for what you're using\n  const { matchUps: hydratedMatches } = tournamentEngine.allTournamentMatchUps({\n    inContext: true,\n    matchUpFilters: {\n      roundNumbers: [1], // Only hydrate first round\n    },\n  });\n\n  // Now work with fully hydrated matchUps\n  hydratedMatches.forEach((matchUp) => {\n    console.log(`${matchUp.sides[0].participant.participantName} vs ${matchUp.sides[1].participant.participantName}`);\n  });\n});\n"})}),"\n",(0,a.jsx)(e.h2,{id:"debugging-patterns",children:"Debugging Patterns"}),"\n",(0,a.jsx)(e.h3,{id:"use-id-prefixes",children:"Use ID Prefixes"}),"\n",(0,a.jsx)(e.p,{children:"Make debugging easier with meaningful prefixes:"}),"\n",(0,a.jsx)(e.pre,{children:(0,a.jsx)(e.code,{className:"language-js",children:"test('debug with prefixes', () => {\n  const { tournamentRecord } = mocksEngine.generateTournamentRecord({\n    participantsProfile: {\n      participantsCount: 32,\n      idPrefix: 'player',\n    },\n    drawProfiles: [\n      {\n        drawSize: 16,\n        idPrefix: 'match',\n      },\n    ],\n  });\n\n  tournamentEngine.setState(tournamentRecord);\n  const { matchUps } = tournamentEngine.allTournamentMatchUps();\n\n  // Console output will show: match-1-1, match-1-2, etc.\n  console.log(matchUps[0].matchUpId);\n  // And: player-I-0, player-I-1, etc.\n  console.log(matchUps[0].sides[0].participantId);\n});\n"})}),"\n",(0,a.jsx)(e.h3,{id:"devcontext-for-detailed-errors",children:"DevContext for Detailed Errors"}),"\n",(0,a.jsx)(e.pre,{children:(0,a.jsx)(e.code,{className:"language-js",children:"test('with devContext for debugging', () => {\n  mocksEngine.devContext(true);\n\n  const { tournamentRecord } = mocksEngine.generateTournamentRecord({\n    drawProfiles: [{ drawSize: 16 }],\n  });\n\n  tournamentEngine.devContext(true).setState(tournamentRecord);\n\n  // Now get detailed error messages for any issues\n  const result = tournamentEngine.setMatchUpStatus({\n    matchUpId: 'invalid-id',\n    outcome: {},\n  });\n\n  // Detailed error information available\n  expect(result.error).toBeDefined();\n});\n"})}),"\n",(0,a.jsx)(e.h2,{id:"integration-testing",children:"Integration Testing"}),"\n",(0,a.jsx)(e.h3,{id:"full-tournament-lifecycle",children:"Full Tournament Lifecycle"}),"\n",(0,a.jsx)(e.pre,{children:(0,a.jsx)(e.code,{className:"language-js",children:"test('complete tournament lifecycle', () => {\n  // 1. Generate tournament\n  const { tournamentRecord, eventIds, venueIds } = mocksEngine.generateTournamentRecord({\n    drawProfiles: [{ drawSize: 8 }],\n    venueProfiles: [{ courtsCount: 3 }],\n  });\n\n  // 2. Load into engine\n  tournamentEngine.setState(tournamentRecord);\n\n  // 3. Schedule matches\n  const { matchUps } = tournamentEngine.allCompetitionMatchUps({\n    inContext: true,\n    nextMatchUps: true,\n  });\n\n  const scheduleResult = tournamentEngine.proAutoSchedule({\n    scheduledDate: '2024-06-01',\n    matchUps,\n  });\n  expect(scheduleResult.success).toBe(true);\n\n  // 4. Complete first round\n  const { matchUps: scheduled } = tournamentEngine.allTournamentMatchUps();\n  const firstRound = scheduled.filter((m) => m.roundNumber === 1);\n\n  firstRound.forEach((matchUp) => {\n    const { outcome } = mocksEngine.generateOutcome();\n    tournamentEngine.setMatchUpStatus({\n      matchUpId: matchUp.matchUpId,\n      drawId: matchUp.drawId,\n      outcome,\n    });\n  });\n\n  // 5. Verify progression\n  const { upcomingMatchUps } = tournamentEngine.tournamentMatchUps();\n  const secondRoundReady = upcomingMatchUps.filter((m) => m.roundNumber === 2 && m.sides.every((s) => s.participantId));\n\n  expect(secondRoundReady.length).toBeGreaterThan(0);\n\n  // 6. Export and verify\n  const { tournamentRecord: final } = tournamentEngine.getTournament();\n  expect(final.events[0].drawDefinitions[0].structures[0].matchUps).toBeDefined();\n});\n"})}),"\n",(0,a.jsx)(e.h2,{id:"best-practices-summary",children:"Best Practices Summary"}),"\n",(0,a.jsxs)(e.ol,{children:["\n",(0,a.jsxs)(e.li,{children:[(0,a.jsx)(e.strong,{children:"Use setState: true"}),": Auto-load tournaments into engine for convenience"]}),"\n",(0,a.jsxs)(e.li,{children:[(0,a.jsx)(e.strong,{children:"Use inContext: true"}),": When you need full participant details, scheduling, or conflict detection"]}),"\n",(0,a.jsxs)(e.li,{children:[(0,a.jsx)(e.strong,{children:"Understand Performance"}),": Use ",(0,a.jsx)(e.code,{children:"inContext: false"})," for large datasets, true only when needed"]}),"\n",(0,a.jsxs)(e.li,{children:[(0,a.jsx)(e.strong,{children:"Reuse Tournament Structures"}),": Generate once, test multiple scenarios"]}),"\n",(0,a.jsxs)(e.li,{children:[(0,a.jsx)(e.strong,{children:"Use Factory Functions"}),": Create helper functions for common setups"]}),"\n",(0,a.jsxs)(e.li,{children:[(0,a.jsx)(e.strong,{children:"Add ID Prefixes"}),": Make debugging easier with meaningful IDs"]}),"\n",(0,a.jsxs)(e.li,{children:[(0,a.jsx)(e.strong,{children:"Enable DevContext"}),": Get detailed errors during development"]}),"\n",(0,a.jsxs)(e.li,{children:[(0,a.jsx)(e.strong,{children:"Test Edge Cases"}),": Use matchUpStatusProfile for various outcomes"]}),"\n",(0,a.jsxs)(e.li,{children:[(0,a.jsx)(e.strong,{children:"Minimize Generation"}),": Don't regenerate unnecessarily in loops"]}),"\n",(0,a.jsxs)(e.li,{children:[(0,a.jsx)(e.strong,{children:"Fixed Values for Snapshots"}),": Use fixed dates/IDs for snapshot testing"]}),"\n",(0,a.jsxs)(e.li,{children:[(0,a.jsx)(e.strong,{children:"Test Complete Flows"}),": Integrate generation with engine operations"]}),"\n",(0,a.jsxs)(e.li,{children:[(0,a.jsx)(e.strong,{children:"Organize Tests Logically"}),": Group related tests, use shared setup"]}),"\n",(0,a.jsxs)(e.li,{children:[(0,a.jsx)(e.strong,{children:"Document Complex Scenarios"}),": Add comments explaining non-obvious test setups"]}),"\n",(0,a.jsxs)(e.li,{children:[(0,a.jsx)(e.strong,{children:"Phase Your Operations"}),": Get basic data first, hydrate only what you need"]}),"\n"]}),"\n",(0,a.jsx)(e.h2,{id:"next-steps",children:"Next Steps"}),"\n",(0,a.jsxs)(e.ul,{children:["\n",(0,a.jsxs)(e.li,{children:[(0,a.jsx)(e.strong,{children:(0,a.jsx)(e.a,{href:"/tods-competition-factory/docs/testing/mocks-engine-tournament-generation",children:"Tournament Generation"})})," - Complete tournament generation options"]}),"\n",(0,a.jsxs)(e.li,{children:[(0,a.jsx)(e.strong,{children:(0,a.jsx)(e.a,{href:"/tods-competition-factory/docs/testing/mocks-engine-participants",children:"Participant Generation"})})," - Types and demographics"]}),"\n",(0,a.jsxs)(e.li,{children:[(0,a.jsx)(e.strong,{children:(0,a.jsx)(e.a,{href:"/tods-competition-factory/docs/testing/mocks-engine-outcomes",children:"Outcome Generation"})})," - Match results and scores"]}),"\n"]})]})}function u(n={}){const{wrapper:e}={...(0,i.R)(),...n.components};return e?(0,a.jsx)(e,{...n,children:(0,a.jsx)(l,{...n})}):l(n)}},8439(n,e,t){t.d(e,{R:()=>r,x:()=>o});var s=t(758);const a={},i=s.createContext(a);function r(n){const e=s.useContext(i);return s.useMemo(function(){return"function"==typeof n?n(e):{...e,...n}},[e,n])}function o(n){let e;return e=n.disableParentContext?"function"==typeof n.components?n.components(a):n.components||a:r(n.components),s.createElement(i.Provider,{value:e},n.children)}}}]);