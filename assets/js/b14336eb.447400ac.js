"use strict";(globalThis.webpackChunkdocumentation=globalThis.webpackChunkdocumentation||[]).push([[1205],{7435(e,n,i){i.r(n),i.d(n,{assets:()=>c,contentTitle:()=>d,default:()=>h,frontMatter:()=>l,metadata:()=>t,toc:()=>a});const t=JSON.parse('{"id":"temporal-engine/event-system-and-validation","title":"Event System & Validation","description":"The TemporalEngine provides two complementary feedback mechanisms: an event subscription system for reacting to state changes in real-time, and a validation pipeline for verifying plan state consistency.","source":"@site/docs/temporal-engine/event-system-and-validation.md","sourceDirName":"temporal-engine","slug":"/temporal-engine/event-system-and-validation","permalink":"/competition-factory/docs/temporal-engine/event-system-and-validation","draft":false,"unlisted":false,"tags":[],"version":"current","frontMatter":{"title":"Event System & Validation"},"sidebar":"docs","previous":{"title":"Core API Reference","permalink":"/competition-factory/docs/temporal-engine/temporal-engine-api"},"next":{"title":"Block Types & Algorithms","permalink":"/competition-factory/docs/temporal-engine/block-types-and-algorithms"}}');var s=i(6070),r=i(8322);const l={title:"Event System & Validation"},d=void 0,c={},a=[{value:"Event Subscription",id:"event-subscription",level:2},{value:"subscribe",id:"subscribe",level:3},{value:"EngineEvent Interface",id:"engineevent-interface",level:3},{value:"Event Types",id:"event-types",level:3},{value:"Conflict Evaluators",id:"conflict-evaluators",level:2},{value:"ConflictEvaluator Interface",id:"conflictevaluator-interface",level:3},{value:"EngineConflict Interface",id:"engineconflict-interface",level:3},{value:"Severity Behavior",id:"severity-behavior",level:3},{value:"Built-in Evaluators",id:"built-in-evaluators",level:3},{value:"Registering Evaluators",id:"registering-evaluators",level:3},{value:"Custom Evaluator Example",id:"custom-evaluator-example",level:3},{value:"Utility Functions",id:"utility-functions",level:3},{value:"Validation Pipeline",id:"validation-pipeline",level:2},{value:"Phases",id:"phases",level:3},{value:"Running the Pipeline",id:"running-the-pipeline",level:3},{value:"ValidationPipelineParams",id:"validationpipelineparams",level:3},{value:"RuleResult Interface",id:"ruleresult-interface",level:3},{value:"ValidationPipelineResult",id:"validationpipelineresult",level:3},{value:"Fix Actions",id:"fix-actions",level:3},{value:"Related Documentation",id:"related-documentation",level:2}];function o(e){const n={a:"a",admonition:"admonition",code:"code",em:"em",h2:"h2",h3:"h3",hr:"hr",li:"li",p:"p",pre:"pre",strong:"strong",table:"table",tbody:"tbody",td:"td",th:"th",thead:"thead",tr:"tr",ul:"ul",...(0,r.R)(),...e.components};return(0,s.jsxs)(s.Fragment,{children:[(0,s.jsxs)(n.p,{children:["The TemporalEngine provides two complementary feedback mechanisms: an ",(0,s.jsx)(n.strong,{children:"event subscription system"})," for reacting to state changes in real-time, and a ",(0,s.jsx)(n.strong,{children:"validation pipeline"})," for verifying plan state consistency."]}),"\n",(0,s.jsx)(n.h2,{id:"event-subscription",children:"Event Subscription"}),"\n",(0,s.jsx)(n.h3,{id:"subscribe",children:"subscribe"}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-ts",children:"subscribe(listener: (event: EngineEvent) => void): () => void\n"})}),"\n",(0,s.jsx)(n.p,{children:"Register a listener for engine events. Returns an unsubscribe function."}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-js",children:"const unsubscribe = engine.subscribe((event) => {\n  switch (event.type) {\n    case 'STATE_CHANGED':\n      console.log('State changed:', event.payload.reason);\n      break;\n    case 'BLOCKS_CHANGED':\n      renderTimeline(event.payload.mutations);\n      break;\n    case 'CONFLICTS_CHANGED':\n      showConflictOverlays(event.payload.conflicts);\n      break;\n    case 'AVAILABILITY_CHANGED':\n      updateTimelineWindow();\n      break;\n    case 'PLAN_CHANGED':\n      refreshSchedulingProfile();\n      break;\n  }\n});\n"})}),"\n",(0,s.jsx)(n.h3,{id:"engineevent-interface",children:"EngineEvent Interface"}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-ts",children:"interface EngineEvent {\n  type: EngineEventType;\n  payload: any;\n}\n"})}),"\n",(0,s.jsx)(n.h3,{id:"event-types",children:"Event Types"}),"\n",(0,s.jsxs)(n.table,{children:[(0,s.jsx)(n.thead,{children:(0,s.jsxs)(n.tr,{children:[(0,s.jsx)(n.th,{children:"Event Type"}),(0,s.jsx)(n.th,{children:"Payload"}),(0,s.jsx)(n.th,{children:"Emitted When"})]})}),(0,s.jsxs)(n.tbody,{children:[(0,s.jsxs)(n.tr,{children:[(0,s.jsx)(n.td,{children:(0,s.jsx)(n.code,{children:"STATE_CHANGED"})}),(0,s.jsx)(n.td,{children:(0,s.jsx)(n.code,{children:"{ reason: string }"})}),(0,s.jsx)(n.td,{children:"Any state change \u2014 init, block mutations, plan changes, tournament record update"})]}),(0,s.jsxs)(n.tr,{children:[(0,s.jsx)(n.td,{children:(0,s.jsx)(n.code,{children:"BLOCKS_CHANGED"})}),(0,s.jsx)(n.td,{children:(0,s.jsx)(n.code,{children:"{ mutations: BlockMutation[] }"})}),(0,s.jsx)(n.td,{children:"Blocks added, updated, or removed"})]}),(0,s.jsxs)(n.tr,{children:[(0,s.jsx)(n.td,{children:(0,s.jsx)(n.code,{children:"CONFLICTS_CHANGED"})}),(0,s.jsx)(n.td,{children:(0,s.jsx)(n.code,{children:"{ conflicts: EngineConflict[] }"})}),(0,s.jsx)(n.td,{children:"Conflicts detected after a mutation"})]}),(0,s.jsxs)(n.tr,{children:[(0,s.jsx)(n.td,{children:(0,s.jsx)(n.code,{children:"AVAILABILITY_CHANGED"})}),(0,s.jsx)(n.td,{children:(0,s.jsx)(n.code,{children:"{}"})}),(0,s.jsx)(n.td,{children:"Court or venue availability window changed"})]}),(0,s.jsxs)(n.tr,{children:[(0,s.jsx)(n.td,{children:(0,s.jsx)(n.code,{children:"PLAN_CHANGED"})}),(0,s.jsx)(n.td,{children:(0,s.jsx)(n.code,{children:"{}"})}),(0,s.jsx)(n.td,{children:"Plan items added, removed, updated, or moved"})]})]})]}),"\n",(0,s.jsx)(n.p,{children:(0,s.jsxs)(n.strong,{children:[(0,s.jsx)(n.code,{children:"STATE_CHANGED"})," reasons:"]})}),"\n",(0,s.jsxs)(n.table,{children:[(0,s.jsx)(n.thead,{children:(0,s.jsxs)(n.tr,{children:[(0,s.jsx)(n.th,{children:"Reason"}),(0,s.jsx)(n.th,{children:"Trigger"})]})}),(0,s.jsxs)(n.tbody,{children:[(0,s.jsxs)(n.tr,{children:[(0,s.jsx)(n.td,{children:(0,s.jsx)(n.code,{children:"'INIT'"})}),(0,s.jsxs)(n.td,{children:[(0,s.jsx)(n.code,{children:"init()"})," completed"]})]}),(0,s.jsxs)(n.tr,{children:[(0,s.jsx)(n.td,{children:(0,s.jsx)(n.code,{children:"'TOURNAMENT_RECORD_UPDATED'"})}),(0,s.jsxs)(n.td,{children:[(0,s.jsx)(n.code,{children:"updateTournamentRecord()"})," called"]})]}),(0,s.jsxs)(n.tr,{children:[(0,s.jsx)(n.td,{children:(0,s.jsx)(n.code,{children:"'BLOCKS_MUTATED'"})}),(0,s.jsx)(n.td,{children:"Any block CRUD operation"})]}),(0,s.jsxs)(n.tr,{children:[(0,s.jsx)(n.td,{children:(0,s.jsx)(n.em,{children:"(from plan methods)"})}),(0,s.jsxs)(n.td,{children:[(0,s.jsx)(n.code,{children:"addPlanItem"}),", ",(0,s.jsx)(n.code,{children:"removePlanItem"}),", ",(0,s.jsx)(n.code,{children:"updatePlanItem"}),", ",(0,s.jsx)(n.code,{children:"movePlanItem"})]})]})]})]}),"\n",(0,s.jsx)(n.admonition,{type:"note",children:(0,s.jsxs)(n.p,{children:["Event handlers are called ",(0,s.jsx)(n.strong,{children:"synchronously"}),". A failing handler will not break the engine \u2014 errors are caught and logged to ",(0,s.jsx)(n.code,{children:"console.error"})," \u2014 but long-running handlers will block the mutation return. Keep handlers fast and delegate heavy work (like DOM updates) to the next microtask."]})}),"\n",(0,s.jsx)(n.hr,{}),"\n",(0,s.jsx)(n.h2,{id:"conflict-evaluators",children:"Conflict Evaluators"}),"\n",(0,s.jsxs)(n.p,{children:["Conflict evaluators are pluggable functions that inspect block mutations and report conflicts. They run during every block CRUD operation (",(0,s.jsx)(n.code,{children:"applyBlock"}),", ",(0,s.jsx)(n.code,{children:"moveBlock"}),", ",(0,s.jsx)(n.code,{children:"resizeBlock"}),")."]}),"\n",(0,s.jsx)(n.h3,{id:"conflictevaluator-interface",children:"ConflictEvaluator Interface"}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-ts",children:"interface ConflictEvaluator {\n  id: string;\n  description: string;\n  evaluate: (ctx: EngineContext, mutations: BlockMutation[]) => EngineConflict[];\n}\n"})}),"\n",(0,s.jsx)(n.h3,{id:"engineconflict-interface",children:"EngineConflict Interface"}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-ts",children:"interface EngineConflict {\n  code: string;\n  message: string;\n  severity: ConflictSeverity;   // 'ERROR' | 'WARN' | 'INFO'\n  timeRange: TimeRange;\n  courts: CourtRef[];\n  relatedMatches?: string[];\n}\n"})}),"\n",(0,s.jsx)(n.h3,{id:"severity-behavior",children:"Severity Behavior"}),"\n",(0,s.jsxs)(n.table,{children:[(0,s.jsx)(n.thead,{children:(0,s.jsxs)(n.tr,{children:[(0,s.jsx)(n.th,{children:"Severity"}),(0,s.jsx)(n.th,{children:"Behavior"})]})}),(0,s.jsxs)(n.tbody,{children:[(0,s.jsxs)(n.tr,{children:[(0,s.jsx)(n.td,{children:(0,s.jsx)(n.code,{children:"ERROR"})}),(0,s.jsxs)(n.td,{children:["Mutation is ",(0,s.jsx)(n.strong,{children:"rejected"})," \u2014 appears in ",(0,s.jsx)(n.code,{children:"result.rejected"})]})]}),(0,s.jsxs)(n.tr,{children:[(0,s.jsx)(n.td,{children:(0,s.jsx)(n.code,{children:"WARN"})}),(0,s.jsxs)(n.td,{children:["Mutation is ",(0,s.jsx)(n.strong,{children:"applied"})," but the warning is included in ",(0,s.jsx)(n.code,{children:"result.conflicts"})]})]}),(0,s.jsxs)(n.tr,{children:[(0,s.jsx)(n.td,{children:(0,s.jsx)(n.code,{children:"INFO"})}),(0,s.jsxs)(n.td,{children:["Mutation is ",(0,s.jsx)(n.strong,{children:"applied"})," with informational note in ",(0,s.jsx)(n.code,{children:"result.conflicts"})]})]})]})]}),"\n",(0,s.jsx)(n.h3,{id:"built-in-evaluators",children:"Built-in Evaluators"}),"\n",(0,s.jsxs)(n.table,{children:[(0,s.jsx)(n.thead,{children:(0,s.jsxs)(n.tr,{children:[(0,s.jsx)(n.th,{children:"Evaluator"}),(0,s.jsx)(n.th,{children:"ID"}),(0,s.jsx)(n.th,{children:"Description"})]})}),(0,s.jsxs)(n.tbody,{children:[(0,s.jsxs)(n.tr,{children:[(0,s.jsx)(n.td,{children:(0,s.jsx)(n.code,{children:"courtOverlapEvaluator"})}),(0,s.jsx)(n.td,{children:(0,s.jsx)(n.code,{children:"COURT_OVERLAP"})}),(0,s.jsx)(n.td,{children:"Detects when blocks overlap on the same court"})]}),(0,s.jsxs)(n.tr,{children:[(0,s.jsx)(n.td,{children:(0,s.jsx)(n.code,{children:"dayBoundaryEvaluator"})}),(0,s.jsx)(n.td,{children:(0,s.jsx)(n.code,{children:"DAY_BOUNDARY"})}),(0,s.jsx)(n.td,{children:"Detects blocks that extend beyond the day's availability window"})]}),(0,s.jsxs)(n.tr,{children:[(0,s.jsx)(n.td,{children:(0,s.jsx)(n.code,{children:"blockDurationEvaluator"})}),(0,s.jsx)(n.td,{children:(0,s.jsx)(n.code,{children:"BLOCK_DURATION"})}),(0,s.jsx)(n.td,{children:"Validates block duration against minimum/maximum thresholds"})]}),(0,s.jsxs)(n.tr,{children:[(0,s.jsx)(n.td,{children:(0,s.jsx)(n.code,{children:"matchWindowEvaluator"})}),(0,s.jsx)(n.td,{children:(0,s.jsx)(n.code,{children:"MATCH_WINDOW"})}),(0,s.jsx)(n.td,{children:"Checks that scheduled match blocks fit within available windows"})]}),(0,s.jsxs)(n.tr,{children:[(0,s.jsx)(n.td,{children:(0,s.jsx)(n.code,{children:"adjacentBlockEvaluator"})}),(0,s.jsx)(n.td,{children:(0,s.jsx)(n.code,{children:"ADJACENT_BLOCK"})}),(0,s.jsx)(n.td,{children:"Warns about blocks with no gap between them (back-to-back scheduling)"})]}),(0,s.jsxs)(n.tr,{children:[(0,s.jsx)(n.td,{children:(0,s.jsx)(n.code,{children:"lightingEvaluator"})}),(0,s.jsx)(n.td,{children:(0,s.jsx)(n.code,{children:"LIGHTING"})}),(0,s.jsx)(n.td,{children:"Warns when blocks extend past sunset on courts without lights"})]}),(0,s.jsxs)(n.tr,{children:[(0,s.jsx)(n.td,{children:(0,s.jsx)(n.code,{children:"maintenanceWindowEvaluator"})}),(0,s.jsx)(n.td,{children:(0,s.jsx)(n.code,{children:"MAINTENANCE_WINDOW"})}),(0,s.jsx)(n.td,{children:"Validates maintenance blocks against venue maintenance policies"})]})]})]}),"\n",(0,s.jsx)(n.h3,{id:"registering-evaluators",children:"Registering Evaluators"}),"\n",(0,s.jsx)(n.p,{children:"Pass evaluators during initialization:"}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-js",children:"import {\n  TemporalEngine,\n  defaultEvaluators,\n} from 'tods-competition-factory';\n\nconst engine = new TemporalEngine();\nengine.init(tournamentRecord, {\n  conflictEvaluators: defaultEvaluators,\n});\n"})}),"\n",(0,s.jsx)(n.p,{children:"Or pick specific evaluators:"}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-js",children:"import {\n  courtOverlapEvaluator,\n  dayBoundaryEvaluator,\n  blockDurationEvaluator,\n} from 'tods-competition-factory';\n\nengine.init(tournamentRecord, {\n  conflictEvaluators: [\n    courtOverlapEvaluator,\n    dayBoundaryEvaluator,\n    blockDurationEvaluator,\n  ],\n});\n"})}),"\n",(0,s.jsx)(n.h3,{id:"custom-evaluator-example",children:"Custom Evaluator Example"}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-js",children:"const noWeekendMatchesEvaluator = {\n  id: 'NO_WEEKEND_MATCHES',\n  description: 'Prevents scheduling matches on weekends',\n  evaluate: (ctx, mutations) => {\n    const conflicts = [];\n    for (const mut of mutations) {\n      if (mut.kind !== 'ADD_BLOCK' || mut.block.type !== 'SCHEDULED') continue;\n      const date = new Date(mut.block.start);\n      const dayOfWeek = date.getDay();\n      if (dayOfWeek === 0 || dayOfWeek === 6) {\n        conflicts.push({\n          code: 'NO_WEEKEND_MATCHES',\n          message: `Match scheduled on ${dayOfWeek === 0 ? 'Sunday' : 'Saturday'}`,\n          severity: 'ERROR',\n          timeRange: { start: mut.block.start, end: mut.block.end },\n          courts: [mut.block.court],\n        });\n      }\n    }\n    return conflicts;\n  },\n};\n"})}),"\n",(0,s.jsx)(n.h3,{id:"utility-functions",children:"Utility Functions"}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-ts",children:"// Group conflicts by severity level\ngroupConflictsBySeverity(conflicts: EngineConflict[]): {\n  errors: EngineConflict[];\n  warnings: EngineConflict[];\n  info: EngineConflict[];\n}\n\n// Get the highest severity in a set of conflicts\ngetHighestSeverity(conflicts: EngineConflict[]): 'ERROR' | 'WARN' | 'INFO' | null\n\n// Format conflicts as human-readable strings\nformatConflicts(conflicts: EngineConflict[]): string[]\n"})}),"\n",(0,s.jsx)(n.hr,{}),"\n",(0,s.jsx)(n.h2,{id:"validation-pipeline",children:"Validation Pipeline"}),"\n",(0,s.jsxs)(n.p,{children:["The validation pipeline validates ",(0,s.jsx)(n.strong,{children:"plan state"})," (round assignments to days/venues) \u2014 not block mutations (those use conflict evaluators). It runs a series of rule checks across four phases, stopping on errors."]}),"\n",(0,s.jsx)(n.admonition,{type:"note",children:(0,s.jsxs)(n.p,{children:["The validation pipeline operates on plan state created via ",(0,s.jsx)(n.code,{children:"addPlanItem()"}),", ",(0,s.jsx)(n.code,{children:"updatePlanItem()"}),", and ",(0,s.jsx)(n.code,{children:"movePlanItem()"}),". It does ",(0,s.jsx)(n.strong,{children:"not"})," validate block CRUD operations \u2014 that is the job of ",(0,s.jsx)(n.a,{href:"#conflict-evaluators",children:"conflict evaluators"}),"."]})}),"\n",(0,s.jsx)(n.h3,{id:"phases",children:"Phases"}),"\n",(0,s.jsxs)(n.table,{children:[(0,s.jsx)(n.thead,{children:(0,s.jsxs)(n.tr,{children:[(0,s.jsx)(n.th,{children:"Phase"}),(0,s.jsx)(n.th,{children:"Purpose"}),(0,s.jsx)(n.th,{children:"Error Behavior"})]})}),(0,s.jsxs)(n.tbody,{children:[(0,s.jsxs)(n.tr,{children:[(0,s.jsx)(n.td,{children:(0,s.jsx)(n.code,{children:"PRECHECK"})}),(0,s.jsx)(n.td,{children:"Validates preconditions \u2014 are all referenced entities (events, draws, venues) present?"}),(0,s.jsx)(n.td,{children:"Stops pipeline if errors found"})]}),(0,s.jsxs)(n.tr,{children:[(0,s.jsx)(n.td,{children:(0,s.jsx)(n.code,{children:"INTEGRITY"})}),(0,s.jsx)(n.td,{children:"Checks structural correctness \u2014 duplicate assignments, missing required fields"}),(0,s.jsx)(n.td,{children:"Stops pipeline if errors found"})]}),(0,s.jsxs)(n.tr,{children:[(0,s.jsx)(n.td,{children:(0,s.jsx)(n.code,{children:"ORDERING"})}),(0,s.jsx)(n.td,{children:"Validates round ordering constraints \u2014 earlier rounds before later rounds"}),(0,s.jsx)(n.td,{children:"Continues to next phase"})]}),(0,s.jsxs)(n.tr,{children:[(0,s.jsx)(n.td,{children:(0,s.jsx)(n.code,{children:"CAPACITY"})}),(0,s.jsx)(n.td,{children:"Checks whether day capacity can accommodate planned rounds"}),(0,s.jsx)(n.td,{children:"Always runs (final phase)"})]})]})]}),"\n",(0,s.jsx)(n.h3,{id:"running-the-pipeline",children:"Running the Pipeline"}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-ts",children:"import { runValidationPipeline } from 'tods-competition-factory';\n\nconst result = runValidationPipeline({\n  engine,                   // TemporalEngine instance\n  day: '2026-06-15',        // Optional: validate specific day only\n  phases: ['PRECHECK', 'INTEGRITY', 'ORDERING', 'CAPACITY'],  // Optional: default all\n});\n\nconsole.log('Issues:', result.results.length);\nconsole.log('Index:', result.issueIndex);\n"})}),"\n",(0,s.jsx)(n.h3,{id:"validationpipelineparams",children:"ValidationPipelineParams"}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-ts",children:"interface ValidationPipelineParams {\n  engine: TemporalEngine;\n  day?: DayId;                    // Filter to specific day\n  phases?: ValidationPhase[];     // Subset of phases to run\n}\n"})}),"\n",(0,s.jsx)(n.h3,{id:"ruleresult-interface",children:"RuleResult Interface"}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-ts",children:"interface RuleResult {\n  ruleId: string;\n  phase: ValidationPhase;         // 'PRECHECK' | 'INTEGRITY' | 'ORDERING' | 'CAPACITY'\n  severity: ValidationSeverity;   // 'ERROR' | 'WARN' | 'INFO'\n  message: string;\n  context?: {\n    day?: string;\n    venueId?: string;\n    planItemId?: string;\n  };\n  fixAction?: FixAction;\n}\n"})}),"\n",(0,s.jsx)(n.h3,{id:"validationpipelineresult",children:"ValidationPipelineResult"}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-ts",children:"interface ValidationPipelineResult {\n  results: RuleResult[];\n  issueIndex: IssueIndex;   // Map<string, RuleResult[]> \u2014 indexed for fast lookup\n}\n"})}),"\n",(0,s.jsx)(n.h3,{id:"fix-actions",children:"Fix Actions"}),"\n",(0,s.jsxs)(n.p,{children:["Some rule results include a ",(0,s.jsx)(n.code,{children:"fixAction"})," that describes a corrective action:"]}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-ts",children:"interface FixAction {\n  type: string;           // e.g., 'JUMP_TO_ITEM', 'MOVE_ITEM_AFTER', 'OPEN_TEMPORAL_GRID'\n  description: string;\n  payload?: any;\n}\n"})}),"\n",(0,s.jsx)(n.p,{children:(0,s.jsx)(n.strong,{children:"Common fix action types:"})}),"\n",(0,s.jsxs)(n.table,{children:[(0,s.jsx)(n.thead,{children:(0,s.jsxs)(n.tr,{children:[(0,s.jsx)(n.th,{children:"Type"}),(0,s.jsx)(n.th,{children:"Description"})]})}),(0,s.jsxs)(n.tbody,{children:[(0,s.jsxs)(n.tr,{children:[(0,s.jsx)(n.td,{children:(0,s.jsx)(n.code,{children:"JUMP_TO_ITEM"})}),(0,s.jsx)(n.td,{children:"Navigate to the offending plan item"})]}),(0,s.jsxs)(n.tr,{children:[(0,s.jsx)(n.td,{children:(0,s.jsx)(n.code,{children:"MOVE_ITEM_AFTER"})}),(0,s.jsx)(n.td,{children:"Reorder a plan item to fix a precedence violation"})]}),(0,s.jsxs)(n.tr,{children:[(0,s.jsx)(n.td,{children:(0,s.jsx)(n.code,{children:"MOVE_ITEM_BEFORE"})}),(0,s.jsx)(n.td,{children:"Reorder a plan item to fix a precedence violation"})]}),(0,s.jsxs)(n.tr,{children:[(0,s.jsx)(n.td,{children:(0,s.jsx)(n.code,{children:"OPEN_TEMPORAL_GRID"})}),(0,s.jsx)(n.td,{children:"Open the temporal grid to resolve an availability issue"})]})]})]}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-js",children:"// Example: applying a fix action\nfor (const result of pipelineResult.results) {\n  if (result.fixAction?.type === 'MOVE_ITEM_AFTER') {\n    const { planItemId, targetPlanItemId } = result.fixAction.payload;\n    // Reorder items in the profile to fix ordering constraint\n  }\n}\n"})}),"\n",(0,s.jsx)(n.hr,{}),"\n",(0,s.jsx)(n.h2,{id:"related-documentation",children:"Related Documentation"}),"\n",(0,s.jsxs)(n.ul,{children:["\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.strong,{children:(0,s.jsx)(n.a,{href:"./temporal-engine-overview",children:"Overview"})})," \u2014 Introduction and architecture"]}),"\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.strong,{children:(0,s.jsx)(n.a,{href:"./temporal-engine-api",children:"Core API Reference"})})," \u2014 Complete method reference"]}),"\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.strong,{children:(0,s.jsx)(n.a,{href:"./block-types-and-algorithms",children:"Block Types & Algorithms"})})," \u2014 Block types, rail derivation, collision detection"]}),"\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.strong,{children:(0,s.jsx)(n.a,{href:"./ui-integration-scenarios",children:"UI Integration Scenarios"})})," \u2014 Building UIs with engine data"]}),"\n"]})]})}function h(e={}){const{wrapper:n}={...(0,r.R)(),...e.components};return n?(0,s.jsx)(n,{...e,children:(0,s.jsx)(o,{...e})}):o(e)}},8322(e,n,i){i.d(n,{R:()=>l,x:()=>d});var t=i(758);const s={},r=t.createContext(s);function l(e){const n=t.useContext(r);return t.useMemo(function(){return"function"==typeof e?e(n):{...n,...e}},[n,e])}function d(e){let n;return n=e.disableParentContext?"function"==typeof e.components?e.components(s):e.components||s:l(e.components),t.createElement(r.Provider,{value:n},e.children)}}}]);