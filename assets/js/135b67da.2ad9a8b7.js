"use strict";(globalThis.webpackChunkdocumentation=globalThis.webpackChunkdocumentation||[]).push([[9898],{5606(e,n,t){t.r(n),t.d(n,{assets:()=>d,contentTitle:()=>a,default:()=>p,frontMatter:()=>o,metadata:()=>i,toc:()=>l});const i=JSON.parse('{"id":"governors/entries-governor","title":"Entries Governor","description":"addDrawEntries","source":"@site/docs/governors/entries-governor.md","sourceDirName":"governors","slug":"/governors/entries-governor","permalink":"/competition-factory/docs/governors/entries-governor","draft":false,"unlisted":false,"tags":[],"version":"current","frontMatter":{"title":"Entries Governor"},"sidebar":"docs","previous":{"title":"Draws Governor","permalink":"/competition-factory/docs/governors/draws-governor"},"next":{"title":"Event Governor","permalink":"/competition-factory/docs/governors/event-governor"}}');var r=t(6070),s=t(8322);const o={title:"Entries Governor"},a=void 0,d={},l=[{value:"addDrawEntries",id:"adddrawentries",level:2},{value:"addEventEntries",id:"addevententries",level:2},{value:"Category Validation",id:"category-validation",level:3},{value:"addEventEntryPairs",id:"addevententrypairs",level:2},{value:"checkValidEntries",id:"checkvalidentries",level:2},{value:"destroyPairEntries",id:"destroypairentries",level:2},{value:"destroyPairEntry",id:"destroypairentry",level:2},{value:"getEntriesAndSeedsCount",id:"getentriesandseedscount",level:2},{value:"getMaxEntryPosition",id:"getmaxentryposition",level:2},{value:"modifyEntriesStatus",id:"modifyentriesstatus",level:2},{value:"modifyEventEntries",id:"modifyevententries",level:2},{value:"promoteAlternate",id:"promotealternate",level:2},{value:"promoteAlternates",id:"promotealternates",level:2},{value:"removeDrawEntries",id:"removedrawentries",level:2},{value:"removeEventEntries",id:"removeevententries",level:2},{value:"setEntryPosition",id:"setentryposition",level:2},{value:"setEntryPositions",id:"setentrypositions",level:2}];function c(e){const n={a:"a",admonition:"admonition",code:"code",em:"em",h2:"h2",h3:"h3",hr:"hr",li:"li",ol:"ol",p:"p",pre:"pre",strong:"strong",ul:"ul",...(0,s.R)(),...e.components};return(0,r.jsxs)(r.Fragment,{children:[(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-js",children:"import { entriesGovernor } from 'tods-competition-factory';\n"})}),"\n",(0,r.jsx)(n.h2,{id:"adddrawentries",children:"addDrawEntries"}),"\n",(0,r.jsxs)(n.p,{children:["Bulk add an array of ",(0,r.jsx)(n.code,{children:"participantIds"})," to a specific ",(0,r.jsx)(n.strong,{children:"stage"})," of a draw with a specific ",(0,r.jsx)(n.strong,{children:"entryStatus"}),". Will fail if ",(0,r.jsx)(n.code,{children:"participantIds"})," are not already present in ",(0,r.jsx)(n.code,{children:"event.entries"}),". Use ",(0,r.jsx)(n.code,{children:"addEventEntries"})," to add to both ",(0,r.jsx)(n.code,{children:"event"})," and ",(0,r.jsx)(n.code,{children:"drawDefinition"})," at the same time."]}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-js",children:"engine.addDrawEntries({\n  suppressDuplicateEntries, // do not throw error on duplicates; instead notify to DATA_ISSUE subscribers\n  ignoreStageSpace, // optional boolean to disable checking available positions\n  entryStageSequence, // optional - applies to qualifying\n  autoEntryPositions, // optional - keeps entries ordered by entryStage/entryStatus and auto-increments\n  entryStatus: ALTERNATE, // optional\n  entryStage: MAIN, // optional\n  participantIds,\n  eventId,\n  drawId,\n});\n"})}),"\n",(0,r.jsx)(n.hr,{}),"\n",(0,r.jsx)(n.h2,{id:"addevententries",children:"addEventEntries"}),"\n",(0,r.jsxs)(n.p,{children:["Adds ",(0,r.jsx)(n.code,{children:"participantIds"})," to ",(0,r.jsx)(n.code,{children:"event.entries"}),"; optionally pass drawId to add participantIds to ",(0,r.jsx)(n.code,{children:"flightProfile.flight[].drawEntries"})," at the same time. See examples in ",(0,r.jsx)(n.a,{href:"/competition-factory/docs/concepts/accessors#tournament-entry-filters",children:"Tournament Entry Filters"}),", ",(0,r.jsx)(n.a,{href:"/competition-factory/docs/concepts/events/entries#adding-entries",children:"Adding Entries"}),", ",(0,r.jsx)(n.a,{href:"/competition-factory/docs/concepts/events/flights#complete-example",children:"Complete Example"}),"."]}),"\n",(0,r.jsx)(n.p,{children:"Supports optional validation of participant eligibility against event category constraints (age ranges, rating requirements)."}),"\n",(0,r.jsx)(n.admonition,{type:"note",children:(0,r.jsxs)(n.p,{children:["Will ",(0,r.jsx)(n.strong,{children:(0,r.jsx)(n.em,{children:"not"})})," throw an error if unable to add entries into specified ",(0,r.jsx)(n.code,{children:"flightProfile.flight[].drawEntries"}),",\nwhich can occur if a ",(0,r.jsx)(n.code,{children:"drawDefinition"})," has already been generated and an attempt is made to add\na participant with ",(0,r.jsx)(n.code,{children:"entryStatus: DIRECT_ACCEPTANCE"}),"."]})}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-js",children:"engine.addEventEntries({\n  suppressDuplicateEntries, // do not throw error on duplicates; instead notify to DATA_ISSUE subscribers\n  entryStatus: ALTERNATE, // optional; defaults to DIRECT_ACCEPTANCE\n  entryStage: MAIN, // optional; defaults to MAIN\n  autoEntryPositions, // optional - keeps entries ordered by entryStage/entryStatus and auto-increments\n  enforceCategory, // optional - validate against event category (age/rating); defaults to false\n  enforceGender, // optional - validate gender; defaults to true\n  participantIds,\n  eventId,\n  drawId, // optional - will add participantIds to specified flightProfile.flight[].drawEntries and drawDefinition.entries (if possible)\n});\n"})}),"\n",(0,r.jsx)(n.h3,{id:"category-validation",children:"Category Validation"}),"\n",(0,r.jsxs)(n.p,{children:["When ",(0,r.jsx)(n.code,{children:"enforceCategory: true"}),", validates participants against event category constraints:"]}),"\n",(0,r.jsxs)(n.p,{children:[(0,r.jsx)(n.strong,{children:"Age Validation"}),":"]}),"\n",(0,r.jsxs)(n.ul,{children:["\n",(0,r.jsx)(n.li,{children:"Participant must be valid throughout entire event period (start to end date)"}),"\n",(0,r.jsxs)(n.li,{children:["Requires ",(0,r.jsx)(n.code,{children:"person.birthDate"})," if age restrictions exist"]}),"\n",(0,r.jsxs)(n.li,{children:["Combined age categories (e.g., ",(0,r.jsx)(n.code,{children:"C50-70"}),") are automatically skipped for individuals"]}),"\n"]}),"\n",(0,r.jsxs)(n.p,{children:[(0,r.jsx)(n.strong,{children:"Rating Validation"}),":"]}),"\n",(0,r.jsxs)(n.ul,{children:["\n",(0,r.jsxs)(n.li,{children:["Participant must have rating matching ",(0,r.jsx)(n.code,{children:"category.ratingType"})]}),"\n",(0,r.jsxs)(n.li,{children:["Rating value must fall within ",(0,r.jsx)(n.code,{children:"ratingMin"}),"/",(0,r.jsx)(n.code,{children:"ratingMax"})," range"]}),"\n",(0,r.jsx)(n.li,{children:"Uses most recent rating from participant's scale items"}),"\n"]}),"\n",(0,r.jsxs)(n.p,{children:[(0,r.jsx)(n.strong,{children:"Rejection Response"}),":"]}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-js",children:"const result = engine.addEventEntries({\n  participantIds: ['player1', 'player2', 'player3'],\n  enforceCategory: true,\n  eventId,\n});\n\nif (result.error) {\n  // result.context.categoryRejections contains detailed rejection information\n  result.context.categoryRejections.forEach((rejection) => {\n    console.log(`${rejection.participantName}:`);\n    rejection.rejectionReasons.forEach((reason) => {\n      console.log(`  - ${reason.reason}`);\n      console.log(`    Details:`, reason.details);\n    });\n  });\n}\n"})}),"\n",(0,r.jsxs)(n.p,{children:[(0,r.jsx)(n.strong,{children:"See:"})," ",(0,r.jsx)(n.a,{href:"/docs/concepts/events/entries#category-validation",children:"Entries - Category Validation"})," for comprehensive documentation and examples."]}),"\n",(0,r.jsx)(n.hr,{}),"\n",(0,r.jsx)(n.h2,{id:"addevententrypairs",children:"addEventEntryPairs"}),"\n",(0,r.jsxs)(n.p,{children:["Add ",(0,r.jsx)(n.strong,{children:"PAIR"})," participant to an event. Creates new ",(0,r.jsx)(n.code,{children:"{ participantType: PAIR }"})," participants if the combination of ",(0,r.jsx)(n.code,{children:"individualParticipantIds"})," does not already exist."]}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-js",children:"engine.addEventEntryPairs({\n  allowDuplicateParticipantIdPairs, // optional - boolean - allow multiple pair participants with the same individualParticipantIds\n  uuids, // optional - array of UUIDs to use for newly created pairs\n  entryStatus: ALTERNATE, // optional\n  entryStage: QUALIFYING, // optional\n  participantIdPairs,\n  eventId,\n});\n"})}),"\n",(0,r.jsx)(n.hr,{}),"\n",(0,r.jsx)(n.h2,{id:"checkvalidentries",children:"checkValidEntries"}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-js",children:"const { error, success } = engine.checkValidEntries({\n  consideredEntries, // optional array of entries to check\n  enforceGender, // optional boolean - defaults to true\n  eventId, // required\n});\n"})}),"\n",(0,r.jsx)(n.hr,{}),"\n",(0,r.jsx)(n.h2,{id:"destroypairentries",children:"destroyPairEntries"}),"\n",(0,r.jsxs)(n.p,{children:["Bulk version of ",(0,r.jsx)(n.code,{children:"destroyPairEntry"}),". Removes multiple PAIR participants from an event and converts them back to individual entries."]}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-js",children:"const { destroyedCount, errors } = engine.destroyPairEntries({\n  participantIds, // array of PAIR participant IDs to destroy\n  removeGroupParticipant, // optional boolean - also remove PAIR from tournament participants\n  eventId, // required\n  drawId, // optional\n});\n\nconsole.log(`Destroyed ${destroyedCount} pair entries`);\nif (errors.length) {\n  console.log('Errors:', errors);\n}\n"})}),"\n",(0,r.jsx)(n.p,{children:(0,r.jsx)(n.strong,{children:"Returns:"})}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-ts",children:"{\n  destroyedCount: number;  // Number of pairs successfully destroyed\n  errors: any[];           // Array of errors encountered\n}\n"})}),"\n",(0,r.jsx)(n.p,{children:(0,r.jsx)(n.strong,{children:"What it does:"})}),"\n",(0,r.jsxs)(n.ul,{children:["\n",(0,r.jsx)(n.li,{children:"Removes PAIR participants from event entries"}),"\n",(0,r.jsxs)(n.li,{children:["Adds individual participants back with ",(0,r.jsx)(n.code,{children:"entryStatus: UNGROUPED"})]}),"\n",(0,r.jsx)(n.li,{children:"Optionally removes PAIR participants from tournament entirely"}),"\n",(0,r.jsx)(n.li,{children:"Processes multiple pairs in one operation"}),"\n"]}),"\n",(0,r.jsx)(n.p,{children:(0,r.jsx)(n.strong,{children:"Use Cases:"})}),"\n",(0,r.jsxs)(n.ul,{children:["\n",(0,r.jsx)(n.li,{children:"Canceling doubles registrations and returning to singles pool"}),"\n",(0,r.jsx)(n.li,{children:"Breaking up pairs due to withdrawals"}),"\n",(0,r.jsx)(n.li,{children:"Converting doubles entries to singles entries"}),"\n",(0,r.jsx)(n.li,{children:"Cleaning up incorrect pair formations"}),"\n"]}),"\n",(0,r.jsx)(n.hr,{}),"\n",(0,r.jsx)(n.h2,{id:"destroypairentry",children:"destroyPairEntry"}),"\n",(0,r.jsxs)(n.p,{children:["Removes a ",(0,r.jsx)(n.code,{children:"{ participantType: PAIR }"})," entry from an event and adds the individualParticipantIds to entries as entryStatus: UNGROUPED"]}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-js",children:"engine.destroyPairEntry({\n  participantId, // PAIR participant ID to destroy\n  removeGroupParticipant, // optional boolean - also remove PAIR from tournament participants\n  eventId, // required\n  drawId, // optional\n});\n"})}),"\n",(0,r.jsx)(n.p,{children:(0,r.jsx)(n.strong,{children:"What it does:"})}),"\n",(0,r.jsxs)(n.ol,{children:["\n",(0,r.jsx)(n.li,{children:"Removes PAIR participant from event.entries"}),"\n",(0,r.jsxs)(n.li,{children:["Adds both individual participants to event.entries with ",(0,r.jsx)(n.code,{children:"entryStatus: UNGROUPED"})]}),"\n",(0,r.jsxs)(n.li,{children:["If ",(0,r.jsx)(n.code,{children:"drawId"})," provided, also updates draw entries"]}),"\n",(0,r.jsxs)(n.li,{children:["Optionally removes PAIR from ",(0,r.jsx)(n.code,{children:"tournamentRecord.participants"})]}),"\n"]}),"\n",(0,r.jsx)(n.p,{children:(0,r.jsx)(n.strong,{children:"Use Cases:"})}),"\n",(0,r.jsxs)(n.ul,{children:["\n",(0,r.jsx)(n.li,{children:"Player partnership dissolution"}),"\n",(0,r.jsx)(n.li,{children:"Changing doubles teams"}),"\n",(0,r.jsx)(n.li,{children:"Converting pair entry to individual entries for different event"}),"\n"]}),"\n",(0,r.jsx)(n.p,{children:(0,r.jsx)(n.strong,{children:"Notes:"})}),"\n",(0,r.jsxs)(n.ul,{children:["\n",(0,r.jsx)(n.li,{children:"Individual participants must exist in tournament"}),"\n",(0,r.jsx)(n.li,{children:"PAIR participant must be in event entries"}),"\n",(0,r.jsxs)(n.li,{children:["Use ",(0,r.jsx)(n.code,{children:"removeGroupParticipant: true"})," to clean up PAIR from entire tournament"]}),"\n",(0,r.jsxs)(n.li,{children:["See ",(0,r.jsx)(n.code,{children:"destroyPairEntries"})," for bulk operation"]}),"\n"]}),"\n",(0,r.jsx)(n.hr,{}),"\n",(0,r.jsx)(n.h2,{id:"getentriesandseedscount",children:"getEntriesAndSeedsCount"}),"\n",(0,r.jsx)(n.p,{children:"Calculates the number of seeds allowed for a draw based on entries count and seeding policy."}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-js",children:"const { entries, stageEntries, seedsCount } = engine.getEntriesAndSeedsCount({\n  policyDefinitions, // optional - seeding policy\n  drawDefinition, // optional - draw context\n  drawSize, // optional - override calculated draw size\n  stage, // required - MAIN or QUALIFYING\n  event, // required - event context\n  drawId, // optional\n});\n\nconsole.log(`${stageEntries.length} entries, ${seedsCount} seeds allowed`);\n"})}),"\n",(0,r.jsx)(n.p,{children:(0,r.jsx)(n.strong,{children:"Returns:"})}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-ts",children:"{\n  entries: Entry[];        // All event entries\n  stageEntries: Entry[];   // Entries for specified stage\n  seedsCount: number;      // Number of seeds allowed by policy\n  error?: ErrorType;\n}\n"})}),"\n",(0,r.jsxs)(n.p,{children:[(0,r.jsx)(n.strong,{children:"Purpose:"})," Determines how many seeds are allowed based on the number of entries and seeding policy configuration."]}),"\n",(0,r.jsx)(n.p,{children:(0,r.jsx)(n.strong,{children:"Seeding Policy Logic:"})}),"\n",(0,r.jsxs)(n.ul,{children:["\n",(0,r.jsx)(n.li,{children:"Checks policy definition for seedsCountThresholds"}),"\n",(0,r.jsx)(n.li,{children:"Matches entries count to threshold ranges"}),"\n",(0,r.jsx)(n.li,{children:"Returns maximum seeds allowed for that range"}),"\n",(0,r.jsx)(n.li,{children:"Falls back to standard seeding rules if no policy"}),"\n"]}),"\n",(0,r.jsx)(n.p,{children:(0,r.jsx)(n.strong,{children:"Use Cases:"})}),"\n",(0,r.jsxs)(n.ul,{children:["\n",(0,r.jsx)(n.li,{children:"Calculating seeds before draw generation"}),"\n",(0,r.jsx)(n.li,{children:"Validating seeding requests against policy"}),"\n",(0,r.jsx)(n.li,{children:"UI display of available seed positions"}),"\n",(0,r.jsx)(n.li,{children:"Enforcing tournament seeding rules"}),"\n"]}),"\n",(0,r.jsx)(n.p,{children:(0,r.jsx)(n.strong,{children:"Notes:"})}),"\n",(0,r.jsxs)(n.ul,{children:["\n",(0,r.jsx)(n.li,{children:"Uses elimination draw size calculation (next power of 2)"}),"\n",(0,r.jsx)(n.li,{children:"Respects seeding policy limits"}),"\n",(0,r.jsx)(n.li,{children:"Returns stage-specific entries (MAIN vs QUALIFYING)"}),"\n",(0,r.jsxs)(n.li,{children:["Used internally by ",(0,r.jsx)(n.code,{children:"generateDrawDefinition"})]}),"\n"]}),"\n",(0,r.jsx)(n.hr,{}),"\n",(0,r.jsx)(n.h2,{id:"getmaxentryposition",children:"getMaxEntryPosition"}),"\n",(0,r.jsxs)(n.p,{children:["Returns the highest ",(0,r.jsx)(n.code,{children:"entryPosition"})," value from entries, optionally filtered by stage and/or entryStatus."]}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-js",children:"const maxPosition = engine.getMaxEntryPosition({\n  entries, // array of entry objects\n  entryStatus, // optional filter - e.g., DIRECT_ACCEPTANCE, ALTERNATE\n  stage, // optional filter - e.g., MAIN, QUALIFYING\n});\n\n// Use for assigning next entry position\nconst nextPosition = maxPosition + 1;\n"})}),"\n",(0,r.jsxs)(n.p,{children:[(0,r.jsx)(n.strong,{children:"Returns:"})," ",(0,r.jsx)(n.code,{children:"number"})," - Highest entryPosition found, or 0 if no matches"]}),"\n",(0,r.jsx)(n.p,{children:(0,r.jsx)(n.strong,{children:"Use Cases:"})}),"\n",(0,r.jsxs)(n.ul,{children:["\n",(0,r.jsx)(n.li,{children:"Determining next entry position when adding entries"}),"\n",(0,r.jsx)(n.li,{children:"Finding last position in acceptance list"}),"\n",(0,r.jsx)(n.li,{children:"Ordering entries by position"}),"\n",(0,r.jsx)(n.li,{children:"Managing entry position sequences"}),"\n"]}),"\n",(0,r.jsx)(n.p,{children:(0,r.jsx)(n.strong,{children:"Notes:"})}),"\n",(0,r.jsxs)(n.ul,{children:["\n",(0,r.jsx)(n.li,{children:"Returns 0 if no entries match filters"}),"\n",(0,r.jsxs)(n.li,{children:["Ignores entries without ",(0,r.jsx)(n.code,{children:"entryPosition"})," (NaN values)"]}),"\n",(0,r.jsxs)(n.li,{children:["Can filter by both ",(0,r.jsx)(n.code,{children:"stage"})," and ",(0,r.jsx)(n.code,{children:"entryStatus"})," simultaneously"]}),"\n",(0,r.jsxs)(n.li,{children:["Used internally when ",(0,r.jsx)(n.code,{children:"autoEntryPositions: true"})]}),"\n"]}),"\n",(0,r.jsx)(n.hr,{}),"\n",(0,r.jsx)(n.h2,{id:"modifyentriesstatus",children:"modifyEntriesStatus"}),"\n",(0,r.jsx)(n.p,{children:"Modify the entryStatus of participants already in an event or flight/draw. Does not allow participants assigned positions in structures to have an entryStatus of WITHDRAWN."}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-js",children:"const result = engine.modifyEntriesStatus({\n  autoEntryPositions, // optional - keeps entries ordered by entryStage/entryStatus and auto-increments\n  participantIds, // ids of participants whose entryStatus will be modified\n  entryStatus, // new entryStatus\n  entryStage, // optional - e.g. QUALIFYING\n  eventSync, // optional - if there is only a single drawDefinition in event, keep event.entries in sync\n  extension, // optional - { name, value } - add if value; removes if value is undefined\n  eventId, // id of event where the modification(s) will occur\n  drawId, // optional - scope to a specific flight/draw\n  stage, // optional - scope to a specific stage\n});\n"})}),"\n",(0,r.jsx)(n.hr,{}),"\n",(0,r.jsx)(n.h2,{id:"modifyevententries",children:"modifyEventEntries"}),"\n",(0,r.jsxs)(n.p,{children:["Modify the entries for an event. For DOUBLES events automatically create PAIR participants if not already present. See examples: ",(0,r.jsx)(n.a,{href:"/competition-factory/docs/concepts/events/entries#update-entry-status",children:"Update Entry Status"}),"."]}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-js",children:"engine.modifyEventEntries({\n  entryStatus = DIRECT_ACCEPTANCE,\n  unpairedParticipantIds = [],\n  participantIdPairs = [],\n  entryStage = MAIN,\n  eventId,\n})\n"})}),"\n",(0,r.jsx)(n.hr,{}),"\n",(0,r.jsx)(n.h2,{id:"promotealternate",children:"promoteAlternate"}),"\n",(0,r.jsx)(n.p,{children:"Promotes a single alternate participant to direct acceptance status."}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-js",children:"const result = engine.promoteAlternate({\n  participantId, // required - participant to promote\n  stage, // optional - defaults to MAIN\n  stageSequence, // optional - for qualifying stages\n  eventId, // required\n  drawId, // optional - also promote in draw\n});\n"})}),"\n",(0,r.jsx)(n.p,{children:(0,r.jsx)(n.strong,{children:"Returns:"})}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-ts",children:"{\n  success: boolean;\n  entryStatusModified?: boolean;\n  error?: ErrorType;\n}\n"})}),"\n",(0,r.jsxs)(n.p,{children:[(0,r.jsx)(n.strong,{children:"Purpose:"})," Changes participant ",(0,r.jsx)(n.code,{children:"entryStatus"})," from ALTERNATE to DIRECT_ACCEPTANCE."]}),"\n",(0,r.jsx)(n.hr,{}),"\n",(0,r.jsx)(n.h2,{id:"promotealternates",children:"promoteAlternates"}),"\n",(0,r.jsxs)(n.p,{children:["Bulk version of ",(0,r.jsx)(n.code,{children:"promoteAlternate"}),". Promotes multiple alternates to direct acceptance."]}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-js",children:"const result = engine.promoteAlternates({\n  participantIds, // required - array of participant IDs to promote\n  stage, // optional - defaults to MAIN\n  stageSequence, // optional - for qualifying stages\n  eventId, // required\n  drawId, // optional - also promote in draw\n});\n"})}),"\n",(0,r.jsxs)(n.p,{children:[(0,r.jsx)(n.strong,{children:"Purpose:"})," Efficiently promote multiple alternates at once after withdrawals."]}),"\n",(0,r.jsx)(n.hr,{}),"\n",(0,r.jsx)(n.h2,{id:"removedrawentries",children:"removeDrawEntries"}),"\n",(0,r.jsx)(n.p,{children:"Removes participant entries from a drawDefinition (but not from the event)."}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-js",children:"const result = engine.removeDrawEntries({\n  participantIds, // required - array of participant IDs to remove\n  stage, // optional - target specific stage (MAIN, QUALIFYING)\n  stageSequence, // optional - target specific stage sequence\n  eventId, // required\n  drawId, // required\n});\n"})}),"\n",(0,r.jsxs)(n.p,{children:[(0,r.jsx)(n.strong,{children:"Purpose:"})," Removes entries from draw only, maintaining event entries."]}),"\n",(0,r.jsx)(n.hr,{}),"\n",(0,r.jsx)(n.h2,{id:"removeevententries",children:"removeEventEntries"}),"\n",(0,r.jsx)(n.p,{children:"Removes participant entries from an event and optionally from associated draws."}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-js",children:"const result = engine.removeEventEntries({\n  participantIds, // required - array of participant IDs to remove\n  stage, // optional - target specific stage\n  stageSequence, // optional - target specific stage sequence\n  autoRemoveUnassigned, // optional boolean - remove if not positioned in draw\n  removeFromDrawEntries, // optional boolean - also remove from draw entries\n  eventId, // required\n  drawId, // optional - specific draw to target\n});\n"})}),"\n",(0,r.jsxs)(n.p,{children:[(0,r.jsx)(n.strong,{children:"Purpose:"})," Removes entries from event and optionally from draws."]}),"\n",(0,r.jsx)(n.hr,{}),"\n",(0,r.jsx)(n.h2,{id:"setentryposition",children:"setEntryPosition"}),"\n",(0,r.jsx)(n.p,{children:"Set entry position a single event entry"}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-js",children:"engine.setEntryPosition({\n  entryPosition,\n  participantId,\n  eventId, // optional if drawId is provided\n  drawId, // optional if eventId is provided\n});\n"})}),"\n",(0,r.jsx)(n.hr,{}),"\n",(0,r.jsx)(n.h2,{id:"setentrypositions",children:"setEntryPositions"}),"\n",(0,r.jsx)(n.p,{children:"Set entry position for multiple event entries."}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-js",children:"engine.setEntryPositions({\n  entryPositions, // array of [{ entryPosition: 1, participantId: 'participantid' }]\n  eventId, // optional if drawId is provided\n  drawId, // optional if eventId is provided\n});\n"})}),"\n",(0,r.jsx)(n.hr,{})]})}function p(e={}){const{wrapper:n}={...(0,s.R)(),...e.components};return n?(0,r.jsx)(n,{...e,children:(0,r.jsx)(c,{...e})}):c(e)}},8322(e,n,t){t.d(n,{R:()=>o,x:()=>a});var i=t(758);const r={},s=i.createContext(r);function o(e){const n=i.useContext(s);return i.useMemo(function(){return"function"==typeof e?e(n):{...n,...e}},[n,e])}function a(e){let n;return n=e.disableParentContext?"function"==typeof e.components?e.components(r):e.components||r:o(e.components),i.createElement(s.Provider,{value:n},e.children)}}}]);