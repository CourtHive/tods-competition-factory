"use strict";(globalThis.webpackChunkdocumentation=globalThis.webpackChunkdocumentation||[]).push([[3059],{7337(e,n,t){t.r(n),t.d(n,{assets:()=>l,contentTitle:()=>s,default:()=>u,frontMatter:()=>a,metadata:()=>i,toc:()=>c});const i=JSON.parse('{"id":"governors/generation-governor","title":"Generation Governor","description":"drawMatic","source":"@site/docs/governors/generation-governor.md","sourceDirName":"governors","slug":"/governors/generation-governor","permalink":"/competition-factory/docs/governors/generation-governor","draft":false,"unlisted":false,"tags":[],"version":"current","frontMatter":{"title":"Generation Governor"},"sidebar":"docs","previous":{"title":"Event Governor","permalink":"/competition-factory/docs/governors/event-governor"},"next":{"title":"matchUp Governor","permalink":"/competition-factory/docs/governors/matchup-governor"}}');var r=t(6070),o=t(8322);const a={title:"Generation Governor"},s=void 0,l={},c=[{value:"drawMatic",id:"drawmatic",level:2},{value:"generateAdHocMatchUps",id:"generateadhocmatchups",level:2},{value:"generateAdHocRounds",id:"generateadhocrounds",level:2},{value:"generateAndPopulatePlayoffStructures",id:"generateandpopulateplayoffstructures",level:2},{value:"generateDrawDefinition",id:"generatedrawdefinition",level:2},{value:"generateDrawMaticRound",id:"generatedrawmaticround",level:2},{value:"generateDrawStructuresAndLinks",id:"generatedrawstructuresandlinks",level:2},{value:"generateDrawTypeAndModifyDrawDefinition",id:"generatedrawtypeandmodifydrawdefinition",level:2},{value:"generateFlightProfile",id:"generateflightprofile",level:2},{value:"generateLineUps",id:"generatelineups",level:2},{value:"generateQualifyingStructure",id:"generatequalifyingstructure",level:2},{value:"generateSeedingScaleItems",id:"generateseedingscaleitems",level:2},{value:"generateStatCrew",id:"generatestatcrew",level:2},{value:"generateVoluntaryConsolation",id:"generatevoluntaryconsolation",level:2},{value:"roundRobinGroups",id:"roundrobingroups",level:2}];function d(e){const n={a:"a",admonition:"admonition",code:"code",h2:"h2",hr:"hr",li:"li",p:"p",pre:"pre",strong:"strong",ul:"ul",...(0,o.R)(),...e.components};return(0,r.jsxs)(r.Fragment,{children:[(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-js",children:"import { generationGovernor } from 'tods-competition-factory';\n"})}),"\n",(0,r.jsx)(n.h2,{id:"drawmatic",children:"drawMatic"}),"\n",(0,r.jsxs)(n.p,{children:[(0,r.jsx)(n.strong,{children:"drawMatic"})," is a dynamic round generator for AD_HOC draws which produces participant pairings with previous opponent and team member avoidance.\nWhen ",(0,r.jsx)(n.code,{children:"{ scaleName, scaleAccessor }"})," values are present, participants will be paired for level-based play."]}),"\n",(0,r.jsxs)(n.p,{children:["The number of rounds (",(0,r.jsx)(n.code,{children:"roundsCount"}),") that can be generated is limited to ",(0,r.jsx)(n.strong,{children:"# participants - 1"}),", which is the normal size of a Round Robin, unless ",(0,r.jsx)(n.code,{children:"{ enableDoubleRobin: true }"}),", in which case the upper limit is ",(0,r.jsx)(n.strong,{children:"(# participants - 1) * 2"}),"."]}),"\n",(0,r.jsxs)(n.p,{children:["The number of participants is determined by the number of ",(0,r.jsx)(n.strong,{children:"entries"})," or the number of valid ",(0,r.jsx)(n.code,{children:"{ participantIds }"})," provided."]}),"\n",(0,r.jsx)(n.admonition,{type:"info",children:(0,r.jsx)(n.p,{children:"Inspired by the work of the Constantine who runs spectacular D3 College Tennis events using this format for flexible round generation when teams arrive and depart on different days."})}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-js",children:"const { matchUps, participantIdPairings, iterations, candidatesCount, modifiedScaleValues } = engine.drawMatic({\n  restrictRoundsCount, // optional boolean defaults to true; set to false for unlimited roundsCount\n  restrictEntryStatus, // optional - only allow STRUCTURE_SELECTED_STATUSES\n  enableDoubleRobin, // optional - allows roundsCount <= (drawSize - 1) * 2\n  generateMatchUps, // optional - defaults to true; when false only returns { participantIdPairings }\n  minimizeDelta, // boolean - force minimum delta in ratings; good for first round\n  participantIds, // optional array of [participantId] to restrict enteredParticipantIds which appear in generated round\n  maxIterations, // optional - defaults to 5000; can be used to set a limit on processing overhead\n  structureId, // optional; if no structureId is specified find the latest AD_HOC stage which has matchUps\n  matchUpIds, // optional array of uuids to be used when generating matchUps\n  eventType, // optional - override eventType of event within which draw appears; e.g. to force use of SINGLES ratings in DOUBLES events\n\n  updateParticipantRatings, // optional boolean; attach modifiedScaleValues to participants\n  dynamicRatings, // optional boolean - generate dynamic ratings from previous round results\n  refreshDynamic, // optional boolean - ignore previously generated dynamic values\n  scaleAccessor, // optional - string to access value within scaleValue, e.g. 'wtnRating'\n  scaleName, // optional - custom rating name to seed dynamic ratings\n\n  roundsCount, // REQUIRED - number of rounds to generate; limited to (1 - drawSize) unless { enableDoubleRobin: true }\n  drawId, // REQUIRED - drawId for which matchUps will be generated\n});\n"})}),"\n",(0,r.jsx)(n.hr,{}),"\n",(0,r.jsx)(n.h2,{id:"generateadhocmatchups",children:"generateAdHocMatchUps"}),"\n",(0,r.jsxs)(n.p,{children:["Draws with ",(0,r.jsx)(n.code,{children:"{ drawType: AD_HOC }"})," allow ",(0,r.jsx)(n.code,{children:"matchUps"})," to be dynamically added. In this type of draw there is no automatic participant progression between rounds. Participant assignment to ",(0,r.jsx)(n.code,{children:"matchUps"})," is done manually, or via ",(0,r.jsx)(n.strong,{children:"drawMatic"}),". The only restriction is that a participant may appear once per round."]}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-js",children:"const { matchUps } = engine.generateAdHocMatchUps({\n  restrictMatchUpsCount, // optional boolean defaults to true; set to false for unlimited matchUpsCount\n  participantIdPairings, // optional - array of array of pairings [['id1', 'id2'], ['id3', 'id4']]\n  matchUpsCount, // optional - number of matchUps to generate; defaults to calc from entries\n  roundNumber, // optional - specify round for which matchUps will be generated\n  structureId, // required only if there is more than one structure\n  matchUpIds, // optional - if matchUpIds are not specified UUIDs are generated\n  newRound, // optional - boolean defaults to false - whether to auto-increment to next roundNumber\n  drawId, // required - drawId of drawDefinition in which target structure is found\n});\n"})}),"\n",(0,r.jsx)(n.hr,{}),"\n",(0,r.jsx)(n.h2,{id:"generateadhocrounds",children:"generateAdHocRounds"}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-js",children:"const { matchUps } = engine.generateAdHocRounds({\n  restrictMatchUpsCount, // optional boolean defaults to true; set to false for unlimited matchUpsCount\n  restrictRoundsCount, // optional boolean defaults to true; set to false for unlimited roundsCount\n  enableDoubleRobin, // optional - allows roundsCount <= (drawSize - 1) * 2\n  matchUpsCount, // optional - number of matchUps to generate per round; defaults to calc from entries\n  roundNumber, // optional - specify round for which matchUps will be generated\n  structureId, // required only if there is more than one structure\n  roundsCount, // defaults to 1\n  matchUpIds, // optional - if matchUpIds are not specified UUIDs are generated\n  newRound, // optional - boolean defaults to false - whether to auto-increment to next roundNumber\n  drawId, // required - drawId of drawDefinition in which target structure is found\n});\n"})}),"\n",(0,r.jsx)(n.hr,{}),"\n",(0,r.jsx)(n.h2,{id:"generateandpopulateplayoffstructures",children:"generateAndPopulatePlayoffStructures"}),"\n",(0,r.jsxs)(n.p,{children:["Generates values but does not attach them to the ",(0,r.jsx)(n.code,{children:"drawDefinition"}),". Used in conjunction with ",(0,r.jsx)(n.code,{children:"attachPlayoffStructures"}),"."]}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-js",children:"const { structures, links, matchUpModifications } = engine.generateAndPopulatePlayoffStructures({\n  requireSequential, // boolean defaults to true; only applies to Round Robin; require finishingPositions to be sequential\n  roundNumbers: [3], // optional if playoffPositions not provided; roundNumbers of structure to be played off.\n  roundProfiles, // optional - source roundNumbers as Object.keys with depth as Object.values, e.g. [{ 1: 2}, {2: 1}]\n  playoffPositions: [3, 4], // optional if roundNumbers not provided; finishing positions to be played off.\n  playoffStructureNameBase, // optional - Root word for default playoff naming, e.g. 'Playoff' for 'Playoff 3-4'\n  exitProfileLimit, // limit playoff rounds generated by the attributes present in playoffAttributes\n  playoffAttributes, // optional - mapping of either exitProfile or finishingPositionRange to structure names (see Finishing Positions concept)\n  playoffGroups, // optional - only applies to Playoffs from ROUND_ROBIN: { structureNameMap: {}, finishingPositions: [], drawType: '' }\n  structureId,\n  drawId,\n});\n"})}),"\n",(0,r.jsx)(n.hr,{}),"\n",(0,r.jsx)(n.h2,{id:"generatedrawdefinition",children:"generateDrawDefinition"}),"\n",(0,r.jsxs)(n.p,{children:["This is a convenience method which handles most use cases for draw generation. See examples in ",(0,r.jsx)(n.a,{href:"/competition-factory/docs/concepts/draws-overview#basic-usage",children:"Basic Usage"}),", ",(0,r.jsx)(n.a,{href:"/competition-factory/docs/concepts/accessors#avoidance-policies",children:"Avoidance Policies"}),", ",(0,r.jsx)(n.a,{href:"/competition-factory/docs/concepts/accessors#nationality-based-draws",children:"Nationality-Based Draws"}),", ",(0,r.jsx)(n.a,{href:"/competition-factory/docs/concepts/draw-types#pre-defined-draw-types",children:"Pre-Defined Draw Types"}),", ",(0,r.jsx)(n.a,{href:"/competition-factory/docs/concepts/events/entries#manual-entry-selection",children:"Manual Entry Selection"}),", and 4 more."]}),"\n",(0,r.jsxs)(n.p,{children:["The ",(0,r.jsx)(n.code,{children:"automated"}),' parameter is "truthy" and supports placing only seeded participants and any byes which are adjacent to seeded positions.\nSupport for this scenario is provided to enable some unique positioning strategies where unseeded participants have some agency in the selection process.']}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-js",children:"const drawDefinitionValues = {\n  eventId, // optional - used to find any avoidance policies to be applied\n  drawSize, // number of drawPositions in the first draw structure\n  drawType, // optional - defaults to SINGLE_ELIMINATION\n  drawName, // cutom name for generated draw structure(s)\n  drawEntries, // array of entries, equal to or a subset of event.entries\n  automated, // optional - whether or not to automatically place participants in structures; true/false or 'truthy' { seedsOnly: true }\n  matchUpType, // optional - SINGLES, DOUBLES, or TEAM\n  matchUpFormat, // optional - default matchUpFormatCode for all contained matchUps\n  playoffMatchUpFormat, // optional - relevant for ROUND_ROBIN_WITH_PLAYOFF\n  hydrateCollections, // optional - propagate { category, gender } for event to collectionDefinitions in tieFormats\n  tieFormat, // optional - { collectionDefinitions, winCriteria } for 'dual' or 'tie' matchUps\n  seedsCount, // optional - number of seeds to generate if no seededParticipants provided\n  seededParticipants, // optional - { participantId: 'id', seedNumber: 1, seedValue, '1' }\n  seedingScaleName, // optional - custom scale for determining seeded participants\n\n  // { positioing: WATERFALL } seeding for ROUND_ROBIN structures\n  // { positioning: CLUSTER } or { positioning: SEPARATE } seeding for elimination structures\n  // { groupSeedingThreshold: 5 } will set seedValue to lowest value within all groups where seedNumber is > 5\n  seedingProfile, // optional { positioning, groupSeedingThreshold }\n\n  qualifyingPlaceholder, // optional boolean - generate a placeholder qualifying structure if qualifiersCount and no qualifyingProfiles\n  qualifiersCount, // optional - how many positionsAssignments will have { qualifier: true }\n  qualifyingOnly, // optional boolean - ignore event.entries that are not entryStage: QUALIFYING\n  qualifyingProfiles, // optional array [{ roundTarget, structureProfiles: [{ drawSize, seedsCount, seedingScaleName, qualifyingPositions }]}]\n\n  structureOptions: {\n    // optional - for ROUND_ROBIN - { groupSize, playoffGroups }\n    groupSize, // e.g. 4 participants per group\n    groupSizeLimit: 8,\n    playoffGroups: [\n      { finishingPositions: [1], structureName: 'Gold Flight', drawType }, // drawype defaults to SINGLE_ELIMINATION\n      { finishingPositions: [2], structureName: 'Silver Flight', drawType }, // drawType can also be COMPASS or FIRST_MATCH_LOSER_CONSOLATION\n    ],\n  },\n\n  staggeredEntry, // optional - accepts non-base-2 drawSizes and generates feed arms for \"extra\" drawPositions\n  policyDefinitions, // optional - seeding or avoidance policies to be used when placing participants\n  qualifyingPositions, // optional - number of positions in draw structure to be filled by qualifiers\n  playoffAttributes, // optional - map of { [finishingPositionRange || exitProfile]: { name: 'customName', abbreviation: 'A' } }\n  enforcePolicyLimits, // optional boolean - defaults to true - constrains seedsCount to policyDefinition limits\n  voluntaryConsolation, // optional { structureName, structureAbbreviation } - causes voluntary consolation structure to be added\n  enforceMinimumDrawSize, // optional boolean - defaults to true - false will allow generation of multi-structure drawTypes with only 2 participants\n  drawTypeCoercion, // optional boolean - coerce multi-structure drawTypes to SINGLE_ELIMINATION for drawSize: 2\n  ignoreStageSpace, // optional boolean - ignore wildcards count & etc.\n\n  compassAttributes, // optional - provide translations for name mappings\n  olympicAttributes, // optional - provide translations for name mappings\n};\n\nconst { drawDefinition } = engine.generateDrawDefinition(drawDefinitionValues);\n"})}),"\n",(0,r.jsx)(n.hr,{}),"\n",(0,r.jsx)(n.h2,{id:"generatedrawmaticround",children:"generateDrawMaticRound"}),"\n",(0,r.jsxs)(n.p,{children:["Typically not called directly. ",(0,r.jsx)(n.code,{children:"engine.drawMatic"})," is a higher level wrapper which automates derivation of ",(0,r.jsx)(n.code,{children:"adHocRatings"}),"."]}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-js",children:"const {\n  participantIdPairings,\n  candidatesCount,\n  iterations,\n  matchUps,\n  success,\n} = generateDrawMaticRound({\n  maxIterations,// optional - defaults to 5000\n  generateMatchUps = true, // optional - defaults to true; when false only returns { participantIdPairings }\n  participantIds, // required\n  adHocRatings, // optional { ['participantId']: numericRating }\n  structureId, // required\n  matchUpIds, // optional array of uuids to be used when generating matchUps\n  eventType, // optional - override eventType of event within which draw appears; e.g. to force use of SINGLES ratings in DOUBLES events\n  drawId, // required\n});\n"})}),"\n",(0,r.jsx)(n.hr,{}),"\n",(0,r.jsx)(n.h2,{id:"generatedrawstructuresandlinks",children:"generateDrawStructuresAndLinks"}),"\n",(0,r.jsxs)(n.p,{children:["Low-level method that generates structures and links for various draw types. Typically called internally by ",(0,r.jsx)(n.code,{children:"generateDrawDefinition"}),"."]}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-js",children:"const { structures, links } = engine.generateDrawStructuresAndLinks({\n  drawDefinition, // required - target drawDefinition to modify\n  drawType, // required - SINGLE_ELIMINATION, ROUND_ROBIN, etc.\n  drawSize, // required - number of draw positions\n  structureName, // optional - custom name for main structure\n  matchUpType, // optional - SINGLES, DOUBLES, TEAM\n  tieFormat, // optional - for TEAM matchUps\n  qualifyingProfiles, // optional - array of qualifying structure configs\n  staggeredEntry, // optional - allows non-power-of-2 drawSizes\n  playoffAttributes, // optional - playoff structure naming\n  appliedPolicies, // optional - seeding/avoidance policies\n  enforceMinimumDrawSize, // optional boolean - defaults to true\n  drawTypeCoercion, // optional boolean - coerce to SINGLE_ELIMINATION for drawSize: 2\n  overwriteExisting, // optional boolean - replace existing structures\n  uuids, // optional - array of UUIDs for structures/matchUps\n});\n"})}),"\n",(0,r.jsx)(n.p,{children:(0,r.jsx)(n.strong,{children:"Returns:"})}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-ts",children:"{\n  structures: Structure[];  // Generated structure objects\n  links: DrawLink[];        // Generated link objects (for multi-stage draws)\n  error?: ErrorType;\n}\n"})}),"\n",(0,r.jsxs)(n.p,{children:[(0,r.jsx)(n.strong,{children:"Purpose:"})," Core method for generating draw structures. Handles all draw type logic including:"]}),"\n",(0,r.jsxs)(n.ul,{children:["\n",(0,r.jsx)(n.li,{children:"Single elimination brackets"}),"\n",(0,r.jsx)(n.li,{children:"Round robin groups"}),"\n",(0,r.jsx)(n.li,{children:"Consolation structures"}),"\n",(0,r.jsx)(n.li,{children:"Qualifying structures"}),"\n",(0,r.jsx)(n.li,{children:"Playoff structures"}),"\n",(0,r.jsx)(n.li,{children:"Feed-in and staggered entry"}),"\n"]}),"\n",(0,r.jsx)(n.p,{children:(0,r.jsx)(n.strong,{children:"Notes:"})}),"\n",(0,r.jsxs)(n.ul,{children:["\n",(0,r.jsxs)(n.li,{children:["Used internally by ",(0,r.jsx)(n.code,{children:"generateDrawDefinition"})]}),"\n",(0,r.jsx)(n.li,{children:"Does not attach structures to drawDefinition (returns them for manual attachment)"}),"\n",(0,r.jsx)(n.li,{children:"Handles complex multi-structure draw types (Curtis, FMLC, Compass, etc.)"}),"\n",(0,r.jsx)(n.li,{children:"Validates draw size and structure compatibility"}),"\n"]}),"\n",(0,r.jsx)(n.hr,{}),"\n",(0,r.jsx)(n.h2,{id:"generatedrawtypeandmodifydrawdefinition",children:"generateDrawTypeAndModifyDrawDefinition"}),"\n",(0,r.jsxs)(n.p,{children:["Generates draw structures and directly modifies the drawDefinition. Higher-level than ",(0,r.jsx)(n.code,{children:"generateDrawStructuresAndLinks"}),"."]}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-js",children:"const { drawDefinition, matchUpsMap } = engine.generateDrawTypeAndModifyDrawDefinition({\n  drawDefinition, // required - drawDefinition to modify\n  drawType, // required - draw type to generate\n  drawSize, // required - number of draw positions\n  matchUpType, // optional - SINGLES, DOUBLES, TEAM\n  matchUpFormat, // optional - default matchUpFormat\n  tieFormat, // optional - for TEAM matchUps\n  structureOptions, // optional - { groupSize, playoffGroups } for ROUND_ROBIN\n  qualifiersCount, // optional - number of qualifier positions\n  qualifyingOnly, // optional boolean - only process QUALIFYING stage entries\n  stageSequence, // optional - target specific stage (1=QUALIFYING, 2=MAIN)\n  drawTypeCoercion, // optional boolean - coerce to SINGLE_ELIMINATION for small draws\n  modifyOriginal, // optional boolean - defaults to true\n  policyDefinitions, // optional - seeding/avoidance policies\n  isMock, // optional boolean - for testing\n});\n"})}),"\n",(0,r.jsx)(n.p,{children:(0,r.jsx)(n.strong,{children:"Returns:"})}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-ts",children:"{\n  drawDefinition: DrawDefinition;      // Modified drawDefinition\n  inContextDrawMatchUps?: MatchUp[];  // All matchUps with context\n  matchUpsMap?: MatchUpsMap;          // Map of matchUpIds to matchUp objects\n  error?: ErrorType;\n}\n"})}),"\n",(0,r.jsx)(n.p,{children:(0,r.jsx)(n.strong,{children:"Difference from generateDrawStructuresAndLinks:"})}),"\n",(0,r.jsxs)(n.ul,{children:["\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.code,{children:"generateDrawTypeAndModifyDrawDefinition"})," modifies the drawDefinition directly"]}),"\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.code,{children:"generateDrawStructuresAndLinks"})," returns structures/links for manual attachment"]}),"\n",(0,r.jsx)(n.li,{children:"This method also generates tieMatchUps for TEAM events"}),"\n",(0,r.jsx)(n.li,{children:"Handles stage-specific modifications (QUALIFYING vs MAIN)"}),"\n",(0,r.jsx)(n.li,{children:"Returns complete matchUpsMap and inContext matchUps"}),"\n"]}),"\n",(0,r.jsx)(n.p,{children:(0,r.jsx)(n.strong,{children:"When to Use:"})}),"\n",(0,r.jsxs)(n.ul,{children:["\n",(0,r.jsx)(n.li,{children:"Modifying existing draws (changing draw type)"}),"\n",(0,r.jsx)(n.li,{children:"Regenerating structures after entry changes"}),"\n",(0,r.jsx)(n.li,{children:"Testing draw modifications"}),"\n",(0,r.jsx)(n.li,{children:"Building custom draw generation workflows"}),"\n"]}),"\n",(0,r.jsx)(n.p,{children:(0,r.jsx)(n.strong,{children:"Notes:"})}),"\n",(0,r.jsxs)(n.ul,{children:["\n",(0,r.jsx)(n.li,{children:"Validates tieFormat for TEAM matchUps"}),"\n",(0,r.jsx)(n.li,{children:"Generates links between structures automatically"}),"\n",(0,r.jsx)(n.li,{children:"Notifies subscribers of draw modifications"}),"\n",(0,r.jsxs)(n.li,{children:["Use ",(0,r.jsx)(n.code,{children:"modifyOriginal: false"})," to get modified copy without changing input"]}),"\n"]}),"\n",(0,r.jsx)(n.hr,{}),"\n",(0,r.jsx)(n.h2,{id:"generateflightprofile",children:"generateFlightProfile"}),"\n",(0,r.jsxs)(n.p,{children:["Splits event entries into ",(0,r.jsx)(n.code,{children:"flightsCount"})," (# of draws). ",(0,r.jsx)(n.code,{children:"flightProfile"})," is an extension on an event which contains attributes to be used by ",(0,r.jsx)(n.code,{children:"generateDrawDefinition"}),". See examples: ",(0,r.jsx)(n.a,{href:"/competition-factory/docs/concepts/events/flights#generating-flight-profiles",children:"Generating Flight Profiles"}),", ",(0,r.jsx)(n.a,{href:"/competition-factory/docs/concepts/events/flights#update-existing-profile",children:"Update Existing Profile"}),", ",(0,r.jsx)(n.a,{href:"/competition-factory/docs/concepts/events/flights#complete-example",children:"Complete Example"}),"."]}),"\n",(0,r.jsxs)(n.p,{children:["NOTE: The method returns ",(0,r.jsx)(n.code,{children:"{ flightProfile, splitEntries }"})," for testing; ",(0,r.jsx)(n.code,{children:"splitEntries"})," provides a breakdown on how ",(0,r.jsx)(n.code,{children:"event.entries"})," were split across each ",(0,r.jsx)(n.code,{children:"flight"})," within the ",(0,r.jsx)(n.code,{children:"event"}),"."]}),"\n",(0,r.jsxs)(n.p,{children:["For an explanation of ",(0,r.jsx)(n.code,{children:"scaleAttributes"})," see ",(0,r.jsx)(n.a,{href:"../concepts/scaleItems",children:"Scale Items"}),"."]}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-js",children:"const scaleAttributes = {\n  scaleType: RATING,\n  eventType: SINGLES,\n  scaleName: 'WTN',\n  accessor, // optional - string determining how to access attribute if scaleValue is an object\n};\n\nconst { flightProfile, splitEntries } = engine.generateFlightProfile({\n  eventId, // event for which entries will be split\n  attachFlightProfile, // boolean - also attach to event after generation\n  scaledEntries, // optional - overrides the use of scaleAttributes, scaleSortMethod, and sortDescending\n  scaleAttributes, // defines participant sort method prior to split\n  scaleSortMethod, // optional - function(a, b) {} sort method, useful when scaleValue is an object or further proessing is required\n  sortDescending, // optional - default sorting is ASCENDING; only applies to default sorting method.\n  flightsCount: 3, // number of draws to be created\n  deleteExisting: true, // optional - remove existing flightProfile\n  splitMethod: SPLIT_WATERFALL, // optional - defaults to SPLIT_LEVEL_BASED\n  drawNames: ['Green Flight', 'Blue Flight'], // optional\n  drawNameRoot: 'Flight', // optional - used to generate drawNames, e.g. 'Flight 1', 'Flight 2'\n});\n\nconst {\n  flights: [\n    {\n      drawId, // unique identifier for generating drawDefinitions\n      drawName, // custom name for generated draw\n      drawEntries, // entries allocated to target draw\n    },\n  ],\n} = flightProfile;\n\n// use flight information to generate drawDefinition\nconst {\n  flights: [flight],\n} = flightProfile;\n\nObject.assign(drawDefinitionValues, flight);\nconst { drawDefinition } = engine.generateDrawDefinition(drawDefinitionValues);\n"})}),"\n",(0,r.jsx)(n.hr,{}),"\n",(0,r.jsx)(n.h2,{id:"generatelineups",children:"generateLineUps"}),"\n",(0,r.jsx)(n.p,{children:"Generates lineUps for TEAM events which have selected teams with ranked or rated individualParticipants. Individual TEAM participants are assigned line positions based on the scale specified."}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-js",children:"const scaleAccessor = {\n  scaleName: categoryName,\n  scaleType: RANKING,\n  sortOrder, // optional - ASCENDING or DESCENDING - defaults to ASCENDING\n};\nconst { lineUps, participantsToAdd } = engine.generateLineUps({\n  useDefaultEventRanking, // optional boolen; when true scaleAccessor is not required\n  scaleAccessor, // see above\n  singlesOnly, // optional boolean - when true SINGLES rankings will be used for DOUBLES position assignment\n  attach, // optional boolean - when true the lineUps will be attached to the drawDefinition specified by drawId\n  drawId,\n});\n"})}),"\n",(0,r.jsx)(n.hr,{}),"\n",(0,r.jsx)(n.h2,{id:"generatequalifyingstructure",children:"generateQualifyingStructure"}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-js",children:"let { structure, link } = engine.generateQualifyingStructure({\n  targetStructureId, // required: structure for which participants will qualify\n  qualifyingPositions, // optional: specify the # of qualifyingPositions\n  qualifyingRoundNumber, // optional: determine qualifyingPositions by # of matchUps in specified round; does not apply to ROUND_ROBIN\n  structureOptions, // optional: specific to ROUND_ROBIN generation\n  structureName, // optional\n  drawSize,\n  drawType, // optional: defaults to SINGLE_ELIMINATION\n  drawId, // required: draw within which target structure appears\n});\n"})}),"\n",(0,r.jsx)(n.hr,{}),"\n",(0,r.jsx)(n.h2,{id:"generateseedingscaleitems",children:"generateSeedingScaleItems"}),"\n",(0,r.jsxs)(n.p,{children:["Used in conjunction with ",(0,r.jsx)(n.code,{children:"getEntriesAndSeedsCount"})," when it is necessary to make use of a custom function for generating ",(0,r.jsx)(n.code,{children:"scaledEntries"}),". See examples: ",(0,r.jsx)(n.a,{href:"/competition-factory/docs/concepts/scaleItems#client-implemented-seeding",children:"Client-Implemented Seeding"}),", ",(0,r.jsx)(n.a,{href:"/competition-factory/docs/concepts/scaleItems#using-factory-getscaledentries",children:"Using Factory getScaledEntries()"}),"."]}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-js",children:"const { scaleItemsWithParticipantIds } = engine.generateSeedingScaleItems({\n  scaleAttributes,\n  scaledEntries,\n  stageEntries,\n  seedsCount,\n  scaleName,\n});\n"})}),"\n",(0,r.jsx)(n.p,{children:(0,r.jsx)(n.strong,{children:"Returns:"})}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-ts",children:"{\n  scaleItemsWithParticipantIds: Array<{\n    participantId: string;\n    scaleItem: ScaleItem;\n  }>;\n}\n"})}),"\n",(0,r.jsx)(n.p,{children:(0,r.jsx)(n.strong,{children:"Use Cases:"})}),"\n",(0,r.jsxs)(n.ul,{children:["\n",(0,r.jsx)(n.li,{children:"Custom seeding logic that requires manual scale generation"}),"\n",(0,r.jsx)(n.li,{children:"Converting external rating systems to CODES scale format"}),"\n",(0,r.jsx)(n.li,{children:"Testing seeding scenarios with specific scale values"}),"\n"]}),"\n",(0,r.jsx)(n.hr,{}),"\n",(0,r.jsx)(n.h2,{id:"generatestatcrew",children:"generateStatCrew"}),"\n",(0,r.jsx)(n.p,{children:"Generates XML output in StatCrew format for college tennis scoring systems."}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-js",children:"const { xml } = engine.generateStatCrew({\n  tournamentRecord, // required - tournament to export\n});\n\n// Save to file for StatCrew import\nfs.writeFileSync('statcrew-export.xml', xml);\n"})}),"\n",(0,r.jsx)(n.p,{children:(0,r.jsx)(n.strong,{children:"Returns:"})}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-ts",children:"{\n  xml: string; // StatCrew-formatted XML\n  success: boolean;\n}\n"})}),"\n",(0,r.jsxs)(n.p,{children:[(0,r.jsx)(n.strong,{children:"Purpose:"})," Export tournament data in StatCrew XML format, which is used by college tennis programs in the United States for official scoring and statistics."]}),"\n",(0,r.jsx)(n.p,{children:(0,r.jsx)(n.strong,{children:"Features:"})}),"\n",(0,r.jsxs)(n.ul,{children:["\n",(0,r.jsx)(n.li,{children:"Exports tournament metadata (name, date, ID)"}),"\n",(0,r.jsx)(n.li,{children:"Includes all team participants"}),"\n",(0,r.jsx)(n.li,{children:"Exports singles and doubles matchUps"}),"\n",(0,r.jsx)(n.li,{children:"Handles TEAM/dual match format"}),"\n",(0,r.jsx)(n.li,{children:"Distinguishes between tournament and dual match formats"}),"\n",(0,r.jsx)(n.li,{children:"Maps participant IDs to teams and individuals"}),"\n"]}),"\n",(0,r.jsx)(n.p,{children:(0,r.jsx)(n.strong,{children:"When to Use:"})}),"\n",(0,r.jsxs)(n.ul,{children:["\n",(0,r.jsx)(n.li,{children:"College tennis tournaments requiring StatCrew integration"}),"\n",(0,r.jsx)(n.li,{children:"Exporting data to NCAA systems"}),"\n",(0,r.jsx)(n.li,{children:"Providing official match results in standardized format"}),"\n"]}),"\n",(0,r.jsx)(n.p,{children:(0,r.jsx)(n.strong,{children:"Notes:"})}),"\n",(0,r.jsxs)(n.ul,{children:["\n",(0,r.jsx)(n.li,{children:"Specifically designed for college tennis workflows"}),"\n",(0,r.jsx)(n.li,{children:"Handles both tournament and dual match formats"}),"\n",(0,r.jsx)(n.li,{children:"Includes participant and matchUp mappings"}),"\n",(0,r.jsx)(n.li,{children:"XML format matches StatCrew import specifications"}),"\n"]}),"\n",(0,r.jsx)(n.hr,{}),"\n",(0,r.jsx)(n.h2,{id:"generatevoluntaryconsolation",children:"generateVoluntaryConsolation"}),"\n",(0,r.jsx)(n.p,{children:"Generates and optionally attaches a voluntary consolation structure to a draw. Voluntary consolations allow first-round losers to opt into a secondary draw."}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-js",children:"const { structures, links } = engine.generateVoluntaryConsolation({\n  drawDefinition, // required - target drawDefinition\n  tournamentRecord, // required - tournament context\n  structureName, // optional - custom name (default: 'Voluntary Consolation')\n  automated, // optional boolean - auto-position participants\n  applyPositioning, // optional boolean - apply positioning policies\n  attachConsolation, // optional boolean - attach to drawDefinition\n  placeByes, // optional boolean - place byes automatically\n  matchUpType, // optional - SINGLES, DOUBLES, TEAM\n  tieFormat, // optional - for TEAM matchUps\n  seedingProfile, // optional - seeding strategy for consolation\n  playoffAttributes, // optional - playoff structure naming\n  staggeredEntry, // optional boolean - allow non-power-of-2 sizes\n  isMock, // optional boolean - for testing\n});\n"})}),"\n",(0,r.jsx)(n.p,{children:(0,r.jsx)(n.strong,{children:"Returns:"})}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-ts",children:"{\n  structures?: Structure[];  // Generated consolation structures\n  links?: DrawLink[];        // Links to main structure\n  error?: ErrorType;\n}\n"})}),"\n",(0,r.jsxs)(n.p,{children:[(0,r.jsx)(n.strong,{children:"Purpose:"})," Creates a consolation draw for first-round losers who opt in voluntarily. Unlike automatic consolations, this requires manual participant selection."]}),"\n",(0,r.jsx)(n.p,{children:(0,r.jsx)(n.strong,{children:"When to Use:"})}),"\n",(0,r.jsxs)(n.ul,{children:["\n",(0,r.jsx)(n.li,{children:"Tournaments with optional consolation draws"}),"\n",(0,r.jsx)(n.li,{children:"Giving first-round losers a chance to continue playing"}),"\n",(0,r.jsx)(n.li,{children:"Recreational or participation-focused tournaments"}),"\n",(0,r.jsx)(n.li,{children:"Testing consolation scenarios"}),"\n"]}),"\n",(0,r.jsx)(n.p,{children:(0,r.jsx)(n.strong,{children:"Notes:"})}),"\n",(0,r.jsxs)(n.ul,{children:["\n",(0,r.jsx)(n.li,{children:"Participants must voluntarily opt into the consolation"}),"\n",(0,r.jsx)(n.li,{children:"Only first-round losers are eligible"}),"\n",(0,r.jsx)(n.li,{children:"Generated structure is linked to main structure"}),"\n",(0,r.jsxs)(n.li,{children:["Use ",(0,r.jsx)(n.code,{children:"attachConsolation: true"})," to automatically attach to drawDefinition"]}),"\n",(0,r.jsxs)(n.li,{children:["Separate from ",(0,r.jsx)(n.code,{children:"addVoluntaryConsolationStructure"})," which manages existing consolations"]}),"\n"]}),"\n",(0,r.jsx)(n.hr,{}),"\n",(0,r.jsx)(n.h2,{id:"roundrobingroups",children:"roundRobinGroups"}),"\n",(0,r.jsx)(n.p,{children:"Utility function for generating round robin matchUp pairings within a group."}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-js",children:"const { groupMatchUps, uniqueMatchUpGroupings } = roundRobinGroups({\n  drawPositions, // array of draw positions in group (e.g., [1, 2, 3, 4])\n});\n\n// Example for 4-person group:\n// groupMatchUps: [[1,2], [1,3], [1,4], [2,3], [2,4], [3,4]]\n"})}),"\n",(0,r.jsx)(n.p,{children:(0,r.jsx)(n.strong,{children:"Returns:"})}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-ts",children:"{\n  groupMatchUps: number[][];        // All matchUp pairings\n  uniqueMatchUpGroupings: number[][]; // Deduplicated pairings\n}\n"})}),"\n",(0,r.jsxs)(n.p,{children:[(0,r.jsx)(n.strong,{children:"Purpose:"})," Generate all possible matchUp pairings for round robin groups, ensuring each participant plays every other participant once."]}),"\n",(0,r.jsx)(n.p,{children:(0,r.jsx)(n.strong,{children:"Internal Use:"})}),"\n",(0,r.jsxs)(n.ul,{children:["\n",(0,r.jsx)(n.li,{children:"Called by round robin structure generators"}),"\n",(0,r.jsx)(n.li,{children:"Used in group stage creation"}),"\n",(0,r.jsx)(n.li,{children:"Ensures complete round robin schedules"}),"\n"]}),"\n",(0,r.jsx)(n.p,{children:(0,r.jsx)(n.strong,{children:"Notes:"})}),"\n",(0,r.jsxs)(n.ul,{children:["\n",(0,r.jsx)(n.li,{children:"Returns all pairings (each matchUp appears twice, once for each participant)"}),"\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.code,{children:"uniqueMatchUpGroupings"})," provides deduplicated list"]}),"\n",(0,r.jsxs)(n.li,{children:["Used internally by ",(0,r.jsx)(n.code,{children:"generateDrawDefinition"})," for ROUND_ROBIN draws"]}),"\n",(0,r.jsx)(n.li,{children:"Can be used for custom round robin scheduling logic"}),"\n"]}),"\n",(0,r.jsx)(n.hr,{})]})}function u(e={}){const{wrapper:n}={...(0,o.R)(),...e.components};return n?(0,r.jsx)(n,{...e,children:(0,r.jsx)(d,{...e})}):d(e)}},8322(e,n,t){t.d(n,{R:()=>a,x:()=>s});var i=t(758);const r={},o=i.createContext(r);function a(e){const n=i.useContext(o);return i.useMemo(function(){return"function"==typeof e?e(n):{...n,...e}},[n,e])}function s(e){let n;return n=e.disableParentContext?"function"==typeof e.components?e.components(r):e.components||r:a(e.components),i.createElement(o.Provider,{value:n},e.children)}}}]);