"use strict";(globalThis.webpackChunkdocumentation=globalThis.webpackChunkdocumentation||[]).push([[2076],{3453(e,n,t){t.r(n),t.d(n,{assets:()=>c,contentTitle:()=>o,default:()=>h,frontMatter:()=>r,metadata:()=>i,toc:()=>l});const i=JSON.parse('{"id":"governors/query-governor","title":"Query Governor","description":"allDrawMatchUps","source":"@site/docs/governors/query-governor.md","sourceDirName":"governors","slug":"/governors/query-governor","permalink":"/competition-factory/docs/governors/query-governor","draft":false,"unlisted":false,"tags":[],"version":"current","frontMatter":{"title":"Query Governor"},"sidebar":"docs","previous":{"title":"Publishing Governor","permalink":"/competition-factory/docs/governors/publishing-governor"},"next":{"title":"Ranking Governor","permalink":"/competition-factory/docs/governors/ranking-governor"}}');var s=t(6070),a=t(8322);const r={title:"Query Governor"},o=void 0,c={},l=[{value:"allDrawMatchUps",id:"alldrawmatchups",level:2},{value:"allEventMatchUps",id:"alleventmatchups",level:2},{value:"allPlayoffPositionsFilled",id:"allplayoffpositionsfilled",level:2},{value:"allTournamentMatchUps",id:"alltournamentmatchups",level:2},{value:"competitionScheduleMatchUps",id:"competitionschedulematchups",level:2},{value:"drawMatchUps",id:"drawmatchups",level:2},{value:"eventMatchUps",id:"eventmatchups",level:2},{value:"getAllEventData",id:"getalleventdata",level:2},{value:"getAllStructureMatchUps",id:"getallstructurematchups",level:2},{value:"getAllowedDrawTypes",id:"getalloweddrawtypes",level:2},{value:"getAllowedMatchUpFormats",id:"getallowedmatchupformats",level:2},{value:"getAvailableMatchUpsCount",id:"getavailablematchupscount",level:2},{value:"getAvailablePlayoffProfiles",id:"getavailableplayoffprofiles",level:2},{value:"getCheckedInParticipantIds",id:"getcheckedinparticipantids",level:2},{value:"getCompetitionDateRange",id:"getcompetitiondaterange",level:2},{value:"getCompetitionMatchUps",id:"getcompetitionmatchups",level:2},{value:"getCompetitionPenalties",id:"getcompetitionpenalties",level:2},{value:"getCompetitionVenues",id:"getcompetitionvenues",level:2},{value:"getCourtInfo",id:"getcourtinfo",level:2},{value:"getCourts",id:"getcourts",level:2},{value:"getDrawData",id:"getdrawdata",level:2},{value:"getDrawParticipantRepresentativeIds",id:"getdrawparticipantrepresentativeids",level:2},{value:"getEligibleVoluntaryConsolationParticipants",id:"geteligiblevoluntaryconsolationparticipants",level:2},{value:"getEntriesAndSeedsCount",id:"getentriesandseedscount",level:2},{value:"getEntryStatusReports",id:"getentrystatusreports",level:2},{value:"getEvent",id:"getevent",level:2},{value:"getEvents",id:"getevents",level:2},{value:"getEventData",id:"geteventdata",level:2},{value:"getTimeItem",id:"gettimeitem",level:2},{value:"getEventProperties",id:"geteventproperties",level:2},{value:"getEventMatchUpFormatTiming",id:"geteventmatchupformattiming",level:2},{value:"getEventStructures",id:"geteventstructures",level:2},{value:"getFlightProfile",id:"getflightprofile",level:2},{value:"getMatchUpCompetitiveProfile",id:"getmatchupcompetitiveprofile",level:2},{value:"getMatchUpContextIds",id:"getmatchupcontextids",level:2},{value:"getMatchUpDependencies",id:"getmatchupdependencies",level:2},{value:"Parameters",id:"parameters",level:3},{value:"Return Value",id:"return-value",level:3},{value:"DependencyEntry",id:"dependencyentry",level:4},{value:"sourceMatchUpIds vs matchUpIds",id:"sourcematchupids-vs-matchupids",level:4},{value:"positionDependencies",id:"positiondependencies",level:4},{value:"Cross-Structure Awareness",id:"cross-structure-awareness",level:3},{value:"Usage Example",id:"usage-example",level:3},{value:"Role in Automated Scheduling",id:"role-in-automated-scheduling",level:3},{value:"Relationship to the Scheduling Profile",id:"relationship-to-the-scheduling-profile",level:3},{value:"DependencyAdapter Pattern",id:"dependencyadapter-pattern",level:3},{value:"getMatchUpFormat",id:"getmatchupformat",level:2},{value:"getMatchUpFormatTiming",id:"getmatchupformattiming",level:2},{value:"getMatchUpFormatTimingUpdate",id:"getmatchupformattimingupdate",level:2},{value:"getMatchUpScheduleDetails",id:"getmatchupscheduledetails",level:2},{value:"getMatchUpsStats",id:"getmatchupsstats",level:2},{value:"getMatchUpDailyLimits",id:"getmatchupdailylimits",level:2},{value:"getModifiedMatchUpFormatTiming",id:"getmodifiedmatchupformattiming",level:2},{value:"getPairedParticipant",id:"getpairedparticipant",level:2},{value:"getParticipantEventDetails",id:"getparticipanteventdetails",level:2},{value:"getParticipantIdFinishingPositions",id:"getparticipantidfinishingpositions",level:2},{value:"getParticipantMembership",id:"getparticipantmembership",level:2},{value:"getParticipantResults",id:"getparticipantresults",level:2},{value:"getParticipants",id:"getparticipants",level:2},{value:"getLinkedTournamentIds",id:"getlinkedtournamentids",level:2},{value:"getPositionsPlayedOff",id:"getpositionsplayedoff",level:2},{value:"getRounds",id:"getrounds",level:2},{value:"getParticipantScaleItem",id:"getparticipantscaleitem",level:2},{value:"getParticipantSchedules",id:"getparticipantschedules",level:2},{value:"getParticipantSignInStatus",id:"getparticipantsigninstatus",level:2},{value:"getParticipantStats",id:"getparticipantstats",level:2},{value:"getPersonRequests",id:"getpersonrequests",level:2},{value:"getPolicyDefinitions",id:"getpolicydefinitions",level:2},{value:"getPositionAssignments",id:"getpositionassignments",level:2},{value:"getPredictiveAccuracy",id:"getpredictiveaccuracy",level:2},{value:"getRoundMatchUps",id:"getroundmatchups",level:2},{value:"getScaledEntries",id:"getscaledentries",level:2},{value:"Parameters",id:"parameters-1",level:3},{value:"Return Value",id:"return-value-1",level:3},{value:"Examples",id:"examples",level:3},{value:"Basic Usage - Sort by Rating",id:"basic-usage---sort-by-rating",level:4},{value:"Sort by Ranking (Descending)",id:"sort-by-ranking-descending",level:4},{value:"Filter by Stage",id:"filter-by-stage",level:4},{value:"Custom Entries Array",id:"custom-entries-array",level:4},{value:"Complex Scale Values with Accessor",id:"complex-scale-values-with-accessor",level:4},{value:"Custom Sort Method",id:"custom-sort-method",level:4},{value:"Common Workflows",id:"common-workflows",level:3},{value:"Generating Seeding from Scaled Entries",id:"generating-seeding-from-scaled-entries",level:4},{value:"Validating Rating Coverage",id:"validating-rating-coverage",level:4},{value:"Notes",id:"notes",level:3},{value:"See Also",id:"see-also",level:3},{value:"getSchedulingProfile",id:"getschedulingprofile",level:2},{value:"getSchedulingProfileIssues",id:"getschedulingprofileissues",level:2},{value:"getSeedsCount",id:"getseedscount",level:2},{value:"getSeedingThresholds",id:"getseedingthresholds",level:2},{value:"getStructureSeedAssignments",id:"getstructureseedassignments",level:2},{value:"getStructureReports",id:"getstructurereports",level:2},{value:"getTeamLineUp",id:"getteamlineup",level:2},{value:"getTieFormat",id:"gettieformat",level:2},{value:"getTournamentInfo",id:"gettournamentinfo",level:2},{value:"getTournamentPersons",id:"gettournamentpersons",level:2},{value:"getTournamentPenalties",id:"gettournamentpenalties",level:2},{value:"getTournamentStructures",id:"gettournamentstructures",level:2},{value:"getValidGroupSizes",id:"getvalidgroupsizes",level:2},{value:"getVenuesAndCourts",id:"getvenuesandcourts",level:2},{value:"getVenueData",id:"getvenuedata",level:2},{value:"generateBookings",id:"generatebookings",level:2},{value:"getVenuesReport",id:"getvenuesreport",level:2},{value:"isCompletedStructure",id:"iscompletedstructure",level:2},{value:"isValidForQualifying",id:"isvalidforqualifying",level:2},{value:"isValidMatchUpFormat",id:"isvalidmatchupformat",level:2},{value:"matchUpActions",id:"matchupactions",level:2},{value:"participantScaleItem",id:"participantscaleitem",level:2},{value:"positionActions",id:"positionactions",level:2},{value:"tallyParticipantResults",id:"tallyparticipantresults",level:2},{value:"Basic Usage",id:"basic-usage",level:3},{value:"Return Values",id:"return-values",level:3},{value:"The generateReport Parameter",id:"the-generatereport-parameter",level:3},{value:"Further Reading",id:"further-reading",level:3},{value:"tournamentMatchUps",id:"tournamentmatchups",level:2},{value:"findExtension",id:"findextension",level:2},{value:"credits",id:"credits",level:2}];function d(e){const n={a:"a",admonition:"admonition",code:"code",em:"em",h2:"h2",h3:"h3",h4:"h4",hr:"hr",li:"li",ol:"ol",p:"p",pre:"pre",strong:"strong",table:"table",tbody:"tbody",td:"td",th:"th",thead:"thead",tr:"tr",ul:"ul",...(0,a.R)(),...e.components};return(0,s.jsxs)(s.Fragment,{children:[(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-js",children:"import { queryGovernor } from 'tods-competition-factory';\n"})}),"\n",(0,s.jsx)(n.h2,{id:"alldrawmatchups",children:"allDrawMatchUps"}),"\n",(0,s.jsxs)(n.p,{children:["Returns all matchUps from all structures within a draw. See examples in ",(0,s.jsx)(n.a,{href:"/competition-factory/docs/concepts/matchup-overview#draw-specific",children:"Draw-Specific"}),", ",(0,s.jsx)(n.a,{href:"/competition-factory/docs/concepts/matchup-overview#next-matchups-winnerloser-progression",children:"Next MatchUps (Winner/Loser Progression)"}),", ",(0,s.jsx)(n.a,{href:"/competition-factory/docs/concepts/matchup-context#next-matchups-progression",children:"Next MatchUps (Progression)"}),", ",(0,s.jsx)(n.a,{href:"/competition-factory/docs/concepts/matchup-context#build-draw-bracket",children:"Build Draw Bracket"}),"."]}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-js",children:"const { matchUps } = engine.allDrawMatchUps({\n  participantsProfile, // optional - ability to specify additions to context (see parameters of getParticipants())\n  contextFilters, // filters based on context attributes\n  matchUpFilters, // attribute filters\n  nextMatchUps, // optioanl - boolean - to include winnerTo and loserTo\n  inContext, // boolean - add context { drawId, structureId, participant, individualParticipants ... }\n  context, // optional context to be added into matchUps\n  drawId,\n});\n"})}),"\n",(0,s.jsx)(n.hr,{}),"\n",(0,s.jsx)(n.h2,{id:"alleventmatchups",children:"allEventMatchUps"}),"\n",(0,s.jsxs)(n.p,{children:["Returns all matchUps for an event. See examples: ",(0,s.jsx)(n.a,{href:"/competition-factory/docs/concepts/matchup-overview#event-specific",children:"Event-Specific"}),"."]}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-js",children:"const { matchUps } = allEventMatchUps({\n  scheduleVisibilityFilters, // { visibilityThreshold: dateString, eventIds, drawIds }\n  participantsProfile, // optional - ability to specify additions to context (see parameters of getParticipants())\n  matchUpFilters, // optional; [ scheduledDates: [], courtIds: [], stages: [], roundNumbers: [], matchUpStatuses: [], matchUpFormats: []]\n  contextFilters, // filters based on context attributes\n  nextMatchUps: true, // include winner/loser target matchUp details\n  inContext: true, // include contextual details\n  eventId,\n});\n"})}),"\n",(0,s.jsx)(n.hr,{}),"\n",(0,s.jsx)(n.h2,{id:"allplayoffpositionsfilled",children:"allPlayoffPositionsFilled"}),"\n",(0,s.jsxs)(n.p,{children:["Returns boolean value for whether playoff positions (which have been generated) are populated with ",(0,s.jsx)(n.code,{children:"participantIds"})," or ",(0,s.jsx)(n.code,{children:"BYEs"}),"."]}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-js",children:"const allPositionsFilled = engine.allPlayoffPositionsFilled({\n  structureId,\n  drawid,\n});\n"})}),"\n",(0,s.jsx)(n.hr,{}),"\n",(0,s.jsx)(n.h2,{id:"alltournamentmatchups",children:"allTournamentMatchUps"}),"\n",(0,s.jsxs)(n.p,{children:["Return an array of all matchUps contained within a tournament. These matchUps are returned ",(0,s.jsx)(n.strong,{children:"inContext"}),". See examples in ",(0,s.jsx)(n.a,{href:"/competition-factory/docs/concepts/extensions#extension-hydration",children:"Extension Hydration"}),", ",(0,s.jsx)(n.a,{href:"/competition-factory/docs/concepts/publishing/publishing-workflows#clear-separation",children:"Clear Separation"}),", ",(0,s.jsx)(n.a,{href:"/competition-factory/docs/concepts/publishing/publishing-workflows#clear-separation",children:"Clear Separation"}),", ",(0,s.jsx)(n.a,{href:"/competition-factory/docs/concepts/timeItems#matchup-time-items",children:"MatchUp Time Items"}),", ",(0,s.jsx)(n.a,{href:"/competition-factory/docs/concepts/matchup-overview#example-usage",children:"Example Usage"}),", and 2 more."]}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-js",children:"const { matchUps, groupInfo } = engine.allTournamentMatchUps({\n  scheduleVisibilityFilters, // { visibilityThreshold: dateString, eventIds, drawIds }\n  participantsProfile, // optional - ability to specify additions to context (see parameters of getParticipants())\n  matchUpFilters, // optional; [ scheduledDates: [], courtIds: [], stages: [], roundNumbers: [], matchUpStatuses: [], matchUpFormats: []]\n  contextFilters, // filters based on context attributes\n  nextMatchUps, // include winnerTo and loserTo matchUps\n  contextProfile, // optional: { inferGender: true, withCompetitiveness: true, withScaleValues: true, exclude: ['attribute', 'to', 'exclude']}\n});\n"})}),"\n",(0,s.jsx)(n.hr,{}),"\n",(0,s.jsx)(n.h2,{id:"competitionschedulematchups",children:"competitionScheduleMatchUps"}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-js",children:"const matchUpFilters = {\n  isMatchUpTie: false,\n  scheduledDate, // scheduled date of matchUps to return\n};. See examples: [Querying Published Schedules](../concepts/publishing/publishing-order-of-play.md#querying-published-schedules), [Competition Schedule](../concepts/publishing/publishing-order-of-play.md#querying-published-schedules).\n\nconst { completedMatchUps, dateMatchUps, courtsData, groupInfo, participants, venues, participants } =\n  engine.competitionScheduleMatchUps({\n    courtCompletedMatchUps, // boolean - include completed matchUps in court.matchUps - useful for pro-scheduling\n    alwaysReturnCompleted, // boolean - when true return completed matchUps regardless of publish state\n    hydrateParticipants, // boolean - defaults to true; when false, matchUp sides contain participantId and only context specific attributes of participant: { entryStatus, entryStage }\n    participantsProfile, // optional - ability to specify additions to context (see parameters of getParticipants())\n    withCourtGridRows, // optional boolean - return { rows } of matchUps for courts layed out as a grid, with empty cells\n    minCourtGridRows, // optional integer - minimum number of rows to return (compared to auto-calculated rows)\n    sortDateMatchUps, // boolean boolean - optional - defaults to `true`\n    usePublishState, // boolean - when true filter out events and dates that have not been published; enforces embargo timestamps\n    matchUpFilters, // optional; [ scheduledDate, scheduledDates: [], courtIds: [], stages: [], roundNumbers: [], matchUpStatuses: [], matchUpFormats: []]\n    sortCourtsData, // boolean - optional\n  });\n"})}),"\n",(0,s.jsxs)(n.p,{children:["When ",(0,s.jsx)(n.code,{children:"usePublishState: true"}),", this method enforces ",(0,s.jsx)(n.a,{href:"../concepts/publishing/publishing-embargo",children:"embargo"})," timestamps at all levels:"]}),"\n",(0,s.jsxs)(n.ul,{children:["\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.strong,{children:"Order of Play embargo"}),": returns empty ",(0,s.jsx)(n.code,{children:"dateMatchUps"})," if the order of play embargo has not passed"]}),"\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.strong,{children:"Draw embargo"}),": filters out matchUps from embargoed draws"]}),"\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.strong,{children:"Stage embargo"}),": filters out matchUps from embargoed stages"]}),"\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.strong,{children:"Structure embargo"}),": filters out matchUps from embargoed structures"]}),"\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.strong,{children:"Round-level filtering"}),": ",(0,s.jsx)(n.code,{children:"roundLimit"})," on a structure caps which rounds appear in the schedule (for all draw types). ",(0,s.jsx)(n.code,{children:"scheduledRounds"})," provides per-round publish/embargo control within the ceiling set by ",(0,s.jsx)(n.code,{children:"roundLimit"}),". See ",(0,s.jsx)(n.a,{href:"../concepts/publishing/publishing-embargo#scheduled-rounds",children:"Scheduled Rounds"}),"."]}),"\n"]}),"\n",(0,s.jsxs)(n.p,{children:[(0,s.jsx)(n.strong,{children:"See"}),": ",(0,s.jsx)(n.a,{href:"../concepts/publishing/publishing-embargo",children:"Embargo"})," for details on how embargo timestamps work."]}),"\n",(0,s.jsx)(n.hr,{}),"\n",(0,s.jsx)(n.h2,{id:"drawmatchups",children:"drawMatchUps"}),"\n",(0,s.jsx)(n.p,{children:"Returns categorized matchUps from all structures within a draw."}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-js",children:"const { upcomingMatchUps, pendingMatchUps, completedMatchUps, abandonedMatchUps, byeMatchUps } = engine.drawMatchUps({\n  tournamentAppliedPolicies, // any policies, such as privacy, to be applied to matchUps\n  contextFilters, // filters based on context attributes\n  matchUpFilters, // attribute filters\n  nextMatchUps, // optioanl - boolean - to include winnerTo and loserTo\n  inContext, // boolean - add context { drawId, structureId, participant, individualParticipants ... }\n  context, // optional context to be added into matchUps\n});\n"})}),"\n",(0,s.jsx)(n.hr,{}),"\n",(0,s.jsx)(n.h2,{id:"eventmatchups",children:"eventMatchUps"}),"\n",(0,s.jsx)(n.p,{children:"Returns matchUps for an event grouped by status."}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-js",children:"const { abandonedMatchUps, byeMatchUps, completedMatchUps, pendingMatchUps, upcomingMatchUps } = engine.eventMatchUps({\n  scheduleVisibilityFilters, // { visibilityThreshold: dateString, eventIds, drawIds }\n  tournamentAppliedPolicies,\n  contextFilters, // optiona; filter by attributes that are only present after matchUpContext has been added (hydration)\n  matchUpFilters, // optional; [ scheduledDates: [], courtIds: [], stages: [], roundNumbers: [], matchUpStatuses: [], matchUpFormats: []]\n  nextMatchUps, // optional boolean; include winner/loser target matchUp details\n  inContext, // optional - adds context details to all matchUps\n  eventId,\n});\n"})}),"\n",(0,s.jsx)(n.hr,{}),"\n",(0,s.jsx)(n.h2,{id:"getalleventdata",children:"getAllEventData"}),"\n",(0,s.jsxs)(n.p,{children:["Returns all ",(0,s.jsx)(n.code,{children:"matchUps"})," for all draws in all events along with ",(0,s.jsx)(n.code,{children:"tournamentInfo"}),", ",(0,s.jsx)(n.code,{children:"eventInfo"}),", and ",(0,s.jsx)(n.code,{children:"drawInfo"}),"."]}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-js",children:"const { allEventData } = engine.getAllEventData({\n  policyDefinitions, // optional - allows participant data to be filtered via a privacy policy\n});\n\nconst { tournamentInfo, eventsData, venuesData } = allEventData;\n"})}),"\n",(0,s.jsx)(n.hr,{}),"\n",(0,s.jsx)(n.h2,{id:"getallstructurematchups",children:"getAllStructureMatchUps"}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-js",children:"const { matchUps } = engine.getAllStructureMatchUps({ drawId, structureId });\n"})}),"\n",(0,s.jsx)(n.hr,{}),"\n",(0,s.jsx)(n.h2,{id:"getalloweddrawtypes",children:"getAllowedDrawTypes"}),"\n",(0,s.jsx)(n.p,{children:"Returns an array of names of allowed Draw Types, if any applicable policies have been applied to the tournamentRecord."}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-js",children:"const drawTypes = engine.getAllowedDrawTypes();\n"})}),"\n",(0,s.jsx)(n.hr,{}),"\n",(0,s.jsx)(n.h2,{id:"getallowedmatchupformats",children:"getAllowedMatchUpFormats"}),"\n",(0,s.jsx)(n.p,{children:"Returns an array of TODS matchUpFormat codes for allowed scoring formats, if any applicable policies have been applied to the tournamentRecord."}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-js",children:"const drawTypes = engine.getAllowedMatchUpFormats();\n"})}),"\n",(0,s.jsx)(n.hr,{}),"\n",(0,s.jsx)(n.h2,{id:"getavailablematchupscount",children:"getAvailableMatchUpsCount"}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-js",children:"const { availableMatchUpsCount } = engine.getAvailableMatchUpsCount({\n  structureId, // required if there is more than one structure in the drawDefinition\n  roundNumber, // optional; will default to last roundNumber\n  drawId,\n});\n"})}),"\n",(0,s.jsx)(n.hr,{}),"\n",(0,s.jsx)(n.h2,{id:"getavailableplayoffprofiles",children:"getAvailablePlayoffProfiles"}),"\n",(0,s.jsxs)(n.p,{children:["If provided a ",(0,s.jsx)(n.code,{children:"structureId"}),", returns rounds of the selected structure which are available for adding playoff structures."]}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-js",children:"const { playoffRounds, playoffRoundsRanges, positionsPlayedOff } = engine.getAvailablePlayoffProfiles({\n  structureId,\n  drawId,\n});\n"})}),"\n",(0,s.jsxs)(n.p,{children:["...for a SINGLE_ELIMINATION struture with ",(0,s.jsx)(n.code,{children:"{ drawSize: 16 }"})," this would return:"]}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-js",children:"{\n  playoffRounds: [ 1, 2, 3 ],\n  playoffRoundsRanges: [\n    { round: 1, range: '9-16' },\n    { round: 2, range: '5-8' },\n    { round: 3, range: '3-4' }\n  ]\n}\n"})}),"\n",(0,s.jsxs)(n.p,{children:["...for a ROUND_ROBIN struture with ",(0,s.jsx)(n.code,{children:"{ drawSize: 16 }"})," and ",(0,s.jsx)(n.code,{children:"{ groupSize: 4 }"})," this would return:"]}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-js",children:'{\n    "finishingPositionsAvailable": [ 1, 2, 3, 4 ],\n    "playoffFinishingPositionRanges": [\n        {\n            "finishingPosition": 1,\n            "finishingPositions": [ 1, 2, 3, 4 ],\n            "finishingPositionRange": "1-4"\n        },\n        {\n            "finishingPosition": 2,\n            "finishingPositions": [ 5, 6, 7, 8 ],\n            "finishingPositionRange": "5-8"\n        },\n        {\n            "finishingPosition": 3,\n            "finishingPositions": [ 9, 10, 11, 12 ],\n            "finishingPositionRange": "9-12"\n        },\n        {\n            "finishingPosition": 4,\n            "finishingPositions": [ 13, 14, 15, 16 ],\n            "finishingPositionRange": "13-16"\n        }\n    ],\n}\n'})}),"\n",(0,s.jsxs)(n.p,{children:["When no ",(0,s.jsx)(n.code,{children:"structureId"})," is provided, returns an array of ",(0,s.jsx)(n.code,{children:"availablePlayoffProfiles"})," with entries for each structure in a specified ",(0,s.jsx)(n.code,{children:"drawDefinition"}),"."]}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-js",children:"const { availablePlayoffProfiles, positionsPlayedOff } = engine.getAvailablePlayoffProfiles({ drawId });\n"})}),"\n",(0,s.jsx)(n.hr,{}),"\n",(0,s.jsx)(n.h2,{id:"getcheckedinparticipantids",children:"getCheckedInParticipantIds"}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-js",children:"const {\n  allParticipantsCheckedIn, // boolean\n  checkedInParticipantIds, // array of participantIds\n} = engine.getCheckedInParticipantIds({ matchUp });\n"})}),"\n",(0,s.jsx)(n.hr,{}),"\n",(0,s.jsx)(n.h2,{id:"getcompetitiondaterange",children:"getCompetitionDateRange"}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-js",children:"const { startDate, endDate } = engine.getCompetitionDateRange();\n"})}),"\n",(0,s.jsx)(n.hr,{}),"\n",(0,s.jsx)(n.h2,{id:"getcompetitionmatchups",children:"getCompetitionMatchUps"}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-js",children:"const { abandonedMatchUps, completedMatchUps, upcomingMatchUps, pendingMatchUps, byeMatchUps, groupInfo, participants } =\n = tournamentEngine.getCompetitionMatchUps();\n"})}),"\n",(0,s.jsx)(n.hr,{}),"\n",(0,s.jsx)(n.h2,{id:"getcompetitionpenalties",children:"getCompetitionPenalties"}),"\n",(0,s.jsx)(n.p,{children:"Returns an array of all penalties issued for all tournaments loaded into engine."}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-js",children:"const { penalties } = engine.getCompetitionPenalties();\n"})}),"\n",(0,s.jsx)(n.hr,{}),"\n",(0,s.jsx)(n.h2,{id:"getcompetitionvenues",children:"getCompetitionVenues"}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-js",children:"const { venues, venueIds } = engine.getCompetitionVenues();\n"})}),"\n",(0,s.jsx)(n.hr,{}),"\n",(0,s.jsx)(n.h2,{id:"getcourtinfo",children:"getCourtInfo"}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-js",children:"const {\n  altitude,\n  courtId,\n  courtName,\n  courtDimensions,\n  latitude,\n  longitude,\n  surfaceCategory,\n  surfaceType,\n  surfacedDate,\n  pace,\n  notes,\n} = engine.getCourtInfo({ courtId });\n"})}),"\n",(0,s.jsx)(n.hr,{}),"\n",(0,s.jsx)(n.h2,{id:"getcourts",children:"getCourts"}),"\n",(0,s.jsx)(n.p,{children:"Returns courts associated with a tournaments; optionally filter by venue(s)."}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-js",children:"const { courts } = engine.getCourts({\n  venueId, // optional - return courts for a specific venue\n  venueIds, // optional - return courts for specified venues\n});\n"})}),"\n",(0,s.jsx)(n.hr,{}),"\n",(0,s.jsx)(n.h2,{id:"getdrawdata",children:"getDrawData"}),"\n",(0,s.jsxs)(n.p,{children:["Primarily used by ",(0,s.jsx)(n.code,{children:"getEventData"})," for publishing purposes."]}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-js",children:"const {\n  drawInfo: {\n    drawActive, // boolean - draw has active matchUps\n    drawCompleted, // boolean - all draw matchUps are complete\n    drawGenerated, // boolean - draw has structures containing matchUps\n    participantPlacements, // boolean - whether any participants have been placed in the draw\n  },\n  structures,\n} = engine.getDrawData({\n  allParticipantResults, // optional boolean; include round statistics per structure even for elimination structures\n  contextProfile, // optional: { inferGender: true, withCompetitiveness: true, withScaleValues: true, exclude: ['attribute', 'to', 'exclude']}\n  drawId,\n});\n"})}),"\n",(0,s.jsx)(n.hr,{}),"\n",(0,s.jsx)(n.h2,{id:"getdrawparticipantrepresentativeids",children:"getDrawParticipantRepresentativeIds"}),"\n",(0,s.jsx)(n.p,{children:"Get the participantIds of participants in the draw who are representing players by observing the creation of the draw."}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-js",children:"const { representativeParticipantIds } = engine.getDrawParticipantRepresentativeIds({\n  drawId,\n});\n"})}),"\n",(0,s.jsx)(n.hr,{}),"\n",(0,s.jsx)(n.h2,{id:"geteligiblevoluntaryconsolationparticipants",children:"getEligibleVoluntaryConsolationParticipants"}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-js",children:"const { eligibleParticipants } = engine.getEligibleVoluntaryConsolationParticipants({\n  excludedMatchUpStatuses, // optional - array of matchUpStatuses which are excluded from matchUpsLimit\n  includeQualifyingStage, // optional - allow losers in qualifying\n  finishingRoundLimit, // optional number - limits considered matchUps by finishingRound, e.g. 3 doesn't consider past QF\n  roundNumberLimit, // optional number - limits matchUps by roundNumber\n  matchUpsLimit, // optional number - limits the number of considered matchUps; works in tandem with excludedMatchUpStatuses\n  winsLimit, // defaults to 0, meaning only participants with no wins are eligible\n  requireLoss, // optional boolean - defaults to true; if false then all participants who have played and appear in MAIN draw are considered\n  requirePlay, // optional boolean - defaults to true; if false then all participants who appear in MAIN draw are considered\n  allEntries, // optional boolean - consider all entries, regardless of whether placed in draw\n  includeEventParticipants, // optional boolean - consider event entries rather than draw entries (if event is present)\n  drawId,\n});\n"})}),"\n",(0,s.jsx)(n.hr,{}),"\n",(0,s.jsx)(n.h2,{id:"getentriesandseedscount",children:"getEntriesAndSeedsCount"}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-js",children:"const { error, entries, seedsCount, stageEntries } = engine.getEntriesAndSeedsCount({\n  policyDefinitions, // seeding policy which determines # of seeds for # of participants/drawSize\n  eventId,\n  drawSize, // optional - overrides number calculaed from entries in either event or draw\n  drawId, // optional - scopes entries to a specific flight/drawDefinition\n  stage, // optional - scopes entries to a specific stage\n});. See examples: [Client-Implemented Seeding](../concepts/scaleItems.md#client-implemented-seeding), [Using Factory getScaledEntries()](../concepts/scaleItems.md#using-factory-getscaledentries).\n"})}),"\n",(0,s.jsx)(n.hr,{}),"\n",(0,s.jsx)(n.h2,{id:"getentrystatusreports",children:"getEntryStatusReports"}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-js",children:"const {\n  tournamentEntryReport: {\n    nonParticipatingEntriesCount,\n    individualParticipantsCount,\n    drawDefinitionsCount,\n    eventsCount,\n  },\n  entryStatusReports, // count and pct of total for all entryStatuses for each event\n  participantEntryReports, // person entryStatus, ranking, seeding, WTN and confidence for each event\n  eventReports, // primarily internal use - entries for each event with main/qualifying seeding\n} = engine.getEntryStatusReports();\n"})}),"\n",(0,s.jsx)(n.p,{children:"To export reports as CSV:"}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-js",children:"const entryStatusCSV = tools.JSON2CSV(entryStatusReports);\nconst personEntryCSV = tools.JSON2CSV(participantEntryReports);\n"})}),"\n",(0,s.jsx)(n.hr,{}),"\n",(0,s.jsx)(n.h2,{id:"getevent",children:"getEvent"}),"\n",(0,s.jsxs)(n.p,{children:["Get an event by either its ",(0,s.jsx)(n.code,{children:"eventId"})," or by a ",(0,s.jsx)(n.code,{children:"drawId"})," which it contains. Also returns ",(0,s.jsx)(n.code,{children:"drawDefinition"})," if a ",(0,s.jsx)(n.code,{children:"drawId"})," is specified. See examples in ",(0,s.jsx)(n.a,{href:"/competition-factory/docs/concepts/events/entries#use-cases",children:"Use Cases"}),", ",(0,s.jsx)(n.a,{href:"/competition-factory/docs/engines/engine-middleware#resolving-events-from-draw-ids",children:"Resolving Events from Draw IDs"}),"."]}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-js",children:"const {\n  event,\n  drawDefinition, // only returned if drawId is specified\n} = engine.getEvent({\n  eventId, // optional - find event by eventId\n  drawId, // optional - find the event which contains specified drawId\n});\n"})}),"\n",(0,s.jsx)(n.hr,{}),"\n",(0,s.jsx)(n.h2,{id:"getevents",children:"getEvents"}),"\n",(0,s.jsxs)(n.p,{children:["Return ",(0,s.jsx)(n.strong,{children:"deepCopies"})," of all events in a tournament record. See examples: ",(0,s.jsx)(n.a,{href:"/competition-factory/docs/concepts/scheduling-profile#programmatic-generation",children:"Programmatic Generation"}),", ",(0,s.jsx)(n.a,{href:"/competition-factory/docs/engines/engine-middleware#setting-active-tournament",children:"Setting Active Tournament"}),", ",(0,s.jsx)(n.a,{href:"/competition-factory/docs/engines/engine-middleware#single-tournament-no-id-required",children:"Single Tournament (No ID Required)"}),"."]}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-js",children:"const { events } = engine.getEvents({\n  withScaleValues, // optional boolean\n  scaleEventType, // override event.eventType for accessing scales, e.g. SINGLES override for DOUBLES events\n  inContext, // optional boolean hydrates with tournamentId\n  eventIds, // optional array\n  drawIds, // optional array\n  context, // optional object to spread into all targeted events\n});\n"})}),"\n",(0,s.jsx)(n.hr,{}),"\n",(0,s.jsx)(n.h2,{id:"geteventdata",children:"getEventData"}),"\n",(0,s.jsxs)(n.p,{children:["Returns event information optimized for publishing: ",(0,s.jsx)(n.code,{children:"matchUps"})," have context and separated into rounds for consumption by visualization libraries such as ",(0,s.jsx)(n.code,{children:"tods-react-draws"}),". See examples: ",(0,s.jsx)(n.a,{href:"/competition-factory/docs/concepts/publishing/publishing-data-subscriptions#event-data-payload",children:"Event Data Payload"}),", ",(0,s.jsx)(n.a,{href:"/competition-factory/docs/concepts/publishing/publishing-workflows#event-data",children:"Event Data"}),", ",(0,s.jsx)(n.a,{href:"/competition-factory/docs/concepts/publishing/publishing-workflows#test-publish-state",children:"Test Publish State"}),"."]}),"\n",(0,s.jsxs)(n.p,{children:["See ",(0,s.jsx)(n.a,{href:"../concepts/policies",children:"Policies"})," for more details on ",(0,s.jsx)(n.code,{children:"policyDefinitions"}),"."]}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-js",children:"const { eventData } = engine.getEventData({\n  allParticipantResults, // optional boolean; include round statistics per structure even for elimination structures\n  participantsProfile, // optional - ability to specify additions to context (see parameters of getParticipants())\n  policyDefinitions, // optional\n  usePublishState, // optional - filter out draws which are not published; enforces embargo timestamps\n  contextProfile, // optional: { inferGender: true, withCompetitiveness: true, withScaleValues: true, exclude: ['attribute', 'to', 'exclude']}\n  eventId,\n});\nconst { drawsData, venuesData, eventInfo, tournamentInfo } = eventData;\n"})}),"\n",(0,s.jsxs)(n.p,{children:["When ",(0,s.jsx)(n.code,{children:"usePublishState: true"}),", this method enforces ",(0,s.jsx)(n.a,{href:"../concepts/publishing/publishing-embargo",children:"embargo"})," timestamps \u2014 embargoed draws, stages, and structures are filtered from ",(0,s.jsx)(n.code,{children:"drawsData"})," until the embargo passes."]}),"\n",(0,s.jsxs)(n.p,{children:[(0,s.jsx)(n.strong,{children:"See"}),": ",(0,s.jsx)(n.a,{href:"../concepts/publishing/publishing-embargo",children:"Embargo"})," for details on how embargo timestamps work."]}),"\n",(0,s.jsx)(n.hr,{}),"\n",(0,s.jsx)(n.h2,{id:"gettimeitem",children:"getTimeItem"}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-js",children:"const { timeItem } = engine.getTimeItem({\n  itemType: ADD_SCALE_ITEMS,\n  itemSubTypes: [SEEDING], // optional\n  participantId, // optional\n  eventId, // optional\n  drawId, // optional\n});. See examples: [Retrieving Time Items](../concepts/timeItems.md#retrieving-time-items), [External Ranking Integration](../concepts/timeItems.md#external-ranking-integration).\n"})}),"\n",(0,s.jsx)(n.p,{children:"Or call without engine:"}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-js",children:"getTimeItem({\n  tournamentRecord, // optional\n  drawDefinition, // optional\n  itemSubTypes, // optional\n  itemType, // required\n  element, // optional - arbitrary element, e.g. participant\n  event, // optional\n});\n"})}),"\n",(0,s.jsx)(n.hr,{}),"\n",(0,s.jsx)(n.h2,{id:"geteventproperties",children:"getEventProperties"}),"\n",(0,s.jsx)(n.p,{children:"Gather attributes of events which come from other tournament elements, e.g. participants which have rankings/ratings/seedings for a given event."}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-js",children:"const { entryScaleAttributes, hasSeededParticipants, hasRankedParticipants, hasRatedParticipants } =\n  engine.getEventProperties({ eventId });\n"})}),"\n",(0,s.jsxs)(n.p,{children:["... where ",(0,s.jsx)(n.strong,{children:"entryScaleAttributes"})," is an array of ",(0,s.jsx)(n.code,{children:"{ participantId, participantName, seed, ranking, rating }"})]}),"\n",(0,s.jsx)(n.hr,{}),"\n",(0,s.jsx)(n.h2,{id:"geteventmatchupformattiming",children:"getEventMatchUpFormatTiming"}),"\n",(0,s.jsx)(n.p,{children:"Method is used internally in advanced scheduling to determine averageMatchUp times for matchUps within an event."}),"\n",(0,s.jsxs)(n.p,{children:["Requires an array of ",(0,s.jsx)(n.code,{children:"matchUpFormats"})," either be defined in scoring policy that is attached to the tournamentRecord or an event, or passed in as parameter. ",(0,s.jsx)(n.code,{children:"matchUpFormats"})," can be passed either as an array of strings, or an array of ",(0,s.jsx)(n.code,{children:"[{ matchUpFormat }]"}),"."]}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-js",children:"const { eventMatchUpFormatTiming } = engine.getEventMatchUpFormatTiming({\n  matchUpFormats, // optional - can be retrieved from policy\n  categoryType, // optional - categoryType is not part of TODS or event attributes, but can be defined in a policy\n  eventId,\n});\n"})}),"\n",(0,s.jsx)(n.hr,{}),"\n",(0,s.jsx)(n.h2,{id:"geteventstructures",children:"getEventStructures"}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-js",children:"const { structures, stageStructures } = engine.getEventStructures({\n  withStageGrouping: true, // optional return structures grouped by stages\n  stageSequences, // optional - specify stageSequences to include\n  stageSequence, // optional - filter by stageSequence\n  stages, // optional - specify stageSequences to include\n  stage, // optional - filter by stage\n  eventId, // REQUIRED\n});\n"})}),"\n",(0,s.jsx)(n.hr,{}),"\n",(0,s.jsx)(n.h2,{id:"getflightprofile",children:"getFlightProfile"}),"\n",(0,s.jsxs)(n.p,{children:["A ",(0,s.jsx)(n.code,{children:"flightProfile"})," is an extension on an ",(0,s.jsx)(n.code,{children:"event"})," detailing the parameters that will be used to generate ",(0,s.jsx)(n.code,{children:"drawDefinitions"})," within the ",(0,s.jsx)(n.code,{children:"event"}),". There is an array of ",(0,s.jsx)(n.code,{children:"flights"})," which specify attributes of a draw such as ",(0,s.jsx)(n.code,{children:"drawEntries, drawName, drawId, flightNumber"})," as well as ",(0,s.jsx)(n.code,{children:"stage"}),', which is significant for flights which are only intended to reflect VOLUNTARY_CONSOLATION structures. A Voluntary Consolation flight is "linked" to the flight from which competitors originate and will be automatically deleted if the source flight is deleted. See examples: ',(0,s.jsx)(n.a,{href:"/competition-factory/docs/concepts/events/flights#creating-draws-from-flight-profiles",children:"Creating Draws from Flight Profiles"}),"."]}),"\n",(0,s.jsxs)(n.p,{children:["If a ",(0,s.jsx)(n.code,{children:"flight"})," has already been used to generate a draw, the ",(0,s.jsx)(n.code,{children:"drawDefinition"})," will be returned with the profile."]}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-js",children:"const { flightProfile } = engine.getFlightProfile({ eventId });\n"})}),"\n",(0,s.jsx)(n.hr,{}),"\n",(0,s.jsx)(n.h2,{id:"getmatchupcompetitiveprofile",children:"getMatchUpCompetitiveProfile"}),"\n",(0,s.jsx)(n.p,{children:'Returns a categorization of a matchUp as "Competitive", "Routine" or "Decisive"'}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-js",children:"const {\n  competitiveness, // [COMPETITIVE, DECISIVE, ROUTINE]\n  pctSpread, // 0-100 - rounded loser's percent of games required to win\n} = engine.getMatchUpCompetitiveProfile({\n  profileBands, // optional { [DECISIVE]: 20, [ROUTINE]: 50 } // can be attached to tournamentRecord as a policy\n  matchUp,\n});\n"})}),"\n",(0,s.jsx)(n.hr,{}),"\n",(0,s.jsx)(n.h2,{id:"getmatchupcontextids",children:"getMatchUpContextIds"}),"\n",(0,s.jsxs)(n.p,{children:['Convenience method to get "context" ids for a ',(0,s.jsx)(n.code,{children:"matchUp"})," by ",(0,s.jsx)(n.code,{children:"matchUpId"}),'. Requires an array of "inContext" ',(0,s.jsx)(n.code,{children:"matchUps"}),"."]}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-js",children:"const { matchUpId, drawId, eventId, structureId, tournamentId } = engine.getMatchUpContextIds({\n  matchUpId,\n  matchUps,\n});\n"})}),"\n",(0,s.jsx)(n.hr,{}),"\n",(0,s.jsx)(n.h2,{id:"getmatchupdependencies",children:"getMatchUpDependencies"}),"\n",(0,s.jsxs)(n.p,{children:["Builds a directed acyclic graph (DAG) of matchUp dependencies across all structures within a draw or across all draws in a tournament/competition. For every ",(0,s.jsx)(n.code,{children:"matchUpId"})," the result contains the complete set of upstream matchUps that must finish first, downstream matchUps that depend on this one, optional participant tracking, and source information grouped by round distance."]}),"\n",(0,s.jsx)(n.p,{children:"This is the factory's authoritative source for scheduling constraint data and is used internally by all automated scheduling paths."}),"\n",(0,s.jsx)(n.h3,{id:"parameters",children:"Parameters"}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-js",children:"const result = engine.getMatchUpDependencies({\n  includeParticipantDependencies, // optional boolean (default false) \u2014 when true, accumulates\n                                  // all potential participantIds for each matchUp transitively\n  drawDefinition, // optional \u2014 scope to a single draw definition\n  matchUps,       // optional \u2014 pre-fetched matchUps (must be inContext); avoids re-fetching\n  matchUpIds,     // optional \u2014 restrict dependency checking to specific matchUpIds\n  drawIds,        // optional \u2014 restrict to specific drawIds\n});\n"})}),"\n",(0,s.jsxs)(n.p,{children:["When called via a competition engine, ",(0,s.jsx)(n.code,{children:"tournamentRecords"})," is supplied automatically. When calling the governor directly, pass either ",(0,s.jsx)(n.code,{children:"tournamentRecord"})," or ",(0,s.jsx)(n.code,{children:"tournamentRecords"}),"."]}),"\n",(0,s.jsx)(n.h3,{id:"return-value",children:"Return Value"}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-js",children:"const {\n  matchUpDependencies, // Record<matchUpId, DependencyEntry>\n  sourceMatchUpIds,    // Record<matchUpId, string[]> \u2014 direct feeder matchUpIds (non-transitive)\n  positionDependencies,// Record<structureId, string[]> \u2014 cross-structure POSITION link dependencies\n  matchUps,            // HydratedMatchUp[] \u2014 the matchUps used for analysis\n  success,             // boolean\n} = result;\n"})}),"\n",(0,s.jsx)(n.h4,{id:"dependencyentry",children:"DependencyEntry"}),"\n",(0,s.jsxs)(n.p,{children:["Each entry in ",(0,s.jsx)(n.code,{children:"matchUpDependencies"})," has the following shape:"]}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-js",children:"matchUpDependencies[matchUpId] = {\n  matchUpIds: string[],           // transitive closure of ALL upstream matchUpIds\n  dependentMatchUpIds: string[],  // direct downstream matchUpIds (matchUps that depend on this one)\n  participantIds: string[],       // all potential participantIds (when includeParticipantDependencies is true)\n  sources: string[][],            // upstream matchUpIds grouped by round distance:\n                                  //   sources[0] = direct feeders (1 round back)\n                                  //   sources[1] = 2 rounds back\n                                  //   sources[2] = 3 rounds back, etc.\n};\n"})}),"\n",(0,s.jsx)(n.h4,{id:"sourcematchupids-vs-matchupids",children:"sourceMatchUpIds vs matchUpIds"}),"\n",(0,s.jsxs)(n.ul,{children:["\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.code,{children:"sourceMatchUpIds[matchUpId]"})," contains only the ",(0,s.jsx)(n.strong,{children:"direct"})," feeder matchUpIds (the two matchUps whose winner/loser feeds into this one)"]}),"\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.code,{children:"matchUpDependencies[matchUpId].matchUpIds"})," contains the ",(0,s.jsx)(n.strong,{children:"complete transitive closure"})," \u2014 every matchUp in the entire upstream chain"]}),"\n"]}),"\n",(0,s.jsx)(n.h4,{id:"positiondependencies",children:"positionDependencies"}),"\n",(0,s.jsxs)(n.p,{children:["For draws that use ",(0,s.jsx)(n.strong,{children:"POSITION links"})," (e.g., Round Robin \u2192 Playoff, Swiss \u2192 Playoff), ",(0,s.jsx)(n.code,{children:"positionDependencies"})," maps a source ",(0,s.jsx)(n.code,{children:"structureId"})," to all ",(0,s.jsx)(n.code,{children:"matchUpIds"})," within that structure. This captures the constraint that ",(0,s.jsx)(n.em,{children:"every"})," matchUp in the source structure must complete before ",(0,s.jsx)(n.em,{children:"any"})," matchUp in the linked target structure can begin."]}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-js",children:"positionDependencies = {\n  [sourceStructureId]: [matchUpId1, matchUpId2, ...], // all matchUpIds in the source structure\n};\n"})}),"\n",(0,s.jsx)(n.h3,{id:"cross-structure-awareness",children:"Cross-Structure Awareness"}),"\n",(0,s.jsxs)(n.p,{children:[(0,s.jsx)(n.code,{children:"getMatchUpDependencies"})," follows ",(0,s.jsx)(n.strong,{children:"all"})," draw link types:"]}),"\n",(0,s.jsxs)(n.table,{children:[(0,s.jsx)(n.thead,{children:(0,s.jsxs)(n.tr,{children:[(0,s.jsx)(n.th,{children:"Link Type"}),(0,s.jsx)(n.th,{children:"How It's Captured"})]})}),(0,s.jsxs)(n.tbody,{children:[(0,s.jsxs)(n.tr,{children:[(0,s.jsxs)(n.td,{children:[(0,s.jsx)(n.strong,{children:"Winner progression"})," (elimination draws)"]}),(0,s.jsxs)(n.td,{children:[(0,s.jsx)(n.code,{children:"winnerMatchUpId"})," on each matchUp"]})]}),(0,s.jsxs)(n.tr,{children:[(0,s.jsxs)(n.td,{children:[(0,s.jsx)(n.strong,{children:"Loser progression"})," (consolation, compass, feed-in)"]}),(0,s.jsxs)(n.td,{children:[(0,s.jsx)(n.code,{children:"loserMatchUpId"})," on each matchUp"]})]}),(0,s.jsxs)(n.tr,{children:[(0,s.jsxs)(n.td,{children:[(0,s.jsx)(n.strong,{children:"POSITION links"})," (RR \u2192 Playoff, Swiss \u2192 Playoff)"]}),(0,s.jsxs)(n.td,{children:[(0,s.jsx)(n.code,{children:"positionDependencies"})," \u2014 all matchUps in the source structure become dependencies of every matchUp in the target structure"]})]})]})]}),"\n",(0,s.jsxs)(n.p,{children:["This means a consolation Round 1 matchUp will correctly list the main draw Round 1 matchUp it depends on (via ",(0,s.jsx)(n.code,{children:"loserMatchUpId"}),"), and a playoff matchUp after a Round Robin will list every RR group matchUp as a dependency."]}),"\n",(0,s.jsx)(n.h3,{id:"usage-example",children:"Usage Example"}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-js",children:"const {\n  matchUpDependencies,\n  sourceMatchUpIds,\n  positionDependencies,\n} = engine.getMatchUpDependencies({\n  includeParticipantDependencies: true,\n});\n\n// Check what must complete before a specific matchUp\nconst deps = matchUpDependencies[targetMatchUpId];\nconsole.log(`${deps.matchUpIds.length} upstream matchUps must complete first`);\nconsole.log(`${deps.participantIds.length} potential participants`);\n\n// Check direct feeders only\nconst feeders = sourceMatchUpIds[targetMatchUpId];\nconsole.log(`${feeders.length} direct feeder matchUps`);\n\n// Check round distance\nconst oneRoundBack = deps.sources[0]; // direct feeders\nconst twoRoundsBack = deps.sources[1]; // feeders of feeders\n"})}),"\n",(0,s.jsx)(n.h3,{id:"role-in-automated-scheduling",children:"Role in Automated Scheduling"}),"\n",(0,s.jsxs)(n.p,{children:[(0,s.jsx)(n.code,{children:"getMatchUpDependencies"})," is the foundation of the factory's scheduling constraint enforcement. The ",(0,s.jsx)(n.a,{href:"../concepts/automated-scheduling",children:"automated scheduling"})," pipeline calls it early in the process (step 2 of ",(0,s.jsx)(n.a,{href:"../concepts/automated-scheduling#pseudocode",children:"scheduleProfileRounds"}),") and threads the dependency data through four constraint functions:"]}),"\n",(0,s.jsxs)(n.table,{children:[(0,s.jsx)(n.thead,{children:(0,s.jsxs)(n.tr,{children:[(0,s.jsx)(n.th,{children:"Function"}),(0,s.jsx)(n.th,{children:"Constraint"}),(0,s.jsx)(n.th,{children:"Uses"})]})}),(0,s.jsxs)(n.tbody,{children:[(0,s.jsxs)(n.tr,{children:[(0,s.jsx)(n.td,{children:(0,s.jsx)(n.code,{children:"checkDependenciesScheduled"})}),(0,s.jsxs)(n.td,{children:[(0,s.jsx)(n.strong,{children:"Gate"}),": all upstream matchUps must already be scheduled before this one can be assigned a time"]}),(0,s.jsxs)(n.td,{children:[(0,s.jsx)(n.code,{children:"matchUpIds"})," (transitive closure)"]})]}),(0,s.jsxs)(n.tr,{children:[(0,s.jsx)(n.td,{children:(0,s.jsx)(n.code,{children:"checkDependentTiming"})}),(0,s.jsxs)(n.td,{children:[(0,s.jsx)(n.strong,{children:"Gate"}),": scheduling this matchUp must not create a timing conflict with already-scheduled downstream matchUps"]}),(0,s.jsx)(n.td,{children:(0,s.jsx)(n.code,{children:"dependentMatchUpIds"})})]}),(0,s.jsxs)(n.tr,{children:[(0,s.jsx)(n.td,{children:(0,s.jsx)(n.code,{children:"checkRecoveryTime"})}),(0,s.jsxs)(n.td,{children:[(0,s.jsx)(n.strong,{children:"Gate"}),": every potential participant must have sufficient rest (",(0,s.jsx)(n.code,{children:"timeAfterRecovery"}),") since their last scheduled matchUp"]}),(0,s.jsx)(n.td,{children:(0,s.jsx)(n.code,{children:"participantIds"})})]}),(0,s.jsxs)(n.tr,{children:[(0,s.jsx)(n.td,{children:(0,s.jsx)(n.code,{children:"updateTimeAfterRecovery"})}),(0,s.jsxs)(n.td,{children:[(0,s.jsx)(n.strong,{children:"State"}),": after scheduling a matchUp, updates the recovery deadline for all potential participants in downstream matchUps"]}),(0,s.jsx)(n.td,{children:(0,s.jsx)(n.code,{children:"participantIds"})})]})]})]}),"\n",(0,s.jsxs)(n.p,{children:["The ",(0,s.jsx)(n.a,{href:"../concepts/pro-scheduling",children:"pro scheduler"})," uses the same dependency data in its ",(0,s.jsx)(n.code,{children:"proConflicts"})," post-hoc analysis to detect ordering violations, court double-bookings, and insufficient recovery gaps."]}),"\n",(0,s.jsx)(n.h3,{id:"relationship-to-the-scheduling-profile",children:"Relationship to the Scheduling Profile"}),"\n",(0,s.jsxs)(n.p,{children:["The ",(0,s.jsx)(n.a,{href:"../concepts/scheduling-profile",children:"scheduling profile"})," defines ",(0,s.jsx)(n.em,{children:"which"})," rounds to schedule on each date/venue. ",(0,s.jsx)(n.code,{children:"getMatchUpDependencies"})," enforces ",(0,s.jsx)(n.em,{children:"whether"})," that ordering is valid:"]}),"\n",(0,s.jsxs)(n.ul,{children:["\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.strong,{children:"Profile validation"}),": The factory's ",(0,s.jsx)(n.code,{children:"getSchedulingProfileIssues()"})," method calls ",(0,s.jsx)(n.code,{children:"getMatchUpDependencies"})," and checks that no matchUp appears ",(0,s.jsx)(n.em,{children:"after"})," a matchUp it depends on within the profile ordering. It returns ",(0,s.jsx)(n.code,{children:"profileIssues"})," with the violating round indices."]}),"\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.strong,{children:"Profile building"}),": Applications that build scheduling profiles interactively (e.g., using the ",(0,s.jsx)(n.code,{children:"courthive-components"})," scheduling profile builder) can use the dependency data to validate the profile in real time before it is submitted for execution."]}),"\n"]}),"\n",(0,s.jsx)(n.h3,{id:"dependencyadapter-pattern",children:"DependencyAdapter Pattern"}),"\n",(0,s.jsxs)(n.p,{children:["The ",(0,s.jsx)(n.code,{children:"courthive-components"})," library provides a ",(0,s.jsx)(n.strong,{children:"DependencyAdapter"})," that lifts matchUp-level dependencies to round-level for scheduling profile validation:"]}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-ts",children:"interface DependencyAdapter {\n  getRoundDependencies: (roundKeyString: string) => string[];\n}\n"})}),"\n",(0,s.jsxs)(n.p,{children:["The adapter is built from ",(0,s.jsx)(n.code,{children:"getMatchUpDependencies"})," results:"]}),"\n",(0,s.jsxs)(n.ol,{children:["\n",(0,s.jsxs)(n.li,{children:["Call ",(0,s.jsx)(n.code,{children:"getMatchUpDependencies({ includeParticipantDependencies: true })"})," on the factory engine"]}),"\n",(0,s.jsxs)(n.li,{children:["Build a ",(0,s.jsx)(n.code,{children:"matchUpId \u2192 roundKey"})," index where ",(0,s.jsx)(n.code,{children:"roundKey"})," is a compound string ",(0,s.jsx)(n.code,{children:'"tournamentId|eventId|drawId|structureId|roundNumber"'})]}),"\n",(0,s.jsxs)(n.li,{children:["For each matchUp, map its upstream ",(0,s.jsx)(n.code,{children:"matchUpIds"})," to their corresponding ",(0,s.jsx)(n.code,{children:"roundKey"})," values"]}),"\n",(0,s.jsxs)(n.li,{children:['Aggregate to produce round-level dependencies: "Round A depends on Round B" if ',(0,s.jsx)(n.em,{children:"any"})," matchUp in Round A has a dependency on ",(0,s.jsx)(n.em,{children:"any"})," matchUp in Round B"]}),"\n"]}),"\n",(0,s.jsx)(n.p,{children:"The adapter enables the profile builder to detect:"}),"\n",(0,s.jsxs)(n.ul,{children:["\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.strong,{children:"Cross-date violations"}),": a round scheduled on Day 1 that depends on rounds not scheduled until Day 2"]}),"\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.strong,{children:"Cross-structure violations"}),": rounds from linked structures scheduled in the wrong order on the same day (e.g., consolation R1 before main draw R1)"]}),"\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.strong,{children:"Missing prerequisite rounds"}),": rounds scheduled that depend on rounds not present in the profile at all"]}),"\n"]}),"\n",(0,s.jsxs)(n.p,{children:["These are surfaced as ",(0,s.jsx)(n.code,{children:"DEPENDENCY_VIOLATION"})," issues with suggested fix actions (",(0,s.jsx)(n.code,{children:"MOVE_ITEM_AFTER"}),", ",(0,s.jsx)(n.code,{children:"MOVE_ITEM_BEFORE"}),", ",(0,s.jsx)(n.code,{children:"JUMP_TO_ITEM"}),")."]}),"\n",(0,s.jsx)(n.admonition,{type:"tip",children:(0,s.jsxs)(n.p,{children:[(0,s.jsx)(n.strong,{children:"Performance"}),": ",(0,s.jsx)(n.code,{children:"getMatchUpDependencies"})," walks all matchUps and builds transitive closures. For large tournaments, compute the result once per session and cache it. The dependency graph is stable unless draws are regenerated or entries change. Pass cached ",(0,s.jsx)(n.code,{children:"matchUps"})," via the ",(0,s.jsx)(n.code,{children:"matchUps"})," parameter to avoid redundant matchUp fetching."]})}),"\n",(0,s.jsx)(n.hr,{}),"\n",(0,s.jsx)(n.h2,{id:"getmatchupformat",children:"getMatchUpFormat"}),"\n",(0,s.jsxs)(n.p,{children:["Returns ",(0,s.jsx)(n.code,{children:"matchUpFormat"})," codes for specified context(s). Refer to ",(0,s.jsx)(n.code,{children:"getMatchUpFormat.test.js"})," for specfic use cases."]}),"\n",(0,s.jsxs)(n.p,{children:[(0,s.jsx)(n.code,{children:"matchUpFormat"})," for each matchUp is determined by traversing the hierarchy: ",(0,s.jsx)(n.code,{children:"matchUp => stucture => drawDefinition => event"})]}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-js",children:"const { matchUpFormat, structureDefaultMatchUpFormat, drawDefaultMatchUpFormat, eventDefaultMatchUpFormat } =\n  engine.getMatchUpFormat({\n    eventId,\n    drawId,\n    structureId,\n    matchUpId,\n  });\n"})}),"\n",(0,s.jsx)(n.hr,{}),"\n",(0,s.jsx)(n.h2,{id:"getmatchupformattiming",children:"getMatchUpFormatTiming"}),"\n",(0,s.jsxs)(n.p,{children:["Searches for policy definitions or extensions to determine the ",(0,s.jsx)(n.code,{children:"averageMinutes"})," and ",(0,s.jsx)(n.code,{children:"recoveryMinutes"})," for a given ",(0,s.jsx)(n.code,{children:"matchUpFormat"}),". Extensions are considered to be overrides of policy definitions."]}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-js",children:"const { averageMinutes, recoveryMinutes } = engine.getMatchUpFormatTiming({\n  defaultAverageMinutes, // optional setting if no matching definition found\n  defaultRecoveryMinutes, // optional setting if no matching definition found\n  matchUpFormat,\n  categoryName, // optional\n  categoryType, // optional\n  eventType, // optional - defaults to SINGLES; SINGLES, DOUBLES\n  eventId, // optional - prioritizes policy definition attached to event before tournament record\n});\n"})}),"\n",(0,s.jsx)(n.hr,{}),"\n",(0,s.jsx)(n.h2,{id:"getmatchupformattimingupdate",children:"getMatchUpFormatTimingUpdate"}),"\n",(0,s.jsx)(n.p,{children:'Returns an array of methods/params necessary for updating a remote instance of a tournamentRecord to match a local instance. This method enables multiple "provisional" updates to be made on a local document without contacting a server; support deployments where a server is considered "master".'}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-js",children:"const { methods } = engine.getMatchUpFormatTimingUpdate();\n"})}),"\n",(0,s.jsx)(n.hr,{}),"\n",(0,s.jsx)(n.h2,{id:"getmatchupscheduledetails",children:"getMatchUpScheduleDetails"}),"\n",(0,s.jsxs)(n.p,{children:["Returns the latest values for all ",(0,s.jsx)(n.code,{children:"matchUp.timeItems"}),", along with calculated values, that relate to the scheduling of a ",(0,s.jsx)(n.code,{children:"matchUp"}),"."]}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-js",children:"const {\n  schedule: {\n    time,\n    courtId,\n    venueId,\n    startTime,\n    endTime,\n    milliseconds,\n    scheduledDate,\n    scheduledTime,\n    allocatedCourts: [{ venueId, courtid }], // applies only to TEAM matchUps\n  },\n} = engine.getMatchUpScheduleDetails({\n  scheduleVisibilityFilters, // { visibilityThreshold: dateString, eventIds, drawIds }\n  matchUp,\n});\n"})}),"\n",(0,s.jsx)(n.hr,{}),"\n",(0,s.jsx)(n.h2,{id:"getmatchupsstats",children:"getMatchUpsStats"}),"\n",(0,s.jsxs)(n.p,{children:["Returns percentages of matchUps which fall into ",(0,s.jsx)(n.code,{children:"cmpetitiveBands"}),' defined as "Competitive", "Routine", and "Decisive".']}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-js",children:"const { competitiveBands } = engine.getMatchUpsStats({\n  profileBands, // optional { [DECISIVE]: 20, [ROUTINE]: 50 } // can also be set in policyDefinitions\n  matchUps,\n});\n"})}),"\n",(0,s.jsx)(n.hr,{}),"\n",(0,s.jsx)(n.h2,{id:"getmatchupdailylimits",children:"getMatchUpDailyLimits"}),"\n",(0,s.jsx)(n.p,{children:"Returns player daily match limits for singles/doubles/total matches."}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-js",children:"const { matchUpDailyLimits } = tournamentId.getMatchUpDailyLimits();\nconst { DOUBLES, SINGLES, total } = matchUpDailyLimits;\n"})}),"\n",(0,s.jsx)(n.hr,{}),"\n",(0,s.jsx)(n.h2,{id:"getmodifiedmatchupformattiming",children:"getModifiedMatchUpFormatTiming"}),"\n",(0,s.jsxs)(n.p,{children:["Returns ",(0,s.jsx)(n.code,{children:"averageTimes"})," and ",(0,s.jsx)(n.code,{children:"recoveryTimes"})," configuration objects for specified ",(0,s.jsx)(n.code,{children:"matchUpFormat"}),". Useful before calling ",(0,s.jsx)(n.code,{children:"modifyMatchUpFormatTiming"})," to preserve existing modifications."]}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-js",children:"const { matchUpFormat, averageTimes, recoveryTimes } = engine.getModifiedMatchUpFormatTiming({\n  matchUpFormat, // TODS matchUpFormat code\n  event, // optional - include event in scope for search\n});\n"})}),"\n",(0,s.jsx)(n.hr,{}),"\n",(0,s.jsx)(n.h2,{id:"getpairedparticipant",children:"getPairedParticipant"}),"\n",(0,s.jsxs)(n.p,{children:["Returns the ",(0,s.jsx)(n.code,{children:"{ participantType: PAIR }"}),", if any, which contains the specified ",(0,s.jsx)(n.code,{children:"individualParticipantIds"}),"."]}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-js",children:"const { participant } = engine.getPairedParticipant({\n  participantIds: individualParticipantIds,\n});\n"})}),"\n",(0,s.jsx)(n.hr,{}),"\n",(0,s.jsx)(n.h2,{id:"getparticipanteventdetails",children:"getParticipantEventDetails"}),"\n",(0,s.jsxs)(n.p,{children:["Returns an array of eventDetails in which a specified ",(0,s.jsx)(n.code,{children:"participantId"})," appears. For details on draw entry within events use ",(0,s.jsx)(n.code,{children:"engine.getParticipants({ inContext: true })"}),"."]}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-js",children:"const { eventDetails } = engine.getParticipantEventDetails({\n  participantId,\n});\n\nconst [{ eventName, eventId }] = eventDetails;\n"})}),"\n",(0,s.jsx)(n.hr,{}),"\n",(0,s.jsx)(n.h2,{id:"getparticipantidfinishingpositions",children:"getParticipantIdFinishingPositions"}),"\n",(0,s.jsx)(n.p,{children:"Returns the Range of finishing positions possible for all participantIds within a draw"}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-js",children:"const idMap = engine.getParticipantIdFinishingPositions({\n  byeAdvancements, // optional boolean - whether or not to consider byeAdvancements\n  drawId,\n});\n\nconst { relevantMatchUps, finishingPositionRanges, finishingPositionRange } = idMap['participantId'];\n"})}),"\n",(0,s.jsx)(n.hr,{}),"\n",(0,s.jsx)(n.h2,{id:"getparticipantmembership",children:"getParticipantMembership"}),"\n",(0,s.jsxs)(n.p,{children:["Returns all grouping participants which include ",(0,s.jsx)(n.code,{children:"participantId"})," in ",(0,s.jsx)(n.code,{children:"{ individualParticipantIds }"}),". See examples: ",(0,s.jsx)(n.a,{href:"/competition-factory/docs/concepts/participants#participant-membership",children:"Participant Membership"}),"."]}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-js",children:"const {\n  [PAIR]: doublesParticipantIds,\n  [GROUP]: groupParticipantIds,\n  [TEAM]: teamParticipantIds,\n} = engine.getParticipantMembership({\n  participantId,\n});\n"})}),"\n",(0,s.jsx)(n.hr,{}),"\n",(0,s.jsx)(n.h2,{id:"getparticipantresults",children:"getParticipantResults"}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-js",children:"const { participantResults } = engine.getParticipantResults({\n  participantIds, // optional array to filter results; used in ROUND_ROBIN for groups\n  tallyPolicy, // policyDefinition for tallying results\n  matchUps, // must be inContext matchUps\n});\n"})}),"\n",(0,s.jsx)(n.hr,{}),"\n",(0,s.jsx)(n.h2,{id:"getparticipants",children:"getParticipants"}),"\n",(0,s.jsxs)(n.p,{children:["Returns ",(0,s.jsx)(n.strong,{children:"deepCopies"})," of competition participants filtered by participantFilters which are arrays of desired participant attribute values. This method is an optimization of ",(0,s.jsx)(n.code,{children:"getCompetitionParticipants"})," and will replace it going forward. See examples in ",(0,s.jsx)(n.a,{href:"/competition-factory/docs/concepts/participants#basic-retrieval",children:"Basic Retrieval"}),", ",(0,s.jsx)(n.a,{href:"/competition-factory/docs/concepts/publishing/publishing-participants",children:"Participants"}),", ",(0,s.jsx)(n.a,{href:"/competition-factory/docs/concepts/participant-context#withmatchups",children:"withMatchUps"}),", ",(0,s.jsx)(n.a,{href:"/competition-factory/docs/concepts/accessors#participant-filtering",children:"Participant Filtering"}),", ",(0,s.jsx)(n.a,{href:"/competition-factory/docs/concepts/scheduling-conflicts#basic-conflict-detection",children:"Basic Conflict Detection"}),", and 1 more."]}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-js",children:"const participantFilters = {\n  accessorValues: [{ accessor, value }], // optional - see Accessors in Concepts\n  eventEntryStatuses, // boolean\n  participantTypes: [INDIVIDUAL],\n  participantRoles, [COMPETITOR],\n  signInStatus, // specific signIn status\n  eventIds, // events in which participants appear\n};\nconst {\n  participantIdsWithConflicts, // returns array of participantIds which have scheduling conflicts\n  competitionParticipants,\n  eventsPublishStatuses,\n  derivedEventInfo,\n  derivedDrawInfo,\n  participantMap, // object { ['participantId']: participant } - NOTE: Not fully hydrated\n  mappedMatchUps, // object { [matchUpId]: matchUp }; when { withMatchUps: true }\n  participants, // array of hydrated participants\n  matchUps, // array of all matchUps; when { withMatchUps: true }\n } =\n  engine.getParticipants({\n    convertExtensions, // optional - BOOLEAN - convert extensions so _extensionName attributes\n    participantFilters, // optional - filters\n    policyDefinitions, // optional - can accept a privacy policy to filter participant attributes\n    usePublishState, // optional - BOOLEAN - don't add seeding information when not published\n    scheduleAnalysis: {\n      scheduledMinutesDifference // optional - scheduling conflicts determined by scheduledTime difference between matchUps\n    },\n    withDraws, // optional - defaults to true if any other context options are specified\n    withEvents, // optional - defaults to true if any other context options are specified\n    withIndividualParticipants, // optional - boolean or attributeFilter template - include hydrated individualParticiapnts for TEAM/PAIR participants\n    withIOC, // optional - will add IOC country code and countryName to participant persons\n    withISO2, // optional - will add ISO2 country code and countryName to participant persons\n    withMatchUps, // optional - include all matchUps in which the participant appears, as well as potentialMatchUps\n    withOpponents, // optional - include opponent participantIds\n    withPotentialMatchUps, // optional boolean\n    withRankingProfile, // optional boolean - include details necessary for point awards\n    withScaleValues, // optional - include { ratings, rankings } attributes extracted from timeItems\n    withSeeding, // optional - add event seeding\n    withScheduleItems, // optional boolean - include array of scheduled matchUp details\n    withSignInStatus, // optional boolean\n    withStatistics, // optional - adds events, matchUps and statistics, e.g. 'winRatio'\n    withTeamMatchUps // optional boolean\n  });\n"})}),"\n",(0,s.jsx)(n.h2,{id:"getlinkedtournamentids",children:"getLinkedTournamentIds"}),"\n",(0,s.jsxs)(n.p,{children:["Returns ",(0,s.jsx)(n.code,{children:"linkedTournamentIds"})," for each tournamentRecord loaded in ",(0,s.jsx)(n.code,{children:"compeitionEngine"}),"."]}),"\n",(0,s.jsx)(n.p,{children:'Caters for the possibility that, for instance, two "linked" tournaments and one "unlinked" tournament could be loaded.'}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-js",children:"const { linkedTournamentIds } = engine.getLinkedTournamentIds();\n/*\n{\n  'tournamentId-1': ['tournamentId-2', 'tournamentId-3'],\n  'tournamentId-2': ['tournamentId-1', 'touranmentId-3'],\n  'tournamentId-3': ['tournamentId-1', 'tournamentId-2']\n}\n*/\n"})}),"\n",(0,s.jsx)(n.hr,{}),"\n",(0,s.jsx)(n.h2,{id:"getpositionsplayedoff",children:"getPositionsPlayedOff"}),"\n",(0,s.jsx)(n.p,{children:"Determines which finishing positions will be returned by a draw. For example, a First Match Loser Consolation with a draw size of 16 will playoff possitions 1, 2, 9 and 10."}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-js",children:"const { positionsPlayedOff } = engine.getPositionsPlayedOff({\n  drawDefinition,\n});\n"})}),"\n",(0,s.jsx)(n.hr,{}),"\n",(0,s.jsx)(n.h2,{id:"getrounds",children:"getRounds"}),"\n",(0,s.jsxs)(n.p,{children:["Returns all rounds of all ",(0,s.jsx)(n.code,{children:"structures"})," in all ",(0,s.jsx)(n.code,{children:"tournamentRecords"}),"."]}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-js",children:"const { rounds, excludedRounds } = engine.getRounds({\n  excludeScheduleDateProfileRounds, // optional date string - exclude rounds which appear in schedulingProfile on given date\n  excludeCompletedRounds, // optional boolean - exclude rounds where all matchUps are completed\n  excludeScheduledRounds, // optional boolean - exclude rounds where all matchUps are scheduled\n  inContextMatchUps, // optional - if not provided will be read from tournamentRecords\n  schedulingProfile, // optional - if not provided will be read from tournamentRecords (where applicable)\n  withSplitRounds, // optional boolean - read schedulingProfile and split rounds where defined\n  matchUpFilters, // optional - filter competition matchUps before deriving rounds\n  withRoundId, // optional boolean - return a unique id for each derived round\n  scheduleDate, // optional - filters out events which are not valid on specified date\n  venueId, // optional - filters out events which are not valid for specified venue\n  context, // optional - object to be spread into derived rounds\n});\n"})}),"\n",(0,s.jsx)(n.p,{children:"Returns the following detail for each round:"}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-js",children:"  {\n    roundSegment: { segmentsCount, segmentNumber }, // if the round has been split in schedulingProfile\n    winnerFinishingPositionRange,\n    unscheduledCount,\n    incompleteCount,\n    minFinishingSum,\n    matchUpsCount,\n    stageSequence,\n    segmentsCount, // when { withSplitRounds: true } and a round split is defined in schedulingProfile\n    structureName,\n    tournamentId,\n    isScheduled, // whether every matchUp in the round has been scheduled (does not consider matchUpStatus: BYE)\n    isComplete, // whether every matchUp in the round has been COMPLETED or ABANDONED/CANCELLED\n    matchUpType,\n    roundNumber,\n    structureId,\n    eventName,\n    roundName,\n    drawName,\n    matchUps,\n    byeCount\n    eventId,\n    drawId,\n    id, // unique id provided when { withRoundId: true }\n  } = round;\n"})}),"\n",(0,s.jsx)(n.hr,{}),"\n",(0,s.jsx)(n.h2,{id:"getparticipantscaleitem",children:"getParticipantScaleItem"}),"\n",(0,s.jsxs)(n.p,{children:["Return a ranking or rating or seeding value for a participant, referenced by participantId. See examples in ",(0,s.jsx)(n.a,{href:"/competition-factory/docs/concepts/scaleItems#get-specific-scale-item",children:"Get Specific Scale Item"}),", ",(0,s.jsx)(n.a,{href:"/competition-factory/docs/concepts/accessors#scale-item-values",children:"Scale Item Values"}),", ",(0,s.jsx)(n.a,{href:"/competition-factory/docs/concepts/accessors#complex-scale-item-retrieval",children:"Complex Scale Item Retrieval"}),"."]}),"\n",(0,s.jsxs)(n.p,{children:["See ",(0,s.jsx)(n.a,{href:"../concepts/scaleItems",children:"Scale Items"}),"."]}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-js",children:"const scaleAttributes = {\n  scaleType: RATING,\n  eventType: SINGLES,\n  scaleName: 'WTN',\n  accessor, // optional - string determining how to access attribute if scaleValue is an object\n};\nconst {\n  scaleItem: { scaleValue },\n  tournamentId,\n} = engine.getParticipantScaleItem({\n  scaleAttributes,\n  participantId,\n});\n"})}),"\n",(0,s.jsx)(n.hr,{}),"\n",(0,s.jsx)(n.h2,{id:"getparticipantschedules",children:"getParticipantSchedules"}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-js",children:"const { participantSchedules } = engine.getParticipantSchedules({\n  participantFilters: { participantIds, participantTypes, eventIds },\n});\n"})}),"\n",(0,s.jsx)(n.hr,{}),"\n",(0,s.jsx)(n.h2,{id:"getparticipantsigninstatus",children:"getParticipantSignInStatus"}),"\n",(0,s.jsxs)(n.p,{children:["Participant signInStatus can be either 'SIGNED_IN' or 'SIGNED_OUT' (or undefined). See ",(0,s.jsx)(n.a,{href:"/docs/governors/participant-governor#modifyparticipantssigninstatus",children:"modifyParticipantsSignInStatus"}),"."]}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-js",children:"const signInStatus = engine.getParticipantSignInStatus({\n  participantId,\n});\n"})}),"\n",(0,s.jsx)(n.hr,{}),"\n",(0,s.jsx)(n.h2,{id:"getparticipantstats",children:"getParticipantStats"}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-js",children:"const result = engine.getParticipantStats({\n  withCompetitiveProfiles, // optional boolean\n  opponentParticipantId, // optional team opponent participantId, otherwise stats vs. all opponents\n  withIndividualStats, // optional boolean\n  teamParticipantId, // optional - when not provided all teams are processed\n  tallyPolicy, // optional\n  matchUps, // optional - specifiy or allow engine to get all\n});\n\nconst {\n  participatingTeamsCount, // only if no teamPartiicpantId has been specified\n  allParticipantStats, // only if no teamParticipantId has been specified\n  relevantMatchUps, // matchUps which were relevant to the calculations\n  opponentStats, // only if opponentParticipantId has been provided\n  teamStats, // only if teamParticipantId has been provided\n  success, // when no error\n  error, // if error\n} = result;\n"})}),"\n",(0,s.jsx)(n.hr,{}),"\n",(0,s.jsx)(n.h2,{id:"getpersonrequests",children:"getPersonRequests"}),"\n",(0,s.jsxs)(n.p,{children:["Returns an object with array of requests for each relevant ",(0,s.jsx)(n.code,{children:"personId"}),". Request objects are returned with a ",(0,s.jsx)(n.code,{children:"requestId"})," which can be used to call ",(0,s.jsx)(n.a,{href:"/docs/governors/participant-governor#modifypersonrequests",children:"modifyPersonRequests"}),"."]}),"\n",(0,s.jsxs)(n.p,{children:["See ",(0,s.jsx)(n.a,{href:"/docs/governors/participant-governor#addpersonrequests",children:"addPersonRequests"})," for request object structure."]}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-js",children:"const { personRequests } = engine.getPersonRequests({\n  requestType, // optional filter\n});\n"})}),"\n",(0,s.jsx)(n.hr,{}),"\n",(0,s.jsx)(n.h2,{id:"getpolicydefinitions",children:"getPolicyDefinitions"}),"\n",(0,s.jsxs)(n.p,{children:["Finds policies which have been attached to the tournamentRecord, or to a target event, or target drawDefinition, in reverse order.\nOnce a matching ",(0,s.jsx)(n.code,{children:"policyType"})," has been found, higher level policies of the same type are ignored, enabling a default policy to be attached to the tournamentRecord and for event-specific or draw-specific policies to override the default(s)."]}),"\n",(0,s.jsxs)(n.p,{children:["The constructed ",(0,s.jsx)(n.code,{children:"policyDefinitions"})," object contains targeted policies from all levels, scoped to the lowest level specified."]}),"\n",(0,s.jsxs)(n.p,{children:["See ",(0,s.jsx)(n.a,{href:"../concepts/policies",children:"Policies"}),"."]}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-js",children:"const { policyDefinitions } = engine.getPolicyDefinitions({\n  policyTypes: [POLICY_TYPE_SEEDING],\n  eventId, // optional\n  drawId, // optional\n});\n"})}),"\n",(0,s.jsx)(n.hr,{}),"\n",(0,s.jsx)(n.h2,{id:"getpositionassignments",children:"getPositionAssignments"}),"\n",(0,s.jsxs)(n.p,{children:["Returns an array of ",(0,s.jsx)(n.code,{children:"positionAssignments"})," for a structure. Combines ",(0,s.jsx)(n.code,{children:"positionAssginments"})," for child structures in the case of ROUND_ROBIN where ",(0,s.jsx)(n.code,{children:"{ structureType: CONTAINER }"}),"."]}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-js",children:"let { positionAssignments } = engine.getPositionAssignments({\n  structureId, // optional if { structure } is provided\n  structure, // optional if { drawId, structureId } are provided\n  drawId, // optional if { structure } is provided\n});\n\nconst [{ drawPosition, participantId, qualifier, bye }] = positionAssignments;\n"})}),"\n",(0,s.jsx)(n.hr,{}),"\n",(0,s.jsx)(n.h2,{id:"getpredictiveaccuracy",children:"getPredictiveAccuracy"}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-js",children:"const { accuracy, zoneDistribution } = engine.getPredictiveAccuracy({\n  exclusionRule: { valueAccessor: 'confidence', range: [0, 70] }, // exclude low confidence values\n\n  zoneMargin: 3, // optional - creates +/- range and report competitiveness distribution\n  zonePct: 20, // optional - precedence over zoneMargin, defaults to 100% of rating range\n\n  valueAccessor: 'wtnRating', // optional if `scaleName` is defined in factory `ratingsParameters`\n  ascending: true, // optional - scale goes from low to high with low being the \"best\"\n  scaleName: WTN,\n});\n"})}),"\n",(0,s.jsx)(n.hr,{}),"\n",(0,s.jsx)(n.h2,{id:"getroundmatchups",children:"getRoundMatchUps"}),"\n",(0,s.jsxs)(n.p,{children:["Organizes matchUps by roundNumber. ",(0,s.jsx)(n.strong,{children:"roundMatchUps"})," contains matchUp objects; ",(0,s.jsx)(n.strong,{children:"roundProfile"})," provides an overview of drawPositions which have advanced to each round, a matchUpsCount, finishingPositionRange for winners and losers, and finishingRound."]}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-js",children:"const { roundMatchUps, roundProfile } = engine.getRoundMatchUps({\n  matchUps,\n});\n"})}),"\n",(0,s.jsx)(n.hr,{}),"\n",(0,s.jsx)(n.h2,{id:"getscaledentries",children:"getScaledEntries"}),"\n",(0,s.jsxs)(n.p,{children:["Retrieves event entries sorted by their scale values (ratings, rankings, etc.). This method is useful for generating seeding when standard sorting by a scale value is sufficient. See examples: ",(0,s.jsx)(n.a,{href:"/competition-factory/docs/concepts/scaleItems#using-factory-getscaledentries",children:"Using Factory getScaledEntries()"}),"."]}),"\n",(0,s.jsx)(n.p,{children:(0,s.jsx)(n.strong,{children:"Purpose:"})}),"\n",(0,s.jsxs)(n.ul,{children:["\n",(0,s.jsx)(n.li,{children:"Sort participants by rating/ranking values"}),"\n",(0,s.jsx)(n.li,{children:"Prepare entries for seeding generation"}),"\n",(0,s.jsx)(n.li,{children:"Filter and order entries for draw placement"}),"\n"]}),"\n",(0,s.jsx)(n.p,{children:(0,s.jsx)(n.strong,{children:"Use Cases:"})}),"\n",(0,s.jsxs)(n.ul,{children:["\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.strong,{children:"Simple Seeding"})," - When seed order directly follows rating/ranking values"]}),"\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.strong,{children:"Pre-Processing"})," - Before applying custom sorting logic"]}),"\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.strong,{children:"Validation"})," - Checking participant ratings before seeding"]}),"\n"]}),"\n",(0,s.jsxs)(n.p,{children:["See ",(0,s.jsx)(n.a,{href:"../concepts/scaleItems",children:"Scale Items"})," and ",(0,s.jsx)(n.a,{href:"../concepts/scaleItems#generating-seeding-scale-items",children:"Generating Seeding Scale Items"}),"."]}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-js",children:"const { scaledEntries } = engine.getScaledEntries({\n  // Entry Source (choose one)\n  eventId, // optional - uses event.entries filtered by stage\n  entries, // optional - provide custom array of entries (overrides eventId)\n\n  // Filters\n  stage, // optional - 'MAIN', 'QUALIFYING', 'CONSOLATION' - filter entries by stage\n\n  // Scale Configuration\n  scaleAttributes, // required - { scaleType, scaleName, eventType, accessor? }\n\n  // Sorting Options\n  scaleSortMethod, // optional - function(a, b) {} - custom sort comparator\n  sortDescending, // optional - boolean - default is ASCENDING\n});\n"})}),"\n",(0,s.jsx)(n.h3,{id:"parameters-1",children:"Parameters"}),"\n",(0,s.jsxs)(n.p,{children:[(0,s.jsx)(n.strong,{children:"eventId"})," - ",(0,s.jsx)(n.em,{children:"string"})," (optional)"]}),"\n",(0,s.jsxs)(n.ul,{children:["\n",(0,s.jsx)(n.li,{children:"Event from which to retrieve entries"}),"\n",(0,s.jsxs)(n.li,{children:["Mutually exclusive with ",(0,s.jsx)(n.code,{children:"entries"})," parameter"]}),"\n",(0,s.jsxs)(n.li,{children:["When provided, uses ",(0,s.jsx)(n.code,{children:"event.entries"})," as source"]}),"\n"]}),"\n",(0,s.jsxs)(n.p,{children:[(0,s.jsx)(n.strong,{children:"entries"})," - ",(0,s.jsx)(n.em,{children:"array"})," (optional)"]}),"\n",(0,s.jsxs)(n.ul,{children:["\n",(0,s.jsx)(n.li,{children:"Custom array of entry objects"}),"\n",(0,s.jsxs)(n.li,{children:["Overrides ",(0,s.jsx)(n.code,{children:"eventId"})," if both provided"]}),"\n",(0,s.jsxs)(n.li,{children:["Must include ",(0,s.jsx)(n.code,{children:"participantId"})," for each entry"]}),"\n"]}),"\n",(0,s.jsxs)(n.p,{children:[(0,s.jsx)(n.strong,{children:"stage"})," - ",(0,s.jsx)(n.em,{children:"string"})," (optional)"]}),"\n",(0,s.jsxs)(n.ul,{children:["\n",(0,s.jsxs)(n.li,{children:["Filter entries by stage: ",(0,s.jsx)(n.code,{children:"'MAIN'"}),", ",(0,s.jsx)(n.code,{children:"'QUALIFYING'"}),", ",(0,s.jsx)(n.code,{children:"'CONSOLATION'"})]}),"\n",(0,s.jsxs)(n.li,{children:["Only applies when using ",(0,s.jsx)(n.code,{children:"eventId"})]}),"\n",(0,s.jsx)(n.li,{children:"Returns only entries matching the specified stage"}),"\n"]}),"\n",(0,s.jsxs)(n.p,{children:[(0,s.jsx)(n.strong,{children:"scaleAttributes"})," - ",(0,s.jsx)(n.em,{children:"object"})," (required)"]}),"\n",(0,s.jsxs)(n.ul,{children:["\n",(0,s.jsx)(n.li,{children:"Defines which scale to use for sorting"}),"\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.strong,{children:"scaleType"}),": ",(0,s.jsx)(n.code,{children:"'RATING'"}),", ",(0,s.jsx)(n.code,{children:"'RANKING'"}),", or ",(0,s.jsx)(n.code,{children:"'SEEDING'"})]}),"\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.strong,{children:"scaleName"}),": Identifier (e.g., ",(0,s.jsx)(n.code,{children:"'WTN'"}),", ",(0,s.jsx)(n.code,{children:"'UTR'"}),", ",(0,s.jsx)(n.code,{children:"'ATP'"}),")"]}),"\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.strong,{children:"eventType"}),": ",(0,s.jsx)(n.code,{children:"'SINGLES'"}),", ",(0,s.jsx)(n.code,{children:"'DOUBLES'"}),", or ",(0,s.jsx)(n.code,{children:"'TEAM'"})]}),"\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.strong,{children:"accessor"})," (optional): Path to nested value if ",(0,s.jsx)(n.code,{children:"scaleValue"})," is an object"]}),"\n"]}),"\n",(0,s.jsxs)(n.p,{children:[(0,s.jsx)(n.strong,{children:"scaleSortMethod"})," - ",(0,s.jsx)(n.em,{children:"function"})," (optional)"]}),"\n",(0,s.jsxs)(n.ul,{children:["\n",(0,s.jsxs)(n.li,{children:["Custom comparator function: ",(0,s.jsx)(n.code,{children:"(a, b) => number"})]}),"\n",(0,s.jsx)(n.li,{children:"Receives two scale values for comparison"}),"\n",(0,s.jsx)(n.li,{children:"Return negative/zero/positive like standard sort"}),"\n",(0,s.jsxs)(n.li,{children:["Useful when ",(0,s.jsx)(n.code,{children:"scaleValue"})," is an object or custom logic needed"]}),"\n"]}),"\n",(0,s.jsxs)(n.p,{children:[(0,s.jsx)(n.strong,{children:"sortDescending"})," - ",(0,s.jsx)(n.em,{children:"boolean"})," (optional)"]}),"\n",(0,s.jsxs)(n.ul,{children:["\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.code,{children:"true"}),": Sort from highest to lowest (largest value first)"]}),"\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.code,{children:"false"}),": Sort from lowest to highest (smallest value first)"]}),"\n",(0,s.jsxs)(n.li,{children:["Default is ",(0,s.jsx)(n.code,{children:"false"})," (ascending order)"]}),"\n",(0,s.jsxs)(n.li,{children:["Only applies to default sorting (not ",(0,s.jsx)(n.code,{children:"scaleSortMethod"}),")"]}),"\n"]}),"\n",(0,s.jsx)(n.h3,{id:"return-value-1",children:"Return Value"}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-js",children:"{\n  scaledEntries; // array of entries sorted by scale values\n}\n"})}),"\n",(0,s.jsxs)(n.p,{children:[(0,s.jsx)(n.strong,{children:"scaledEntries"})," - Array of entry objects, each containing:"]}),"\n",(0,s.jsxs)(n.ul,{children:["\n",(0,s.jsx)(n.li,{children:"Original entry attributes"}),"\n",(0,s.jsx)(n.li,{children:"Participant scale information"}),"\n",(0,s.jsx)(n.li,{children:"Sorted by scale value according to parameters"}),"\n"]}),"\n",(0,s.jsx)(n.h3,{id:"examples",children:"Examples"}),"\n",(0,s.jsx)(n.h4,{id:"basic-usage---sort-by-rating",children:"Basic Usage - Sort by Rating"}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-js",children:"// Get entries sorted by WTN rating (ascending)\nconst { scaledEntries } = tournamentEngine.getScaledEntries({\n  eventId: 'singles-main',\n  scaleAttributes: {\n    scaleType: 'RATING',\n    scaleName: 'WTN',\n    eventType: 'SINGLES',\n  },\n});\n\n// scaledEntries[0] has lowest WTN rating\n// scaledEntries[last] has highest WTN rating\n"})}),"\n",(0,s.jsx)(n.h4,{id:"sort-by-ranking-descending",children:"Sort by Ranking (Descending)"}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-js",children:"// Get entries sorted by ATP ranking (highest rank first)\nconst { scaledEntries } = tournamentEngine.getScaledEntries({\n  eventId: 'singles-main',\n  scaleAttributes: {\n    scaleType: 'RANKING',\n    scaleName: 'ATP',\n    eventType: 'SINGLES',\n  },\n  sortDescending: true, // highest ranking first\n});\n\n// scaledEntries[0] has best (lowest number) ATP ranking\n"})}),"\n",(0,s.jsx)(n.h4,{id:"filter-by-stage",children:"Filter by Stage"}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-js",children:"// Get only qualifying entries sorted by rating\nconst { scaledEntries } = tournamentEngine.getScaledEntries({\n  eventId: 'singles-event',\n  stage: 'QUALIFYING',\n  scaleAttributes: {\n    scaleType: 'RATING',\n    scaleName: 'UTR',\n    eventType: 'SINGLES',\n  },\n});\n"})}),"\n",(0,s.jsx)(n.h4,{id:"custom-entries-array",children:"Custom Entries Array"}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-js",children:"// Sort custom set of participants\nconst myEntries = [\n  { participantId: 'p1', entryStage: 'MAIN', entryStatus: 'DIRECT_ACCEPTANCE' },\n  { participantId: 'p2', entryStage: 'MAIN', entryStatus: 'DIRECT_ACCEPTANCE' },\n  { participantId: 'p3', entryStage: 'MAIN', entryStatus: 'WILDCARD' },\n];\n\nconst { scaledEntries } = tournamentEngine.getScaledEntries({\n  entries: myEntries, // Use custom array instead of event entries\n  scaleAttributes: {\n    scaleType: 'RATING',\n    scaleName: 'WTN',\n    eventType: 'SINGLES',\n  },\n});\n"})}),"\n",(0,s.jsx)(n.h4,{id:"complex-scale-values-with-accessor",children:"Complex Scale Values with Accessor"}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-js",children:"// When scaleValue is an object, use accessor to specify comparison value\nconst { scaledEntries } = tournamentEngine.getScaledEntries({\n  eventId: 'singles-main',\n  scaleAttributes: {\n    scaleType: 'RATING',\n    scaleName: 'NTRP',\n    eventType: 'SINGLES',\n    accessor: 'ntrpRating', // Extract this property from scaleValue object\n  },\n});\n\n// Participants have scale items like:\n// scaleValue: { ntrpRating: 4.5, ratingYear: '2024', ustaRatingType: 'C' }\n// Accessor 'ntrpRating' tells method to sort by the 4.5 value\n"})}),"\n",(0,s.jsx)(n.h4,{id:"custom-sort-method",children:"Custom Sort Method"}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-js",children:"// Custom sorting logic for complex cases\nconst { scaledEntries } = tournamentEngine.getScaledEntries({\n  eventId: 'singles-main',\n  scaleAttributes: {\n    scaleType: 'RATING',\n    scaleName: 'WTN',\n    eventType: 'SINGLES',\n  },\n  scaleSortMethod: (a, b) => {\n    // Custom logic: prioritize by confidence, then by rating\n    const confidenceDiff = (b.confidence || 0) - (a.confidence || 0);\n    if (confidenceDiff !== 0) return confidenceDiff;\n    return a.rating - b.rating; // Ascending rating\n  },\n});\n"})}),"\n",(0,s.jsx)(n.h3,{id:"common-workflows",children:"Common Workflows"}),"\n",(0,s.jsx)(n.h4,{id:"generating-seeding-from-scaled-entries",children:"Generating Seeding from Scaled Entries"}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-js",children:"// Step 1: Get scaled entries\nconst { scaledEntries } = tournamentEngine.getScaledEntries({\n  eventId: 'singles-main',\n  stage: 'MAIN',\n  scaleAttributes: {\n    scaleType: 'RATING',\n    scaleName: 'WTN',\n    eventType: 'SINGLES',\n  },\n  sortDescending: true, // Highest rating first\n});\n\n// Step 2: Get seeds count\nconst { seedsCount } = tournamentEngine.getEntriesAndSeedsCount({\n  policyDefinitions: POLICY_SEEDING,\n  eventId: 'singles-main',\n  stage: 'MAIN',\n});\n\n// Step 3: Take top entries\nconst topEntries = scaledEntries.slice(0, seedsCount);\n\n// Step 4: Generate seeding scale items\nconst { scaleItemsWithParticipantIds } = tournamentEngine.generateSeedingScaleItems({\n  scaleAttributes: {\n    scaleType: 'SEEDING',\n    scaleName: 'singles-main',\n    eventType: 'SINGLES',\n  },\n  scaledEntries: topEntries,\n  seedsCount,\n  scaleName: 'singles-main',\n});\n\n// Step 5: Save to participants\nscaleItemsWithParticipantIds.forEach(({ participantId, scaleItems }) => {\n  tournamentEngine.setParticipantScaleItems({ participantId, scaleItems });\n});\n"})}),"\n",(0,s.jsx)(n.h4,{id:"validating-rating-coverage",children:"Validating Rating Coverage"}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-js",children:"// Check how many entries have ratings\nconst { scaledEntries } = tournamentEngine.getScaledEntries({\n  eventId: 'singles-main',\n  scaleAttributes: {\n    scaleType: 'RATING',\n    scaleName: 'WTN',\n    eventType: 'SINGLES',\n  },\n});\n\nconst totalEntries = scaledEntries.length;\nconst ratedEntries = scaledEntries.filter((entry) => entry.scaleValue).length;\nconst ratingCoverage = (ratedEntries / totalEntries) * 100;\n\nconsole.log(`${ratingCoverage.toFixed(1)}% of entries have WTN ratings`);\n"})}),"\n",(0,s.jsx)(n.h3,{id:"notes",children:"Notes"}),"\n",(0,s.jsx)(n.p,{children:(0,s.jsx)(n.strong,{children:"Missing Scale Values:"})}),"\n",(0,s.jsxs)(n.ul,{children:["\n",(0,s.jsx)(n.li,{children:"Entries without matching scale items are included but placed at the end"}),"\n",(0,s.jsx)(n.li,{children:"Their order among unrated entries is undefined"}),"\n",(0,s.jsx)(n.li,{children:"Consider filtering these out before generating seeding"}),"\n"]}),"\n",(0,s.jsx)(n.p,{children:(0,s.jsx)(n.strong,{children:"Performance:"})}),"\n",(0,s.jsxs)(n.ul,{children:["\n",(0,s.jsx)(n.li,{children:"Method retrieves scale items for all entries"}),"\n",(0,s.jsx)(n.li,{children:"More efficient than manually querying each participant"}),"\n",(0,s.jsx)(n.li,{children:"Results are suitable for immediate use in seeding generation"}),"\n"]}),"\n",(0,s.jsx)(n.p,{children:(0,s.jsx)(n.strong,{children:"Comparison with autoSeeding():"})}),"\n",(0,s.jsxs)(n.ul,{children:["\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.code,{children:"getScaledEntries()"})," only sorts entries; doesn't assign seeds"]}),"\n",(0,s.jsx)(n.li,{children:"Allows inspection/modification before generating seeds"}),"\n",(0,s.jsx)(n.li,{children:"More control over seeding process"}),"\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.code,{children:"autoSeeding()"})," combines sorting and assignment in one call"]}),"\n"]}),"\n",(0,s.jsx)(n.h3,{id:"see-also",children:"See Also"}),"\n",(0,s.jsxs)(n.ul,{children:["\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.strong,{children:(0,s.jsx)(n.a,{href:"../concepts/scaleItems",children:"Scale Items"})})," - Complete scale items documentation"]}),"\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.strong,{children:(0,s.jsx)(n.a,{href:"../concepts/scaleItems#generating-seeding-scale-items",children:"Generating Seeding Scale Items"})})," - Seeding generation patterns"]}),"\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.strong,{children:(0,s.jsx)(n.a,{href:"/docs/governors/draws-governor#autoseeding",children:"Auto Seeding"})})," - Automatic seeding"]}),"\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.strong,{children:(0,s.jsx)(n.a,{href:"/docs/governors/generation-governor#generateseedingscaleitems",children:"generateSeedingScaleItems"})})," - Generate seed assignments"]}),"\n"]}),"\n",(0,s.jsx)(n.hr,{}),"\n",(0,s.jsx)(n.h2,{id:"getschedulingprofile",children:"getSchedulingProfile"}),"\n",(0,s.jsxs)(n.p,{children:["Returns a ",(0,s.jsx)(n.code,{children:"schedulingProfile"})," (if present). Checks the integrity of the profile to account for any ",(0,s.jsx)(n.code,{children:"venues"})," or ",(0,s.jsx)(n.code,{children:"drawDefinitions"})," which have been deleted."]}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-js",children:"const { schedulingProfile } = engine.getSchedulingProfile();\n"})}),"\n",(0,s.jsx)(n.hr,{}),"\n",(0,s.jsx)(n.h2,{id:"getschedulingprofileissues",children:"getSchedulingProfileIssues"}),"\n",(0,s.jsxs)(n.p,{children:["Analyzes the ",(0,s.jsx)(n.code,{children:"schedulingProfile"})," (if any) that is attached to the ",(0,s.jsx)(n.code,{children:"tournamentRecord(s)"})," and reports any issues with the ordering of rounds."]}),"\n",(0,s.jsxs)(n.p,{children:["The analysis for each ",(0,s.jsx)(n.code,{children:"scheduleDate"})," only includes ",(0,s.jsx)(n.code,{children:"matchUps"})," to be scheduled on that date.\nIn other words, the method only reports on scheduling issues relative to the group of ",(0,s.jsx)(n.code,{children:"matchUpIds"})," derived from rounds which are being scheduled for each date."]}),"\n",(0,s.jsxs)(n.admonition,{type:"note",children:[(0,s.jsxs)(n.p,{children:["In some cases it is valid to schedule a second round, for instance, before a first round, because there may be some second round ",(0,s.jsx)(n.code,{children:"matchUps"})," which are ready to be played... possibly due to ",(0,s.jsx)(n.code,{children:"participants"})," advancing via first round BYEs or WALKOVERs."]}),(0,s.jsxs)(n.p,{children:["Regardless of issues reported, ",(0,s.jsx)(n.code,{children:"engine.scheduleProfileRounds()"})," will attempt to follow the desired order, but will not schedule ",(0,s.jsx)(n.code,{children:"matchUps"})," before dependencies."]})]}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-js",children:"const {\n  profileIssues: {\n    // object includes matchUpIds which are out of order\n    matchUpIdsShouldBeAfter: {\n      [matchUpId]: {\n        earlierRoundIndices: [index], // indices of scheduled rounds which must be scheduled before matchUpId\n        shouldBeAfter: [matchUpId], // array of matchUpIds which must be scheduled before matchUpId\n      },\n    },\n  },\n  // roundIndex is the index of the round to be scheduled within the schedulingProfile for a givn date\n  roundIndexShouldBeAfter: {\n    [scheduleDate]: {\n      [index]: [indexOfEarlierRound], // maps the index of the round within a date's scheduled rounds to those rounds which should be scheduled first\n    },\n  },\n} = engine.getSchedulingProfileIssues({\n  dates, // optional array of target dates\n});\n"})}),"\n",(0,s.jsx)(n.hr,{}),"\n",(0,s.jsx)(n.h2,{id:"getseedscount",children:"getSeedsCount"}),"\n",(0,s.jsx)(n.p,{children:"Takes a policyDefinition, drawSize and participantsCount and returrns the number of seeds valid for the specified drawSize"}),"\n",(0,s.jsx)(n.admonition,{type:"note",children:(0,s.jsxs)(n.p,{children:[(0,s.jsx)(n.code,{children:"drawSizeProgression"})," will be overridden by a ",(0,s.jsx)(n.code,{children:"{ drawSizeProgression }"})," value in a policyDefinition."]})}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-js",children:"const { seedsCount, error } = engine.getSeedsCount({\n  drawSizeProgression, // optional - fits the seedsCount to the participantsCount rather than the drawSize\n  policyDefinitions: SEEDING_USTA,\n  participantsCount: 15,\n  drawSize: 128,\n});\n"})}),"\n",(0,s.jsx)(n.hr,{}),"\n",(0,s.jsx)(n.h2,{id:"getseedingthresholds",children:"getSeedingThresholds"}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-js",children:"const { seedingThresholds } = engine.getSeedingThresholds({\n  roundRobinGroupsCount,\n  participantsCount,\n});\n"})}),"\n",(0,s.jsx)(n.hr,{}),"\n",(0,s.jsx)(n.h2,{id:"getstructureseedassignments",children:"getStructureSeedAssignments"}),"\n",(0,s.jsx)(n.p,{children:"Returns seedAssignments for a specific structure based on structureId or structure"}),"\n",(0,s.jsxs)(n.p,{children:["The structure of an ",(0,s.jsx)(n.strong,{children:(0,s.jsx)(n.em,{children:"assignment object"})})," is as follows:"]}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-json",children:'{\n  "seedNumber": 1,\n  "seedValue": "1",\n  "participantId": "uuid-of-participant"\n}\n'})}),"\n",(0,s.jsx)(n.p,{children:"The most basic usage is to retrieve seed assignments for a draw which has a single main stage structure"}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-js",children:"const { seedAssignments } = engine.getStructureSeedAssignments({\n  structureId,\n  drawId,\n});\n"})}),"\n",(0,s.jsx)(n.hr,{}),"\n",(0,s.jsx)(n.h2,{id:"getstructurereports",children:"getStructureReports"}),"\n",(0,s.jsx)(n.p,{children:"Returns details of all structures within a tournamentRecord, as well as aggregated details per event."}),"\n",(0,s.jsx)(n.p,{children:(0,s.jsx)(n.code,{children:"tournamentId, eventId, structureId, drawId, eventType, category: subType, categoryName, ageCategoryCode, flightNumber, drawType, stage, winningPersonId, winningPersonWTNrating, winningPersonWTNconfidence, winningPerson2Id, winningPerson2WTNrating, winningPerson2WTNconfidence, positionManipulations, pctNoRating, matchUpFormat, pctInitialMatchUpFormat, matchUpsCount, tieFormatDesc, tieFormatName, avgConfidence, avgWTN"})}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-js",children:"const {\n  structureReports,\n  eventStructureReports: {\n    totalPositionManipulations,\n    maxPositionManipulations,\n    generatedDrawsCount,\n    drawDeletionsCount,\n  },\n} = engine.getStructureReports({\n  firstStageSequenceOnly, // boolean - defaults to true - only return first stageSequence\n  firstFlightOnly, // boolean - defaults to true - only return first flight when multiple drawDefinitions per event\n  extensionProfiles: [\n    {\n      name, // extension name\n      label, // label for generated attribute\n      accessor, // dot-notation accessor for extension value, e.g. 'attribute.attribute'\n    },\n  ],\n});\n"})}),"\n",(0,s.jsx)(n.p,{children:"To export report as CSV:"}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-js",children:"const csv = tools.JSON2CSV(structureReports);\n"})}),"\n",(0,s.jsx)(n.hr,{}),"\n",(0,s.jsx)(n.h2,{id:"getteamlineup",children:"getTeamLineUp"}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-js",children:"const { lineUp } = engine.getTeamLineUp({ drawId, participantId });\n"})}),"\n",(0,s.jsx)(n.hr,{}),"\n",(0,s.jsx)(n.h2,{id:"gettieformat",children:"getTieFormat"}),"\n",(0,s.jsxs)(n.p,{children:["Returns ",(0,s.jsx)(n.code,{children:"tieFormat"})," definition objects for specified context(s)."]}),"\n",(0,s.jsxs)(n.p,{children:[(0,s.jsx)(n.code,{children:"tieFormat"})," for each matchUp is determined by traversing the hierarchy: ",(0,s.jsx)(n.code,{children:"matchUp => stucture => drawDefinition => event"})]}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-js",children:"const { tieFormat, structureDefaultTieFormat, drawDefaultTieFormat, eventDefaultTieFormat } = engine.getTieFormat({\n  structureId,\n  matchUpId,\n  eventId,\n  drawId,\n});\n"})}),"\n",(0,s.jsx)(n.hr,{}),"\n",(0,s.jsx)(n.h2,{id:"gettournamentinfo",children:"getTournamentInfo"}),"\n",(0,s.jsxs)(n.p,{children:["Returns tournament attributes. Used to attach details to publishing payload by ",(0,s.jsx)(n.code,{children:"getEventData"}),"."]}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-js",children:"const { tournamentInfo } = getTournamentInfo({ tournamentRecord });\nconst {\n  tournamentId,\n  tournamentRank,\n\n  formalName,\n  tournamentName,\n  promotionalName,\n  onlineResources,\n\n  localTimeZone,\n  startDate,\n  endDate,\n\n  hostCountryCode,\n  tournamentStatus,\n} = tournamentInfo;\n"})}),"\n",(0,s.jsx)(n.hr,{}),"\n",(0,s.jsx)(n.h2,{id:"gettournamentpersons",children:"getTournamentPersons"}),"\n",(0,s.jsxs)(n.p,{children:["Returns ",(0,s.jsx)(n.strong,{children:"deepCopies"})," of persons extracted from tournament participants. Each person includes an array of ",(0,s.jsx)(n.code,{children:"participantIds"})," from which person data was retrieved."]}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-js",children:"const { tournamentPersons } = engine.getTournamentPersons({\n  participantFilters: { participantRoles: [COMPETITOR] }, // optional - filters\n});\n"})}),"\n",(0,s.jsx)(n.hr,{}),"\n",(0,s.jsx)(n.h2,{id:"gettournamentpenalties",children:"getTournamentPenalties"}),"\n",(0,s.jsx)(n.p,{children:"Returns an array of all penalties issued during a tournament."}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-js",children:"const { penalties } = engine.getTournamentPenalties();\n"})}),"\n",(0,s.jsx)(n.hr,{}),"\n",(0,s.jsx)(n.h2,{id:"gettournamentstructures",children:"getTournamentStructures"}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-js",children:"const { structures, stageStructures } = engine.getTournamentStructures({\n  withStageGrouping: true, // optional return structures grouped by stages\n  stageSequences, // optional - specify stageSequences to include\n  stageSequence, // optional - filter by stageSequence\n  stages, // optional - specify stageSequences to include\n  stage, // optional - filter by stage\n});\n"})}),"\n",(0,s.jsx)(n.hr,{}),"\n",(0,s.jsx)(n.h2,{id:"getvalidgroupsizes",children:"getValidGroupSizes"}),"\n",(0,s.jsxs)(n.p,{children:["Returns valid Round Robin group sizes for specified ",(0,s.jsx)(n.code,{children:"drawSize"}),"."]}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-js",children:"const { validGroupSizes } = engine.getValidGroupSizes({\n  groupSizeLimit, // optional - defaults to 10\n  drawSize,\n});\n"})}),"\n",(0,s.jsx)(n.hr,{}),"\n",(0,s.jsx)(n.h2,{id:"getvenuesandcourts",children:"getVenuesAndCourts"}),"\n",(0,s.jsx)(n.p,{children:"Returns an array of all Venues which are part of a tournamentRecord and an aggregation of courts across all venues."}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-js",children:"const { venues, courts } = engine.getVenuesAndCourts({\n  convertExtensions, // optional boolean\n  ignoreDisabled, // optional boolean\n  dates, // optional - used with ignoreDisabled - applies to courts\n});\n"})}),"\n",(0,s.jsx)(n.hr,{}),"\n",(0,s.jsx)(n.h2,{id:"getvenuedata",children:"getVenueData"}),"\n",(0,s.jsxs)(n.p,{children:["Returns restricted venue attributes along with information for all associated courts. Used primarily by ",(0,s.jsx)(n.code,{children:"getEventData"})," to return a subset of venue/courts information for publishing purposes."]}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-js",children:"const {\n  venueName,\n  venueAbbreviation,\n  courtsInfo, // array of courts and associated attributes\n} = engine.getVenueData({ venueId });\n"})}),"\n",(0,s.jsx)(n.hr,{}),"\n",(0,s.jsx)(n.h2,{id:"generatebookings",children:"generateBookings"}),"\n",(0,s.jsx)(n.p,{children:'This methods is used internally for creating a "virtual" view of court availability.'}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-js",children:"const { bookings, relevantMatchUps } = engine.generateBookings({\n  defaultRecoveryMinutes, // optional\n  averageMatchUpMinutes, // optional\n  periodLength, // optional - scheduling period in minutes\n  scheduleDate, // optional - only consider matchUps scheduled on scheduleDate\n  venueIds, // optional - only consider matchUps at specific venue(s)\n  matchUps,\n});\n"})}),"\n",(0,s.jsx)(n.hr,{}),"\n",(0,s.jsx)(n.h2,{id:"getvenuesreport",children:"getVenuesReport"}),"\n",(0,s.jsxs)(n.p,{children:["Returns a ",(0,s.jsx)(n.code,{children:"venueReports"})," array which provides details for each targt ",(0,s.jsx)(n.code,{children:"venue"})," for targt date(s)."]}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-js",children:"const { venuesReport } = engine.getVenuesReport({\n  dates, // optional array of target dates\n  venueIds, // optional array of target venueIds\n  ignoreDisabled, // optional boolean, defaults to true - ignore disabled venues/courts\n});\n\nconst {\n  availableCourts, // how many courts are available for date\n  availableMinutes, // total courts minutes available for date\n  scheduledMinutes, // minutes of court time that are scheduled for matchUps\n  scheduledMatchUpsCount, // number of scheduled matchUps\n  percentUtilization, // percent of available minutes utilized by scheduled matchUps\n} = venuesReport[0].venueReport[date];\n"})}),"\n",(0,s.jsx)(n.hr,{}),"\n",(0,s.jsx)(n.h2,{id:"iscompletedstructure",children:"isCompletedStructure"}),"\n",(0,s.jsx)(n.p,{children:"Returns boolean whether all matchUps in a given structure have been completed"}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-js",children:"const structureIsComplete = engine.isCompletedStructure({\n  structureId,\n});\n"})}),"\n",(0,s.jsx)(n.hr,{}),"\n",(0,s.jsx)(n.h2,{id:"isvalidforqualifying",children:"isValidForQualifying"}),"\n",(0,s.jsxs)(n.p,{children:["Provides determination of whether qualifying structure(s) may be added to the structure specified by ",(0,s.jsx)(n.code,{children:"structureId"}),"."]}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-js",children:"const { valid } = engine.isValidForQualifying({\n  structureId,\n  drawId,\n});\n"})}),"\n",(0,s.jsx)(n.hr,{}),"\n",(0,s.jsx)(n.h2,{id:"isvalidmatchupformat",children:"isValidMatchUpFormat"}),"\n",(0,s.jsx)(n.p,{children:"Returns boolean indicating whether matchUpFormat code is valid."}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-js",children:"const valid = engine.isValidMatchUpFormat({ matchUpFormat });\n"})}),"\n",(0,s.jsx)(n.hr,{}),"\n",(0,s.jsx)(n.h2,{id:"matchupactions",children:"matchUpActions"}),"\n",(0,s.jsxs)(n.p,{children:["Return an array of all validActions for a specific matchUp. See examples: ",(0,s.jsx)(n.a,{href:"/competition-factory/docs/concepts/actions#usage",children:"Usage"}),", ",(0,s.jsx)(n.a,{href:"/competition-factory/docs/concepts/matchup-overview#matchup-actions",children:"MatchUp Actions"}),"."]}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-js",children:"const {\n  isByeMatchUp, // boolean; true if matchUp includes a BYE\n  structureIsComplete, // boolean; true if structure is ready for positioning\n  validActions, // array of possible actions given current matchUpStatus\n} = engine.matchUpActions({\n  restrictAdHocRoundParticipants, // optional - true by default; applies to AD_HOC; disallow the same participant being in the same round multiple times\n  sideNumber, // optional - select side to which action should apply; applies to AD_HOC position assignments\n  matchUpId, // required - reference to targeted matchUp\n  drawId, // optional - not strictly required; method will find matchUp by brute force without it\n});\n\nconst {\n  type, // 'REFEREE', 'SCHEDULE', 'PENALTY', 'STATUS', 'SCORE', 'START', 'END', 'SUBSTITUTION'.\n  method, // engine method relating to action type\n  payload, // attributes to be passed to method\n  // additional method-specific options for values to be added to payload when calling method\n} = validAction;\n"})}),"\n",(0,s.jsx)(n.hr,{}),"\n",(0,s.jsx)(n.h2,{id:"participantscaleitem",children:"participantScaleItem"}),"\n",(0,s.jsxs)(n.p,{children:["Similar to ",(0,s.jsx)(n.a,{href:"#getparticipantscaleitem",children:"getParticipantScaleItem"})," but takes a ",(0,s.jsx)(n.code,{children:"participant"})," object and doesn't require ",(0,s.jsx)(n.code,{children:"engine.setState(tournamentRecord)"}),"."]}),"\n",(0,s.jsxs)(n.p,{children:["See ",(0,s.jsx)(n.a,{href:"../concepts/scaleItems",children:"Scale Items"}),"."]}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-js",children:"const scaleAttributes = {\n  scaleType: RATING,\n  eventType: SINGLES,\n  scaleName: 'WTN',\n  accessor, // optional - string determining how to access attribute if scaleValue is an object\n};\nconst {\n  scaleItem: { scaleValue },\n} = engine.participantScaleItem({\n  scaleAttributes,\n  participant,\n});\n"})}),"\n",(0,s.jsx)(n.hr,{}),"\n",(0,s.jsx)(n.h2,{id:"positionactions",children:"positionActions"}),"\n",(0,s.jsxs)(n.p,{children:["Returns valid actions for a given ",(0,s.jsx)(n.code,{children:"drawPosition"}),". If params includes ",(0,s.jsx)(n.code,{children:"matchUpId"})," will pass through to ",(0,s.jsx)(n.a,{href:"#matchupactions",children:"matchUpActions"})," when called for ",(0,s.jsx)(n.strong,{children:"AD_HOC"})," structures. See examples: ",(0,s.jsx)(n.a,{href:"/competition-factory/docs/concepts/actions#usage",children:"Usage"}),"."]}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-js",children:"const positionActions = engine.positionActions({\n  policyDefinitions: positionActionsPolicy, // optional - policy defining what actions are allowed in client context\n  returnParticipants, // optional boolean; defaults to true; performance optimization when false requires client to provide participants.\n  drawPosition,\n  structureId,\n  drawId,\n});\n\nconst {\n  isActiveDrawPosition, // boolean\n  isByePosition, // boolean\n  isDrawPosition, // boolean\n  hasPositionAssiged, // boolean\n  validActions,\n} = positionActions;\n\nconst {\n  type, // 'ASSIGN', 'LUCKY', 'SWAP', 'BYE', 'REMOVE'\n  method, // engine method relating to action type\n  payload, // attributes to be passed to method\n  // additional method-specific options for values to be added to payload when calling method\n} = validAction;\n"})}),"\n",(0,s.jsx)(n.hr,{}),"\n",(0,s.jsx)(n.h2,{id:"tallyparticipantresults",children:"tallyParticipantResults"}),"\n",(0,s.jsx)(n.p,{children:"Generates participant results and groupOrder for round robin structures. Calculates standings based on win/loss records, sets, games, points, and applies tiebreaking directives from the round robin tally policy."}),"\n",(0,s.jsx)(n.h3,{id:"basic-usage",children:"Basic Usage"}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-js",children:"const { participantResults, order, bracketComplete, report, readableReport } = tallyParticipantResults({\n  policyDefinitions, // Optional - policy with roundRobinTally configuration\n  matchUps, // Required - array of round robin matchUps\n  matchUpFormat, // Optional - default format for the structure\n  perPlayer, // Optional - expected matchUps per participant\n  subOrderMap, // Optional - sub-order mapping for playoff placement\n  pressureRating, // Optional - calculate pressure ratings\n  generateReport: false, // Optional - generate detailed tiebreaking report\n});\n"})}),"\n",(0,s.jsx)(n.h3,{id:"return-values",children:"Return Values"}),"\n",(0,s.jsxs)(n.p,{children:[(0,s.jsx)(n.strong,{children:"participantResults"})," - Object keyed by participantId with statistics and placement"]}),"\n",(0,s.jsxs)(n.p,{children:[(0,s.jsx)(n.strong,{children:"order"})," - Array of participants in final/provisional order with resolution status"]}),"\n",(0,s.jsxs)(n.p,{children:[(0,s.jsx)(n.strong,{children:"bracketComplete"})," - Boolean indicating if all matchUps are complete"]}),"\n",(0,s.jsxs)(n.p,{children:[(0,s.jsx)(n.strong,{children:"report"})," - Array of tiebreaking steps (when generateReport: true)"]}),"\n",(0,s.jsxs)(n.p,{children:[(0,s.jsx)(n.strong,{children:"readableReport"})," - Human-readable tiebreaking explanation (when generateReport: true)"]}),"\n",(0,s.jsx)(n.h3,{id:"the-generatereport-parameter",children:"The generateReport Parameter"}),"\n",(0,s.jsxs)(n.p,{children:["When ",(0,s.jsx)(n.code,{children:"generateReport: true"}),", returns detailed information about ",(0,s.jsx)(n.strong,{children:"exactly how tiebreaks were resolved"}),":"]}),"\n",(0,s.jsx)(n.p,{children:(0,s.jsx)(n.strong,{children:"Why use it?"})}),"\n",(0,s.jsxs)(n.ul,{children:["\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.strong,{children:"Transparency"})," - Show participants how their placement was determined"]}),"\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.strong,{children:"Debugging"})," - Understand why specific tiebreaking directives were used"]}),"\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.strong,{children:"Validation"})," - Verify that tiebreaking followed the expected policy"]}),"\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.strong,{children:"Documentation"})," - Record the complete tiebreaking process"]}),"\n"]}),"\n",(0,s.jsx)(n.p,{children:(0,s.jsx)(n.strong,{children:"What's included?"})}),"\n",(0,s.jsx)(n.p,{children:"For each tiebreaking step:"}),"\n",(0,s.jsxs)(n.ol,{children:["\n",(0,s.jsxs)(n.li,{children:["Which directive was applied (e.g., ",(0,s.jsx)(n.code,{children:"matchUpsPct"}),", ",(0,s.jsx)(n.code,{children:"headToHead.setsPct"}),")"]}),"\n",(0,s.jsx)(n.li,{children:"How participants grouped by that directive's values"}),"\n",(0,s.jsx)(n.li,{children:"Whether the directive used idsFilter (head-to-head for tied participants only)"}),"\n",(0,s.jsx)(n.li,{children:"Whether maxParticipants excluded the directive (skipping 3+ way ties)"}),"\n",(0,s.jsx)(n.li,{children:"Which participants remained tied after the directive"}),"\n",(0,s.jsx)(n.li,{children:"Final order with resolution status"}),"\n"]}),"\n",(0,s.jsx)(n.p,{children:(0,s.jsx)(n.strong,{children:"Example readableReport output:"})}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-text",children:"Step 1: 4 participants were grouped by matchUpsPct\n0.75 matchUpsPct: Player A, Player B\n0.50 matchUpsPct: Player C\n0.25 matchUpsPct: Player D\n----------------------\nStep 2: 2 participants were separated by headToHead.matchUpsPct\nheadToHead.matchUpsPct was calculated considering ONLY TIED PARTICIPANTS\n1.00 headToHead.matchUpsPct: Player A\n0.00 headToHead.matchUpsPct: Player B\n----------------------\nFinal Order:\n1: Player A => resolved: true\n2: Player B => resolved: true\n3: Player C => resolved: true\n4: Player D => resolved: true\n"})}),"\n",(0,s.jsx)(n.p,{children:(0,s.jsx)(n.strong,{children:"Example usage:"})}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-js",children:"const { participantResults, order, report, readableReport } = tallyParticipantResults({\n  matchUps: roundRobinMatchUps,\n  policyDefinitions: {\n    roundRobinTally: {\n      tallyDirectives: [\n        { attribute: 'matchUpsPct' },\n        { attribute: 'headToHead.matchUpsPct', idsFilter: true, maxParticipants: 2 },\n        { attribute: 'headToHead.setsPct', idsFilter: true, maxParticipants: 2 },\n        { attribute: 'setsPct' },\n      ],\n    },\n  },\n  generateReport: true,\n});\n\n// Display human-readable report\nconsole.log(readableReport);\n\n// Analyze programmatically\nreport.forEach((step) => {\n  console.log(`${step.attribute}: ${step.participantIds.length} still tied`);\n  if (step.idsFilter) console.log('  \u2192 Head-to-head calculation');\n  if (step.excludedDirectives) console.log('  \u2192 Some directives skipped (maxParticipants)');\n});\n"})}),"\n",(0,s.jsxs)(n.admonition,{title:"Development Context",type:"tip",children:[(0,s.jsxs)(n.p,{children:["Setting ",(0,s.jsx)(n.code,{children:"engine.devContext({ tally: true })"})," will automatically log ",(0,s.jsx)(n.code,{children:"readableReport"})," to the console during calculation, even when ",(0,s.jsx)(n.code,{children:"generateReport: false"}),"."]}),(0,s.jsxs)(n.p,{children:["In browser consoles of client applications use: ",(0,s.jsx)(n.code,{children:"dev.context({ tally: true })"})," where available."]})]}),"\n",(0,s.jsx)(n.h3,{id:"further-reading",children:"Further Reading"}),"\n",(0,s.jsxs)(n.ul,{children:["\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.strong,{children:(0,s.jsx)(n.a,{href:"/competition-factory/docs/policies/roundRobinTallyPolicy",children:"Round Robin Tally Policy"})})," - Complete policy documentation"]}),"\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.strong,{children:(0,s.jsx)(n.a,{href:"/competition-factory/docs/policies/roundRobinTallyPolicy#tallydirectives",children:"tallyDirectives"})})," - Configure tiebreaking order"]}),"\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.strong,{children:(0,s.jsx)(n.a,{href:"/competition-factory/docs/policies/roundRobinTallyPolicy#idsfilter",children:"idsFilter"})})," - Head-to-head calculations"]}),"\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.strong,{children:(0,s.jsx)(n.a,{href:"/competition-factory/docs/policies/maxParticipants",children:"maxParticipants"})})," - Participant count thresholds"]}),"\n"]}),"\n",(0,s.jsx)(n.hr,{}),"\n",(0,s.jsx)(n.h2,{id:"tournamentmatchups",children:"tournamentMatchUps"}),"\n",(0,s.jsxs)(n.p,{children:["Returns tournament matchUps grouped by matchUpStatus. These matchUps are returned with ",(0,s.jsx)(n.em,{children:"context"}),"."]}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-js",children:"const {\n  abandonedMatchUps,\n  completedMatchUps,\n  upcomingMatchUps,\n  pendingMatchUps,\n  byeMatchUps,\n  groupInfo,\n  participants,\n} = engine.tournamentMatchUps({\n  scheduleVisibilityFilters, // { visibilityThreshold: dateString, eventIds, drawIds }\n  policyDefinitions, // optional - seeding or avoidance policies to be used when placing participants\n  matchUpFilters, // optional; [ scheduledDates: [], courtIds: [], stages: [], roundNumbers: [], matchUpStatuses: [], matchUpFormats: []]\n});\n"})}),"\n",(0,s.jsx)(n.hr,{}),"\n",(0,s.jsx)(n.h2,{id:"findextension",children:"findExtension"}),"\n",(0,s.jsxs)(n.p,{children:["Finds and returns a specific extension by name from a tournament element (tournament, event, draw, participant, matchUp, etc.). See examples: ",(0,s.jsx)(n.a,{href:"/competition-factory/docs/concepts/scheduling-profile#retrieving-scheduling-profile",children:"Retrieving Scheduling Profile"}),"."]}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-js",children:"const { extension, info } = engine.findExtension({\n  name: 'privateNote', // extension name to find\n  element: tournamentRecord, // object containing extensions array\n  discover: true, // optional - search in params for extension\n});\n\nif (extension) {\n  console.log(extension.value);\n}\n"})}),"\n",(0,s.jsx)(n.p,{children:(0,s.jsx)(n.strong,{children:"Parameters:"})}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-ts",children:"{\n  name: string;                    // required - extension name\n  element?: any;                   // object with extensions array\n  discover?: boolean | string[];   // search params for extension\n  ...params                        // additional objects to search (if discover is true)\n}\n"})}),"\n",(0,s.jsx)(n.p,{children:(0,s.jsx)(n.strong,{children:"Returns:"})}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-ts",children:"{\n  extension?: Extension;\n  info?: string;  // NOT_FOUND if extension doesn't exist\n  error?: ErrorType;  // MISSING_VALUE if name or element missing\n}\n"})}),"\n",(0,s.jsx)(n.p,{children:(0,s.jsx)(n.strong,{children:"Notes:"})}),"\n",(0,s.jsxs)(n.ul,{children:["\n",(0,s.jsx)(n.li,{children:"Returns first matching extension by name"}),"\n",(0,s.jsxs)(n.li,{children:["If ",(0,s.jsx)(n.code,{children:"discover"})," is ",(0,s.jsx)(n.code,{children:"true"}),", searches all params for objects with extensions"]}),"\n",(0,s.jsxs)(n.li,{children:["If ",(0,s.jsx)(n.code,{children:"discover"})," is ",(0,s.jsx)(n.code,{children:"string[]"}),", only searches specified param keys"]}),"\n",(0,s.jsx)(n.li,{children:"Useful for finding custom extensions without knowing exact location"}),"\n"]}),"\n",(0,s.jsx)(n.hr,{}),"\n",(0,s.jsx)(n.h2,{id:"credits",children:"credits"}),"\n",(0,s.jsx)(n.p,{children:"Returns an acknowledgments string recognizing contributors to the CourtHive/TODS project."}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-js",children:"const acknowledgments = engine.credits();\nconsole.log(acknowledgments);\n"})}),"\n",(0,s.jsxs)(n.p,{children:[(0,s.jsx)(n.strong,{children:"Returns:"})," ",(0,s.jsx)(n.code,{children:"string"})," - Multi-line acknowledgments text"]}),"\n",(0,s.jsxs)(n.p,{children:[(0,s.jsx)(n.strong,{children:"Note:"})," This method provides attribution and thanks to the many people who contributed to the development of the tournament management system and TODS standards."]}),"\n",(0,s.jsx)(n.hr,{})]})}function h(e={}){const{wrapper:n}={...(0,a.R)(),...e.components};return n?(0,s.jsx)(n,{...e,children:(0,s.jsx)(d,{...e})}):d(e)}},8322(e,n,t){t.d(n,{R:()=>r,x:()=>o});var i=t(758);const s={},a=i.createContext(s);function r(e){const n=i.useContext(a);return i.useMemo(function(){return"function"==typeof e?e(n):{...n,...e}},[n,e])}function o(e){let n;return n=e.disableParentContext?"function"==typeof e.components?e.components(s):e.components||s:r(e.components),i.createElement(a.Provider,{value:n},e.children)}}}]);