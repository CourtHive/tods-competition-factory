"use strict";(globalThis.webpackChunkdocumentation=globalThis.webpackChunkdocumentation||[]).push([[6930],{4701(n,e,i){i.r(e),i.d(e,{assets:()=>o,contentTitle:()=>a,default:()=>h,frontMatter:()=>l,metadata:()=>t,toc:()=>r});const t=JSON.parse('{"id":"concepts/scheduling-conflicts","title":"Conflict Reporting","description":"Overview","source":"@site/docs/concepts/scheduling-conflicts.mdx","sourceDirName":"concepts","slug":"/concepts/scheduling-conflicts","permalink":"/tods-competition-factory/docs/concepts/scheduling-conflicts","draft":false,"unlisted":false,"tags":[],"version":"current","frontMatter":{"title":"Conflict Reporting"},"sidebar":"docs","previous":{"title":"Pro Scheduling","permalink":"/tods-competition-factory/docs/concepts/pro-scheduling"},"next":{"title":"Publishing","permalink":"/tods-competition-factory/docs/concepts/publishing"}}');var c=i(6070),s=i(8439);const l={title:"Conflict Reporting"},a=void 0,o={},r=[{value:"Overview",id:"overview",level:2},{value:"How Conflict Detection Works",id:"how-conflict-detection-works",level:2},{value:"Conflict Calculation",id:"conflict-calculation",level:3},{value:"Retrieving Conflict Information",id:"retrieving-conflict-information",level:2},{value:"Basic Conflict Detection",id:"basic-conflict-detection",level:3},{value:"Custom Conflict Threshold",id:"custom-conflict-threshold",level:3},{value:"Conflict Data Structure",id:"conflict-data-structure",level:2},{value:"Conflict Types",id:"conflict-types",level:3},{value:"Understanding Potential Matches",id:"understanding-potential-matches",level:2},{value:"Resolution Strategies",id:"resolution-strategies",level:2},{value:"1. Identify All Conflicts",id:"1-identify-all-conflicts",level:3},{value:"2. Reschedule Conflicting Matches",id:"2-reschedule-conflicting-matches",level:3},{value:"3. Adjust Scheduling Policy",id:"3-adjust-scheduling-policy",level:3},{value:"4. Manual Override",id:"4-manual-override",level:3},{value:"Best Practices",id:"best-practices",level:2},{value:"Conflict Prevention",id:"conflict-prevention",level:3},{value:"Conflict Resolution Priority",id:"conflict-resolution-priority",level:3},{value:"Communication",id:"communication",level:3},{value:"Common Scenarios",id:"common-scenarios",level:2},{value:"Multi-Event Players",id:"multi-event-players",level:3},{value:"Back-to-Back Matches",id:"back-to-back-matches",level:3},{value:"Finals Day Conflicts",id:"finals-day-conflicts",level:3},{value:"Validation Workflow",id:"validation-workflow",level:2},{value:"Related Documentation",id:"related-documentation",level:2}];function d(n){const e={a:"a",admonition:"admonition",code:"code",h2:"h2",h3:"h3",li:"li",ol:"ol",p:"p",pre:"pre",strong:"strong",ul:"ul",...(0,s.R)(),...n.components};return(0,c.jsxs)(c.Fragment,{children:[(0,c.jsx)(e.h2,{id:"overview",children:"Overview"}),"\n",(0,c.jsx)(e.p,{children:"Schedule conflict reporting identifies players who have overlapping match commitments that violate recovery time requirements or scheduling policies. The Competition Factory automatically detects and reports these conflicts to help tournament directors maintain player welfare and schedule integrity."}),"\n",(0,c.jsx)(e.h2,{id:"how-conflict-detection-works",children:"How Conflict Detection Works"}),"\n",(0,c.jsx)(e.p,{children:"Conflicts are detected when a player's matches are scheduled too close together, based on:"}),"\n",(0,c.jsxs)(e.ol,{children:["\n",(0,c.jsxs)(e.li,{children:[(0,c.jsx)(e.strong,{children:"Scheduling Policy"}),": Uses format-specific average match times and recovery periods"]}),"\n",(0,c.jsxs)(e.li,{children:[(0,c.jsx)(e.strong,{children:"Actual Match End Times"}),": If available, uses real completion time plus recovery"]}),"\n",(0,c.jsxs)(e.li,{children:[(0,c.jsx)(e.strong,{children:"Custom Thresholds"}),": Optionally override with specific minute differences"]}),"\n"]}),"\n",(0,c.jsx)(e.h3,{id:"conflict-calculation",children:"Conflict Calculation"}),"\n",(0,c.jsx)(e.p,{children:"A conflict occurs when:"}),"\n",(0,c.jsx)(e.pre,{children:(0,c.jsx)(e.code,{children:"Match 1 projected end time + recovery time > Match 2 scheduled start time\n"})}),"\n",(0,c.jsx)(e.p,{children:"Where:"}),"\n",(0,c.jsxs)(e.ul,{children:["\n",(0,c.jsxs)(e.li,{children:[(0,c.jsx)(e.strong,{children:"Projected end time"})," = ",(0,c.jsx)(e.code,{children:"scheduledTime + averageMinutes"})," OR actual ",(0,c.jsx)(e.code,{children:"endTime"})]}),"\n",(0,c.jsxs)(e.li,{children:[(0,c.jsx)(e.strong,{children:"Recovery time"})," = Policy-defined rest period (format and category specific)"]}),"\n",(0,c.jsxs)(e.li,{children:[(0,c.jsx)(e.strong,{children:"Match 2 start time"})," = Next scheduled match for the player"]}),"\n"]}),"\n",(0,c.jsx)(e.h2,{id:"retrieving-conflict-information",children:"Retrieving Conflict Information"}),"\n",(0,c.jsx)(e.h3,{id:"basic-conflict-detection",children:"Basic Conflict Detection"}),"\n",(0,c.jsx)(e.pre,{children:(0,c.jsx)(e.code,{className:"language-js",children:"import { tournamentEngine } from 'tods-competition-factory';\n\nconst {\n  participants,\n  participantIdsWithConflicts, // Array of participantIds with conflicts\n} = tournamentEngine.getParticipants({\n  withMatchUps: true,\n  scheduleAnalysis: true,\n});\n\n// Check for conflicts\nif (participantIdsWithConflicts.length > 0) {\n  console.log(`${participantIdsWithConflicts.length} players have scheduling conflicts`);\n\n  // Get detailed conflict information\n  const conflictedPlayers = participants.filter((p) => participantIdsWithConflicts.includes(p.participantId));\n\n  conflictedPlayers.forEach((player) => {\n    console.log(`${player.participantName}:`);\n    player.scheduleConflicts.forEach((conflict) => {\n      console.log(`  Match ${conflict.matchUpId1} conflicts with ${conflict.matchUpId2}`);\n    });\n  });\n}\n"})}),"\n",(0,c.jsx)(e.h3,{id:"custom-conflict-threshold",children:"Custom Conflict Threshold"}),"\n",(0,c.jsx)(e.p,{children:"Override policy defaults with a specific minute difference:"}),"\n",(0,c.jsx)(e.pre,{children:(0,c.jsx)(e.code,{className:"language-js",children:"const { participants, participantIdsWithConflicts } = tournamentEngine.getParticipants({\n  scheduleAnalysis: {\n    scheduledMinutesDifference: 60, // Flag any matches within 60 minutes\n  },\n  withMatchUps: true,\n});\n"})}),"\n",(0,c.jsx)(e.p,{children:"This approach:"}),"\n",(0,c.jsxs)(e.ul,{children:["\n",(0,c.jsxs)(e.li,{children:[(0,c.jsx)(e.strong,{children:"Ignores"})," policy-defined recovery times"]}),"\n",(0,c.jsxs)(e.li,{children:[(0,c.jsx)(e.strong,{children:"Flags"})," any matches scheduled less than 60 minutes apart"]}),"\n",(0,c.jsxs)(e.li,{children:[(0,c.jsx)(e.strong,{children:"Useful for"})," quick validation or stricter requirements"]}),"\n"]}),"\n",(0,c.jsx)(e.h2,{id:"conflict-data-structure",children:"Conflict Data Structure"}),"\n",(0,c.jsxs)(e.p,{children:["Participants with conflicts include a ",(0,c.jsx)(e.code,{children:"scheduleConflicts"})," array:"]}),"\n",(0,c.jsx)(e.pre,{children:(0,c.jsx)(e.code,{className:"language-ts",children:"type Participant = {\n  participantId: string;\n  participantName: string;\n  scheduleConflicts?: Array<{\n    matchUpId1: string;\n    matchUpId2: string;\n    gap?: number; // Minutes between matches (if calculable)\n    required?: number; // Required minutes based on policy\n  }>;\n  matchUps?: MatchUp[]; // Player's scheduled matches\n  potentialMatchUps?: MatchUp[]; // Future possible matches\n};\n"})}),"\n",(0,c.jsx)(e.h3,{id:"conflict-types",children:"Conflict Types"}),"\n",(0,c.jsxs)(e.p,{children:[(0,c.jsx)(e.strong,{children:"1. Confirmed Conflicts"})," - Both matches have scheduled times:"]}),"\n",(0,c.jsx)(e.pre,{children:(0,c.jsx)(e.code,{className:"language-js",children:"{\n  matchUpId1: 'match-123',  // First match\n  matchUpId2: 'match-456',  // Second match\n  gap: 45,                  // Actual minutes between matches\n  required: 60              // Required recovery time\n}\n"})}),"\n",(0,c.jsxs)(e.p,{children:[(0,c.jsx)(e.strong,{children:"2. Potential Conflicts"})," - Involves future/conditional matches:"]}),"\n",(0,c.jsx)(e.pre,{children:(0,c.jsx)(e.code,{className:"language-js",children:"{\n  matchUpId1: 'match-123',  // Current match\n  matchUpId2: 'match-789',  // Potential future match (if player wins)\n  gap: 30,\n  required: 60\n}\n"})}),"\n",(0,c.jsx)(e.h2,{id:"understanding-potential-matches",children:"Understanding Potential Matches"}),"\n",(0,c.jsx)(e.admonition,{title:"Potential MatchUps",type:"note",children:(0,c.jsxs)(e.p,{children:[(0,c.jsx)(e.code,{children:"potentialMatchUps"})," are matches a player will participate in based on winning or losing their current match. The conflict detector considers these to prevent scheduling issues in later rounds."]})}),"\n",(0,c.jsx)(e.p,{children:"Example scenario:"}),"\n",(0,c.jsxs)(e.ul,{children:["\n",(0,c.jsx)(e.li,{children:"Player has Semifinals match at 2:00 PM"}),"\n",(0,c.jsx)(e.li,{children:"Finals scheduled at 4:00 PM (if player wins)"}),"\n",(0,c.jsx)(e.li,{children:"Recovery time required: 90 minutes"}),"\n",(0,c.jsxs)(e.li,{children:[(0,c.jsx)(e.strong,{children:"Conflict detected"}),": Not enough time between potential end (3:30 PM + recovery) and finals start (4:00 PM)"]}),"\n"]}),"\n",(0,c.jsx)(e.h2,{id:"resolution-strategies",children:"Resolution Strategies"}),"\n",(0,c.jsx)(e.h3,{id:"1-identify-all-conflicts",children:"1. Identify All Conflicts"}),"\n",(0,c.jsx)(e.pre,{children:(0,c.jsx)(e.code,{className:"language-js",children:"const { participants, participantIdsWithConflicts } = tournamentEngine.getParticipants({\n  scheduleAnalysis: true,\n  withMatchUps: true,\n  withPotentialMatchUps: true,\n});\n\n// Group conflicts by severity\nconst criticalConflicts = [];\nconst minorConflicts = [];\n\nparticipants\n  .filter((p) => p.scheduleConflicts?.length > 0)\n  .forEach((player) => {\n    player.scheduleConflicts.forEach((conflict) => {\n      const shortfall = (conflict.required || 0) - (conflict.gap || 0);\n\n      if (shortfall > 30) {\n        criticalConflicts.push({ player, conflict, shortfall });\n      } else {\n        minorConflicts.push({ player, conflict, shortfall });\n      }\n    });\n  });\n\nconsole.log(`Critical conflicts: ${criticalConflicts.length}`);\nconsole.log(`Minor conflicts: ${minorConflicts.length}`);\n"})}),"\n",(0,c.jsx)(e.h3,{id:"2-reschedule-conflicting-matches",children:"2. Reschedule Conflicting Matches"}),"\n",(0,c.jsx)(e.pre,{children:(0,c.jsx)(e.code,{className:"language-js",children:"// Reschedule one of the conflicting matches\ncriticalConflicts.forEach(({ player, conflict }) => {\n  // Get match details\n  const match1 = player.matchUps.find((m) => m.matchUpId === conflict.matchUpId1);\n  const match2 = player.matchUps.find((m) => m.matchUpId === conflict.matchUpId2);\n\n  // Determine which match to move (usually the later one)\n  const matchToReschedule = match2;\n\n  // Calculate new time with sufficient recovery\n  const match1End = addMinutes(match1.schedule.scheduledTime, 90); // avg match time\n  const newTime = addMinutes(match1End, conflict.required);\n\n  // Apply new schedule\n  tournamentEngine.addMatchUpScheduledTime({\n    matchUpId: matchToReschedule.matchUpId,\n    scheduledTime: newTime,\n    scheduledDate: matchToReschedule.schedule.scheduledDate,\n  });\n});\n\n// Re-check for conflicts\nconst { participantIdsWithConflicts: remainingConflicts } = tournamentEngine.getParticipants({\n  scheduleAnalysis: true,\n});\n\nconsole.log(`Remaining conflicts: ${remainingConflicts.length}`);\n"})}),"\n",(0,c.jsx)(e.h3,{id:"3-adjust-scheduling-policy",children:"3. Adjust Scheduling Policy"}),"\n",(0,c.jsx)(e.p,{children:"If conflicts are systematic, adjust the policy. These functions add extensions to the tournament record that are read by scheduling functions:"}),"\n",(0,c.jsx)(e.pre,{children:(0,c.jsx)(e.code,{className:"language-js",children:"// Increase recovery times (adds tournament-level extension)\ntournamentEngine.modifyMatchUpFormatTiming({\n  matchUpFormat: 'SET3-S:6/TB7',\n  recoveryTimes: [\n    {\n      categoryNames: [],\n      minutes: { default: 90 }, // Increased from 60\n    },\n  ],\n});\n\n// Reduce daily limits (adds tournament-level extension)\ntournamentEngine.setMatchUpDailyLimits({\n  dailyLimits: { SINGLES: 1, DOUBLES: 1, total: 2 }, // More restrictive\n});\n"})}),"\n",(0,c.jsx)(e.admonition,{type:"note",children:(0,c.jsx)(e.p,{children:"These modifications persist at the tournament level and affect all subsequent scheduling operations until explicitly changed."})}),"\n",(0,c.jsx)(e.h3,{id:"4-manual-override",children:"4. Manual Override"}),"\n",(0,c.jsx)(e.p,{children:"For unavoidable conflicts (e.g., late-night match followed by early match next day):"}),"\n",(0,c.jsx)(e.pre,{children:(0,c.jsx)(e.code,{className:"language-js",children:"// Document the exception\ntournamentEngine.addExtension({\n  matchUpId: 'match-456',\n  extension: {\n    name: 'scheduleException',\n    value: {\n      reason: 'Tournament director approved - player consent obtained',\n      approvedBy: 'TD Name',\n      timestamp: new Date().toISOString(),\n    },\n  },\n});\n"})}),"\n",(0,c.jsx)(e.h2,{id:"best-practices",children:"Best Practices"}),"\n",(0,c.jsx)(e.h3,{id:"conflict-prevention",children:"Conflict Prevention"}),"\n",(0,c.jsxs)(e.ol,{children:["\n",(0,c.jsxs)(e.li,{children:["\n",(0,c.jsx)(e.p,{children:(0,c.jsx)(e.strong,{children:"Run conflict analysis before finalizing schedules"})}),"\n",(0,c.jsx)(e.pre,{children:(0,c.jsx)(e.code,{className:"language-js",children:"// Before publishing order of play\nconst { participantIdsWithConflicts } = tournamentEngine.getParticipants({\n  scheduleAnalysis: true,\n});\n\nif (participantIdsWithConflicts.length > 0) {\n  console.warn('STOP: Conflicts detected - resolve before publishing');\n}\n"})}),"\n"]}),"\n",(0,c.jsxs)(e.li,{children:["\n",(0,c.jsx)(e.p,{children:(0,c.jsx)(e.strong,{children:"Check after each schedule change"})}),"\n",(0,c.jsxs)(e.ul,{children:["\n",(0,c.jsx)(e.li,{children:"Re-run analysis after rescheduling matches"}),"\n",(0,c.jsx)(e.li,{children:"Ensure fixes don't create new conflicts"}),"\n"]}),"\n"]}),"\n",(0,c.jsxs)(e.li,{children:["\n",(0,c.jsx)(e.p,{children:(0,c.jsx)(e.strong,{children:"Consider potential matches"})}),"\n",(0,c.jsxs)(e.ul,{children:["\n",(0,c.jsxs)(e.li,{children:["Enable ",(0,c.jsx)(e.code,{children:"withPotentialMatchUps"})," to detect future conflicts"]}),"\n",(0,c.jsx)(e.li,{children:"Particularly important for semifinals/finals scheduling"}),"\n"]}),"\n"]}),"\n"]}),"\n",(0,c.jsx)(e.h3,{id:"conflict-resolution-priority",children:"Conflict Resolution Priority"}),"\n",(0,c.jsxs)(e.ol,{children:["\n",(0,c.jsxs)(e.li,{children:[(0,c.jsx)(e.strong,{children:"Critical conflicts"})," (gap < required by 60+ minutes) - immediate resolution"]}),"\n",(0,c.jsxs)(e.li,{children:[(0,c.jsx)(e.strong,{children:"Moderate conflicts"})," (gap < required by 30-60 minutes) - high priority"]}),"\n",(0,c.jsxs)(e.li,{children:[(0,c.jsx)(e.strong,{children:"Minor conflicts"})," (gap < required by < 30 minutes) - evaluate case-by-case"]}),"\n"]}),"\n",(0,c.jsx)(e.h3,{id:"communication",children:"Communication"}),"\n",(0,c.jsx)(e.p,{children:"When conflicts exist:"}),"\n",(0,c.jsxs)(e.ul,{children:["\n",(0,c.jsxs)(e.li,{children:[(0,c.jsx)(e.strong,{children:"Notify affected players"})," immediately"]}),"\n",(0,c.jsxs)(e.li,{children:[(0,c.jsx)(e.strong,{children:"Obtain consent"})," if conflict cannot be resolved"]}),"\n",(0,c.jsxs)(e.li,{children:[(0,c.jsx)(e.strong,{children:"Document exceptions"})," for tournament records"]}),"\n",(0,c.jsxs)(e.li,{children:[(0,c.jsx)(e.strong,{children:"Explain"})," how the conflict will be managed (e.g., medical timeout extended, warm-up time adjusted)"]}),"\n"]}),"\n",(0,c.jsx)(e.h2,{id:"common-scenarios",children:"Common Scenarios"}),"\n",(0,c.jsx)(e.h3,{id:"multi-event-players",children:"Multi-Event Players"}),"\n",(0,c.jsx)(e.p,{children:"Players in both singles and doubles often face conflicts:"}),"\n",(0,c.jsx)(e.pre,{children:(0,c.jsx)(e.code,{className:"language-js",children:"// Find multi-event players with conflicts\nconst multiEventPlayers = participants.filter((p) => {\n  const eventTypes = new Set(p.matchUps?.map((m) => m.eventType));\n  return eventTypes.size > 1 && p.scheduleConflicts?.length > 0;\n});\n\nmultiEventPlayers.forEach((player) => {\n  console.log(`${player.participantName} has ${player.scheduleConflicts.length} cross-event conflicts`);\n});\n"})}),"\n",(0,c.jsx)(e.h3,{id:"back-to-back-matches",children:"Back-to-Back Matches"}),"\n",(0,c.jsx)(e.p,{children:"Players scheduled on multiple courts simultaneously:"}),"\n",(0,c.jsx)(e.pre,{children:(0,c.jsx)(e.code,{className:"language-js",children:"// Detect impossible simultaneous scheduling\nconst simultaneousMatches = participants.filter((p) => {\n  const matches = p.matchUps || [];\n  const times = matches.map((m) => m.schedule?.scheduledTime).filter(Boolean);\n  return new Set(times).size < times.length; // Duplicate times = simultaneous\n});\n"})}),"\n",(0,c.jsx)(e.h3,{id:"finals-day-conflicts",children:"Finals Day Conflicts"}),"\n",(0,c.jsx)(e.p,{children:"Semifinals too close to finals:"}),"\n",(0,c.jsx)(e.pre,{children:(0,c.jsx)(e.code,{className:"language-js",children:"// Check specific round scheduling\nconst finalists = participants.filter((p) => {\n  const hasSemifinal = p.matchUps?.some((m) => m.roundName === 'Semifinals');\n  const hasFinal = p.potentialMatchUps?.some((m) => m.roundName === 'Finals');\n  return hasSemifinal && hasFinal && p.scheduleConflicts?.length > 0;\n});\n"})}),"\n",(0,c.jsx)(e.h2,{id:"validation-workflow",children:"Validation Workflow"}),"\n",(0,c.jsx)(e.p,{children:"Complete validation before publishing schedules:"}),"\n",(0,c.jsx)(e.pre,{children:(0,c.jsx)(e.code,{className:"language-js",children:"// Comprehensive schedule validation\nfunction validateSchedule(tournamentEngine) {\n  const validation = {\n    conflicts: [],\n    warnings: [],\n    errors: [],\n  };\n\n  // 1. Check for scheduling conflicts\n  const { participantIdsWithConflicts, participants } = tournamentEngine.getParticipants({\n    scheduleAnalysis: true,\n    withMatchUps: true,\n    withPotentialMatchUps: true,\n  });\n\n  if (participantIdsWithConflicts.length > 0) {\n    validation.errors.push({\n      type: 'SCHEDULE_CONFLICT',\n      count: participantIdsWithConflicts.length,\n      details: participants\n        .filter((p) => participantIdsWithConflicts.includes(p.participantId))\n        .map((p) => ({\n          name: p.participantName,\n          conflicts: p.scheduleConflicts,\n        })),\n    });\n  }\n\n  // 2. Check daily limits\n  const overLimitPlayers = participants.filter((p) => {\n    const matchesByDate = groupBy(p.matchUps, (m) => m.schedule?.scheduledDate);\n    return Object.values(matchesByDate).some((matches) => matches.length > 3);\n  });\n\n  if (overLimitPlayers.length > 0) {\n    validation.warnings.push({\n      type: 'DAILY_LIMIT_EXCEEDED',\n      count: overLimitPlayers.length,\n    });\n  }\n\n  // 3. Check for unscheduled matches\n  const { matchUps } = tournamentEngine.allTournamentMatchUps();\n  const unscheduled = matchUps.filter((m) => !m.schedule?.scheduledTime);\n\n  if (unscheduled.length > 0) {\n    validation.warnings.push({\n      type: 'UNSCHEDULED_MATCHES',\n      count: unscheduled.length,\n    });\n  }\n\n  return validation;\n}\n\n// Run validation\nconst validation = validateSchedule(tournamentEngine);\n\nif (validation.errors.length > 0) {\n  console.error('Schedule has errors - cannot publish:');\n  console.error(JSON.stringify(validation.errors, null, 2));\n} else if (validation.warnings.length > 0) {\n  console.warn('Schedule has warnings - review before publishing:');\n  console.warn(JSON.stringify(validation.warnings, null, 2));\n} else {\n  console.log('Schedule validation passed - ready to publish');\n}\n"})}),"\n",(0,c.jsx)(e.h2,{id:"related-documentation",children:"Related Documentation"}),"\n",(0,c.jsxs)(e.ul,{children:["\n",(0,c.jsxs)(e.li,{children:[(0,c.jsx)(e.strong,{children:(0,c.jsx)(e.a,{href:"./scheduling-overview",children:"Scheduling Overview"})})," - Understanding scheduling workflows"]}),"\n",(0,c.jsxs)(e.li,{children:[(0,c.jsx)(e.strong,{children:(0,c.jsx)(e.a,{href:"./scheduling-policy",children:"Scheduling Policy"})})," - Configuring recovery times and daily limits"]}),"\n",(0,c.jsxs)(e.li,{children:[(0,c.jsx)(e.strong,{children:(0,c.jsx)(e.a,{href:"./automated-scheduling",children:"Automated Scheduling"})})," - How conflicts are prevented during auto-scheduling"]}),"\n",(0,c.jsxs)(e.li,{children:[(0,c.jsx)(e.strong,{children:(0,c.jsx)(e.a,{href:"/docs/governors/query-governor",children:"Query Governor"})})," - API reference for getParticipants method"]}),"\n"]})]})}function h(n={}){const{wrapper:e}={...(0,s.R)(),...n.components};return e?(0,c.jsx)(e,{...n,children:(0,c.jsx)(d,{...n})}):d(n)}},8439(n,e,i){i.d(e,{R:()=>l,x:()=>a});var t=i(758);const c={},s=t.createContext(c);function l(n){const e=t.useContext(s);return t.useMemo(function(){return"function"==typeof n?n(e):{...e,...n}},[e,n])}function a(n){let e;return e=n.disableParentContext?"function"==typeof n.components?n.components(c):n.components||c:l(n.components),t.createElement(s.Provider,{value:e},n.children)}}}]);