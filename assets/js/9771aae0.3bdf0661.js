"use strict";(globalThis.webpackChunkdocumentation=globalThis.webpackChunkdocumentation||[]).push([[4978],{3805:(e,n,t)=>{t.d(n,{xA:()=>u,yg:()=>g});var a=t(758);function r(e,n,t){return n in e?Object.defineProperty(e,n,{value:t,enumerable:!0,configurable:!0,writable:!0}):e[n]=t,e}function o(e,n){var t=Object.keys(e);if(Object.getOwnPropertySymbols){var a=Object.getOwnPropertySymbols(e);n&&(a=a.filter((function(n){return Object.getOwnPropertyDescriptor(e,n).enumerable}))),t.push.apply(t,a)}return t}function s(e){for(var n=1;n<arguments.length;n++){var t=null!=arguments[n]?arguments[n]:{};n%2?o(Object(t),!0).forEach((function(n){r(e,n,t[n])})):Object.getOwnPropertyDescriptors?Object.defineProperties(e,Object.getOwnPropertyDescriptors(t)):o(Object(t)).forEach((function(n){Object.defineProperty(e,n,Object.getOwnPropertyDescriptor(t,n))}))}return e}function i(e,n){if(null==e)return{};var t,a,r=function(e,n){if(null==e)return{};var t,a,r={},o=Object.keys(e);for(a=0;a<o.length;a++)t=o[a],n.indexOf(t)>=0||(r[t]=e[t]);return r}(e,n);if(Object.getOwnPropertySymbols){var o=Object.getOwnPropertySymbols(e);for(a=0;a<o.length;a++)t=o[a],n.indexOf(t)>=0||Object.prototype.propertyIsEnumerable.call(e,t)&&(r[t]=e[t])}return r}var c=a.createContext({}),l=function(e){var n=a.useContext(c),t=n;return e&&(t="function"==typeof e?e(n):s(s({},n),e)),t},u=function(e){var n=l(e.components);return a.createElement(c.Provider,{value:n},e.children)},d="mdxType",p={inlineCode:"code",wrapper:function(e){var n=e.children;return a.createElement(a.Fragment,{},n)}},m=a.forwardRef((function(e,n){var t=e.components,r=e.mdxType,o=e.originalType,c=e.parentName,u=i(e,["components","mdxType","originalType","parentName"]),d=l(t),m=r,g=d["".concat(c,".").concat(m)]||d[m]||p[m]||o;return t?a.createElement(g,s(s({ref:n},u),{},{components:t})):a.createElement(g,s({ref:n},u))}));function g(e,n){var t=arguments,r=n&&n.mdxType;if("string"==typeof e||r){var o=t.length,s=new Array(o);s[0]=m;var i={};for(var c in n)hasOwnProperty.call(n,c)&&(i[c]=n[c]);i.originalType=e,i[d]="string"==typeof e?e:r,s[1]=i;for(var l=2;l<o;l++)s[l]=t[l];return a.createElement.apply(null,s)}return a.createElement.apply(null,t)}m.displayName="MDXCreateElement"},112:(e,n,t)=>{t.r(n),t.d(n,{assets:()=>c,contentTitle:()=>s,default:()=>p,frontMatter:()=>o,metadata:()=>i,toc:()=>l});var a=t(2232),r=(t(758),t(3805));const o={title:"Advanced Patterns & Best Practices"},s="Advanced Patterns & Best Practices",i={unversionedId:"testing/mocks-engine-patterns",id:"testing/mocks-engine-patterns",title:"Advanced Patterns & Best Practices",description:"This guide covers common testing patterns, best practices, and advanced techniques for using the mocksEngine effectively.",source:"@site/docs/testing/mocks-engine-patterns.md",sourceDirName:"testing",slug:"/testing/mocks-engine-patterns",permalink:"/tods-competition-factory/docs/testing/mocks-engine-patterns",draft:!1,tags:[],version:"current",frontMatter:{title:"Advanced Patterns & Best Practices"},sidebar:"docs",previous:{title:"Outcome Generation",permalink:"/tods-competition-factory/docs/testing/mocks-engine-outcomes"},next:{title:"Factory Server",permalink:"/tods-competition-factory/docs/testing/factory-server"}},c={},l=[{value:"Test Organization",id:"test-organization",level:2},{value:"Shared Tournament Setup",id:"shared-tournament-setup",level:3},{value:"Factory Functions",id:"factory-functions",level:3},{value:"Testing Draw Structures",id:"testing-draw-structures",level:2},{value:"Complete Draw Generation",id:"complete-draw-generation",level:3},{value:"Testing Playoff Structures",id:"testing-playoff-structures",level:3},{value:"Testing Scheduling Scenarios",id:"testing-scheduling-scenarios",level:2},{value:"Auto-Scheduling with Conflict Detection",id:"auto-scheduling-with-conflict-detection",level:3},{value:"Time-based Scheduling",id:"time-based-scheduling",level:3},{value:"Testing Match Completion",id:"testing-match-completion",level:2},{value:"Progressive Completion",id:"progressive-completion",level:3},{value:"Different Match Outcomes",id:"different-match-outcomes",level:3},{value:"Testing Participant Scenarios",id:"testing-participant-scenarios",level:2},{value:"Entry Status Testing",id:"entry-status-testing",level:3},{value:"Seeding Tests",id:"seeding-tests",level:3},{value:"Testing Team Events",id:"testing-team-events",level:2},{value:"Team Creation from Attributes",id:"team-creation-from-attributes",level:3},{value:"Understanding inContext: Hydrated vs Basic MatchUps",id:"understanding-incontext-hydrated-vs-basic-matchups",level:2},{value:"Basic MatchUps (inContext: false or omitted)",id:"basic-matchups-incontext-false-or-omitted",level:3},{value:"Fully Hydrated MatchUps (inContext: true)",id:"fully-hydrated-matchups-incontext-true",level:3},{value:"When inContext is REQUIRED",id:"when-incontext-is-required",level:3},{value:"1. Scheduling Operations",id:"1-scheduling-operations",level:4},{value:"2. Conflict Detection",id:"2-conflict-detection",level:4},{value:"3. Display/Reporting",id:"3-displayreporting",level:4},{value:"Performance Considerations",id:"performance-considerations",level:3},{value:"Best Practice Pattern",id:"best-practice-pattern",level:3},{value:"Debugging Patterns",id:"debugging-patterns",level:2},{value:"Use ID Prefixes",id:"use-id-prefixes",level:3},{value:"DevContext for Detailed Errors",id:"devcontext-for-detailed-errors",level:3},{value:"Integration Testing",id:"integration-testing",level:2},{value:"Full Tournament Lifecycle",id:"full-tournament-lifecycle",level:3},{value:"Best Practices Summary",id:"best-practices-summary",level:2},{value:"Next Steps",id:"next-steps",level:2}],u={toc:l},d="wrapper";function p({components:e,...n}){return(0,r.yg)(d,(0,a.A)({},u,n,{components:e,mdxType:"MDXLayout"}),(0,r.yg)("h1",{id:"advanced-patterns--best-practices"},"Advanced Patterns & Best Practices"),(0,r.yg)("p",null,"This guide covers common testing patterns, best practices, and advanced techniques for using the mocksEngine effectively."),(0,r.yg)("h2",{id:"test-organization"},"Test Organization"),(0,r.yg)("h3",{id:"shared-tournament-setup"},"Shared Tournament Setup"),(0,r.yg)("p",null,"Create reusable tournament setups:"),(0,r.yg)("pre",null,(0,r.yg)("code",{parentName:"pre",className:"language-js"},"import { mocksEngine } from 'tods-competition-factory';\nimport { describe, beforeEach, it, expect } from 'vitest';\n\ndescribe('Tournament Scheduling', () => {\n  beforeEach(() => {\n    // Use setState: true for convenience - no need to call setState in each test\n    mocksEngine.generateTournamentRecord({\n      drawProfiles: [{ drawSize: 16 }],\n      venueProfiles: [{ courtsCount: 4 }],\n      setState: true, // Auto-loads into tournamentEngine\n    });\n  });\n\n  it('can schedule matches', () => {\n    // Tournament already loaded - can use engine methods directly\n    const { matchUps } = tournamentEngine.allCompetitionMatchUps({\n      inContext: true, // Fully hydrated matchUps for scheduling\n      nextMatchUps: true,\n    });\n    // Test scheduling logic...\n  });\n\n  it('detects scheduling conflicts', () => {\n    // Tournament already loaded\n    const { matchUps } = tournamentEngine.allCompetitionMatchUps({\n      inContext: true, // Required for conflict detection\n      nextMatchUps: true,\n    });\n    const { rowIssues } = tournamentEngine.proConflicts({ matchUps });\n    // Test conflict detection...\n  });\n});\n")),(0,r.yg)("h3",{id:"factory-functions"},"Factory Functions"),(0,r.yg)("p",null,"Create factory functions for common scenarios:"),(0,r.yg)("pre",null,(0,r.yg)("code",{parentName:"pre",className:"language-js"},"// test/helpers/tournamentFactory.js\nexport function createTournamentWithScheduling(options = {}) {\n  const defaults = {\n    drawProfiles: [{ drawSize: 16 }],\n    venueProfiles: [{ courtsCount: 4 }],\n    startDate: '2024-06-01',\n  };\n\n  return mocksEngine.generateTournamentRecord({\n    ...defaults,\n    ...options,\n  });\n}\n\nexport function createDoublesAndSinglesTournament() {\n  return mocksEngine.generateTournamentRecord({\n    participantsProfile: { participantsCount: 64 },\n    drawProfiles: [\n      { drawSize: 32, eventType: 'SINGLES' },\n      { drawSize: 16, eventType: 'DOUBLES' },\n    ],\n  });\n}\n\n// In tests:\nimport { createTournamentWithScheduling } from './helpers/tournamentFactory';\n\ntest('scheduling test', () => {\n  const { tournamentRecord } = createTournamentWithScheduling({\n    drawProfiles: [{ drawSize: 32 }],\n  });\n  // ...\n});\n")),(0,r.yg)("h2",{id:"testing-draw-structures"},"Testing Draw Structures"),(0,r.yg)("h3",{id:"complete-draw-generation"},"Complete Draw Generation"),(0,r.yg)("p",null,"Test a complete draw with qualifying structure. Note that qualifying is a stage within the draw, not a separate draw:"),(0,r.yg)("pre",null,(0,r.yg)("code",{parentName:"pre",className:"language-js"},"test('generates complete championship draw with qualifying', () => {\n  const { tournamentRecord, drawIds } = mocksEngine.generateTournamentRecord({\n    participantsProfile: {\n      participantsCount: 128,\n      sex: 'FEMALE',\n      category: { categoryName: 'Open', ratingType: 'WTN' },\n      scaleAllParticipants: true,\n    },\n    drawProfiles: [\n      {\n        drawSize: 64,\n        drawName: \"Women's Singles Championship\",\n        seedsCount: 16,\n        qualifiersCount: 8, // 8 positions for qualifiers\n        qualifyingProfiles: [\n          {\n            roundTarget: 1, // Qualifiers enter round 1 of main draw\n            structureProfiles: [\n              {\n                stageSequence: 1,\n                drawSize: 16, // 16 players compete for 8 spots\n                seedsCount: 4,\n              },\n            ],\n          },\n        ],\n        completionGoal: 40, // Complete 40 matchUps total\n      },\n    ],\n  });\n\n  tournamentEngine.setState(tournamentRecord);\n\n  const { matchUps } = tournamentEngine.allTournamentMatchUps();\n  const qualifyingMatches = matchUps.filter((m) => m.stage === 'QUALIFYING');\n  const mainDrawMatches = matchUps.filter((m) => m.stage === 'MAIN');\n\n  expect(qualifyingMatches.length).toBe(8); // 16 players = 8 matches\n  expect(mainDrawMatches.length).toBe(63); // 64-draw = 63 matches\n  expect(drawIds.length).toBe(1); // Single draw with qualifying stage\n});\n")),(0,r.yg)("h3",{id:"testing-playoff-structures"},"Testing Playoff Structures"),(0,r.yg)("pre",null,(0,r.yg)("code",{parentName:"pre",className:"language-js"},"test('generates playoffs for positions', () => {\n  const { tournamentRecord } = mocksEngine.generateTournamentRecord({\n    drawProfiles: [\n      {\n        drawSize: 16,\n        withPlayoffs: {\n          roundProfiles: [{ 4: 1 }], // Playoffs from round 4\n          playoffPositions: [3, 4], // 3rd/4th place playoff\n          playoffAttributes: {\n            '0-4': { name: 'Bronze Medal Match', abbreviation: 'BM' },\n          },\n        },\n      },\n    ],\n  });\n\n  tournamentEngine.setState(tournamentRecord);\n  const { drawDefinition } = tournamentEngine.getEvent();\n\n  const playoffStructures = drawDefinition.structures.filter((s) => s.stage === 'PLAY_OFF');\n\n  expect(playoffStructures.length).toBeGreaterThan(0);\n});\n")),(0,r.yg)("h2",{id:"testing-scheduling-scenarios"},"Testing Scheduling Scenarios"),(0,r.yg)("h3",{id:"auto-scheduling-with-conflict-detection"},"Auto-Scheduling with Conflict Detection"),(0,r.yg)("pre",null,(0,r.yg)("code",{parentName:"pre",className:"language-js"},"test('detects participant conflicts in scheduling', () => {\n  const { tournamentRecord } = mocksEngine.generateTournamentRecord({\n    participantsProfile: { participantsCount: 32 },\n    drawProfiles: [\n      { drawSize: 16, eventType: 'SINGLES', idPrefix: 'singles' },\n      { drawSize: 8, eventType: 'DOUBLES', idPrefix: 'doubles' },\n    ],\n    venueProfiles: [{ courtsCount: 5 }],\n  });\n\n  tournamentEngine.setState(tournamentRecord);\n\n  // Schedule all matches\n  let { matchUps } = tournamentEngine.allCompetitionMatchUps({\n    inContext: true,\n    nextMatchUps: true,\n  });\n\n  const result = tournamentEngine.proAutoSchedule({\n    scheduledDate: '2024-06-01',\n    matchUps,\n  });\n\n  expect(result.success).toBe(true);\n\n  // Verify no conflicts\n  ({ matchUps } = tournamentEngine.allCompetitionMatchUps({\n    inContext: true,\n    nextMatchUps: true,\n    matchUpFilters: { scheduledDate: '2024-06-01' },\n  }));\n\n  const { rowIssues } = tournamentEngine.proConflicts({ matchUps });\n  const conflicts = Object.values(rowIssues)\n    .flat()\n    .filter((issue) => issue.issue === 'CONFLICT');\n\n  expect(conflicts.length).toBe(0);\n});\n")),(0,r.yg)("h3",{id:"time-based-scheduling"},"Time-based Scheduling"),(0,r.yg)("pre",null,(0,r.yg)("code",{parentName:"pre",className:"language-js"},"test('schedules matches with time slots', () => {\n  const { tournamentRecord, venueIds } = mocksEngine.generateTournamentRecord({\n    drawProfiles: [{ drawSize: 16 }],\n    venueProfiles: [\n      {\n        courtsCount: 4,\n        startTime: '08:00',\n        endTime: '20:00',\n      },\n    ],\n  });\n\n  tournamentEngine.setState(tournamentRecord);\n\n  const { matchUps } = tournamentEngine.allTournamentMatchUps();\n\n  matchUps.slice(0, 4).forEach((matchUp, index) => {\n    const scheduledTime = `${8 + index * 2}:00`;\n\n    tournamentEngine.addMatchUpScheduleItems({\n      matchUpId: matchUp.matchUpId,\n      drawId: matchUp.drawId,\n      schedule: {\n        scheduledDate: '2024-06-01',\n        scheduledTime,\n      },\n    });\n  });\n\n  const { dateMatchUps } = tournamentEngine.competitionScheduleMatchUps({\n    matchUpFilters: { scheduledDate: '2024-06-01' },\n  });\n\n  expect(dateMatchUps.length).toBe(4);\n  expect(dateMatchUps[0].schedule.scheduledTime).toBeDefined();\n});\n")),(0,r.yg)("h2",{id:"testing-match-completion"},"Testing Match Completion"),(0,r.yg)("h3",{id:"progressive-completion"},"Progressive Completion"),(0,r.yg)("p",null,"Test draw advancement through rounds:"),(0,r.yg)("pre",null,(0,r.yg)("code",{parentName:"pre",className:"language-js"},"test('advances draw through rounds', () => {\n  const { tournamentRecord } = mocksEngine.generateTournamentRecord({\n    drawProfiles: [{ drawSize: 8, idPrefix: 'match' }],\n  });\n\n  tournamentEngine.setState(tournamentRecord);\n\n  // Complete first round\n  let { matchUps } = tournamentEngine.allTournamentMatchUps();\n  const firstRoundMatches = matchUps.filter((m) => m.roundNumber === 1);\n\n  firstRoundMatches.forEach((matchUp) => {\n    const { outcome } = mocksEngine.generateOutcome({\n      matchUpFormat: matchUp.matchUpFormat,\n      winningSide: 1,\n    });\n\n    tournamentEngine.setMatchUpStatus({\n      matchUpId: matchUp.matchUpId,\n      drawId: matchUp.drawId,\n      outcome,\n    });\n  });\n\n  // Verify second round is ready\n  ({ matchUps } = tournamentEngine.allTournamentMatchUps());\n  const secondRoundMatches = matchUps.filter((m) => m.roundNumber === 2);\n\n  expect(secondRoundMatches.every((m) => m.sides.every((s) => s.participantId))).toBe(true);\n});\n")),(0,r.yg)("h3",{id:"different-match-outcomes"},"Different Match Outcomes"),(0,r.yg)("p",null,"Test various outcome scenarios:"),(0,r.yg)("pre",null,(0,r.yg)("code",{parentName:"pre",className:"language-js"},"test('handles various match outcomes', () => {\n  const { tournamentRecord } = mocksEngine.generateTournamentRecord({\n    drawProfiles: [\n      {\n        drawSize: 8,\n        outcomes: [\n          { roundNumber: 1, roundPosition: 1, matchUpStatus: 'COMPLETED', scoreString: '6-4 6-2', winningSide: 1 },\n          { roundNumber: 1, roundPosition: 2, matchUpStatus: 'RETIRED', winningSide: 1 },\n          { roundNumber: 1, roundPosition: 3, matchUpStatus: 'WALKOVER', winningSide: 2 },\n          { roundNumber: 1, roundPosition: 4, matchUpStatus: 'DEFAULTED', winningSide: 1 },\n        ],\n      },\n    ],\n  });\n\n  tournamentEngine.setState(tournamentRecord);\n  const { completedMatchUps } = tournamentEngine.tournamentMatchUps();\n\n  expect(completedMatchUps.length).toBe(4);\n  expect(completedMatchUps.map((m) => m.matchUpStatus).sort()).toEqual([\n    'COMPLETED',\n    'DEFAULTED',\n    'RETIRED',\n    'WALKOVER',\n  ]);\n});\n")),(0,r.yg)("h2",{id:"testing-participant-scenarios"},"Testing Participant Scenarios"),(0,r.yg)("h3",{id:"entry-status-testing"},"Entry Status Testing"),(0,r.yg)("pre",null,(0,r.yg)("code",{parentName:"pre",className:"language-js"},"test('manages alternates and direct acceptances', () => {\n  const { tournamentRecord } = mocksEngine.generateTournamentRecord({\n    participantsProfile: { participantsCount: 50 },\n    drawProfiles: [\n      {\n        drawSize: 32,\n        // 32 get DIRECT_ACCEPTANCE, 18 remain as potential alternates\n      },\n    ],\n  });\n\n  tournamentEngine.setState(tournamentRecord);\n\n  const { participants } = tournamentEngine.getParticipants();\n  const { event } = tournamentEngine.getEvent();\n  const { entries } = event;\n\n  const directAcceptance = entries.filter((e) => e.entryStatus === 'DIRECT_ACCEPTANCE');\n  const remaining = participants.length - directAcceptance.length;\n\n  expect(directAcceptance.length).toBe(32);\n  expect(remaining).toBe(18);\n});\n")),(0,r.yg)("h3",{id:"seeding-tests"},"Seeding Tests"),(0,r.yg)("pre",null,(0,r.yg)("code",{parentName:"pre",className:"language-js"},"test('seeds participants by rating', () => {\n  const { tournamentRecord } = mocksEngine.generateTournamentRecord({\n    participantsProfile: {\n      participantsCount: 64,\n      category: { categoryName: 'Open', ratingType: 'WTN' },\n      scaleAllParticipants: true,\n    },\n    drawProfiles: [\n      {\n        drawSize: 32,\n        seedsCount: 8,\n      },\n    ],\n  });\n\n  tournamentEngine.setState(tournamentRecord);\n\n  const { seedAssignments } = tournamentEngine.getEvent();\n  expect(Object.keys(seedAssignments).length).toBe(8);\n\n  // Verify top seeds are in expected positions\n  const { positionAssignments } = tournamentEngine.getPositionAssignments();\n  const topSeedPosition = positionAssignments.find((pa) => pa.seedNumber === 1);\n\n  expect(topSeedPosition.drawPosition).toBe(1);\n});\n")),(0,r.yg)("h2",{id:"testing-team-events"},"Testing Team Events"),(0,r.yg)("h3",{id:"team-creation-from-attributes"},"Team Creation from Attributes"),(0,r.yg)("pre",null,(0,r.yg)("code",{parentName:"pre",className:"language-js"},"test('creates teams from participant attributes', () => {\n  const { tournamentRecord } = mocksEngine.generateTournamentRecord({\n    participantsProfile: {\n      participantsCount: 64,\n      teamKey: 'person.addresses[0].state', // Group by state\n      addressProps: {\n        statesProfile: {\n          CA: 16,\n          TX: 16,\n          NY: 16,\n          FL: 16,\n        },\n      },\n    },\n    drawProfiles: [\n      {\n        drawSize: 4,\n        eventType: 'TEAM',\n      },\n    ],\n  });\n\n  tournamentEngine.setState(tournamentRecord);\n\n  const { participants } = tournamentEngine.getParticipants({\n    participantFilters: { participantTypes: ['TEAM'] },\n  });\n\n  expect(participants.length).toBe(4);\n  participants.forEach((team) => {\n    expect(team.individualParticipantIds.length).toBeGreaterThan(0);\n  });\n});\n")),(0,r.yg)("h2",{id:"understanding-incontext-hydrated-vs-basic-matchups"},"Understanding inContext: Hydrated vs Basic MatchUps"),(0,r.yg)("p",null,"A critical concept when working with matchUps is the difference between basic and fully hydrated matchUps."),(0,r.yg)("h3",{id:"basic-matchups-incontext-false-or-omitted"},"Basic MatchUps (inContext: false or omitted)"),(0,r.yg)("pre",null,(0,r.yg)("code",{parentName:"pre",className:"language-js"},"const { matchUps } = tournamentEngine.allTournamentMatchUps();\n\n// Basic matchUp contains:\n{\n  matchUpId: 'abc-123',\n  roundNumber: 1,\n  roundPosition: 1,\n  sides: [\n    { participantId: 'player-1' },  // Only ID, not full participant\n    { participantId: 'player-2' }\n  ],\n  // Missing: event details, participant details, venue info, etc.\n}\n")),(0,r.yg)("h3",{id:"fully-hydrated-matchups-incontext-true"},"Fully Hydrated MatchUps (inContext: true)"),(0,r.yg)("pre",null,(0,r.yg)("code",{parentName:"pre",className:"language-js"},"const { matchUps } = tournamentEngine.allTournamentMatchUps({\n  inContext: true,  // Fully hydrate with contextual data\n});\n\n// Hydrated matchUp contains everything from basic, PLUS:\n{\n  // ... basic fields ...\n\n  // Event context\n  eventName: 'Singles Championship',\n  eventType: 'SINGLES',\n  gender: 'FEMALE',\n  category: { categoryName: 'U18' },\n\n  // Draw context\n  drawName: 'Main Draw',\n  drawType: 'SINGLE_ELIMINATION',\n  stage: 'MAIN',\n  structureName: 'Main',\n  roundName: 'Round of 16',\n\n  // Full participant details\n  sides: [\n    {\n      participantId: 'player-1',\n      participant: {\n        participantName: 'Jane Doe',\n        person: {\n          standardGivenName: 'Jane',\n          standardFamilyName: 'Doe',\n          nationalityCode: 'USA',\n          // ... full person details\n        },\n        // ... rankings, ratings, etc.\n      }\n    },\n    // ... side 2 with full details\n  ],\n\n  // Scheduling context (if scheduled)\n  schedule: {\n    venueId: 'venue-1',\n    venueName: 'Main Stadium',\n    venueAbbreviation: 'MS',\n    courtId: 'court-1',\n    courtName: 'Center Court',\n    scheduledDate: '2024-06-01',\n    scheduledTime: '10:00',\n  },\n\n  // Potential participants for future rounds\n  potentialParticipants: [[...], [...]],\n\n  // Dependency information\n  winnerTo: { /* next matchUp info */ },\n  loserTo: { /* consolation matchUp info */ },\n}\n")),(0,r.yg)("h3",{id:"when-incontext-is-required"},"When inContext is REQUIRED"),(0,r.yg)("p",null,"Certain operations require ",(0,r.yg)("inlineCode",{parentName:"p"},"inContext: true"),":"),(0,r.yg)("h4",{id:"1-scheduling-operations"},"1. Scheduling Operations"),(0,r.yg)("pre",null,(0,r.yg)("code",{parentName:"pre",className:"language-js"},"// \u274c WRONG: Will fail or produce incorrect results\nconst { matchUps } = tournamentEngine.allCompetitionMatchUps();\ntournamentEngine.proAutoSchedule({ matchUps, scheduledDate: '2024-06-01' });\n\n// \u2705 CORRECT: Scheduling needs participant context\nconst { matchUps } = tournamentEngine.allCompetitionMatchUps({\n  inContext: true,\n  nextMatchUps: true, // Also needed for dependency info\n});\ntournamentEngine.proAutoSchedule({ matchUps, scheduledDate: '2024-06-01' });\n")),(0,r.yg)("h4",{id:"2-conflict-detection"},"2. Conflict Detection"),(0,r.yg)("pre",null,(0,r.yg)("code",{parentName:"pre",className:"language-js"},"// \u274c WRONG: Can't detect participant conflicts without context\nconst { matchUps } = tournamentEngine.allCompetitionMatchUps();\nconst { rowIssues } = tournamentEngine.proConflicts({ matchUps });\n\n// \u2705 CORRECT: Needs participant details to detect conflicts\nconst { matchUps } = tournamentEngine.allCompetitionMatchUps({\n  inContext: true,\n  nextMatchUps: true,\n});\nconst { rowIssues } = tournamentEngine.proConflicts({ matchUps });\n")),(0,r.yg)("h4",{id:"3-displayreporting"},"3. Display/Reporting"),(0,r.yg)("pre",null,(0,r.yg)("code",{parentName:"pre",className:"language-js"},'// \u274c WRONG: Can\'t display names, only IDs\nconst { matchUps } = tournamentEngine.allTournamentMatchUps();\nconsole.log(matchUps[0].sides[0].participantId); // Just an ID\n\n// \u2705 CORRECT: Has full names and details for display\nconst { matchUps } = tournamentEngine.allTournamentMatchUps({\n  inContext: true,\n});\nconsole.log(matchUps[0].sides[0].participant.participantName); // "Jane Doe"\n')),(0,r.yg)("h3",{id:"performance-considerations"},"Performance Considerations"),(0,r.yg)("pre",null,(0,r.yg)("code",{parentName:"pre",className:"language-js"},"// For large datasets, consider performance tradeoff\ntest('performance-critical operation', () => {\n  // \u274c SLOW: Hydrating 1000+ matchUps is expensive\n  const { matchUps } = tournamentEngine.allTournamentMatchUps({\n    inContext: true,\n  });\n\n  // Just checking IDs\n  const matchUpIds = matchUps.map((m) => m.matchUpId);\n\n  // \u2705 FASTER: Only get what you need\n  const { matchUps: basicMatchUps } = tournamentEngine.allTournamentMatchUps();\n  const matchUpIds = basicMatchUps.map((m) => m.matchUpId);\n\n  // \u2705 BEST: Get full context only when needed\n  const matchUpId = basicMatchUps[0].matchUpId;\n  const { matchUp } = tournamentEngine.findMatchUp({\n    matchUpId,\n    inContext: true, // Hydrate just this one\n  });\n});\n")),(0,r.yg)("h3",{id:"best-practice-pattern"},"Best Practice Pattern"),(0,r.yg)("pre",null,(0,r.yg)("code",{parentName:"pre",className:"language-js"},"test('efficient matchUp operations', () => {\n  mocksEngine.generateTournamentRecord({\n    drawProfiles: [{ drawSize: 32 }],\n    setState: true,\n  });\n\n  // Phase 1: Find what you need (fast, no hydration)\n  const { matchUps } = tournamentEngine.allTournamentMatchUps();\n  const firstRoundMatches = matchUps.filter((m) => m.roundNumber === 1);\n\n  // Phase 2: Get full details only for what you're using\n  const { matchUps: hydratedMatches } = tournamentEngine.allTournamentMatchUps({\n    inContext: true,\n    matchUpFilters: {\n      roundNumbers: [1], // Only hydrate first round\n    },\n  });\n\n  // Now work with fully hydrated matchUps\n  hydratedMatches.forEach((matchUp) => {\n    console.log(`${matchUp.sides[0].participant.participantName} vs ${matchUp.sides[1].participant.participantName}`);\n  });\n});\n")),(0,r.yg)("h2",{id:"debugging-patterns"},"Debugging Patterns"),(0,r.yg)("h3",{id:"use-id-prefixes"},"Use ID Prefixes"),(0,r.yg)("p",null,"Make debugging easier with meaningful prefixes:"),(0,r.yg)("pre",null,(0,r.yg)("code",{parentName:"pre",className:"language-js"},"test('debug with prefixes', () => {\n  const { tournamentRecord } = mocksEngine.generateTournamentRecord({\n    participantsProfile: {\n      participantsCount: 32,\n      idPrefix: 'player',\n    },\n    drawProfiles: [\n      {\n        drawSize: 16,\n        idPrefix: 'match',\n      },\n    ],\n  });\n\n  tournamentEngine.setState(tournamentRecord);\n  const { matchUps } = tournamentEngine.allTournamentMatchUps();\n\n  // Console output will show: match-1-1, match-1-2, etc.\n  console.log(matchUps[0].matchUpId);\n  // And: player-I-0, player-I-1, etc.\n  console.log(matchUps[0].sides[0].participantId);\n});\n")),(0,r.yg)("h3",{id:"devcontext-for-detailed-errors"},"DevContext for Detailed Errors"),(0,r.yg)("pre",null,(0,r.yg)("code",{parentName:"pre",className:"language-js"},"test('with devContext for debugging', () => {\n  mocksEngine.devContext(true);\n\n  const { tournamentRecord } = mocksEngine.generateTournamentRecord({\n    drawProfiles: [{ drawSize: 16 }],\n  });\n\n  tournamentEngine.devContext(true).setState(tournamentRecord);\n\n  // Now get detailed error messages for any issues\n  const result = tournamentEngine.setMatchUpStatus({\n    matchUpId: 'invalid-id',\n    outcome: {},\n  });\n\n  // Detailed error information available\n  expect(result.error).toBeDefined();\n});\n")),(0,r.yg)("h2",{id:"integration-testing"},"Integration Testing"),(0,r.yg)("h3",{id:"full-tournament-lifecycle"},"Full Tournament Lifecycle"),(0,r.yg)("pre",null,(0,r.yg)("code",{parentName:"pre",className:"language-js"},"test('complete tournament lifecycle', () => {\n  // 1. Generate tournament\n  const { tournamentRecord, eventIds, venueIds } = mocksEngine.generateTournamentRecord({\n    drawProfiles: [{ drawSize: 8 }],\n    venueProfiles: [{ courtsCount: 3 }],\n  });\n\n  // 2. Load into engine\n  tournamentEngine.setState(tournamentRecord);\n\n  // 3. Schedule matches\n  const { matchUps } = tournamentEngine.allCompetitionMatchUps({\n    inContext: true,\n    nextMatchUps: true,\n  });\n\n  const scheduleResult = tournamentEngine.proAutoSchedule({\n    scheduledDate: '2024-06-01',\n    matchUps,\n  });\n  expect(scheduleResult.success).toBe(true);\n\n  // 4. Complete first round\n  const { matchUps: scheduled } = tournamentEngine.allTournamentMatchUps();\n  const firstRound = scheduled.filter((m) => m.roundNumber === 1);\n\n  firstRound.forEach((matchUp) => {\n    const { outcome } = mocksEngine.generateOutcome();\n    tournamentEngine.setMatchUpStatus({\n      matchUpId: matchUp.matchUpId,\n      drawId: matchUp.drawId,\n      outcome,\n    });\n  });\n\n  // 5. Verify progression\n  const { upcomingMatchUps } = tournamentEngine.tournamentMatchUps();\n  const secondRoundReady = upcomingMatchUps.filter((m) => m.roundNumber === 2 && m.sides.every((s) => s.participantId));\n\n  expect(secondRoundReady.length).toBeGreaterThan(0);\n\n  // 6. Export and verify\n  const { tournamentRecord: final } = tournamentEngine.getTournament();\n  expect(final.events[0].drawDefinitions[0].structures[0].matchUps).toBeDefined();\n});\n")),(0,r.yg)("h2",{id:"best-practices-summary"},"Best Practices Summary"),(0,r.yg)("ol",null,(0,r.yg)("li",{parentName:"ol"},(0,r.yg)("strong",{parentName:"li"},"Use setState: true"),": Auto-load tournaments into engine for convenience"),(0,r.yg)("li",{parentName:"ol"},(0,r.yg)("strong",{parentName:"li"},"Use inContext: true"),": When you need full participant details, scheduling, or conflict detection"),(0,r.yg)("li",{parentName:"ol"},(0,r.yg)("strong",{parentName:"li"},"Understand Performance"),": Use ",(0,r.yg)("inlineCode",{parentName:"li"},"inContext: false")," for large datasets, true only when needed"),(0,r.yg)("li",{parentName:"ol"},(0,r.yg)("strong",{parentName:"li"},"Reuse Tournament Structures"),": Generate once, test multiple scenarios"),(0,r.yg)("li",{parentName:"ol"},(0,r.yg)("strong",{parentName:"li"},"Use Factory Functions"),": Create helper functions for common setups"),(0,r.yg)("li",{parentName:"ol"},(0,r.yg)("strong",{parentName:"li"},"Add ID Prefixes"),": Make debugging easier with meaningful IDs"),(0,r.yg)("li",{parentName:"ol"},(0,r.yg)("strong",{parentName:"li"},"Enable DevContext"),": Get detailed errors during development"),(0,r.yg)("li",{parentName:"ol"},(0,r.yg)("strong",{parentName:"li"},"Test Edge Cases"),": Use matchUpStatusProfile for various outcomes"),(0,r.yg)("li",{parentName:"ol"},(0,r.yg)("strong",{parentName:"li"},"Minimize Generation"),": Don't regenerate unnecessarily in loops"),(0,r.yg)("li",{parentName:"ol"},(0,r.yg)("strong",{parentName:"li"},"Fixed Values for Snapshots"),": Use fixed dates/IDs for snapshot testing"),(0,r.yg)("li",{parentName:"ol"},(0,r.yg)("strong",{parentName:"li"},"Test Complete Flows"),": Integrate generation with engine operations"),(0,r.yg)("li",{parentName:"ol"},(0,r.yg)("strong",{parentName:"li"},"Organize Tests Logically"),": Group related tests, use shared setup"),(0,r.yg)("li",{parentName:"ol"},(0,r.yg)("strong",{parentName:"li"},"Document Complex Scenarios"),": Add comments explaining non-obvious test setups"),(0,r.yg)("li",{parentName:"ol"},(0,r.yg)("strong",{parentName:"li"},"Phase Your Operations"),": Get basic data first, hydrate only what you need")),(0,r.yg)("h2",{id:"next-steps"},"Next Steps"),(0,r.yg)("ul",null,(0,r.yg)("li",{parentName:"ul"},(0,r.yg)("strong",{parentName:"li"},(0,r.yg)("a",{parentName:"strong",href:"/tods-competition-factory/docs/testing/mocks-engine-tournament-generation"},"Tournament Generation"))," - Complete tournament generation options"),(0,r.yg)("li",{parentName:"ul"},(0,r.yg)("strong",{parentName:"li"},(0,r.yg)("a",{parentName:"strong",href:"/tods-competition-factory/docs/testing/mocks-engine-participants"},"Participant Generation"))," - Types and demographics"),(0,r.yg)("li",{parentName:"ul"},(0,r.yg)("strong",{parentName:"li"},(0,r.yg)("a",{parentName:"strong",href:"/tods-competition-factory/docs/testing/mocks-engine-outcomes"},"Outcome Generation"))," - Match results and scores")))}p.isMDXComponent=!0}}]);