"use strict";(globalThis.webpackChunkdocumentation=globalThis.webpackChunkdocumentation||[]).push([[9094],{112(e,t,n){n.r(t),n.d(t,{assets:()=>c,contentTitle:()=>i,default:()=>l,frontMatter:()=>o,metadata:()=>r,toc:()=>d});const r=JSON.parse('{"id":"governors/matchup-format-governor","title":"matchUpFormat Governor","description":"The matchUpFormatGovernor provides utilities for parsing, validating, and generating matchUp format codes. These format codes define scoring rules for matches (sets, games, tiebreaks, timed sets, etc.) across any sport.","source":"@site/docs/governors/matchup-format-governor.md","sourceDirName":"governors","slug":"/governors/matchup-format-governor","permalink":"/competition-factory/docs/governors/matchup-format-governor","draft":false,"unlisted":false,"tags":[],"version":"current","frontMatter":{"title":"matchUpFormat Governor"},"sidebar":"docs","previous":{"title":"matchUp Governor","permalink":"/competition-factory/docs/governors/matchup-governor"},"next":{"title":"Mocks Governor","permalink":"/competition-factory/docs/governors/mocks-governor"}}');var a=n(6070),s=n(8322);const o={title:"matchUpFormat Governor"},i=void 0,c={},d=[{value:"parse",id:"parse",level:2},{value:"stringify",id:"stringify",level:2},{value:"isValid / isValidMatchUpFormat",id:"isvalid--isvalidmatchupformat",level:2}];function m(e){const t={a:"a",code:"code",h2:"h2",hr:"hr",li:"li",ol:"ol",p:"p",pre:"pre",strong:"strong",ul:"ul",...(0,s.R)(),...e.components};return(0,a.jsxs)(a.Fragment,{children:[(0,a.jsx)(t.pre,{children:(0,a.jsx)(t.code,{className:"language-js",children:"import { matchUpFormatGovernor } from 'tods-competition-factory';\n"})}),"\n",(0,a.jsxs)(t.p,{children:["The ",(0,a.jsx)(t.strong,{children:"matchUpFormatGovernor"})," provides utilities for parsing, validating, and generating matchUp format codes. These format codes define scoring rules for matches (sets, games, tiebreaks, timed sets, etc.) across any sport."]}),"\n",(0,a.jsxs)(t.p,{children:[(0,a.jsx)(t.strong,{children:"See also:"})," ",(0,a.jsx)(t.a,{href:"/docs/codes/matchup-format",children:"matchUpFormat Codes"})," for the complete format specification, grammar reference, and cross-sport format examples."]}),"\n",(0,a.jsx)(t.p,{children:(0,a.jsx)(t.strong,{children:"Format Code Examples:"})}),"\n",(0,a.jsxs)(t.ul,{children:["\n",(0,a.jsxs)(t.li,{children:[(0,a.jsx)(t.code,{children:"SET3-S:6/TB7"})," - Best of 3 sets, first to 6 games, tiebreak to 7 at 6-6"]}),"\n",(0,a.jsxs)(t.li,{children:[(0,a.jsx)(t.code,{children:"SET5-S:6/TB7-F:6/TB10"})," - Best of 5 sets, final set tiebreak to 10"]}),"\n",(0,a.jsxs)(t.li,{children:[(0,a.jsx)(t.code,{children:"SET1-S:4/TB7@3"})," - Single set to 4 games, tiebreak to 7 at 3-3"]}),"\n",(0,a.jsxs)(t.li,{children:[(0,a.jsx)(t.code,{children:"T20"})," - 20-minute timed set (games-based)"]}),"\n",(0,a.jsxs)(t.li,{children:[(0,a.jsx)(t.code,{children:"T10P"})," - 10-minute timed set (points-based)"]}),"\n",(0,a.jsxs)(t.li,{children:[(0,a.jsx)(t.code,{children:"SET3-S:TB11@RALLY"})," - Pickleball: best of 3 to 11, rally scoring"]}),"\n",(0,a.jsxs)(t.li,{children:[(0,a.jsx)(t.code,{children:"HAL2A-S:T45"})," - Soccer: 2 halves of 45 min, aggregate"]}),"\n",(0,a.jsxs)(t.li,{children:[(0,a.jsx)(t.code,{children:"SET5-S:5-G:3C"})," - TYPTI: 5 sets to 5, 3 consecutive points per game"]}),"\n",(0,a.jsxs)(t.li,{children:[(0,a.jsx)(t.code,{children:"SET7XA-S:T10P"})," - INTENNSE: exactly 7 timed sets, aggregate, points-based"]}),"\n",(0,a.jsxs)(t.li,{children:[(0,a.jsx)(t.code,{children:"INN4XA-S:O3-M:T50"})," - BLW Wiffle Ball: 4 innings, 3 outs, aggregate, 50-min match cap"]}),"\n"]}),"\n",(0,a.jsx)(t.hr,{}),"\n",(0,a.jsx)(t.h2,{id:"parse",children:"parse"}),"\n",(0,a.jsx)(t.p,{children:"Parses a matchUp format code string into a structured object representation."}),"\n",(0,a.jsxs)(t.p,{children:[(0,a.jsx)(t.strong,{children:"Purpose:"})," Convert a compact format code string into a detailed object that describes all scoring rules. This enables programmatic access to scoring parameters."]}),"\n",(0,a.jsx)(t.p,{children:(0,a.jsx)(t.strong,{children:"When to Use:"})}),"\n",(0,a.jsxs)(t.ul,{children:["\n",(0,a.jsx)(t.li,{children:"Validating match format codes"}),"\n",(0,a.jsx)(t.li,{children:"Extracting scoring rules from format strings"}),"\n",(0,a.jsx)(t.li,{children:"Building scoring interfaces that need to understand format details"}),"\n",(0,a.jsx)(t.li,{children:"Converting between format representations"}),"\n",(0,a.jsx)(t.li,{children:"Analyzing tournament format requirements"}),"\n"]}),"\n",(0,a.jsx)(t.p,{children:(0,a.jsx)(t.strong,{children:"Parameters:"})}),"\n",(0,a.jsx)(t.pre,{children:(0,a.jsx)(t.code,{className:"language-ts",children:'matchUpFormatCode: string; // CODES format code (e.g., "SET3-S:6/TB7")\n'})}),"\n",(0,a.jsx)(t.p,{children:(0,a.jsx)(t.strong,{children:"Returns:"})}),"\n",(0,a.jsx)(t.pre,{children:(0,a.jsx)(t.code,{className:"language-ts",children:"{\n  bestOf?: number;           // Best of N sets (e.g., 3 for best of 3)\n  exactly?: number;          // Exactly N sets (for formats like SET3X)\n  matchRoot?: string;        // Root type, only present for non-SET roots (e.g., 'HAL', 'QTR', 'PER', 'RND', 'FRM', 'MAP')\n  aggregate?: boolean;       // True when match-level A modifier is present\n  matchMods?: string[];      // Unknown modifier letters for forward compatibility\n  setFormat?: {\n    setTo: number;           // Games to win set (e.g., 6)\n    tiebreakAt?: number;     // When tiebreak starts (e.g., 6 for 6-6)\n    tiebreakFormat?: {\n      tiebreakTo: number;    // Points to win tiebreak (e.g., 7)\n      NoAD?: boolean;        // No-advantage tiebreak\n      modifier?: string;     // Custom tiebreak modifier\n    };\n    tiebreakSet?: {          // Mutually exclusive with setTo/tiebreakFormat\n      tiebreakTo: number;    // Points to win tiebreak set\n      NoAD?: boolean;\n      modifier?: string;     // e.g., 'RALLY' for pickleball\n    };\n    noTiebreak?: boolean;    // Set has no tiebreak\n    NoAD?: boolean;          // No-advantage games (no deuce)\n    timed?: boolean;         // Is this a timed set?\n    minutes?: number;        // Minutes for timed set\n    based?: string;          // Scoring basis: 'G' (games), 'P' (points)\n    outs?: number;           // Outs per team per inning (e.g., 3 for baseball/wiffle ball)\n  };\n  finalSetFormat?: {         // Same structure as setFormat, for final set\n    // ... (all setFormat properties)\n  };\n  gameFormat?: {             // Game-level format specification (-G: section)\n    type: 'TRADITIONAL';     // Traditional tennis/padel game scoring (0-15-30-40)\n    deuceAfter?: number;     // Deuce cap: 1=golden point, 3=Star Point, undefined=unlimited\n  } | {\n    type: 'CONSECUTIVE';     // Consecutive points to win a game\n    count: number;           // Number of consecutive points required\n    deuceAfter?: number;     // Optional deuce cap\n  };\n  matchUpConstraint?: {      // Match-level constraint (-M: section)\n    timed: boolean;          // Whether match has a time cap\n    minutes: number;         // Match time cap in minutes\n  };\n  simplified?: boolean;      // True for single-set formats like \"T20\"\n} | undefined                // undefined if parsing fails\n"})}),"\n",(0,a.jsx)(t.p,{children:(0,a.jsx)(t.strong,{children:"Examples:"})}),"\n",(0,a.jsx)(t.pre,{children:(0,a.jsx)(t.code,{className:"language-js",children:"// Parse standard tennis format\nconst parsed = matchUpFormatGovernor.parse('SET3-S:6/TB7');\n// {\n//   bestOf: 3,\n//   setFormat: {\n//     setTo: 6,\n//     tiebreakAt: 6,\n//     tiebreakFormat: { tiebreakTo: 7 }\n//   }\n// }\n\n// Parse with final set variation\nconst parsed = matchUpFormatGovernor.parse('SET5-S:6/TB7-F:6/TB10');\n// {\n//   bestOf: 5,\n//   setFormat: { setTo: 6, tiebreakAt: 6, tiebreakFormat: { tiebreakTo: 7 } },\n//   finalSetFormat: { setTo: 6, tiebreakAt: 6, tiebreakFormat: { tiebreakTo: 10 } }\n// }\n\n// Parse timed set\nconst parsed = matchUpFormatGovernor.parse('T20');\n// {\n//   bestOf: 1,\n//   simplified: true,\n//   setFormat: { timed: true, minutes: 20 }\n// }\n\n// Parse short set with early tiebreak\nconst parsed = matchUpFormatGovernor.parse('SET1-S:4/TB7@3');\n// {\n//   bestOf: 1,\n//   setFormat: { setTo: 4, tiebreakAt: 3, tiebreakFormat: { tiebreakTo: 7 } }\n// }\n\n// Parse pickleball with rally scoring\nconst parsed = matchUpFormatGovernor.parse('SET3-S:TB11@RALLY');\n// {\n//   bestOf: 3,\n//   setFormat: { tiebreakSet: { tiebreakTo: 11, modifier: 'RALLY' } }\n// }\n\n// Parse non-SET root (soccer)\nconst parsed = matchUpFormatGovernor.parse('HAL2A-S:T45');\n// {\n//   matchRoot: 'HAL',\n//   bestOf: 2,\n//   aggregate: true,\n//   setFormat: { timed: true, minutes: 45 }\n// }\n\n// Parse with game format (TYPTI)\nconst parsed = matchUpFormatGovernor.parse('SET5-S:5-G:3C');\n// {\n//   bestOf: 5,\n//   setFormat: { setTo: 5, noTiebreak: true },\n//   gameFormat: { type: 'CONSECUTIVE', count: 3 }\n// }\n\n// Parse INTENNSE format\nconst parsed = matchUpFormatGovernor.parse('SET7XA-S:T10P');\n// {\n//   exactly: 7,\n//   aggregate: true,\n//   setFormat: { timed: true, minutes: 10, based: 'P' }\n// }\n\n// Parse Padel Star Point format\nconst parsed = matchUpFormatGovernor.parse('SET3-S:6/TB7-G:TN3D');\n// {\n//   bestOf: 3,\n//   setFormat: { setTo: 6, tiebreakAt: 6, tiebreakFormat: { tiebreakTo: 7 } },\n//   gameFormat: { type: 'TRADITIONAL', deuceAfter: 3 }\n// }\n\n// Parse explicit traditional game format\nconst parsed = matchUpFormatGovernor.parse('SET3-S:6/TB7-G:TN');\n// {\n//   bestOf: 3,\n//   setFormat: { setTo: 6, tiebreakAt: 6, tiebreakFormat: { tiebreakTo: 7 } },\n//   gameFormat: { type: 'TRADITIONAL' }\n// }\n\n// Parse outs-based format (wiffle ball)\nconst parsed = matchUpFormatGovernor.parse('INN4XA-S:O3-M:T50');\n// {\n//   matchRoot: 'INN',\n//   exactly: 4,\n//   aggregate: true,\n//   setFormat: { outs: 3 },\n//   matchUpConstraint: { timed: true, minutes: 50 }\n// }\n\n// Parse match constraint with tennis format\nconst parsed = matchUpFormatGovernor.parse('SET3-S:6/TB7-M:T120');\n// {\n//   bestOf: 3,\n//   setFormat: { setTo: 6, tiebreakAt: 6, tiebreakFormat: { tiebreakTo: 7 } },\n//   matchUpConstraint: { timed: true, minutes: 120 }\n// }\n\n// Invalid format returns undefined\nconst parsed = matchUpFormatGovernor.parse('INVALID');\n// undefined\n"})}),"\n",(0,a.jsx)(t.p,{children:(0,a.jsx)(t.strong,{children:"Notes:"})}),"\n",(0,a.jsxs)(t.ul,{children:["\n",(0,a.jsxs)(t.li,{children:["Returns ",(0,a.jsx)(t.code,{children:"undefined"})," for invalid format codes"]}),"\n",(0,a.jsx)(t.li,{children:"Supports standard sets, timed sets, and tiebreak sets"}),"\n",(0,a.jsx)(t.li,{children:"Handles special cases like no-advantage (NoAD) games and tiebreaks"}),"\n",(0,a.jsxs)(t.li,{children:["Timed sets can be games-based (G) or points-based (P); aggregate scoring is signaled by the match-level ",(0,a.jsx)(t.code,{children:"A"})," modifier"]}),"\n",(0,a.jsxs)(t.li,{children:[(0,a.jsx)(t.code,{children:"matchRoot"})," is only included when the root is not ",(0,a.jsx)(t.code,{children:"SET"})," (backward compatibility)"]}),"\n",(0,a.jsxs)(t.li,{children:[(0,a.jsx)(t.code,{children:"aggregate"})," is only included when ",(0,a.jsx)(t.code,{children:"true"})]}),"\n",(0,a.jsxs)(t.li,{children:["Sections (",(0,a.jsx)(t.code,{children:"-S:"}),", ",(0,a.jsx)(t.code,{children:"-F:"}),", ",(0,a.jsx)(t.code,{children:"-G:"}),", ",(0,a.jsx)(t.code,{children:"-M:"}),") are dispatched by key, not by position, so order doesn't matter"]}),"\n",(0,a.jsxs)(t.li,{children:["For ",(0,a.jsx)(t.code,{children:"SET"})," root, ",(0,a.jsx)(t.code,{children:"bestOf"})," must be < 6 (for non-timed formats); non-",(0,a.jsx)(t.code,{children:"SET"})," roots have no limit"]}),"\n",(0,a.jsxs)(t.li,{children:["Format grammar: ",(0,a.jsx)(t.code,{children:"{ROOT}{count}[X][A]-S:{setSpec}[-G:{gameSpec}][-F:{setSpec}][-M:{matchConstraint}]"})]}),"\n",(0,a.jsxs)(t.li,{children:["Outs-based set format (",(0,a.jsx)(t.code,{children:"-S:O3"}),") is for innings-based sports (baseball, wiffle ball)"]}),"\n",(0,a.jsxs)(t.li,{children:["Match constraint (",(0,a.jsx)(t.code,{children:"-M:T50"}),") sets a match-level time cap that applies across all segments"]}),"\n",(0,a.jsxs)(t.li,{children:["Timed format: ",(0,a.jsx)(t.code,{children:"T{minutes}[G|P][/TB{points}]"})]}),"\n",(0,a.jsxs)(t.li,{children:["See ",(0,a.jsx)(t.a,{href:"/docs/codes/matchup-format",children:"matchUpFormat Codes"})," for complete format specification and cross-sport examples"]}),"\n"]}),"\n",(0,a.jsx)(t.hr,{}),"\n",(0,a.jsx)(t.h2,{id:"stringify",children:"stringify"}),"\n",(0,a.jsx)(t.p,{children:"Converts a parsed matchUp format object back into a compact format code string."}),"\n",(0,a.jsxs)(t.p,{children:[(0,a.jsx)(t.strong,{children:"Purpose:"})," Generate a standard CODES format code from a structured format object. This is the inverse operation of ",(0,a.jsx)(t.code,{children:"parse()"})," and is useful for creating format codes programmatically."]}),"\n",(0,a.jsx)(t.p,{children:(0,a.jsx)(t.strong,{children:"When to Use:"})}),"\n",(0,a.jsxs)(t.ul,{children:["\n",(0,a.jsx)(t.li,{children:"Creating format codes from UI inputs"}),"\n",(0,a.jsx)(t.li,{children:"Normalizing format representations"}),"\n",(0,a.jsx)(t.li,{children:"Generating format codes for storage or transmission"}),"\n",(0,a.jsx)(t.li,{children:"Validating format consistency (parse \u2192 modify \u2192 stringify)"}),"\n",(0,a.jsx)(t.li,{children:"Converting between format representations"}),"\n"]}),"\n",(0,a.jsx)(t.p,{children:(0,a.jsx)(t.strong,{children:"Parameters:"})}),"\n",(0,a.jsx)(t.pre,{children:(0,a.jsx)(t.code,{className:"language-ts",children:"matchUpFormatObject: {       // Parsed format object\n  bestOf?: number;\n  exactly?: number;\n  matchRoot?: string;        // Non-SET root type (e.g., 'HAL', 'QTR', 'INN')\n  aggregate?: boolean;       // Include A suffix in head\n  setFormat?: object;        // Includes outs for -S:O{n}\n  finalSetFormat?: object;\n  gameFormat?: {             // Emit -G: section\n    type: 'TRADITIONAL' | 'CONSECUTIVE';\n    count?: number;          // Required when type is 'CONSECUTIVE'\n    deuceAfter?: number;     // Optional deuce cap (e.g., 3 for Star Point)\n  };\n  matchUpConstraint?: {      // Emit -M: section\n    timed: boolean;          // Whether match has a time cap\n    minutes: number;         // Match time cap in minutes\n  };\n  simplified?: boolean;\n};\npreserveRedundant?: boolean; // Keep redundant tiebreakAt values (default: false)\n"})}),"\n",(0,a.jsx)(t.p,{children:(0,a.jsx)(t.strong,{children:"Returns:"})}),"\n",(0,a.jsx)(t.pre,{children:(0,a.jsx)(t.code,{className:"language-ts",children:"string | undefined; // Format code string, or undefined if invalid\n"})}),"\n",(0,a.jsx)(t.p,{children:(0,a.jsx)(t.strong,{children:"Examples:"})}),"\n",(0,a.jsx)(t.pre,{children:(0,a.jsx)(t.code,{className:"language-js",children:'// Stringify standard format\nconst formatString = matchUpFormatGovernor.stringify({\n  bestOf: 3,\n  setFormat: {\n    setTo: 6,\n    tiebreakAt: 6,\n    tiebreakFormat: { tiebreakTo: 7 },\n  },\n});\n// "SET3-S:6/TB7"\n\n// Stringify with final set variation\nconst formatString = matchUpFormatGovernor.stringify({\n  bestOf: 5,\n  setFormat: { setTo: 6, tiebreakAt: 6, tiebreakFormat: { tiebreakTo: 7 } },\n  finalSetFormat: { setTo: 6, tiebreakAt: 6, tiebreakFormat: { tiebreakTo: 10 } },\n});\n// "SET5-S:6/TB7-F:6/TB10"\n\n// Stringify timed set\nconst formatString = matchUpFormatGovernor.stringify({\n  bestOf: 1,\n  simplified: true,\n  setFormat: { timed: true, minutes: 20 },\n});\n// "T20"\n\n// Stringify with non-SET root (soccer)\nconst formatString = matchUpFormatGovernor.stringify({\n  matchRoot: \'HAL\',\n  bestOf: 2,\n  aggregate: true,\n  setFormat: { timed: true, minutes: 45 },\n});\n// "HAL2A-S:T45"\n\n// Stringify with game format (TYPTI)\nconst formatString = matchUpFormatGovernor.stringify({\n  bestOf: 5,\n  setFormat: { setTo: 5, noTiebreak: true },\n  gameFormat: { type: \'CONSECUTIVE\', count: 3 },\n});\n// "SET5-S:5-G:3C"\n\n// Stringify Padel Star Point format\nconst formatString = matchUpFormatGovernor.stringify({\n  bestOf: 3,\n  setFormat: { setTo: 6, tiebreakAt: 6, tiebreakFormat: { tiebreakTo: 7 } },\n  gameFormat: { type: \'TRADITIONAL\', deuceAfter: 3 },\n});\n// "SET3-S:6/TB7-G:TN3D"\n\n// Stringify INTENNSE format\nconst formatString = matchUpFormatGovernor.stringify({\n  exactly: 7,\n  aggregate: true,\n  setFormat: { timed: true, minutes: 10, based: \'P\' },\n});\n// "SET7XA-S:T10P"\n\n// Stringify with early tiebreak (redundant tiebreakAt omitted by default)\nconst formatString = matchUpFormatGovernor.stringify({\n  bestOf: 1,\n  setFormat: { setTo: 4, tiebreakAt: 3, tiebreakFormat: { tiebreakTo: 7 } },\n});\n// "SET1-S:4/TB7@3"\n\n// Preserve redundant tiebreakAt (when tiebreakAt equals setTo)\nconst formatString = matchUpFormatGovernor.stringify(\n  {\n    bestOf: 1,\n    setFormat: { setTo: 6, tiebreakAt: 6, tiebreakFormat: { tiebreakTo: 7 } },\n  },\n  true,\n);\n// "SET1-S:6/TB7@6" (with preserveRedundant: true)\n\n// Without preserveRedundant, @6 is omitted\nconst formatString = matchUpFormatGovernor.stringify({\n  bestOf: 1,\n  setFormat: { setTo: 6, tiebreakAt: 6, tiebreakFormat: { tiebreakTo: 7 } },\n});\n// "SET1-S:6/TB7" (default behavior)\n\n// Stringify outs-based format (wiffle ball)\nconst formatString = matchUpFormatGovernor.stringify({\n  matchRoot: \'INN\',\n  exactly: 4,\n  aggregate: true,\n  setFormat: { outs: 3 },\n  matchUpConstraint: { timed: true, minutes: 50 },\n});\n// "INN4XA-S:O3-M:T50"\n\n// Stringify with match constraint on tennis format\nconst formatString = matchUpFormatGovernor.stringify({\n  bestOf: 3,\n  setFormat: { setTo: 6, tiebreakAt: 6, tiebreakFormat: { tiebreakTo: 7 } },\n  matchUpConstraint: { timed: true, minutes: 120 },\n});\n// "SET3-S:6/TB7-M:T120"\n'})}),"\n",(0,a.jsx)(t.p,{children:(0,a.jsx)(t.strong,{children:"Notes:"})}),"\n",(0,a.jsxs)(t.ul,{children:["\n",(0,a.jsxs)(t.li,{children:["Returns ",(0,a.jsx)(t.code,{children:"undefined"})," for invalid format objects"]}),"\n",(0,a.jsxs)(t.li,{children:["By default, omits ",(0,a.jsx)(t.code,{children:"@{at}"})," when ",(0,a.jsx)(t.code,{children:"tiebreakAt"})," equals ",(0,a.jsx)(t.code,{children:"setTo"})," (standard case)"]}),"\n",(0,a.jsxs)(t.li,{children:["Set ",(0,a.jsx)(t.code,{children:"preserveRedundant: true"})," to include ",(0,a.jsx)(t.code,{children:"@{at}"})," even when it matches ",(0,a.jsx)(t.code,{children:"setTo"})]}),"\n",(0,a.jsx)(t.li,{children:"Automatically omits final set format if identical to standard set format"}),"\n",(0,a.jsx)(t.li,{children:"Single-set timed formats (T20, T10P) use simplified representation"}),"\n",(0,a.jsxs)(t.li,{children:[(0,a.jsx)(t.code,{children:"bestOf: 1"})," and ",(0,a.jsx)(t.code,{children:"exactly: 1"})," both stringify to ",(0,a.jsx)(t.code,{children:"SET1"})," (no X suffix)"]}),"\n",(0,a.jsx)(t.li,{children:"Games-based timed sets omit the 'G' suffix (it's the default)"}),"\n",(0,a.jsxs)(t.li,{children:[(0,a.jsx)(t.code,{children:"matchRoot"})," defaults to ",(0,a.jsx)(t.code,{children:"SET"})," when not specified"]}),"\n",(0,a.jsxs)(t.li,{children:[(0,a.jsx)(t.code,{children:"aggregate: true"})," adds the ",(0,a.jsx)(t.code,{children:"A"})," suffix after the count (e.g., ",(0,a.jsx)(t.code,{children:"HAL2A"}),")"]}),"\n",(0,a.jsxs)(t.li,{children:[(0,a.jsx)(t.code,{children:"gameFormat"})," emits the ",(0,a.jsx)(t.code,{children:"-G:"})," section (e.g., ",(0,a.jsx)(t.code,{children:"-G:3C"}),", ",(0,a.jsx)(t.code,{children:"-G:TN3D"}),")"]}),"\n",(0,a.jsxs)(t.li,{children:[(0,a.jsx)(t.code,{children:"matchUpConstraint"})," emits the ",(0,a.jsx)(t.code,{children:"-M:"})," section (e.g., ",(0,a.jsx)(t.code,{children:"-M:T50"}),")"]}),"\n",(0,a.jsxs)(t.li,{children:[(0,a.jsx)(t.code,{children:"setFormat.outs"})," emits outs-based segment format (e.g., ",(0,a.jsx)(t.code,{children:"-S:O3"}),")"]}),"\n",(0,a.jsxs)(t.li,{children:["Head modifier ordering is canonical: count \u2192 X \u2192 A (e.g., ",(0,a.jsx)(t.code,{children:"SET7XA"}),")"]}),"\n",(0,a.jsxs)(t.li,{children:["See ",(0,a.jsx)(t.a,{href:"/docs/codes/matchup-format",children:"matchUpFormat Codes"})," for the complete format grammar"]}),"\n"]}),"\n",(0,a.jsx)(t.hr,{}),"\n",(0,a.jsx)(t.h2,{id:"isvalid--isvalidmatchupformat",children:"isValid / isValidMatchUpFormat"}),"\n",(0,a.jsx)(t.p,{children:"Validates whether a format code string is properly formed and can be successfully parsed and round-tripped."}),"\n",(0,a.jsxs)(t.p,{children:[(0,a.jsx)(t.strong,{children:"Purpose:"})," Verify that a format code string conforms to CODES specification. This ensures the format can be used reliably throughout the system."]}),"\n",(0,a.jsx)(t.p,{children:(0,a.jsx)(t.strong,{children:"When to Use:"})}),"\n",(0,a.jsxs)(t.ul,{children:["\n",(0,a.jsx)(t.li,{children:"Validating user input for match formats"}),"\n",(0,a.jsx)(t.li,{children:"Checking format codes before storing"}),"\n",(0,a.jsx)(t.li,{children:"Verifying format codes from external sources"}),"\n",(0,a.jsx)(t.li,{children:"Form validation in tournament setup"}),"\n",(0,a.jsx)(t.li,{children:"Catching malformed format strings early"}),"\n"]}),"\n",(0,a.jsx)(t.p,{children:(0,a.jsx)(t.strong,{children:"Parameters:"})}),"\n",(0,a.jsx)(t.pre,{children:(0,a.jsx)(t.code,{className:"language-ts",children:"{\n  matchUpFormat: string; // Format code to validate\n}\n"})}),"\n",(0,a.jsx)(t.p,{children:(0,a.jsx)(t.strong,{children:"Returns:"})}),"\n",(0,a.jsx)(t.pre,{children:(0,a.jsx)(t.code,{className:"language-ts",children:"boolean; // true if valid, false if invalid\n"})}),"\n",(0,a.jsxs)(t.p,{children:[(0,a.jsx)(t.strong,{children:"Validation Logic:"}),"\nThe format is considered valid if:"]}),"\n",(0,a.jsxs)(t.ol,{children:["\n",(0,a.jsx)(t.li,{children:"It can be successfully parsed"}),"\n",(0,a.jsx)(t.li,{children:"When stringified again, it matches the original (round-trip test)"}),"\n",(0,a.jsxs)(t.li,{children:["The 'G' suffix on timed-basis sets (e.g., ",(0,a.jsx)(t.code,{children:"T10G"}),") is normalized before comparison"]}),"\n"]}),"\n",(0,a.jsx)(t.p,{children:(0,a.jsx)(t.strong,{children:"Examples:"})}),"\n",(0,a.jsx)(t.pre,{children:(0,a.jsx)(t.code,{className:"language-js",children:"// Valid standard formats\nmatchUpFormatGovernor.isValidMatchUpFormat({\n  matchUpFormat: 'SET3-S:6/TB7',\n}); // true\n\nmatchUpFormatGovernor.isValidMatchUpFormat({\n  matchUpFormat: 'SET5-S:6/TB7-F:6/TB10',\n}); // true\n\n// Valid timed formats\nmatchUpFormatGovernor.isValidMatchUpFormat({\n  matchUpFormat: 'T20',\n}); // true\n\nmatchUpFormatGovernor.isValidMatchUpFormat({\n  matchUpFormat: 'T20G',\n}); // true (games-based, G is optional)\n\n// Valid multi-root formats\nmatchUpFormatGovernor.isValidMatchUpFormat({\n  matchUpFormat: 'HAL2A-S:T45',\n}); // true (soccer)\n\nmatchUpFormatGovernor.isValidMatchUpFormat({\n  matchUpFormat: 'QTR4A-S:T12',\n}); // true (basketball)\n\nmatchUpFormatGovernor.isValidMatchUpFormat({\n  matchUpFormat: 'RND12A-S:T3',\n}); // true (boxing)\n\n// Valid game format sections\nmatchUpFormatGovernor.isValidMatchUpFormat({\n  matchUpFormat: 'SET5-S:5-G:3C',\n}); // true (TYPTI)\n\nmatchUpFormatGovernor.isValidMatchUpFormat({\n  matchUpFormat: 'SET3-S:6/TB7-G:TN3D',\n}); // true (Padel Star Point)\n\n// Valid outs-based and match constraint formats\nmatchUpFormatGovernor.isValidMatchUpFormat({\n  matchUpFormat: 'INN4XA-S:O3-M:T50',\n}); // true (BLW Wiffle Ball)\n\nmatchUpFormatGovernor.isValidMatchUpFormat({\n  matchUpFormat: 'SET3-S:6/TB7-M:T120',\n}); // true (tennis with match time cap)\n\n// Valid pickleball formats\nmatchUpFormatGovernor.isValidMatchUpFormat({\n  matchUpFormat: 'SET3-S:TB11@RALLY',\n}); // true\n\n// Invalid formats\nmatchUpFormatGovernor.isValidMatchUpFormat({\n  matchUpFormat: 'INVALID',\n}); // false\n\nmatchUpFormatGovernor.isValidMatchUpFormat({\n  matchUpFormat: 'SET3-S:5-G:INVALID',\n}); // false (unknown game format)\n\nmatchUpFormatGovernor.isValidMatchUpFormat({\n  matchUpFormat: 'SET3-S:5-G:3C-G:4C',\n}); // false (duplicate -G: section)\n\nmatchUpFormatGovernor.isValidMatchUpFormat({\n  matchUpFormat: '',\n}); // false (empty string)\n"})}),"\n",(0,a.jsx)(t.p,{children:(0,a.jsx)(t.strong,{children:"Notes:"})}),"\n",(0,a.jsxs)(t.ul,{children:["\n",(0,a.jsx)(t.li,{children:"Performs round-trip validation (parse \u2192 stringify \u2192 compare)"}),"\n",(0,a.jsxs)(t.li,{children:["Empty strings return ",(0,a.jsx)(t.code,{children:"false"})]}),"\n",(0,a.jsxs)(t.li,{children:["Non-string values return ",(0,a.jsx)(t.code,{children:"false"})]}),"\n",(0,a.jsxs)(t.li,{children:["The 'G' suffix on timed sets is stripped during validation (games-based is default), but only the timed-basis ",(0,a.jsx)(t.code,{children:"G"})," (e.g., ",(0,a.jsx)(t.code,{children:"T10G"}),"), not the ",(0,a.jsx)(t.code,{children:"-G:"})," section key"]}),"\n",(0,a.jsx)(t.li,{children:"NoAD (no-advantage) is supported for both games and tiebreaks"}),"\n",(0,a.jsx)(t.li,{children:"Format must follow the grammar exactly"}),"\n",(0,a.jsxs)(t.li,{children:["Both ",(0,a.jsx)(t.code,{children:"isValid"})," and ",(0,a.jsx)(t.code,{children:"isValidMatchUpFormat"})," are available (same function, different export names)"]}),"\n",(0,a.jsxs)(t.li,{children:["All ",(0,a.jsx)(t.a,{href:"/docs/codes/matchup-format#match-root-types",children:"match root types"})," are validated"]}),"\n",(0,a.jsxs)(t.li,{children:["See ",(0,a.jsx)(t.a,{href:"/docs/codes/matchup-format",children:"matchUpFormat Codes"})," for the complete format specification"]}),"\n"]}),"\n",(0,a.jsx)(t.hr,{})]})}function l(e={}){const{wrapper:t}={...(0,s.R)(),...e.components};return t?(0,a.jsx)(t,{...e,children:(0,a.jsx)(m,{...e})}):m(e)}},8322(e,t,n){n.d(t,{R:()=>o,x:()=>i});var r=n(758);const a={},s=r.createContext(a);function o(e){const t=r.useContext(s);return r.useMemo(function(){return"function"==typeof e?e(t):{...t,...e}},[t,e])}function i(e){let t;return t=e.disableParentContext?"function"==typeof e.components?e.components(a):e.components||a:o(e.components),r.createElement(s.Provider,{value:t},e.children)}}}]);