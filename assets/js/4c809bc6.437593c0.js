"use strict";(globalThis.webpackChunkdocumentation=globalThis.webpackChunkdocumentation||[]).push([[630],{4648(e,n,s){s.r(n),s.d(n,{assets:()=>a,contentTitle:()=>o,default:()=>u,frontMatter:()=>r,metadata:()=>t,toc:()=>d});const t=JSON.parse('{"id":"scale-engine/aggregation","title":"Multi-Tournament Aggregation","description":"The aggregation layer combines point awards from multiple tournaments into ranking lists. It operates as pure computation \u2014 no tournament state is accessed. The consumer is responsible for collecting PointAward[] from multiple getTournamentPoints calls and passing them to generateRankingList.","source":"@site/docs/scale-engine/aggregation.md","sourceDirName":"scale-engine","slug":"/scale-engine/aggregation","permalink":"/competition-factory/docs/scale-engine/aggregation","draft":false,"unlisted":false,"tags":[],"version":"current","frontMatter":{"title":"Multi-Tournament Aggregation"},"sidebar":"docs","previous":{"title":"Quality Win Points","permalink":"/competition-factory/docs/scale-engine/quality-win-points"},"next":{"title":"Overview","permalink":"/competition-factory/docs/scoring-engine/scoring-engine-overview"}}');var i=s(6070),l=s(8322);const r={title:"Multi-Tournament Aggregation"},o=void 0,a={},d=[{value:"Aggregation Pipeline",id:"aggregation-pipeline",level:2},{value:"Typical Pipeline",id:"typical-pipeline",level:2},{value:"Counting Buckets",id:"counting-buckets",level:2},{value:"Point Components",id:"point-components",level:3},{value:"bestOfCount",id:"bestofcount",level:3},{value:"maxResultsPerLevel",id:"maxresultsperlevel",level:3},{value:"mandatoryRules",id:"mandatoryrules",level:3},{value:"Without Counting Buckets",id:"without-counting-buckets",level:2},{value:"Rolling Period",id:"rolling-period",level:2},{value:"Category Filter",id:"category-filter",level:2},{value:"Minimum Countable Results",id:"minimum-countable-results",level:2},{value:"Tiebreakers",id:"tiebreakers",level:2},{value:"RankingListEntry Output",id:"rankinglistentry-output",level:2},{value:"Per-Participant Breakdown",id:"per-participant-breakdown",level:2},{value:"Ranking Policy Examples",id:"ranking-policy-examples",level:2},{value:"ATP (<code>POLICY_RANKING_POINTS_ATP.ts</code>)",id:"atp-policy_ranking_points_atpts",level:3},{value:"WTA (<code>POLICY_RANKING_POINTS_WTA.ts</code>)",id:"wta-policy_ranking_points_wtats",level:3},{value:"Related Documentation",id:"related-documentation",level:2}];function c(e){const n={a:"a",code:"code",h2:"h2",h3:"h3",li:"li",ol:"ol",p:"p",pre:"pre",strong:"strong",table:"table",tbody:"tbody",td:"td",th:"th",thead:"thead",tr:"tr",ul:"ul",...(0,l.R)(),...e.components};return(0,i.jsxs)(i.Fragment,{children:[(0,i.jsxs)(n.p,{children:["The aggregation layer combines point awards from multiple tournaments into ranking lists. It operates as pure computation \u2014 no tournament state is accessed. The consumer is responsible for collecting ",(0,i.jsx)(n.code,{children:"PointAward[]"})," from multiple ",(0,i.jsx)(n.code,{children:"getTournamentPoints"})," calls and passing them to ",(0,i.jsx)(n.code,{children:"generateRankingList"}),"."]}),"\n",(0,i.jsx)(n.h2,{id:"aggregation-pipeline",children:"Aggregation Pipeline"}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-text",children:"  PointAward[] (from multiple tournaments)\n       |\n  1. Category Filter     ageCategoryCodes, genders, eventTypes\n       |\n  2. Rolling Period       Exclude awards older than rollingPeriodDays\n       |\n  3. Group by Person      Collect all awards per personId\n       |\n  4. Bucket Processing    Per counting bucket:\n       |                    - Filter by eventTypes + pointComponents\n       +-> Sort descending  - Sort by computed value\n       +-> Level cap        - Apply maxResultsPerLevel\n       +-> Mandatory select - Apply mandatoryRules (if any)\n       +-> Best-of-N        - Fill remaining slots via bestOfCount\n       +-> Sum              - Bucket total\n       |\n  5. Total Points         Sum across all buckets\n       |\n  6. Minimum Check        meetsMinimum if countingResults >= minCountableResults\n       |\n  7. Sort + Tiebreak      Sort descending, apply tiebreakCriteria\n       |\n  8. Assign Ranks         1-based, tied ranks for equal positions\n       |\n       v\n  RankingListEntry[]\n"})}),"\n",(0,i.jsx)(n.h2,{id:"typical-pipeline",children:"Typical Pipeline"}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-js",children:"import { generateRankingList } from 'tods-competition-factory';\n\n// Step 1: Collect awards from multiple tournaments\nconst allAwards = [];\n\nfor (const tournamentRecord of seasonTournaments) {\n  scaleEngine.setState(tournamentRecord);\n  const { personPoints } = scaleEngine.getTournamentPoints({\n    policyDefinitions: rankingPolicy,\n    level: tournamentRecord.level,\n  });\n\n  for (const [personId, awards] of Object.entries(personPoints)) {\n    allAwards.push(...awards.map((a) => ({ ...a, personId })));\n  }\n}\n\n// Step 2: Generate ranking list\nconst rankingList = generateRankingList({\n  pointAwards: allAwards,\n  aggregationRules,\n  asOfDate: '2025-12-31',\n});\n"})}),"\n",(0,i.jsx)(n.h2,{id:"counting-buckets",children:"Counting Buckets"}),"\n",(0,i.jsxs)(n.p,{children:["Counting buckets define how awards are grouped and counted. Each bucket filters awards by ",(0,i.jsx)(n.code,{children:"eventTypes"})," and extracts point values from ",(0,i.jsx)(n.code,{children:"pointComponents"}),":"]}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-js",children:"aggregationRules: {\n  countingBuckets: [\n    {\n      bucketName: 'Singles',\n      eventTypes: ['SINGLES'],\n      pointComponents: ['positionPoints', 'perWinPoints', 'bonusPoints'],\n      bestOfCount: 6,                    // best 6 results count\n      maxResultsPerLevel: { 7: 2 },     // max 2 level-7 results\n    },\n    {\n      bucketName: 'Doubles',\n      eventTypes: ['DOUBLES'],\n      pointComponents: ['positionPoints', 'perWinPoints', 'bonusPoints'],\n      bestOfCount: 2,                    // best 2 results count\n    },\n    {\n      bucketName: 'Quality Wins',\n      pointComponents: ['qualityWinPoints'],\n      bestOfCount: 0,                    // 0 = count ALL (no limit)\n    },\n  ],\n}\n"})}),"\n",(0,i.jsx)(n.h3,{id:"point-components",children:"Point Components"}),"\n",(0,i.jsxs)(n.p,{children:["The ",(0,i.jsx)(n.code,{children:"pointComponents"})," array specifies which fields on each award to sum for the bucket value:"]}),"\n",(0,i.jsxs)(n.table,{children:[(0,i.jsx)(n.thead,{children:(0,i.jsxs)(n.tr,{children:[(0,i.jsx)(n.th,{children:"Component"}),(0,i.jsx)(n.th,{children:"Source"})]})}),(0,i.jsxs)(n.tbody,{children:[(0,i.jsxs)(n.tr,{children:[(0,i.jsx)(n.td,{children:(0,i.jsx)(n.code,{children:"'positionPoints'"})}),(0,i.jsx)(n.td,{children:"Finishing position points"})]}),(0,i.jsxs)(n.tr,{children:[(0,i.jsx)(n.td,{children:(0,i.jsx)(n.code,{children:"'perWinPoints'"})}),(0,i.jsx)(n.td,{children:"Per-win points"})]}),(0,i.jsxs)(n.tr,{children:[(0,i.jsx)(n.td,{children:(0,i.jsx)(n.code,{children:"'bonusPoints'"})}),(0,i.jsx)(n.td,{children:"Champion/finalist bonus"})]}),(0,i.jsxs)(n.tr,{children:[(0,i.jsx)(n.td,{children:(0,i.jsx)(n.code,{children:"'qualityWinPoints'"})}),(0,i.jsx)(n.td,{children:"Quality win bonus"})]}),(0,i.jsxs)(n.tr,{children:[(0,i.jsx)(n.td,{children:(0,i.jsx)(n.code,{children:"'linePoints'"})}),(0,i.jsx)(n.td,{children:"Team line position points"})]}),(0,i.jsxs)(n.tr,{children:[(0,i.jsx)(n.td,{children:(0,i.jsx)(n.code,{children:"'points'"})}),(0,i.jsx)(n.td,{children:"Combined total (position + perWin + bonus)"})]})]})]}),"\n",(0,i.jsx)(n.h3,{id:"bestofcount",children:"bestOfCount"}),"\n",(0,i.jsxs)(n.ul,{children:["\n",(0,i.jsxs)(n.li,{children:[(0,i.jsx)(n.code,{children:"0"})," \u2014 Count all results (no limit)"]}),"\n",(0,i.jsxs)(n.li,{children:[(0,i.jsx)(n.code,{children:"N > 0"})," \u2014 Count only the best N results; remaining are dropped"]}),"\n"]}),"\n",(0,i.jsx)(n.h3,{id:"maxresultsperlevel",children:"maxResultsPerLevel"}),"\n",(0,i.jsx)(n.p,{children:"Limits how many results from a specific tournament level count toward the bucket:"}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-js",children:"maxResultsPerLevel: { 7: 2, 6: 3 }\n// At most 2 level-7 results and 3 level-6 results count\n"})}),"\n",(0,i.jsxs)(n.p,{children:["Results exceeding the level cap are moved to ",(0,i.jsx)(n.code,{children:"droppedResults"}),"."]}),"\n",(0,i.jsx)(n.h3,{id:"mandatoryrules",children:"mandatoryRules"}),"\n",(0,i.jsxs)(n.p,{children:["Real-world ranking systems (ATP, WTA) require that results from certain tournament levels always count toward a player's ranking, even if those results are worse than results from lower-tier events. The ",(0,i.jsx)(n.code,{children:"mandatoryRules"})," array on a counting bucket enforces this:"]}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-js",children:"{\n  bucketName: 'Singles',\n  eventTypes: ['SINGLES'],\n  pointComponents: ['positionPoints', 'perWinPoints', 'bonusPoints'],\n  bestOfCount: 19,\n  mandatoryRules: [\n    { ruleName: 'Grand Slams', levels: [1] },           // all GS results count\n    { ruleName: 'WTA 1000 Combined', levels: [3], bestOfCount: 6 }, // best 6 of L3\n  ],\n}\n"})}),"\n",(0,i.jsxs)(n.p,{children:["Each ",(0,i.jsx)(n.code,{children:"MandatoryRule"})," has:"]}),"\n",(0,i.jsxs)(n.table,{children:[(0,i.jsx)(n.thead,{children:(0,i.jsxs)(n.tr,{children:[(0,i.jsx)(n.th,{children:"Field"}),(0,i.jsx)(n.th,{children:"Description"})]})}),(0,i.jsxs)(n.tbody,{children:[(0,i.jsxs)(n.tr,{children:[(0,i.jsx)(n.td,{children:(0,i.jsx)(n.code,{children:"ruleName"})}),(0,i.jsx)(n.td,{children:"Optional label for debugging/display"})]}),(0,i.jsxs)(n.tr,{children:[(0,i.jsx)(n.td,{children:(0,i.jsx)(n.code,{children:"levels"})}),(0,i.jsx)(n.td,{children:"Tournament levels whose results are mandatory"})]}),(0,i.jsxs)(n.tr,{children:[(0,i.jsx)(n.td,{children:(0,i.jsx)(n.code,{children:"bestOfCount"})}),(0,i.jsx)(n.td,{children:"If set, only the best N results from these levels are mandatory; otherwise all count"})]})]})]}),"\n",(0,i.jsx)(n.p,{children:(0,i.jsx)(n.strong,{children:"Algorithm:"})}),"\n",(0,i.jsxs)(n.ol,{children:["\n",(0,i.jsxs)(n.li,{children:["After scoring and sorting, ",(0,i.jsx)(n.code,{children:"maxResultsPerLevel"})," caps are applied first."]}),"\n",(0,i.jsxs)(n.li,{children:["For each mandatory rule, matching results are selected (best N if ",(0,i.jsx)(n.code,{children:"bestOfCount"})," is set, otherwise all)."]}),"\n",(0,i.jsx)(n.li,{children:"Mandatory results fill counting slots first."}),"\n",(0,i.jsxs)(n.li,{children:["Remaining ",(0,i.jsx)(n.code,{children:"bestOfCount"})," slots are filled with the best non-mandatory results."]}),"\n",(0,i.jsxs)(n.li,{children:["If mandatory results exceed ",(0,i.jsx)(n.code,{children:"bestOfCount"}),", all mandatory results still count \u2014 mandatory rules take priority."]}),"\n"]}),"\n",(0,i.jsxs)(n.p,{children:[(0,i.jsx)(n.strong,{children:"Example:"})," A player with bestOfCount=4 and a Grand Slam mandatory rule who has 3 optional results at 500, 400, 300 points and 1 Grand Slam result at 10 points:"]}),"\n",(0,i.jsxs)(n.ul,{children:["\n",(0,i.jsx)(n.li,{children:"Without mandatory: best 4 would be impossible (only 4 total), all count = 1210"}),"\n",(0,i.jsx)(n.li,{children:"With mandatory: GS 10pts counts + best 3 optional (500+400+300) = 1210"}),"\n"]}),"\n",(0,i.jsx)(n.p,{children:"The difference becomes clear when there are more results than slots \u2014 the mandatory result displaces a higher-scoring optional result that would otherwise count."}),"\n",(0,i.jsx)(n.h2,{id:"without-counting-buckets",children:"Without Counting Buckets"}),"\n",(0,i.jsxs)(n.p,{children:["When no ",(0,i.jsx)(n.code,{children:"countingBuckets"})," are defined, all awards are treated as a single group. The value for each award is ",(0,i.jsx)(n.code,{children:"points + qualityWinPoints"}),". Global ",(0,i.jsx)(n.code,{children:"bestOfCount"})," and ",(0,i.jsx)(n.code,{children:"maxResultsPerLevel"})," from ",(0,i.jsx)(n.code,{children:"aggregationRules"})," apply:"]}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-js",children:"aggregationRules: {\n  bestOfCount: 10,              // best 10 results overall\n  maxResultsPerLevel: { 7: 3 }, // max 3 level-7 results\n}\n"})}),"\n",(0,i.jsx)(n.h2,{id:"rolling-period",children:"Rolling Period"}),"\n",(0,i.jsx)(n.p,{children:"Filter awards by date to implement rolling ranking windows:"}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-js",children:"aggregationRules: {\n  rollingPeriodDays: 365, // only awards from the last 365 days\n}\n"})}),"\n",(0,i.jsxs)(n.p,{children:["Awards are filtered by their ",(0,i.jsx)(n.code,{children:"endDate"})," field. Awards without an ",(0,i.jsx)(n.code,{children:"endDate"})," are always included. The cutoff is calculated from ",(0,i.jsx)(n.code,{children:"asOfDate"}),":"]}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-js",children:"generateRankingList({\n  pointAwards: allAwards,\n  aggregationRules: { rollingPeriodDays: 365 },\n  asOfDate: '2025-12-31', // only awards ending after 2024-12-31\n});\n"})}),"\n",(0,i.jsx)(n.h2,{id:"category-filter",children:"Category Filter"}),"\n",(0,i.jsx)(n.p,{children:"Filter awards before aggregation by category, gender, or event type:"}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-js",children:"generateRankingList({\n  pointAwards: allAwards,\n  categoryFilter: {\n    ageCategoryCodes: ['U18'],\n    genders: ['MALE'],\n    eventTypes: ['SINGLES'],\n  },\n});\n"})}),"\n",(0,i.jsx)(n.h2,{id:"minimum-countable-results",children:"Minimum Countable Results"}),"\n",(0,i.jsx)(n.p,{children:"Flag entries that don't have enough results to be considered for official ranking:"}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-js",children:"aggregationRules: {\n  minCountableResults: 3,\n}\n"})}),"\n",(0,i.jsxs)(n.p,{children:["Entries below the threshold have ",(0,i.jsx)(n.code,{children:"meetsMinimum: false"})," but are still included in the output with their points and rank."]}),"\n",(0,i.jsx)(n.h2,{id:"tiebreakers",children:"Tiebreakers"}),"\n",(0,i.jsxs)(n.p,{children:["When two entries have the same ",(0,i.jsx)(n.code,{children:"totalPoints"}),", tiebreak criteria are applied in order:"]}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-js",children:"aggregationRules: {\n  tiebreakCriteria: ['highestSingleResult', 'mostCountingResults', 'mostWins'],\n}\n"})}),"\n",(0,i.jsxs)(n.table,{children:[(0,i.jsx)(n.thead,{children:(0,i.jsxs)(n.tr,{children:[(0,i.jsx)(n.th,{children:"Criterion"}),(0,i.jsx)(n.th,{children:"Resolution"})]})}),(0,i.jsxs)(n.tbody,{children:[(0,i.jsxs)(n.tr,{children:[(0,i.jsx)(n.td,{children:(0,i.jsx)(n.code,{children:"'highestSingleResult'"})}),(0,i.jsxs)(n.td,{children:["Highest individual ",(0,i.jsx)(n.code,{children:"points"})," value among counting results"]})]}),(0,i.jsxs)(n.tr,{children:[(0,i.jsx)(n.td,{children:(0,i.jsx)(n.code,{children:"'mostCountingResults'"})}),(0,i.jsx)(n.td,{children:"More counting results wins"})]}),(0,i.jsxs)(n.tr,{children:[(0,i.jsx)(n.td,{children:(0,i.jsx)(n.code,{children:"'mostWins'"})}),(0,i.jsxs)(n.td,{children:["More total ",(0,i.jsx)(n.code,{children:"winCount"})," across counting results wins"]})]})]})]}),"\n",(0,i.jsx)(n.p,{children:"Tied entries that remain unresolved after all criteria share the same rank."}),"\n",(0,i.jsx)(n.h2,{id:"rankinglistentry-output",children:"RankingListEntry Output"}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-ts",children:"{\n  personId: string;\n  totalPoints: number;\n  rank: number;                    // 1-based, tied for equal positions\n  meetsMinimum: boolean;           // false if below minCountableResults\n  countingResults: PointAward[];   // results that count toward total\n  droppedResults: PointAward[];    // results excluded by bestOfCount or level cap\n  bucketBreakdown?: [{             // present when countingBuckets are used\n    bucketName: string;\n    countingResults: PointAward[];\n    droppedResults: PointAward[];\n    bucketTotal: number;\n  }];\n}\n"})}),"\n",(0,i.jsx)(n.h2,{id:"per-participant-breakdown",children:"Per-Participant Breakdown"}),"\n",(0,i.jsxs)(n.p,{children:["Use ",(0,i.jsx)(n.code,{children:"getParticipantPoints"})," to inspect a single participant's counting/dropped breakdown:"]}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-js",children:"import { getParticipantPoints } from 'tods-competition-factory';\n\nconst { buckets, totalPoints } = getParticipantPoints({\n  pointAwards: allAwards,\n  personId: 'player-abc',\n  aggregationRules,\n});\n"})}),"\n",(0,i.jsx)(n.h2,{id:"ranking-policy-examples",children:"Ranking Policy Examples"}),"\n",(0,i.jsxs)(n.p,{children:["The factory ships with complete ranking policies that demonstrate real-world aggregation configurations. These are located in ",(0,i.jsx)(n.code,{children:"src/fixtures/policies/"}),":"]}),"\n",(0,i.jsxs)(n.h3,{id:"atp-policy_ranking_points_atpts",children:["ATP (",(0,i.jsx)(n.code,{children:"POLICY_RANKING_POINTS_ATP.ts"}),")"]}),"\n",(0,i.jsx)(n.p,{children:"The ATP policy demonstrates:"}),"\n",(0,i.jsxs)(n.ul,{children:["\n",(0,i.jsxs)(n.li,{children:[(0,i.jsx)(n.strong,{children:"Separate singles/doubles buckets"})," \u2014 Singles best-of-19, Doubles best-of-18"]}),"\n",(0,i.jsxs)(n.li,{children:[(0,i.jsx)(n.strong,{children:"Mandatory counting"})," \u2014 Grand Slams (level 1) and ATP 1000 (levels 3, 4) always count in the Singles bucket, even if the results are worse than optional results"]}),"\n",(0,i.jsxs)(n.li,{children:[(0,i.jsx)(n.strong,{children:"Rolling 52-week period"})," \u2014 ",(0,i.jsx)(n.code,{children:"rollingPeriodDays: 364"})]}),"\n",(0,i.jsxs)(n.li,{children:[(0,i.jsx)(n.strong,{children:"No gender/category separation"})," \u2014 ATP is a single-gender tour"]}),"\n"]}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-js",children:"// from POLICY_RANKING_POINTS_ATP.ts\ncountingBuckets: [\n  {\n    bucketName: 'Singles',\n    eventTypes: ['SINGLES'],\n    bestOfCount: 19,\n    pointComponents: ['positionPoints', 'perWinPoints', 'bonusPoints'],\n    mandatoryRules: [\n      { ruleName: 'Grand Slams', levels: [1] },\n      { ruleName: 'ATP 1000', levels: [3, 4] },\n    ],\n  },\n  {\n    bucketName: 'Doubles',\n    eventTypes: ['DOUBLES'],\n    bestOfCount: 18,\n    pointComponents: ['positionPoints', 'perWinPoints', 'bonusPoints'],\n  },\n],\n"})}),"\n",(0,i.jsxs)(n.h3,{id:"wta-policy_ranking_points_wtats",children:["WTA (",(0,i.jsx)(n.code,{children:"POLICY_RANKING_POINTS_WTA.ts"}),")"]}),"\n",(0,i.jsx)(n.p,{children:"The WTA policy demonstrates:"}),"\n",(0,i.jsxs)(n.ul,{children:["\n",(0,i.jsxs)(n.li,{children:[(0,i.jsxs)(n.strong,{children:["Mandatory counting with ",(0,i.jsx)(n.code,{children:"bestOfCount"})," on a rule"]})," \u2014 Grand Slams (level 1) all count; best 6 of the combined WTA 1000 events (level 3) are mandatory via ",(0,i.jsx)(n.code,{children:"bestOfCount: 6"})]}),"\n",(0,i.jsxs)(n.li,{children:[(0,i.jsx)(n.strong,{children:"Minimum countable results"})," \u2014 ",(0,i.jsx)(n.code,{children:"minCountableResults: 3"})]}),"\n",(0,i.jsxs)(n.li,{children:[(0,i.jsx)(n.strong,{children:"Tiebreakers"})," \u2014 ",(0,i.jsx)(n.code,{children:"highestSingleResult"})," then ",(0,i.jsx)(n.code,{children:"mostCountingResults"})]}),"\n"]}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-js",children:"// from POLICY_RANKING_POINTS_WTA.ts\ncountingBuckets: [\n  {\n    bucketName: 'Singles',\n    eventTypes: ['SINGLES'],\n    bestOfCount: 19,\n    pointComponents: ['positionPoints', 'perWinPoints', 'bonusPoints'],\n    mandatoryRules: [\n      { ruleName: 'Grand Slams', levels: [1] },\n      { ruleName: 'WTA 1000 Combined', levels: [3], bestOfCount: 6 },\n    ],\n  },\n  {\n    bucketName: 'Doubles',\n    eventTypes: ['DOUBLES'],\n    bestOfCount: 12,\n    pointComponents: ['positionPoints', 'perWinPoints', 'bonusPoints'],\n  },\n],\n"})}),"\n",(0,i.jsx)(n.p,{children:"Both policies also include full award profiles (finishing position points, qualifying bonuses, per-win points) for every tournament level in their respective tours. See the source files for the complete definitions."}),"\n",(0,i.jsx)(n.h2,{id:"related-documentation",children:"Related Documentation"}),"\n",(0,i.jsxs)(n.ul,{children:["\n",(0,i.jsxs)(n.li,{children:[(0,i.jsx)(n.strong,{children:(0,i.jsx)(n.a,{href:"./scale-engine-overview",children:"Scale Engine Overview"})})," \u2014 Introduction and architecture"]}),"\n",(0,i.jsxs)(n.li,{children:[(0,i.jsx)(n.strong,{children:(0,i.jsx)(n.a,{href:"./scale-engine-api",children:"Core API Reference"})})," \u2014 generateRankingList and getParticipantPoints API"]}),"\n",(0,i.jsxs)(n.li,{children:[(0,i.jsx)(n.strong,{children:(0,i.jsx)(n.a,{href:"./ranking-points-pipeline",children:"Ranking Points Pipeline"})})," \u2014 How per-tournament points are computed"]}),"\n",(0,i.jsxs)(n.li,{children:[(0,i.jsx)(n.strong,{children:(0,i.jsx)(n.a,{href:"./quality-win-points",children:"Quality Win Points"})})," \u2014 Quality win bonus system"]}),"\n",(0,i.jsxs)(n.li,{children:[(0,i.jsx)(n.strong,{children:(0,i.jsx)(n.a,{href:"/docs/policies/rankingPolicy",children:"Ranking Policy"})})," \u2014 Full policy structure including aggregationRules"]}),"\n"]})]})}function u(e={}){const{wrapper:n}={...(0,l.R)(),...e.components};return n?(0,i.jsx)(n,{...e,children:(0,i.jsx)(c,{...e})}):c(e)}},8322(e,n,s){s.d(n,{R:()=>r,x:()=>o});var t=s(758);const i={},l=t.createContext(i);function r(e){const n=t.useContext(l);return t.useMemo(function(){return"function"==typeof e?e(n):{...n,...e}},[n,e])}function o(e){let n;return n=e.disableParentContext?"function"==typeof e.components?e.components(i):e.components||i:r(e.components),t.createElement(l.Provider,{value:n},e.children)}}}]);