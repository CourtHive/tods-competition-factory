"use strict";(globalThis.webpackChunkdocumentation=globalThis.webpackChunkdocumentation||[]).push([[3162],{6204(e,t,n){n.r(t),n.d(t,{assets:()=>d,contentTitle:()=>c,default:()=>h,frontMatter:()=>r,metadata:()=>a,toc:()=>l});const a=JSON.parse('{"id":"governors/matchup-governor","title":"matchUp Governor","description":"allCompetitionMatchUps","source":"@site/docs/governors/matchup-governor.md","sourceDirName":"governors","slug":"/governors/matchup-governor","permalink":"/competition-factory/docs/governors/matchup-governor","draft":false,"unlisted":false,"tags":[],"version":"current","frontMatter":{"title":"matchUp Governor"},"sidebar":"docs","previous":{"title":"Generation Governor","permalink":"/competition-factory/docs/governors/generation-governor"},"next":{"title":"matchUpFormat Governor","permalink":"/competition-factory/docs/governors/matchup-format-governor"}}');var i=n(6070),s=n(8322);const r={title:"matchUp Governor"},c=void 0,d={},l=[{value:"allCompetitionMatchUps",id:"allcompetitionmatchups",level:2},{value:"allDrawMatchUps",id:"alldrawmatchups",level:2},{value:"allEventMatchUps",id:"alleventmatchups",level:2},{value:"allTournamentMatchUps",id:"alltournamentmatchups",level:2},{value:"analyzeMatchUp",id:"analyzematchup",level:2},{value:"applyLineUps",id:"applylineups",level:2},{value:"assignMatchUpSideParticipant",id:"assignmatchupsideparticipant",level:2},{value:"assignTieMatchUpParticipantId",id:"assigntiematchupparticipantid",level:2},{value:"bulkMatchUpStatusUpdate",id:"bulkmatchupstatusupdate",level:2},{value:"checkInParticipant",id:"checkinparticipant",level:2},{value:"checkOutParticipant",id:"checkoutparticipant",level:2},{value:"calculateWinCriteria",id:"calculatewincriteria",level:2},{value:"checkMatchUpIsComplete",id:"checkmatchupiscomplete",level:2},{value:"competitionScheduleMatchUps",id:"competitionschedulematchups",level:2},{value:"Publish-state filtering",id:"publish-state-filtering",level:3},{value:"Embargo enforcement",id:"embargo-enforcement",level:3},{value:"disableTieAutoCalc",id:"disabletieautocalc",level:2},{value:"enableTieAutoCalc",id:"enabletieautocalc",level:2},{value:"drawMatchUps",id:"drawmatchups",level:2},{value:"eventMatchUps",id:"eventmatchups",level:2},{value:"filterMatchUps",id:"filtermatchups",level:2},{value:"findMatchUp",id:"findmatchup",level:2},{value:"getAllDrawMatchUps",id:"getalldrawmatchups",level:2},{value:"getAllStructureMatchUps",id:"getallstructurematchups",level:2},{value:"getCheckedInParticipantIds",id:"getcheckedinparticipantids",level:2},{value:"getCompetitionMatchUps",id:"getcompetitionmatchups",level:2},{value:"getEventMatchUpFormatTiming",id:"geteventmatchupformattiming",level:2},{value:"getMatchUpCompetitiveProfile",id:"getmatchupcompetitiveprofile",level:2},{value:"getMatchUpContextIds",id:"getmatchupcontextids",level:2},{value:"getMatchUpDailyLimits",id:"getmatchupdailylimits",level:2},{value:"getMatchUpDailyLimitsUpdate",id:"getmatchupdailylimitsupdate",level:2},{value:"getMatchUpDependencies",id:"getmatchupdependencies",level:2},{value:"getMatchUpFormat",id:"getmatchupformat",level:2},{value:"getMatchUpFormatTiming",id:"getmatchupformattiming",level:2},{value:"getMatchUpFormatTimingUpdate",id:"getmatchupformattimingupdate",level:2},{value:"getMatchUpScheduleDetails",id:"getmatchupscheduledetails",level:2},{value:"getMatchUpType",id:"getmatchuptype",level:2},{value:"getMatchUpsStats",id:"getmatchupsstats",level:2},{value:"getModifiedMatchUpFormatTiming",id:"getmodifiedmatchupformattiming",level:2},{value:"getParticipantResults",id:"getparticipantresults",level:2},{value:"getPredictiveAccuracy",id:"getpredictiveaccuracy",level:2},{value:"getRoundMatchUps",id:"getroundmatchups",level:2},{value:"getRounds",id:"getrounds",level:2},{value:"getHomeParticipantId",id:"gethomeparticipantid",level:2},{value:"isValidMatchUpFormat",id:"isvalidmatchupformat",level:2},{value:"matchUpActions",id:"matchupactions",level:2},{value:"participantScheduledMatchUps",id:"participantscheduledmatchups",level:2},{value:"publicFindMatchUp",id:"publicfindmatchup",level:2},{value:"removeMatchUpSideParticipant",id:"removematchupsideparticipant",level:2},{value:"replaceTieMatchUpParticipantId",id:"replacetiematchupparticipantid",level:2},{value:"removeTieMatchUpParticipantId",id:"removetiematchupparticipantid",level:2},{value:"removeDelegatedOutcome",id:"removedelegatedoutcome",level:2},{value:"resetMatchUpLineUps",id:"resetmatchuplineups",level:2},{value:"resetAdHocMatchUps",id:"resetadhocmatchups",level:2},{value:"resetScorecard",id:"resetscorecard",level:2},{value:"resetTieFormat",id:"resettieformat",level:2},{value:"setDelegatedOutcome",id:"setdelegatedoutcome",level:2},{value:"setMatchUpFormat",id:"setmatchupformat",level:2},{value:"setMatchUpState",id:"setmatchupstate",level:2},{value:"setMatchUpStatus",id:"setmatchupstatus",level:2},{value:"setOrderOfFinish",id:"setorderoffinish",level:2},{value:"Validation",id:"validation",level:3},{value:"substituteParticipant",id:"substituteparticipant",level:2},{value:"tallyParticipantResults",id:"tallyparticipantresults",level:2},{value:"toggleParticipantCheckInState",id:"toggleparticipantcheckinstate",level:2},{value:"updateTieMatchUpScore",id:"updatetiematchupscore",level:2},{value:"tournamentMatchUps",id:"tournamentmatchups",level:2},{value:"validMatchUp",id:"validmatchup",level:2},{value:"validMatchUps",id:"validmatchups",level:2}];function o(e){const t={a:"a",admonition:"admonition",code:"code",em:"em",h2:"h2",h3:"h3",hr:"hr",li:"li",p:"p",pre:"pre",strong:"strong",ul:"ul",...(0,s.R)(),...e.components};return(0,i.jsxs)(i.Fragment,{children:[(0,i.jsx)(t.pre,{children:(0,i.jsx)(t.code,{className:"language-js",children:"import { matchUpGovernor } from 'tods-competition-factory';\n"})}),"\n",(0,i.jsx)(t.h2,{id:"allcompetitionmatchups",children:"allCompetitionMatchUps"}),"\n",(0,i.jsxs)(t.p,{children:["Returns all matchUps from all tournaments in a competition. See examples in ",(0,i.jsx)(t.a,{href:"/competition-factory/docs/concepts/pro-scheduling#using-proconflicts-for-analysis",children:"Using proConflicts() for Analysis"}),"."]}),"\n",(0,i.jsx)(t.pre,{children:(0,i.jsx)(t.code,{className:"language-js",children:"const { matchUps } = engine.allCompetitionMatchUps({\n  tournamentRecords, // required - array of tournament records\n});\n"})}),"\n",(0,i.jsx)(t.hr,{}),"\n",(0,i.jsx)(t.h2,{id:"alldrawmatchups",children:"allDrawMatchUps"}),"\n",(0,i.jsx)(t.p,{children:"Returns all matchUps from a specific draw."}),"\n",(0,i.jsx)(t.pre,{children:(0,i.jsx)(t.code,{className:"language-js",children:"const { matchUps } = engine.allDrawMatchUps({\n  drawId, // required\n});\n"})}),"\n",(0,i.jsx)(t.hr,{}),"\n",(0,i.jsx)(t.h2,{id:"alleventmatchups",children:"allEventMatchUps"}),"\n",(0,i.jsx)(t.p,{children:"Returns all matchUps from a specific event."}),"\n",(0,i.jsx)(t.pre,{children:(0,i.jsx)(t.code,{className:"language-js",children:"const { matchUps } = engine.allEventMatchUps({\n  eventId, // required\n});\n"})}),"\n",(0,i.jsx)(t.hr,{}),"\n",(0,i.jsx)(t.h2,{id:"alltournamentmatchups",children:"allTournamentMatchUps"}),"\n",(0,i.jsx)(t.p,{children:"Returns all matchUps from a tournament."}),"\n",(0,i.jsx)(t.pre,{children:(0,i.jsx)(t.code,{className:"language-js",children:"const { matchUps } = engine.allTournamentMatchUps();\n"})}),"\n",(0,i.jsx)(t.hr,{}),"\n",(0,i.jsx)(t.h2,{id:"analyzematchup",children:"analyzeMatchUp"}),"\n",(0,i.jsx)(t.p,{children:"Analyzes a matchUp to extract detailed information."}),"\n",(0,i.jsx)(t.pre,{children:(0,i.jsx)(t.code,{className:"language-js",children:"const { analysis } = engine.analyzeMatchUp({\n  matchUp, // required\n});\n"})}),"\n",(0,i.jsx)(t.hr,{}),"\n",(0,i.jsx)(t.h2,{id:"applylineups",children:"applyLineUps"}),"\n",(0,i.jsxs)(t.p,{children:["Applies ",(0,i.jsx)(t.code,{children:"lineUps"})," to the ",(0,i.jsx)(t.code,{children:"sides"})," of a ",(0,i.jsx)(t.em,{children:"TEAM"})," matchUp. Order is not important as team side is determined automatically. Does not check to ensure that participants in ",(0,i.jsx)(t.code,{children:"lineUps"})," are part of teams; this is assumed. It is possible to have ",(0,i.jsx)(t.strong,{children:(0,i.jsx)(t.em,{children:"some"})})," participants assigned to a team side who are not part of a team."]}),"\n",(0,i.jsx)(t.pre,{children:(0,i.jsx)(t.code,{className:"language-js",children:"result = engine.applyLineUps({\n  matchUpId, // must be { matchUpType: TEAM }\n  lineUps, // array of at most two lineUps (see CODES)\n  drawId, // reference to draw in which matchUp occurs\n});\n"})}),"\n",(0,i.jsx)(t.hr,{}),"\n",(0,i.jsx)(t.h2,{id:"assignmatchupsideparticipant",children:"assignMatchUpSideParticipant"}),"\n",(0,i.jsx)(t.p,{children:"Assign participant to AD_HOC matchUp."}),"\n",(0,i.jsx)(t.pre,{children:(0,i.jsx)(t.code,{className:"language-js",children:"engine.assignMatchUpSideParticipant({\n  participantId,\n  sideNumber,\n  matchUpId,\n  drawId,\n});\n"})}),"\n",(0,i.jsx)(t.hr,{}),"\n",(0,i.jsx)(t.h2,{id:"assigntiematchupparticipantid",children:"assignTieMatchUpParticipantId"}),"\n",(0,i.jsxs)(t.p,{children:["Used when interactively assigning participants to ",(0,i.jsx)(t.code,{children:"matchUps"}),". When individual ",(0,i.jsx)(t.code,{children:"participantIds"})," are assigned to ",(0,i.jsx)(t.code,{children:"{ matchUpType: 'DOUBLES' }"})," it handles creating ",(0,i.jsx)(t.code,{children:"{ participantType: PAIR }"})," participants dynamically. See examples: ",(0,i.jsx)(t.a,{href:"/competition-factory/docs/concepts/participants#creating-pairs-automatically",children:"Creating Pairs Automatically"}),"."]}),"\n",(0,i.jsx)(t.pre,{children:(0,i.jsx)(t.code,{className:"language-js",children:'engine.assignTieMatchUpParticipantId({\n  teamParticipantId, // optional - participant team can be derived from participantId. This supports assigning "borrowed" players from other teams.\n  participantId, // id of INDIVIDUAL or PAIR participant to be assigned to a matchUp\n  tieMatchUpId, // matchUpId of a SINGLES or DOUBLES that is part of a matchUp between teams\n  sideNumber, // optional - only necessary if a participant is part of both teams (edge case!)\n  drawId, // identifies draw in which matchUp is present\n});\n'})}),"\n",(0,i.jsx)(t.hr,{}),"\n",(0,i.jsx)(t.h2,{id:"bulkmatchupstatusupdate",children:"bulkMatchUpStatusUpdate"}),"\n",(0,i.jsx)(t.p,{children:"Provides the ability to update the outcomes of multiple matchUps at once."}),"\n",(0,i.jsx)(t.pre,{children:(0,i.jsx)(t.code,{className:"language-js",children:"const outcomes = [\n  {\n    eventId,\n    drawId,\n    matchUpId,\n    matchUpFormat,\n    matchUpStatus,\n    winningSide,\n    score,\n  },\n];\nengine.bulkMatchUpStatusUpdate({ outcomes });\n"})}),"\n",(0,i.jsx)(t.hr,{}),"\n",(0,i.jsx)(t.h2,{id:"checkinparticipant",children:"checkInParticipant"}),"\n",(0,i.jsxs)(t.p,{children:["Set the check-in state for a participant. Used to determine when both participants in a matchUp are available to be assigned to a court. See examples: ",(0,i.jsx)(t.a,{href:"/competition-factory/docs/concepts/participants#sign-in-management",children:"Sign-In Management"}),", ",(0,i.jsx)(t.a,{href:"/competition-factory/docs/concepts/matchup-overview#participant-check-in",children:"Participant Check-In"}),"."]}),"\n",(0,i.jsx)(t.pre,{children:(0,i.jsx)(t.code,{className:"language-js",children:"engine.checkInParticipant({\n  participantId,\n  matchUpId,\n  drawId,\n});\n"})}),"\n",(0,i.jsx)(t.hr,{}),"\n",(0,i.jsx)(t.h2,{id:"checkoutparticipant",children:"checkOutParticipant"}),"\n",(0,i.jsx)(t.pre,{children:(0,i.jsx)(t.code,{className:"language-js",children:"engine.checkOutParticipant({\n  participantId,\n  matchUpId,\n  drawId,\n});. See examples: [Sign-In Management](../concepts/participants.md#sign-in-management).\n"})}),"\n",(0,i.jsx)(t.hr,{}),"\n",(0,i.jsx)(t.h2,{id:"calculatewincriteria",children:"calculateWinCriteria"}),"\n",(0,i.jsx)(t.p,{children:"Calculates the win criteria for a matchUp based on format."}),"\n",(0,i.jsx)(t.pre,{children:(0,i.jsx)(t.code,{className:"language-js",children:"const { criteria } = engine.calculateWinCriteria({\n  matchUpFormat, // required\n});\n"})}),"\n",(0,i.jsx)(t.hr,{}),"\n",(0,i.jsx)(t.h2,{id:"checkmatchupiscomplete",children:"checkMatchUpIsComplete"}),"\n",(0,i.jsx)(t.p,{children:"Checks if a matchUp has a winning side."}),"\n",(0,i.jsx)(t.pre,{children:(0,i.jsx)(t.code,{className:"language-js",children:"const { isComplete } = engine.checkMatchUpIsComplete({\n  matchUp, // required\n});\n"})}),"\n",(0,i.jsx)(t.hr,{}),"\n",(0,i.jsx)(t.h2,{id:"competitionschedulematchups",children:"competitionScheduleMatchUps"}),"\n",(0,i.jsxs)(t.p,{children:["Returns scheduled matchUps across all tournaments in a competition, with support for publish-state filtering and embargo enforcement. See examples: ",(0,i.jsx)(t.a,{href:"/competition-factory/docs/concepts/publishing/publishing-order-of-play#querying-published-schedules",children:"Querying Published Schedules"}),"."]}),"\n",(0,i.jsx)(t.pre,{children:(0,i.jsx)(t.code,{className:"language-js",children:"const {\n  completedMatchUps, // completed matchUps (for the filtered date when not using alwaysReturnCompleted)\n  mappedParticipants, // { [participantId]: participant } - returned when hydrateParticipants is false\n  dateMatchUps, // all incomplete matchUps for the filtered date(s)\n  courtPrefix, // court prefix string (returned when withCourtGridRows is true)\n  courtsData, // array of court objects, each with a matchUps array\n  groupInfo, // group/round-robin information\n  venues, // venue data\n  rows, // court grid rows (returned when withCourtGridRows is true)\n} = engine.competitionScheduleMatchUps({\n  courtCompletedMatchUps, // boolean - include completed matchUps in court.matchUps; useful for pro-scheduling\n  alwaysReturnCompleted, // boolean - return completed matchUps regardless of publish state\n  activeTournamentId, // optional string - target a specific tournament in multi-tournament competitions\n  hydrateParticipants, // boolean - defaults to true; when false, sides contain participantId and context-specific attributes only\n  participantsProfile, // optional - specify additions to context (see getParticipants())\n  policyDefinitions, // optional - e.g. privacy policies\n  withCourtGridRows, // optional boolean - return { rows } of matchUps for courts laid out as a grid, with empty cells\n  minCourtGridRows, // optional integer - minimum number of rows to return\n  sortDateMatchUps, // boolean - optional - defaults to true\n  usePublishState, // boolean - filter by publish state: published eventIds, scheduledDates, and embargo timestamps\n  contextFilters, // optional - filters based on context attributes (e.g. drawIds)\n  matchUpFilters, // optional - { scheduledDate, scheduledDates[], courtIds[], stages[], roundNumbers[], matchUpStatuses[], matchUpFormats[], eventIds[], isMatchUpTie }\n  sortCourtsData, // boolean - optional\n  nextMatchUps, // boolean - include winnerTo and loserTo matchUps\n  status, // optional string - publish status key, defaults to 'PUBLIC'\n});\n"})}),"\n",(0,i.jsx)(t.h3,{id:"publish-state-filtering",children:"Publish-state filtering"}),"\n",(0,i.jsxs)(t.p,{children:["When ",(0,i.jsx)(t.code,{children:"usePublishState: true"}),", the method reads the ",(0,i.jsx)(t.code,{children:"PUBLISH.STATUS"})," timeItem from the tournament and applies the following filters:"]}),"\n",(0,i.jsxs)(t.ul,{children:["\n",(0,i.jsxs)(t.li,{children:[(0,i.jsx)(t.strong,{children:"Published dates"}),": only matchUps whose ",(0,i.jsx)(t.code,{children:"scheduledDate"})," is in ",(0,i.jsx)(t.code,{children:"orderOfPlay.scheduledDates"})," are returned. An empty ",(0,i.jsx)(t.code,{children:"scheduledDates"})," array (or omitted) means all dates are published."]}),"\n",(0,i.jsxs)(t.li,{children:[(0,i.jsx)(t.strong,{children:"Published events"}),": if ",(0,i.jsx)(t.code,{children:"orderOfPlay.eventIds"})," is non-empty, only matchUps from those events are returned."]}),"\n",(0,i.jsxs)(t.li,{children:[(0,i.jsx)(t.strong,{children:"Published draws"}),": only matchUps from published draws are included, determined by event-level publish status."]}),"\n"]}),"\n",(0,i.jsx)(t.h3,{id:"embargo-enforcement",children:"Embargo enforcement"}),"\n",(0,i.jsxs)(t.p,{children:["When ",(0,i.jsx)(t.code,{children:"usePublishState: true"}),", this method also enforces ",(0,i.jsx)(t.a,{href:"../concepts/publishing/publishing-embargo",children:"embargo"})," timestamps at all levels:"]}),"\n",(0,i.jsxs)(t.ul,{children:["\n",(0,i.jsxs)(t.li,{children:[(0,i.jsx)(t.strong,{children:"Order of Play embargo"}),": returns empty ",(0,i.jsx)(t.code,{children:"dateMatchUps"})," if the OOP embargo timestamp has not passed"]}),"\n",(0,i.jsxs)(t.li,{children:[(0,i.jsx)(t.strong,{children:"Draw embargo"}),": filters out matchUps from embargoed draws"]}),"\n",(0,i.jsxs)(t.li,{children:[(0,i.jsx)(t.strong,{children:"Stage embargo"}),": filters out matchUps from embargoed stages"]}),"\n",(0,i.jsxs)(t.li,{children:[(0,i.jsx)(t.strong,{children:"Structure embargo"}),": filters out matchUps from embargoed structures"]}),"\n",(0,i.jsxs)(t.li,{children:[(0,i.jsx)(t.strong,{children:"Round-level filtering"}),": ",(0,i.jsx)(t.code,{children:"roundLimit"})," on a structure caps which rounds appear in the schedule. ",(0,i.jsx)(t.code,{children:"scheduledRounds"})," provides per-round publish/embargo control within the ceiling set by ",(0,i.jsx)(t.code,{children:"roundLimit"}),". See ",(0,i.jsx)(t.a,{href:"../concepts/publishing/publishing-embargo#scheduled-rounds",children:"Scheduled Rounds"}),"."]}),"\n"]}),"\n",(0,i.jsxs)(t.p,{children:[(0,i.jsx)(t.strong,{children:"See"}),": ",(0,i.jsx)(t.a,{href:"../concepts/publishing/publishing-embargo",children:"Embargo"})," for details on how embargo timestamps work."]}),"\n",(0,i.jsx)(t.hr,{}),"\n",(0,i.jsx)(t.h2,{id:"disabletieautocalc",children:"disableTieAutoCalc"}),"\n",(0,i.jsx)(t.p,{children:"Disable default behavior of auto calculating TEAM matchUp scores."}),"\n",(0,i.jsx)(t.pre,{children:(0,i.jsx)(t.code,{className:"language-js",children:"engine.disableTieAutoCalc({ drawId, matchUpId });\n"})}),"\n",(0,i.jsx)(t.hr,{}),"\n",(0,i.jsx)(t.h2,{id:"enabletieautocalc",children:"enableTieAutoCalc"}),"\n",(0,i.jsx)(t.p,{children:"Re-enable default behavior of auto calculating TEAM matchUp scores, and trigger auto calculation."}),"\n",(0,i.jsx)(t.pre,{children:(0,i.jsx)(t.code,{className:"language-js",children:"engine.enableTieAutoCalc({ drawId, matchUpId });\n"})}),"\n",(0,i.jsx)(t.hr,{}),"\n",(0,i.jsx)(t.h2,{id:"drawmatchups",children:"drawMatchUps"}),"\n",(0,i.jsx)(t.p,{children:"Returns matchUps from a specific draw with filtering options."}),"\n",(0,i.jsx)(t.pre,{children:(0,i.jsx)(t.code,{className:"language-js",children:"const { matchUps } = engine.drawMatchUps({\n  drawId, // required\n  matchUpFilters, // optional - filter criteria\n  inContext, // optional - add context attributes\n});\n"})}),"\n",(0,i.jsx)(t.hr,{}),"\n",(0,i.jsx)(t.h2,{id:"eventmatchups",children:"eventMatchUps"}),"\n",(0,i.jsx)(t.p,{children:"Returns matchUps from a specific event with filtering options."}),"\n",(0,i.jsx)(t.pre,{children:(0,i.jsx)(t.code,{className:"language-js",children:"const { matchUps } = engine.eventMatchUps({\n  eventId, // required\n  matchUpFilters, // optional\n  inContext, // optional\n});\n"})}),"\n",(0,i.jsx)(t.hr,{}),"\n",(0,i.jsx)(t.h2,{id:"filtermatchups",children:"filterMatchUps"}),"\n",(0,i.jsx)(t.p,{children:"Filters matchUps based on provided criteria."}),"\n",(0,i.jsx)(t.pre,{children:(0,i.jsx)(t.code,{className:"language-js",children:"const { matchUps } = engine.filterMatchUps({\n  matchUps, // required - matchUps to filter\n  matchUpFilters, // required - filter criteria\n});\n"})}),"\n",(0,i.jsx)(t.hr,{}),"\n",(0,i.jsx)(t.h2,{id:"findmatchup",children:"findMatchUp"}),"\n",(0,i.jsx)(t.pre,{children:(0,i.jsx)(t.code,{className:"language-js",children:"const {\n  matchUp,\n  structure, // returned for convenience\n} = engine.findMatchUp({\n  inContext, // optional - boolean - returns matchUp with additional attributes\n  matchUpId,\n  drawId,\n});\n"})}),"\n",(0,i.jsx)(t.hr,{}),"\n",(0,i.jsx)(t.h2,{id:"getalldrawmatchups",children:"getAllDrawMatchUps"}),"\n",(0,i.jsx)(t.p,{children:"Returns all matchUps from all structures in a draw."}),"\n",(0,i.jsx)(t.pre,{children:(0,i.jsx)(t.code,{className:"language-js",children:"const { matchUps } = engine.getAllDrawMatchUps({\n  drawId, // required\n  inContext, // optional\n});\n"})}),"\n",(0,i.jsx)(t.hr,{}),"\n",(0,i.jsx)(t.h2,{id:"getallstructurematchups",children:"getAllStructureMatchUps"}),"\n",(0,i.jsx)(t.p,{children:"Returns all matchUps from all structures."}),"\n",(0,i.jsx)(t.pre,{children:(0,i.jsx)(t.code,{className:"language-js",children:"const { matchUps } = engine.getAllStructureMatchUps({\n  structures, // required - array of structures\n  inContext, // optional\n});\n"})}),"\n",(0,i.jsx)(t.hr,{}),"\n",(0,i.jsx)(t.h2,{id:"getcheckedinparticipantids",children:"getCheckedInParticipantIds"}),"\n",(0,i.jsx)(t.p,{children:"Returns participant IDs that have checked in for a matchUp."}),"\n",(0,i.jsx)(t.pre,{children:(0,i.jsx)(t.code,{className:"language-js",children:"const { participantIds } = engine.getCheckedInParticipantIds({\n  matchUpId, // required\n  drawId, // required\n});\n"})}),"\n",(0,i.jsx)(t.hr,{}),"\n",(0,i.jsx)(t.h2,{id:"getcompetitionmatchups",children:"getCompetitionMatchUps"}),"\n",(0,i.jsx)(t.p,{children:"Returns matchUps from all tournaments in a competition."}),"\n",(0,i.jsx)(t.pre,{children:(0,i.jsx)(t.code,{className:"language-js",children:"const { matchUps } = engine.getCompetitionMatchUps({\n  tournamentRecords, // required\n  matchUpFilters, // optional\n});\n"})}),"\n",(0,i.jsx)(t.hr,{}),"\n",(0,i.jsx)(t.h2,{id:"geteventmatchupformattiming",children:"getEventMatchUpFormatTiming"}),"\n",(0,i.jsx)(t.p,{children:"Returns format timing configuration for an event."}),"\n",(0,i.jsx)(t.pre,{children:(0,i.jsx)(t.code,{className:"language-js",children:"const { timing } = engine.getEventMatchUpFormatTiming({\n  eventId, // required\n});\n"})}),"\n",(0,i.jsx)(t.hr,{}),"\n",(0,i.jsx)(t.h2,{id:"getmatchupcompetitiveprofile",children:"getMatchUpCompetitiveProfile"}),"\n",(0,i.jsx)(t.p,{children:"Returns competitive profile analysis for a matchUp."}),"\n",(0,i.jsx)(t.pre,{children:(0,i.jsx)(t.code,{className:"language-js",children:"const { profile } = engine.getMatchUpCompetitiveProfile({\n  matchUp, // required\n});\n"})}),"\n",(0,i.jsx)(t.hr,{}),"\n",(0,i.jsx)(t.h2,{id:"getmatchupcontextids",children:"getMatchUpContextIds"}),"\n",(0,i.jsx)(t.p,{children:"Returns context IDs (tournamentId, eventId, drawId) for a matchUp."}),"\n",(0,i.jsx)(t.pre,{children:(0,i.jsx)(t.code,{className:"language-js",children:"const { contextIds } = engine.getMatchUpContextIds({\n  matchUpId, // required\n});\n"})}),"\n",(0,i.jsx)(t.hr,{}),"\n",(0,i.jsx)(t.h2,{id:"getmatchupdailylimits",children:"getMatchUpDailyLimits"}),"\n",(0,i.jsx)(t.p,{children:"Returns daily participation limits for matchUps."}),"\n",(0,i.jsx)(t.pre,{children:(0,i.jsx)(t.code,{className:"language-js",children:"const { limits } = engine.getMatchUpDailyLimits();\n"})}),"\n",(0,i.jsx)(t.hr,{}),"\n",(0,i.jsx)(t.h2,{id:"getmatchupdailylimitsupdate",children:"getMatchUpDailyLimitsUpdate"}),"\n",(0,i.jsx)(t.p,{children:"Calculates updated daily limits after a matchUp."}),"\n",(0,i.jsx)(t.pre,{children:(0,i.jsx)(t.code,{className:"language-js",children:"const { updatedLimits } = engine.getMatchUpDailyLimitsUpdate({\n  participantId, // required\n  matchUpFormat, // required\n});\n"})}),"\n",(0,i.jsx)(t.hr,{}),"\n",(0,i.jsx)(t.h2,{id:"getmatchupdependencies",children:"getMatchUpDependencies"}),"\n",(0,i.jsx)(t.p,{children:"Builds a directed acyclic graph (DAG) of matchUp dependencies across all structures and draws. Returns the complete transitive closure of upstream matchUpIds, direct downstream dependents, optional participant tracking, and cross-structure POSITION link dependencies (e.g., Round Robin \u2192 Playoff)."}),"\n",(0,i.jsxs)(t.p,{children:["Used internally by the ",(0,i.jsx)(t.a,{href:"../concepts/automated-scheduling",children:"automated scheduling"})," pipeline to enforce dependency ordering, recovery time, and participant conflict constraints. Also used by the ",(0,i.jsx)(t.code,{children:"DependencyAdapter"})," pattern in ",(0,i.jsx)(t.code,{children:"courthive-components"})," for interactive ",(0,i.jsx)(t.a,{href:"../concepts/scheduling-profile",children:"scheduling profile"})," validation."]}),"\n",(0,i.jsx)(t.pre,{children:(0,i.jsx)(t.code,{className:"language-js",children:"const {\n  matchUpDependencies, // Record<matchUpId, { matchUpIds, dependentMatchUpIds, participantIds, sources }>\n  sourceMatchUpIds, // Record<matchUpId, string[]> \u2014 direct feeder matchUpIds\n  positionDependencies, // Record<structureId, string[]> \u2014 cross-structure POSITION link deps\n  matchUps, // HydratedMatchUp[] \u2014 the matchUps used for analysis\n} = engine.getMatchUpDependencies({\n  includeParticipantDependencies, // optional boolean (default false)\n  drawDefinition, // optional \u2014 scope to a single draw\n  matchUps, // optional \u2014 pre-fetched inContext matchUps\n  matchUpIds, // optional \u2014 restrict to specific matchUpIds\n  drawIds, // optional \u2014 restrict to specific drawIds\n});\n"})}),"\n",(0,i.jsxs)(t.p,{children:["For full documentation including return value details, cross-structure awareness, scheduling integration, and the DependencyAdapter pattern, see ",(0,i.jsx)(t.a,{href:"./query-governor#getmatchupdependencies",children:"getMatchUpDependencies in the Query Governor"}),"."]}),"\n",(0,i.jsx)(t.hr,{}),"\n",(0,i.jsx)(t.h2,{id:"getmatchupformat",children:"getMatchUpFormat"}),"\n",(0,i.jsx)(t.p,{children:"Returns the matchUp format for a matchUp."}),"\n",(0,i.jsx)(t.pre,{children:(0,i.jsx)(t.code,{className:"language-js",children:"const { matchUpFormat } = engine.getMatchUpFormat({\n  matchUpId, // required\n  drawId, // optional\n  eventId, // optional\n});\n"})}),"\n",(0,i.jsx)(t.hr,{}),"\n",(0,i.jsx)(t.h2,{id:"getmatchupformattiming",children:"getMatchUpFormatTiming"}),"\n",(0,i.jsx)(t.p,{children:"Returns timing parameters for a matchUp format."}),"\n",(0,i.jsx)(t.pre,{children:(0,i.jsx)(t.code,{className:"language-js",children:"const { timing } = engine.getMatchUpFormatTiming({\n  matchUpFormat, // required\n});\n"})}),"\n",(0,i.jsx)(t.hr,{}),"\n",(0,i.jsx)(t.h2,{id:"getmatchupformattimingupdate",children:"getMatchUpFormatTimingUpdate"}),"\n",(0,i.jsx)(t.p,{children:"Returns updated timing after format modifications."}),"\n",(0,i.jsx)(t.pre,{children:(0,i.jsx)(t.code,{className:"language-js",children:"const { timing } = engine.getMatchUpFormatTimingUpdate({\n  matchUpFormat, // required\n  modifications, // required\n});\n"})}),"\n",(0,i.jsx)(t.hr,{}),"\n",(0,i.jsx)(t.h2,{id:"getmatchupscheduledetails",children:"getMatchUpScheduleDetails"}),"\n",(0,i.jsx)(t.p,{children:"Returns detailed schedule information for a matchUp."}),"\n",(0,i.jsx)(t.pre,{children:(0,i.jsx)(t.code,{className:"language-js",children:"const { details } = engine.getMatchUpScheduleDetails({\n  matchUpId, // required\n  drawId, // required\n});\n"})}),"\n",(0,i.jsx)(t.hr,{}),"\n",(0,i.jsx)(t.h2,{id:"getmatchuptype",children:"getMatchUpType"}),"\n",(0,i.jsx)(t.p,{children:"Returns the matchUp type (SINGLES, DOUBLES, TEAM)."}),"\n",(0,i.jsx)(t.pre,{children:(0,i.jsx)(t.code,{className:"language-js",children:"const { matchUpType } = engine.getMatchUpType({\n  matchUp, // required\n});\n"})}),"\n",(0,i.jsx)(t.hr,{}),"\n",(0,i.jsx)(t.h2,{id:"getmatchupsstats",children:"getMatchUpsStats"}),"\n",(0,i.jsx)(t.p,{children:"Returns statistics for a collection of matchUps."}),"\n",(0,i.jsx)(t.pre,{children:(0,i.jsx)(t.code,{className:"language-js",children:"const { stats } = engine.getMatchUpsStats({\n  matchUps, // required\n});\n"})}),"\n",(0,i.jsx)(t.hr,{}),"\n",(0,i.jsx)(t.h2,{id:"getmodifiedmatchupformattiming",children:"getModifiedMatchUpFormatTiming"}),"\n",(0,i.jsx)(t.p,{children:"Returns timing with custom modifications applied."}),"\n",(0,i.jsx)(t.pre,{children:(0,i.jsx)(t.code,{className:"language-js",children:"const { timing } = engine.getModifiedMatchUpFormatTiming({\n  matchUpFormat, // required\n  eventId, // optional\n});\n"})}),"\n",(0,i.jsx)(t.hr,{}),"\n",(0,i.jsx)(t.h2,{id:"getparticipantresults",children:"getParticipantResults"}),"\n",(0,i.jsx)(t.p,{children:"Returns results for participants across matchUps."}),"\n",(0,i.jsx)(t.pre,{children:(0,i.jsx)(t.code,{className:"language-js",children:"const { results } = engine.getParticipantResults({\n  matchUps, // required\n});\n"})}),"\n",(0,i.jsx)(t.hr,{}),"\n",(0,i.jsx)(t.h2,{id:"getpredictiveaccuracy",children:"getPredictiveAccuracy"}),"\n",(0,i.jsx)(t.p,{children:"Returns accuracy metrics for predictive algorithms."}),"\n",(0,i.jsx)(t.pre,{children:(0,i.jsx)(t.code,{className:"language-js",children:"const { accuracy } = engine.getPredictiveAccuracy({\n  matchUps, // required\n});\n"})}),"\n",(0,i.jsx)(t.hr,{}),"\n",(0,i.jsx)(t.h2,{id:"getroundmatchups",children:"getRoundMatchUps"}),"\n",(0,i.jsx)(t.p,{children:"Returns matchUps for a specific round."}),"\n",(0,i.jsx)(t.pre,{children:(0,i.jsx)(t.code,{className:"language-js",children:"const { matchUps } = engine.getRoundMatchUps({\n  drawId, // required\n  structureId, // required\n  roundNumber, // required\n});\n"})}),"\n",(0,i.jsx)(t.hr,{}),"\n",(0,i.jsx)(t.h2,{id:"getrounds",children:"getRounds"}),"\n",(0,i.jsx)(t.p,{children:"Returns round information for a structure."}),"\n",(0,i.jsx)(t.pre,{children:(0,i.jsx)(t.code,{className:"language-js",children:"const { rounds } = engine.getRounds({\n  drawId, // required\n  structureId, // required\n});\n"})}),"\n",(0,i.jsx)(t.hr,{}),"\n",(0,i.jsx)(t.h2,{id:"gethomeparticipantid",children:"getHomeParticipantId"}),"\n",(0,i.jsx)(t.pre,{children:(0,i.jsx)(t.code,{className:"language-js",children:"const { homeParticipantId } = engine.getHomeParticipantId({ matchUp });\n"})}),"\n",(0,i.jsx)(t.hr,{}),"\n",(0,i.jsx)(t.h2,{id:"isvalidmatchupformat",children:"isValidMatchUpFormat"}),"\n",(0,i.jsx)(t.p,{children:"Validates a matchUp format string or object."}),"\n",(0,i.jsx)(t.pre,{children:(0,i.jsx)(t.code,{className:"language-js",children:"const { valid } = engine.isValidMatchUpFormat({\n  matchUpFormat, // required\n});\n"})}),"\n",(0,i.jsx)(t.hr,{}),"\n",(0,i.jsx)(t.h2,{id:"matchupactions",children:"matchUpActions"}),"\n",(0,i.jsx)(t.p,{children:"Returns available actions for a matchUp."}),"\n",(0,i.jsx)(t.pre,{children:(0,i.jsx)(t.code,{className:"language-js",children:"const { validActions } = engine.matchUpActions({\n  matchUpId, // required\n  drawId, // required\n  policyDefinitions, // optional\n});\n"})}),"\n",(0,i.jsx)(t.hr,{}),"\n",(0,i.jsx)(t.h2,{id:"participantscheduledmatchups",children:"participantScheduledMatchUps"}),"\n",(0,i.jsx)(t.p,{children:"Returns scheduled matchUps for a specific participant."}),"\n",(0,i.jsx)(t.pre,{children:(0,i.jsx)(t.code,{className:"language-js",children:"const { matchUps } = engine.participantScheduledMatchUps({\n  participantId, // required\n  scheduleDate, // optional - filter by date\n});\n"})}),"\n",(0,i.jsx)(t.hr,{}),"\n",(0,i.jsx)(t.h2,{id:"publicfindmatchup",children:"publicFindMatchUp"}),"\n",(0,i.jsx)(t.p,{children:"Finds a matchUp with privacy policies applied."}),"\n",(0,i.jsx)(t.pre,{children:(0,i.jsx)(t.code,{className:"language-js",children:"const { matchUp } = engine.publicFindMatchUp({\n  matchUpId, // required\n  policyDefinitions, // optional\n});\n"})}),"\n",(0,i.jsx)(t.hr,{}),"\n",(0,i.jsx)(t.h2,{id:"removematchupsideparticipant",children:"removeMatchUpSideParticipant"}),"\n",(0,i.jsx)(t.p,{children:"Removes participant assigned to AD_HOC matchUp."}),"\n",(0,i.jsx)(t.pre,{children:(0,i.jsx)(t.code,{className:"language-js",children:"engine.removeMatchUpSideParticipant({\n  sideNumber, // number - required\n  matchUpId, // required\n  drawId, // required\n});\n"})}),"\n",(0,i.jsx)(t.hr,{}),"\n",(0,i.jsx)(t.h2,{id:"replacetiematchupparticipantid",children:"replaceTieMatchUpParticipantId"}),"\n",(0,i.jsx)(t.pre,{children:(0,i.jsx)(t.code,{className:"language-js",children:"engine.replaceTieMatchUpParticipantId({\n  existingParticipantId,\n  newParticipantId,\n  tieMatchUpId,\n  drawId,\n});\n"})}),"\n",(0,i.jsx)(t.hr,{}),"\n",(0,i.jsx)(t.h2,{id:"removetiematchupparticipantid",children:"removeTieMatchUpParticipantId"}),"\n",(0,i.jsx)(t.pre,{children:(0,i.jsx)(t.code,{className:"language-js",children:"engine.removeTieMatchUpParticipantId({\n  participantId, // id of INDIVIDUAL or PAIR be removed\n  tieMatchUpId, // tieMatchUp, matchUpType either DOUBLES or SINGLES\n  drawId, // draw within which tieMatchUp is found\n});\n"})}),"\n",(0,i.jsx)(t.hr,{}),"\n",(0,i.jsx)(t.h2,{id:"removedelegatedoutcome",children:"removeDelegatedOutcome"}),"\n",(0,i.jsx)(t.p,{children:"Removes a delegated outcome from a matchUp."}),"\n",(0,i.jsx)(t.pre,{children:(0,i.jsx)(t.code,{className:"language-js",children:"engine.removeDelegatedOutcome({\n  matchUpId, // required\n  drawId, // required\n});\n"})}),"\n",(0,i.jsx)(t.hr,{}),"\n",(0,i.jsx)(t.h2,{id:"resetmatchuplineups",children:"resetMatchUpLineUps"}),"\n",(0,i.jsx)(t.p,{children:"Clears lineups from a TEAM matchUp."}),"\n",(0,i.jsx)(t.pre,{children:(0,i.jsx)(t.code,{className:"language-js",children:"engine.resetMatchUpLineUps({\n  matchUpId, // required\n  drawId, // required\n});\n"})}),"\n",(0,i.jsx)(t.hr,{}),"\n",(0,i.jsx)(t.h2,{id:"resetadhocmatchups",children:"resetAdHocMatchUps"}),"\n",(0,i.jsx)(t.p,{children:"Will remove all results (scores) and optionally all participant assignments from specified matchUps (via matchUpIds or roundNumbers)."}),"\n",(0,i.jsx)(t.pre,{children:(0,i.jsx)(t.code,{className:"language-js",children:"const result = engine.resetAdHocMatchUps({\n  removeAssignments, // optional; remove all assigned participants\n  roundNumbers, // optional if matchUpids provided\n  matchUpIds, // optional only if roundNumber(s) provided\n  structureId, // optional unless matchUpIds not provided\n  drawId,\n};\n\nexport function resetAdHocMatchUps(params: ResetAdHocMatchUps) {\n  const paramsCheck = checkRequiredParameters(params, [\n    { [DRAW_DEFINITION]: true, [EVENT]: true },\n    {\n      [ONE_OF]: { [MATCHUP_IDS]: false, roundNumbers: false },\n      [INVALID]: INVALID_VALUES,\n      [OF_TYPE]: ARRAY,\n    },\n  ]);\n  if (paramsCheck.error) return paramsCheck;\n\n  const structureResult = getAdHocStructureDetails(params);\n  if (structureResult.error) return structureResult;\n  const { matchUpIds } = structureResult;\n})\n"})}),"\n",(0,i.jsx)(t.hr,{}),"\n",(0,i.jsx)(t.h2,{id:"resetscorecard",children:"resetScorecard"}),"\n",(0,i.jsxs)(t.p,{children:["Removes all scores from ",(0,i.jsx)(t.code,{children:"tieMatchUps"})," within a TEAM ",(0,i.jsx)(t.code,{children:"matchUp"}),"; preserves ",(0,i.jsx)(t.code,{children:"lineUps"}),"."]}),"\n",(0,i.jsx)(t.pre,{children:(0,i.jsx)(t.code,{className:"language-js",children:"engine.resetScorecard({\n  tiebreakReset, // optional boolean - check for tiebreak scenarios and reset tieFormat\n  tournamentId, // required\n  matchUpId, // required - must be a TEAM matchUp\n  drawId, // required\n});\n"})}),"\n",(0,i.jsx)(t.hr,{}),"\n",(0,i.jsx)(t.h2,{id:"resettieformat",children:"resetTieFormat"}),"\n",(0,i.jsxs)(t.p,{children:["Remove the ",(0,i.jsx)(t.code,{children:"tieFormat"})," from a TEAM ",(0,i.jsx)(t.code,{children:"matchUp"})," if there is a ",(0,i.jsx)(t.code,{children:"tieFormat"})," further up the hierarchy; modifies ",(0,i.jsx)(t.code,{children:"matchUp.tieMatchUps"})," to correspond."]}),"\n",(0,i.jsx)(t.pre,{children:(0,i.jsx)(t.code,{className:"language-js",children:"engine.resetTieFormat({\n  tournamentId, // required\n  matchUpId, // must be a TEAM matchUp\n  drawId, // required\n  uuids, // optional - in client/server scenarios generated matchUps must have equivalent matchUpIds\n});\n"})}),"\n",(0,i.jsx)(t.hr,{}),"\n",(0,i.jsx)(t.h2,{id:"setdelegatedoutcome",children:"setDelegatedOutcome"}),"\n",(0,i.jsx)(t.p,{children:"Sets a delegated outcome for a matchUp (e.g., referee decision)."}),"\n",(0,i.jsx)(t.pre,{children:(0,i.jsx)(t.code,{className:"language-js",children:"engine.setDelegatedOutcome({\n  matchUpId, // required\n  drawId, // required\n  outcome, // required - outcome object\n});\n"})}),"\n",(0,i.jsx)(t.hr,{}),"\n",(0,i.jsx)(t.h2,{id:"setmatchupformat",children:"setMatchUpFormat"}),"\n",(0,i.jsxs)(t.p,{children:["Sets the ",(0,i.jsx)(t.code,{children:"matchUpFormat"})," for a specific ",(0,i.jsx)(t.code,{children:"matchUp"})," or for any scope within the hierarchy of a ",(0,i.jsx)(t.code,{children:"tournamentRecord"}),"."]}),"\n",(0,i.jsxs)(t.admonition,{type:"info",children:[(0,i.jsxs)(t.p,{children:["If an array of ",(0,i.jsx)(t.code,{children:"scheduledDates"})," is provided then ",(0,i.jsx)(t.code,{children:"matchUps"})," which have ",(0,i.jsx)(t.code,{children:"matchUpStatus: TO_BE_PLAYED"})," and are scheduled to be played on the specified dates will have their ",(0,i.jsx)(t.code,{children:"matchUpFormat"})," fixed rather than inherited. This means that subsequent changes to the parent ",(0,i.jsx)(t.code,{children:"structure.matchUpFormat"})," will have no effect on such ",(0,i.jsx)(t.code,{children:"matchUps"}),"."]}),(0,i.jsxs)(t.p,{children:["The ",(0,i.jsx)(t.code,{children:"force"})," attribute will remove the ",(0,i.jsx)(t.code,{children:"matchUpFormat"})," from all targeted ",(0,i.jsx)(t.code,{children:"matchUps"})," which have ",(0,i.jsx)(t.code,{children:"matchUpStatus: TO_BE_PLAYED"}),"; this allows the effect of using ",(0,i.jsx)(t.code,{children:"scheduledDates"})," to be reversed. Use of this attribute will have no effect if ",(0,i.jsx)(t.code,{children:"scheduledDates"})," is also provided."]})]}),"\n",(0,i.jsx)(t.pre,{children:(0,i.jsx)(t.code,{className:"language-js",children:"engine.setMatchUpFormat({\n  matchUpFormat, // CODES matchUpFormatCode\n  eventType, // optional - restrict to SINGLES or DOUBLES\n\n  matchUpId, // optional - set matchUpFormat for a specific matchUp\n  drawId, // required only if matchUpId, structureId or structureIds is present\n  force, // optional boolean - when setting for structure, draws or events, strip any defined matchUpFormat from all TO_BE_PLAYED matchUps\n\n  // scoping options\n  scheduledDates, // optional - ['2022-01-01']\n  stageSequences, // optional - [1, 2]\n  structureIds, // optional - ['structureId1', 'structureId2']\n  structureId, // optional\n  eventIds, // optional - ['eventId1', 'eventId2']\n  eventId, // optional\n  drawIds, // optional - ['drawId1', 'drawId2']\n  stages, // optional - ['MAIN', 'CONSOLATION']\n});\n"})}),"\n",(0,i.jsx)(t.hr,{}),"\n",(0,i.jsx)(t.h2,{id:"setmatchupstate",children:"setMatchUpState"}),"\n",(0,i.jsx)(t.p,{children:"Sets the state of a matchUp (status, score, winningSide)."}),"\n",(0,i.jsx)(t.pre,{children:(0,i.jsx)(t.code,{className:"language-js",children:"engine.setMatchUpState({\n  matchUpId, // required\n  drawId, // required\n  matchUpStatus, // optional\n  score, // optional\n  winningSide, // optional\n});\n"})}),"\n",(0,i.jsx)(t.hr,{}),"\n",(0,i.jsx)(t.h2,{id:"setmatchupstatus",children:"setMatchUpStatus"}),"\n",(0,i.jsxs)(t.p,{children:["Sets either matchUpStatus or score and winningSide; values to be set are passed in outcome object. Handles any winner/loser participant movements within or across structures. See examples: ",(0,i.jsx)(t.a,{href:"/competition-factory/docs/concepts/matchup-overview#setting-scores",children:"Setting Scores"}),", ",(0,i.jsx)(t.a,{href:"/competition-factory/docs/engines/engine-middleware#matchup-operations",children:"MatchUp Operations"}),", ",(0,i.jsx)(t.a,{href:"/competition-factory/docs/engines/mutation-engines#real-world-example-live-scoring-updates",children:"Real-World Example: Live Scoring Updates"}),"."]}),"\n",(0,i.jsx)(t.pre,{children:(0,i.jsx)(t.code,{className:"language-js",children:"const outcome = {\n  matchUpStatus, // optional\n  winningSide, // optional\n  score, // optional\n};\n\nengine.setMatchUpStatus({\n  disableScoreValidation, // optional boolean\n  allowChangePropagation, // optional boolean - allow winner/loser to be swapped and propgate change throughout draw structures\n  disableAutoCalc, // optional - applies only to { matchUpType: TEAM }\n  enableAutoCalc, // optional - applies only to { matchUpType: TEAM }\n  tournamentId,\n  matchUpTieId, // optional - if part of a TIE matchUp\n  matchUpId,\n  outcome, // optional\n  drawId,\n  schedule: {\n    // optional - set schedule items\n    courtIds, // optional - applies only to TEAM matchUps => creates .allocatedCourts\n    courtId, // requires scheduledDate\n    venueId,\n    scheduledDate,\n    scheduledTime,\n    startTime,\n    endTime,\n  },\n  notes, // optional - add note (string) to matchUp object\n});\n"})}),"\n",(0,i.jsx)(t.hr,{}),"\n",(0,i.jsx)(t.h2,{id:"setorderoffinish",children:"setOrderOfFinish"}),"\n",(0,i.jsxs)(t.p,{children:["Sets the ",(0,i.jsx)(t.code,{children:"orderOfFinish"})," attribute for ",(0,i.jsx)(t.code,{children:"matchUps"})," specified by ",(0,i.jsx)(t.code,{children:"matchUpId"})," in the ",(0,i.jsx)(t.code,{children:"finishingOrder"})," array."]}),"\n",(0,i.jsx)(t.h3,{id:"validation",children:"Validation"}),"\n",(0,i.jsxs)(t.p,{children:["Validation is done within a ",(0,i.jsx)(t.em,{children:"cohort"})," of ",(0,i.jsx)(t.code,{children:"matchUps"})," which have equivalent ",(0,i.jsx)(t.code,{children:"structureId"}),", ",(0,i.jsx)(t.code,{children:"matchUpType"}),", ",(0,i.jsx)(t.code,{children:"roundNumber"}),", and ",(0,i.jsx)(t.code,{children:"matchUpTieId"})," (if applicable)."]}),"\n",(0,i.jsxs)(t.ul,{children:["\n",(0,i.jsxs)(t.li,{children:[(0,i.jsx)(t.code,{children:"matchUpIds"})," in ",(0,i.jsx)(t.code,{children:"finishingOrder"})," must be part of the same ",(0,i.jsx)(t.em,{children:"cohort"})]}),"\n",(0,i.jsxs)(t.li,{children:[(0,i.jsx)(t.code,{children:"orderOfFinish"})," values must be unique positive integers within the ",(0,i.jsx)(t.em,{children:"cohort"})]}),"\n"]}),"\n",(0,i.jsx)(t.pre,{children:(0,i.jsx)(t.code,{className:"language-js",children:"engine.setOrderOfFinish({\n  finishingOrder: [{ matchUpId, orderOfFinish: 1 }],\n  drawId,\n});\n"})}),"\n",(0,i.jsx)(t.hr,{}),"\n",(0,i.jsx)(t.h2,{id:"substituteparticipant",children:"substituteParticipant"}),"\n",(0,i.jsx)(t.p,{children:"Substitutes one participant for another in a matchUp."}),"\n",(0,i.jsx)(t.pre,{children:(0,i.jsx)(t.code,{className:"language-js",children:"engine.substituteParticipant({\n  matchUpId, // required\n  drawId, // required\n  participantIdToRemove, // required\n  participantIdToAdd, // required\n});\n"})}),"\n",(0,i.jsx)(t.hr,{}),"\n",(0,i.jsx)(t.h2,{id:"tallyparticipantresults",children:"tallyParticipantResults"}),"\n",(0,i.jsx)(t.p,{children:"Calculates participant results/standings from matchUps."}),"\n",(0,i.jsx)(t.pre,{children:(0,i.jsx)(t.code,{className:"language-js",children:"const { results } = engine.tallyParticipantResults({\n  matchUps, // required\n});\n"})}),"\n",(0,i.jsx)(t.hr,{}),"\n",(0,i.jsx)(t.h2,{id:"toggleparticipantcheckinstate",children:"toggleParticipantCheckInState"}),"\n",(0,i.jsx)(t.pre,{children:(0,i.jsx)(t.code,{className:"language-js",children:"engine.toggleParticipantCheckInState({\n  participantId,\n  tournamentId,\n  matchUpId,\n  drawId,\n});. See examples: [Sign-In Management](../concepts/participants.md#sign-in-management).\n"})}),"\n",(0,i.jsx)(t.hr,{}),"\n",(0,i.jsx)(t.h2,{id:"updatetiematchupscore",children:"updateTieMatchUpScore"}),"\n",(0,i.jsx)(t.p,{children:"Trigger automatic calculation of the score of a TEAM matchUp."}),"\n",(0,i.jsx)(t.pre,{children:(0,i.jsx)(t.code,{className:"language-js",children:"engine.updateTieMatchUpScore({\n  tournamentId, // optional if default tournament set\n  matchUpId,\n  drawId,\n});\n"})}),"\n",(0,i.jsx)(t.hr,{}),"\n",(0,i.jsx)(t.h2,{id:"tournamentmatchups",children:"tournamentMatchUps"}),"\n",(0,i.jsx)(t.p,{children:"Returns all matchUps from the current tournament."}),"\n",(0,i.jsx)(t.pre,{children:(0,i.jsx)(t.code,{className:"language-js",children:"const { matchUps } = engine.tournamentMatchUps({\n  matchUpFilters, // optional\n  inContext, // optional\n});\n"})}),"\n",(0,i.jsx)(t.hr,{}),"\n",(0,i.jsx)(t.h2,{id:"validmatchup",children:"validMatchUp"}),"\n",(0,i.jsx)(t.p,{children:"Validates a single matchUp object."}),"\n",(0,i.jsx)(t.pre,{children:(0,i.jsx)(t.code,{className:"language-js",children:"const { valid, errors } = engine.validMatchUp({\n  matchUp, // required\n});\n"})}),"\n",(0,i.jsx)(t.hr,{}),"\n",(0,i.jsx)(t.h2,{id:"validmatchups",children:"validMatchUps"}),"\n",(0,i.jsx)(t.p,{children:"Validates an array of matchUp objects."}),"\n",(0,i.jsx)(t.pre,{children:(0,i.jsx)(t.code,{className:"language-js",children:"const { valid, errors } = engine.validMatchUps({\n  matchUps, // required\n});\n"})}),"\n",(0,i.jsx)(t.hr,{})]})}function h(e={}){const{wrapper:t}={...(0,s.R)(),...e.components};return t?(0,i.jsx)(t,{...e,children:(0,i.jsx)(o,{...e})}):o(e)}},8322(e,t,n){n.d(t,{R:()=>r,x:()=>c});var a=n(758);const i={},s=a.createContext(i);function r(e){const t=a.useContext(s);return a.useMemo(function(){return"function"==typeof e?e(t):{...t,...e}},[t,e])}function c(e){let t;return t=e.disableParentContext?"function"==typeof e.components?e.components(i):e.components||i:r(e.components),a.createElement(s.Provider,{value:t},e.children)}}}]);