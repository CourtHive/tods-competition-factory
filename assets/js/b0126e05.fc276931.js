"use strict";(self.webpackChunkdocumentation=self.webpackChunkdocumentation||[]).push([[2228],{5140:(e,n,t)=>{t.r(n),t.d(n,{assets:()=>d,contentTitle:()=>r,default:()=>h,frontMatter:()=>s,metadata:()=>o,toc:()=>c});var i=t(1527),a=t(7942);const s={title:"drawEngine API"},r=void 0,o={id:"apis/draw-engine-api",title:"drawEngine API",description:"All _drawEngine_ methods which make a mutation return either { success: true } or { error }",source:"@site/docs/apis/draw-engine-api.md",sourceDirName:"apis",slug:"/apis/draw-engine-api",permalink:"/tods-competition-factory/docs/apis/draw-engine-api",draft:!1,unlisted:!1,tags:[],version:"current",frontMatter:{title:"drawEngine API"},sidebar:"docs",previous:{title:"Draw Engine",permalink:"/tods-competition-factory/docs/engines/draw-engine-overview"},next:{title:"MatchUp Engine",permalink:"/tods-competition-factory/docs/engines/matchup-engine-overview"}},d={},c=[{value:"addDrawEntries",id:"adddrawentries",level:2},{value:"addDrawEntry",id:"adddrawentry",level:2},{value:"addFinishingRounds",id:"addfinishingrounds",level:2},{value:"addMatchUpEndTime",id:"addmatchupendtime",level:2},{value:"addMatchUpOfficial",id:"addmatchupofficial",level:2},{value:"addMatchUpResumeTime",id:"addmatchupresumetime",level:2},{value:"addMatchUpScheduledDate",id:"addmatchupscheduleddate",level:2},{value:"addMatchUpScheduledTime",id:"addmatchupscheduledtime",level:2},{value:"addMatchUpScheduleItems",id:"addmatchupscheduleitems",level:2},{value:"addMatchUpStartTime",id:"addmatchupstarttime",level:2},{value:"addMatchUpStopTime",id:"addmatchupstoptime",level:2},{value:"addPlayoffStructures",id:"addplayoffstructures",level:2},{value:"addMatchUpTimeItem",id:"addmatchuptimeitem",level:2},{value:"addVoluntaryConsolationStage",id:"addvoluntaryconsolationstage",level:2},{value:"addVoluntaryConsolationStructure",id:"addvoluntaryconsolationstructure",level:3},{value:"allDrawMatchUps",id:"alldrawmatchups",level:2},{value:"allPlayoffPositionsFilled",id:"allplayoffpositionsfilled",level:2},{value:"allStructureMatchUps",id:"allstructurematchups",level:2},{value:"assignDrawPosition",id:"assigndrawposition",level:2},{value:"assignDrawPositionBye",id:"assigndrawpositionbye",level:2},{value:"assignSeed",id:"assignseed",level:2},{value:"attachPlayoffStructures",id:"attachplayoffstructures",level:2},{value:"attachPolicies",id:"attachpolicies",level:2},{value:"automatedPositioning",id:"automatedpositioning",level:2},{value:"checkInParticipant",id:"checkinparticipant",level:2},{value:"checkOutParticipant",id:"checkoutparticipant",level:2},{value:"clearDrawPosition",id:"cleardrawposition",level:2},{value:"deleteAdHocMatchUps",id:"deleteadhocmatchups",level:2},{value:"devContext",id:"devcontext",level:2},{value:"drawMatchUps",id:"drawmatchups",level:2},{value:"drawMatic",id:"drawmatic",level:2},{value:"disableTiaAutoCalc",id:"disabletiaautocalc",level:2},{value:"enableTiaAutoCalc",id:"enabletiaautocalc",level:2},{value:"findMatchUp",id:"findmatchup",level:2},{value:"generateAdHocMatchUps",id:"generateadhocmatchups",level:2},{value:"generateAndPopulatePlayoffStructures",id:"generateandpopulateplayoffstructures",level:2},{value:"generateDrawTypeAndModifyDrawDefinition",id:"generatedrawtypeandmodifydrawdefinition",level:2},{value:"generateQualifyingLink",id:"generatequalifyinglink",level:2},{value:"getAvailablePlayoffProfiles",id:"getavailableplayoffprofiles",level:2},{value:"getCheckedInParticipantIds",id:"getcheckedinparticipantids",level:2},{value:"getDrawStructures",id:"getdrawstructures",level:2},{value:"getEliminationDrawSize",id:"geteliminationdrawsize",level:2},{value:"getMatchUpContextIds",id:"getmatchupcontextids",level:2},{value:"getMatchUpParticipantIds",id:"getmatchupparticipantids",level:2},{value:"getMatchUpScheduleDetails",id:"getmatchupscheduledetails",level:2},{value:"getNextSeedBlock",id:"getnextseedblock",level:2},{value:"getNextUnfilledDrawPositions",id:"getnextunfilleddrawpositions",level:2},{value:"getParticipantIdFinishingPositions",id:"getparticipantidfinishingpositions",level:2},{value:"getPositionsPlayedOff",id:"getpositionsplayedoff",level:2},{value:"getRoundMatchUps",id:"getroundmatchups",level:2},{value:"getSeedingThresholds",id:"getseedingthresholds",level:2},{value:"getSourceRounds",id:"getsourcerounds",level:2},{value:"getStructureSeedAssignments",id:"getstructureseedassignments",level:2},{value:"getState",id:"getstate",level:2},{value:"getValidGroupSizes",id:"getvalidgroupsizes",level:2},{value:"initializeStructureSeedAssignments",id:"initializestructureseedassignments",level:2},{value:"isCompletedStructure",id:"iscompletedstructure",level:2},{value:"matchUpActions",id:"matchupactions",level:2},{value:"matchUpDuration",id:"matchupduration",level:2},{value:"newDrawDefinition",id:"newdrawdefinition",level:2},{value:"positionActions",id:"positionactions",level:2},{value:"removeEntry",id:"removeentry",level:2},{value:"removeStructure",id:"removestructure",level:2},{value:"renameStructures",id:"renamestructures",level:2},{value:"reset",id:"reset",level:2},{value:"resetMatchUpTimeItems",id:"resetmatchuptimeitems",level:2},{value:"resolveDrawPositions",id:"resolvedrawpositions",level:2},{value:"setDrawDescription",id:"setdrawdescription",level:2},{value:"setMatchUpFormat",id:"setmatchupformat",level:2},{value:"setMatchUpStatus",id:"setmatchupstatus",level:2},{value:"setOrderOfFinish",id:"setorderoffinish",level:2},{value:"Validation",id:"validation",level:3},{value:"setParticipants",id:"setparticipants",level:2},{value:"setStageAlternatesCount",id:"setstagealternatescount",level:2},{value:"setStageDrawSize",id:"setstagedrawsize",level:2},{value:"setStageQualifiersCount",id:"setstagequalifierscount",level:2},{value:"setStageWildcardsCount",id:"setstagewildcardscount",level:2},{value:"setState",id:"setstate",level:2},{value:"setSubOrder",id:"setsuborder",level:2},{value:"swapDrawPositionAssignments",id:"swapdrawpositionassignments",level:2},{value:"getStructureMatchUps",id:"getstructurematchups",level:2},{value:"validDrawPositions",id:"validdrawpositions",level:2},{value:"version",id:"version",level:2}];function l(e){const n={a:"a",admonition:"admonition",code:"code",em:"em",h2:"h2",h3:"h3",hr:"hr",li:"li",p:"p",pre:"pre",strong:"strong",ul:"ul",...(0,a.ah)(),...e.components};return(0,i.jsxs)(i.Fragment,{children:[(0,i.jsxs)(n.p,{children:["All ",(0,i.jsx)(n.strong,{children:(0,i.jsx)(n.em,{children:"drawEngine"})})," methods which make a mutation return either ",(0,i.jsx)(n.code,{children:"{ success: true }"})," or ",(0,i.jsx)(n.code,{children:"{ error }"})]}),"\n",(0,i.jsx)(n.hr,{}),"\n",(0,i.jsx)(n.h2,{id:"adddrawentries",children:"addDrawEntries"}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-js",children:"drawEngine.addDrawEntries({\n  participantIds, // an array of participantIds, should all be of the same participantType\n  entryStatus, // optional - defaults to DIRECT_ACCEPTANCE\n  stage, // optional - stage into which participantIds have been entered; defaults to MAIN\n  stageSequence, // optional - applies to qualifying\n  autoEntryPositions, // optional - keeps entries ordered by entryStage/entryStatus and auto-increments\n  ignoreStageSpace, // optional boolean to disable checking available positions\n});\n"})}),"\n",(0,i.jsx)(n.hr,{}),"\n",(0,i.jsx)(n.h2,{id:"adddrawentry",children:"addDrawEntry"}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-js",children:"drawEngine.addDrawEntry({\n  participantId,\n  entryStage, // optional - stage into which participantIds have been entered; defaults to MAIN\n  entryStatus, // optional - defaults to DIRECT_ACCEPTANCE\n  entryPosition, // optional - used to order entries, e.g. { entryPosition: 1 } for 1st alternate\n  ignoreStageSpace, // optional boolean to disable checking available positions\n});\n"})}),"\n",(0,i.jsx)(n.hr,{}),"\n",(0,i.jsx)(n.h2,{id:"addfinishingrounds",children:"addFinishingRounds"}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-js",children:"addFinishingRounds({\n  finishingPositionOffset = 0, // required for sub-structures; e.g. consolation fed from R32 would have { finishingPositionOffset: 16 }\n  roundLimit, // for qualifying, offset the final round so that qualifyinground is finishingRound\n  matchUps, // required - matchUps belonging to a single structure\n});\n"})}),"\n",(0,i.jsx)(n.hr,{}),"\n",(0,i.jsx)(n.h2,{id:"addmatchupendtime",children:"addMatchUpEndTime"}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-js",children:"const endTime = '2020-01-01T09:05:00Z';\ndrawEngine.addMatchUpEndTime({\n  validateTimeSeries, // optional - true by default - when false does not verify endTime is later than startTime\n  disableNotice, // when disabled subscribers will not be notified\n  matchUpId,\n  endTime,\n});\n"})}),"\n",(0,i.jsx)(n.hr,{}),"\n",(0,i.jsx)(n.h2,{id:"addmatchupofficial",children:"addMatchUpOfficial"}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-js",children:"drawEngine.addMatchUpOfficial({\n  matchUpId,\n  participantId,\n  officialType,\n  disableNotice, // when disabled subscribers will not be notified\n});\n"})}),"\n",(0,i.jsx)(n.hr,{}),"\n",(0,i.jsx)(n.h2,{id:"addmatchupresumetime",children:"addMatchUpResumeTime"}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-js",children:"const resumeTime = '2020-01-01T09:00:00Z';\ndrawEngine.addMatchUpResumeTime({\n  matchUpId,\n  resumeTime,\n  disableNotice, // when disabled subscribers will not be notified\n});\n"})}),"\n",(0,i.jsx)(n.hr,{}),"\n",(0,i.jsx)(n.h2,{id:"addmatchupscheduleddate",children:"addMatchUpScheduledDate"}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-js",children:"const scheduledDate = '2020-01-01';\ndrawEngine.addMatchUpScheduledDate({\n  matchUpId,\n  scheduledDate,\n  disableNotice, // when disabled subscribers will not be notified\n});\n"})}),"\n",(0,i.jsx)(n.hr,{}),"\n",(0,i.jsx)(n.h2,{id:"addmatchupscheduledtime",children:"addMatchUpScheduledTime"}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-js",children:"const scheduledTime = '08:00';\ndrawEngine.addMatchUpScheduledTime({\n  matchUpId,\n  scheduledTime,\n  disableNotice, // when disabled subscribers will not be notified\n});\n"})}),"\n",(0,i.jsx)(n.hr,{}),"\n",(0,i.jsx)(n.h2,{id:"addmatchupscheduleitems",children:"addMatchUpScheduleItems"}),"\n",(0,i.jsx)(n.p,{children:"Convenience function to add several schedule items at once."}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-js",children:"drawEngine.addMatchUpScheduleItems({\n  matchUpId,\n  schedule: {\n    scheduledTime,\n    scheduledDate,\n    startTime,\n    endTime,\n  },\n  disableNotice, // when disabled subscribers will not be notified\n});\n"})}),"\n",(0,i.jsx)(n.hr,{}),"\n",(0,i.jsx)(n.h2,{id:"addmatchupstarttime",children:"addMatchUpStartTime"}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-js",children:"const startTime = '2020-01-01T08:05:00Z';\ndrawEngine.addMatchUpStartTime({\n  matchUpId,\n  startTime,\n  disableNotice, // when disabled subscribers will not be notified\n});\n"})}),"\n",(0,i.jsx)(n.hr,{}),"\n",(0,i.jsx)(n.h2,{id:"addmatchupstoptime",children:"addMatchUpStopTime"}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-js",children:"const stopTime = '2020-01-01T08:15:00Z';\ndrawEngine.addMatchUpStopTime({\n  matchUpId,\n  stopTime,\n  disableNotice, // when disabled subscribers will not be notified\n});\n"})}),"\n",(0,i.jsx)(n.hr,{}),"\n",(0,i.jsx)(n.h2,{id:"addplayoffstructures",children:"addPlayoffStructures"}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-js",children:"drawEngine.addPlayoffStructures({\n  structureId,\n  roundNumbers: [3], // optional if playoffPositions not provided; roundNumbers of structure to be played off.\n  roundProfiles, // optional - source roundNumbers as Object.keys with depth as Object.values, e.g. [{ 1: 2}, {2: 1}]\n  playoffPositions: [3, 4], // optional if roundNumbers not provided; finishing positions to be played off.\n  playoffAttributes, // optional - mapping of either exitProfile or finishingPositionRange to structure names, e.g. 0-1-1 for South\n  exitProfileLimit, // limit playoff rounds generated by the attributes present in playoffAttributes\n  playoffStructureNameBase, // optional - Root word for default playoff naming, e.g. 'Playoff' for 'Playoff 3-4'\n});\n\n// example use of playoffAttributes - will generated playoff structure from 2nd round with structureName: 'BRONZE'\nconst playoffAttributes = {\n  '0-2': { name: 'BRONZE', abbreviation: 'B' },\n};\n"})}),"\n",(0,i.jsx)(n.hr,{}),"\n",(0,i.jsx)(n.h2,{id:"addmatchuptimeitem",children:"addMatchUpTimeItem"}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-js",children:"const timeItem = {\n  itemType: SCHEDULED_DATE,\n  itemValue: scheduledDate,\n};\ndrawEngine.addMatchUpTimeItem({\n  matchUpId,\n  timeItem,\n  duplicateValues: false,\n});\n"})}),"\n",(0,i.jsx)(n.hr,{}),"\n",(0,i.jsx)(n.h2,{id:"addvoluntaryconsolationstage",children:"addVoluntaryConsolationStage"}),"\n",(0,i.jsxs)(n.p,{children:["Modifies the entryProfile for a draw to allow ",(0,i.jsx)(n.code,{children:"{ entryStage: VOLUNTARY_CONSOLATION }"})]}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-js",children:"drawEngine.addVoluntaryConsolationStage({\n  drawSize,\n});\n"})}),"\n",(0,i.jsx)(n.hr,{}),"\n",(0,i.jsx)(n.h3,{id:"addvoluntaryconsolationstructure",children:"addVoluntaryConsolationStructure"}),"\n",(0,i.jsxs)(n.p,{children:["Generates a new structure within a ",(0,i.jsx)(n.code,{children:"drawDefinition"})," if any draw entries are present for ",(0,i.jsx)(n.code,{children:"{ entryStage: VOLUNTARY_CONSOLATION }"}),"."]}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-js",children:"drawEngine.addVoluntaryConsolationStructure();\n"})}),"\n",(0,i.jsx)(n.hr,{}),"\n",(0,i.jsx)(n.h2,{id:"alldrawmatchups",children:"allDrawMatchUps"}),"\n",(0,i.jsx)(n.p,{children:"Returns all matchUps from all structures within a draw."}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-js",children:"const { matchUps } = drawEngine.allDrawMatchUps({\n  context, // optional context to be added into matchUps\n  inContext, // boolean - add context { drawId, structureId, participant, individualParticipants ... }\n  nextMatchUps, // optioanl - boolean - to include winnerTo and loserTo\n  matchUpFilters, // attribute filters\n  contextFilters, // filters based on context attributes\n  tournamentParticipants, // optional - provide an array of tournamentParticipants to add into matchUps\n  requireParticipants, // optional - require that participants be loaded into drawEngine or passed into method\n  tournamentAppliedPolicies, // any policies, such as privacy, to be applied to matchUps\n  contextProfile, // optional: { inferGender: true, withCompetitiveness: true, withScaleValues: true, exclude: ['attribute', 'to', 'exclude']}\n});\n"})}),"\n",(0,i.jsx)(n.hr,{}),"\n",(0,i.jsx)(n.h2,{id:"allplayoffpositionsfilled",children:"allPlayoffPositionsFilled"}),"\n",(0,i.jsxs)(n.p,{children:["Returns boolean value for whether playoff positions (which have been generated) are populated with ",(0,i.jsx)(n.code,{children:"participantIds"})," or ",(0,i.jsx)(n.code,{children:"BYEs"}),"."]}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-js",children:"const allPositionsFilled = allPlayoffPositionsFilled({\n  drawDefinition,\n  structureId,\n});\n"})}),"\n",(0,i.jsx)(n.hr,{}),"\n",(0,i.jsx)(n.h2,{id:"allstructurematchups",children:"allStructureMatchUps"}),"\n",(0,i.jsx)(n.p,{children:"Returns all matchUps from a single structure within a draw."}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-js",children:"const { matchUps } = drawEngine.allStructureMatchUps({\n  structureId,\n  context, // optional context to be added into matchUps\n  inContext, // boolean - add context { drawId, structureId, participant, individualParticipants ... }\n  nextMatchUps, // optioanl - boolean - to include winnerTo and loserTo\n  matchUpFilters, // attribute filters\n  contextFilters, // filters based on context attributes\n  tournamentParticipants, // optional - provide an array of tournamentParticipants to add into matchUps\n  requireParticipants, // optional - require that participants be loaded into drawEngine or passed into method\n  tournamentAppliedPolicies, // any policies, such as privacy, to be applied to matchUps\n});\n"})}),"\n",(0,i.jsx)(n.hr,{}),"\n",(0,i.jsx)(n.h2,{id:"assigndrawposition",children:"assignDrawPosition"}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-js",children:"drawEngine.assignDrawPosition({\n  structureId,\n  drawPosition,\n  participantId,\n});\n"})}),"\n",(0,i.jsx)(n.hr,{}),"\n",(0,i.jsx)(n.h2,{id:"assigndrawpositionbye",children:"assignDrawPositionBye"}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-js",children:"drawEngine.assignDrawPositionBye({\n  structureId,\n  drawPosition,\n});\n"})}),"\n",(0,i.jsx)(n.hr,{}),"\n",(0,i.jsx)(n.h2,{id:"assignseed",children:"assignSeed"}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-js",children:"result = drawEngine.assignSeed({\n  structureId,\n  seedNumber,\n  seedValue, // optional - display value, e.g. '5-8'\n  participantId,\n});\n"})}),"\n",(0,i.jsx)(n.hr,{}),"\n",(0,i.jsx)(n.h2,{id:"attachplayoffstructures",children:"attachPlayoffStructures"}),"\n",(0,i.jsxs)(n.p,{children:["Attaches the results of ",(0,i.jsx)(n.code,{children:"generateAndPopulatePlayoffStructures"})," to a ",(0,i.jsx)(n.code,{children:"drawDefinition"}),".\nUsed primarily when multiple instances of ",(0,i.jsx)(n.code,{children:"drawEngine"})," are in use and the generation step is performed by one instance."]}),"\n",(0,i.jsx)(n.admonition,{type:"note",children:(0,i.jsxs)(n.p,{children:[(0,i.jsx)(n.code,{children:"drawEngine.addPlayoffStructures()"})," calls both ",(0,i.jsx)(n.code,{children:"generateAndPopulatePlayoffStructures"})," and ",(0,i.jsx)(n.code,{children:"attachPlayoffStructures"})," and is used when there is only one instance of ",(0,i.jsx)(n.code,{children:"drawEngine"}),"."]})}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-js",children:"drawEngine.attachPlayoffStructures({ structures, links });\n"})}),"\n",(0,i.jsx)(n.hr,{}),"\n",(0,i.jsx)(n.h2,{id:"attachpolicies",children:"attachPolicies"}),"\n",(0,i.jsx)(n.p,{children:"Attaches a policy to a drawDefinition."}),"\n",(0,i.jsxs)(n.p,{children:["See ",(0,i.jsx)(n.a,{href:"../concepts/policies",children:"Policies"}),"."]}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-js",children:"drawEngine.attachPolicies({ policyDefinitions: SEEDING_POLICY });\n"})}),"\n",(0,i.jsx)(n.hr,{}),"\n",(0,i.jsx)(n.h2,{id:"automatedpositioning",children:"automatedPositioning"}),"\n",(0,i.jsxs)(n.p,{children:["Positions participants in a draw structure. ",(0,i.jsx)(n.code,{children:"drawEngine"})," is agnostic about the type of participants that are placed in a draw structure, but requires tournament participants for avoidance policies to work."]}),"\n",(0,i.jsxs)(n.p,{children:["See ",(0,i.jsx)(n.a,{href:"../concepts/policies",children:"Policies"}),"."]}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-js",children:"drawEngine.automatedPositioning({\n  structureId,\n  participants, // optional - participants must be passed in for Avoidance Policies to be effective\n});\n"})}),"\n",(0,i.jsx)(n.hr,{}),"\n",(0,i.jsx)(n.h2,{id:"checkinparticipant",children:"checkInParticipant"}),"\n",(0,i.jsx)(n.p,{children:"Set the check-in state for a participant. Used to determine when both participants in a matchUp are available to be assigned to a court."}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-js",children:"drawEngine.checkInParticipant({\n  matchUpId,\n  participantId,\n});\n"})}),"\n",(0,i.jsx)(n.hr,{}),"\n",(0,i.jsx)(n.h2,{id:"checkoutparticipant",children:"checkOutParticipant"}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-js",children:"drawEngine.checkOutParticipant({\n  matchUpId,\n  participantId,\n});\n"})}),"\n",(0,i.jsx)(n.hr,{}),"\n",(0,i.jsx)(n.h2,{id:"cleardrawposition",children:"clearDrawPosition"}),"\n",(0,i.jsxs)(n.p,{children:["Removes a ",(0,i.jsx)(n.code,{children:"participantId"})," or ",(0,i.jsx)(n.code,{children:"bye"})," from a specified ",(0,i.jsx)(n.code,{children:"drawPosition"})," within a ",(0,i.jsx)(n.code,{children:"structure"})," or, optionally, removes a specified ",(0,i.jsx)(n.code,{children:"participantId"})," from a ",(0,i.jsx)(n.code,{children:"structure"}),"."]}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-js",children:"drawEngine.clearDrawPosition({\n  structureId,\n  drawPosition, // optional if participantId is provided\n  participantId, // optional if drawPosition is provided\n});\n"})}),"\n",(0,i.jsx)(n.hr,{}),"\n",(0,i.jsx)(n.h2,{id:"deleteadhocmatchups",children:"deleteAdHocMatchUps"}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-js",children:"const result = drawEngine.deleteAdHocMatchUps({\n  drawDefinition, // required - drawDefinition in which target structure is found\n  structureId, // required - structureId of structure for which matchUps are being generated\n  matchUpIds, // array of matchUpIds identifying matchUps to be deleted\n});\n"})}),"\n",(0,i.jsx)(n.hr,{}),"\n",(0,i.jsx)(n.h2,{id:"devcontext",children:"devContext"}),"\n",(0,i.jsxs)(n.p,{children:["Setting devContext(true) bypasses ",(0,i.jsxs)(n.strong,{children:["try "," catch (err) "]})," code block and in some cases enables logging"]}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-js",children:"drawEngine.devContext(true);\n"})}),"\n",(0,i.jsx)(n.hr,{}),"\n",(0,i.jsx)(n.h2,{id:"drawmatchups",children:"drawMatchUps"}),"\n",(0,i.jsx)(n.p,{children:"Returns categorized matchUps from all structures within a draw."}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-js",children:"const {\n  upcomingMatchUps,\n  pendingMatchUps,\n  completedMatchUps,\n  abandonedMatchUps,\n  byeMatchUps,\n} = drawEngine.drawMatchUps({\n  context, // optional context to be added into matchUps\n  inContext, // boolean - add context { drawId, structureId, participant, individualParticipants ... }\n  nextMatchUps, // optioanl - boolean - to include winnerTo and loserTo\n  matchUpFilters, // attribute filters\n  contextFilters, // filters based on context attributes\n  tournamentParticipants, // optional - provide an array of tournamentParticipants to add into matchUps\n  requireParticipants, // optional - require that participants be loaded into drawEngine or passed into method\n  tournamentAppliedPolicies, // any policies, such as privacy, to be applied to matchUps\n});\n"})}),"\n",(0,i.jsx)(n.hr,{}),"\n",(0,i.jsx)(n.h2,{id:"drawmatic",children:"drawMatic"}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-js",children:"const { matchUps } = drawEngine.drawMatic({\n  addToStructure, // optional - defaults to true\n  drawId,\n});\n"})}),"\n",(0,i.jsx)(n.hr,{}),"\n",(0,i.jsx)(n.h2,{id:"disabletiaautocalc",children:"disableTiaAutoCalc"}),"\n",(0,i.jsx)(n.p,{children:"Disable default behavior of auto calculating TEAM matchUp scores."}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-js",children:"drawEngine.disableTieAutoCalc({ matchUpId });\n"})}),"\n",(0,i.jsx)(n.hr,{}),"\n",(0,i.jsx)(n.h2,{id:"enabletiaautocalc",children:"enableTiaAutoCalc"}),"\n",(0,i.jsx)(n.p,{children:"Re-enable default behavior of auto calculating TEAM matchUp scores, and trigger auto calculation."}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-js",children:"drawEngine.enableTieAutoCalc({ matchUpId });\n"})}),"\n",(0,i.jsx)(n.hr,{}),"\n",(0,i.jsx)(n.h2,{id:"findmatchup",children:"findMatchUp"}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-js",children:"const {\n  matchUp,\n  structure, // returned for convenience\n} = drawEngine.findMatchUp({\n  matchUpId,\n  inContext, // optional - boolean - returns matchUp with additional attributes\n  tournamentParticipants, // optional - enables inContext matchUp to contain full participant objects\n});\n"})}),"\n",(0,i.jsx)(n.hr,{}),"\n",(0,i.jsx)(n.h2,{id:"generateadhocmatchups",children:"generateAdHocMatchUps"}),"\n",(0,i.jsxs)(n.p,{children:["Draws with ",(0,i.jsx)(n.code,{children:"{ drawType: AD_HOC }"})," allow ",(0,i.jsx)(n.code,{children:"matchUps"})," to be dynamically added. In this type of draw there is no automatic participant progression between rounds. Participant assignment to ",(0,i.jsx)(n.code,{children:"matchUps"})," is done manually, or via ",(0,i.jsx)(n.strong,{children:"DrawMatic"}),". The only restriction is that a participant may appear once per round."]}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-js",children:"const result = drawEngine.generateAdHocMatchUps({\n  participantIdPairings, // optional - array of array of pairings [['id1', 'id2'], ['id3', 'id4']]\n  drawDefinition, // required - drawDefinition in which target structure is found\n  structureId, // required when more than one structure is present - structureId of structure for which matchUps are being generated\n  matchUpIds, // optional - if matchUpIds are not specified UUIDs are generated\n  roundNumber, // optional - specify round for which matchUps will be generated\n  newRound, // optional - boolean defaults to false - whether to auto-increment to next roundNumber\n});\n"})}),"\n",(0,i.jsx)(n.hr,{}),"\n",(0,i.jsx)(n.h2,{id:"generateandpopulateplayoffstructures",children:"generateAndPopulatePlayoffStructures"}),"\n",(0,i.jsxs)(n.p,{children:["Generates ",(0,i.jsx)(n.code,{children:"structures"})," and ",(0,i.jsx)(n.code,{children:"links"})," but does not attach them to the ",(0,i.jsx)(n.code,{children:"drawDefinition"}),". Used in conjunction with ",(0,i.jsx)(n.code,{children:"attachPlayoffStructures"}),"."]}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-js",children:"const { structures, links, matchUpModifications } =\n  drawEngine.generateAndPopulatePlayoffStructures({\n    requireSequential, // boolean defaults to true; only applies to Round Robin; require finishingPositions to be sequential\n    roundNumbers: [3], // optional if playoffPositions not provided; roundNumbers of structure to be played off.\n    roundProfiles, // optional - source roundNumbers as Object.keys with depth as Object.values, e.g. [{ 1: 2}, {2: 1}]\n    playoffPositions: [3, 4], // optional if roundNumbers not provided; finishing positions to be played off.\n    playoffAttributes, // optional - mapping of either exitProfile or finishingPositionRange to structure names, e.g. 0-1-1 for South\n    exitProfileLimit, // limit playoff rounds generated by the attributes present in playoffAttributes\n    playoffStructureNameBase, // optional - Root word for default playoff naming, e.g. 'Playoff' for 'Playoff 3-4'\n    structureId,\n  });\n"})}),"\n",(0,i.jsx)(n.hr,{}),"\n",(0,i.jsx)(n.h2,{id:"generatedrawtypeandmodifydrawdefinition",children:"generateDrawTypeAndModifyDrawDefinition"}),"\n",(0,i.jsx)(n.p,{children:"Convenience method to generate pre-defined drawTypes."}),"\n",(0,i.jsxs)(n.p,{children:["For more information on ",(0,i.jsx)(n.code,{children:"feedPolicy"})," see ",(0,i.jsx)(n.a,{href:"../policies/feedPolicy",children:"Feed Policies"}),"."]}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-js",children:"drawEngine.generateDrawTypeAndModifyDrawDefinition({\n  drawType, // defaults to SINGLE_ELIMINATION\n  modifyOriginal, // optional - defaults to true (primarily used by other engines)\n\n  matchUpType, // optional - defaults to SINGLES - will check first on drawDefinition\n  matchUpFormat, // optional - default matchUpFormat\n  tieFormat, // optional - overrides drawDefinition.tieFormat, if present, for TEAM draws\n  playoffMatchUpFormat, // optional - default playoffMatchUpFormat\n\n  staggeredEntry, // optional - accepts non-base-2 drawSizes and generates feed arms for \"extra\" drawPositions\n  seedingProfile, // optional { positioning, groupSeedingThreshold }; WATERFALL seeding for ROUND_ROBIN structures, CLUSTER or SEPARATE seeding for elimination structures\n  feedPolicy, // optional - provides fine-grain control for FEED_IN_CONSOLATION feed links\n\n  qualifyingPositions, // optional - number of drawPositions to be filled by qualifiers\n  finishingPositionLimit, // optional - for playoff structures, limit to the number of positions to be played off\n\n  structureOptions: {\n    groupSize, // e.g. 4 participants per group\n    groupSizeLimit: 8,\n    playoffGroups: [\n      { finishingPositions: [1], structureName: 'Gold Flight', drawType }, // drawype defaults to SINGLE_ELIMINATION\n      { finishingPositions: [2], structureName: 'Silver Flight', drawType }, // drawType can also be COMPASS or FIRST_MATCH_LOSER_CONSOLATION\n    ],\n  },\n\n  uuids, // optional - array of UUIDs to be used for structureIds and matchUpIds\n\n  structureName, // optional - defaults to stage\n});\n"})}),"\n",(0,i.jsx)(n.hr,{}),"\n",(0,i.jsx)(n.h2,{id:"generatequalifyinglink",children:"generateQualifyingLink"}),"\n",(0,i.jsxs)(n.p,{children:["Generates and adds a ",(0,i.jsx)(n.code,{children:"link"})," to ",(0,i.jsx)(n.code,{children:"drawDefinition.links"}),"."]}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-js",children:"drawEngine.generateQualifyingLink({\n  qualifyingStructureId,\n  mainStructureId,\n});\n"})}),"\n",(0,i.jsx)(n.hr,{}),"\n",(0,i.jsx)(n.h2,{id:"getavailableplayoffprofiles",children:"getAvailablePlayoffProfiles"}),"\n",(0,i.jsxs)(n.p,{children:["If provided a ",(0,i.jsx)(n.code,{children:"structureId"}),", returns rounds of the selected structure which are available for adding playoff structures."]}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-js",children:"const { playoffRounds, playoffRoundsRanges, positionsPlayedOff } =\n  drawEngine.getAvailablePlayoffProfiles({\n    structureId,\n  });\n"})}),"\n",(0,i.jsxs)(n.p,{children:["...for a SINGLE_ELIMINATION struture with ",(0,i.jsx)(n.code,{children:"{ drawSize: 16 }"})," this would return:"]}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-js",children:"{\n  playoffRounds: [ 1, 2, 3 ],\n  playoffRoundsRanges: [\n    { round: 1, range: '9-16' },\n    { round: 2, range: '5-8' },\n    { round: 3, range: '3-4' }\n  ]\n}\n"})}),"\n",(0,i.jsxs)(n.p,{children:["...for a ROUND_ROBIN struture with ",(0,i.jsx)(n.code,{children:"{ drawSize: 16 }"})," and ",(0,i.jsx)(n.code,{children:"{ groupSize: 4 }"})," this would return:"]}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-js",children:'{\n    "finishingPositionsAvailable": [ 1, 2, 3, 4 ],\n    "playoffFinishingPositionRanges": [\n        {\n            "finishingPosition": 1,\n            "finishingPositions": [ 1, 2, 3, 4 ],\n            "finishingPositionRange": "1-4"\n        },\n        {\n            "finishingPosition": 2,\n            "finishingPositions": [ 5, 6, 7, 8 ],\n            "finishingPositionRange": "5-8"\n        },\n        {\n            "finishingPosition": 3,\n            "finishingPositions": [ 9, 10, 11, 12 ],\n            "finishingPositionRange": "9-12"\n        },\n        {\n            "finishingPosition": 4,\n            "finishingPositions": [ 13, 14, 15, 16 ],\n            "finishingPositionRange": "13-16"\n        }\n    ],\n}\n'})}),"\n",(0,i.jsxs)(n.p,{children:["When no ",(0,i.jsx)(n.code,{children:"structureId"})," is provided, returns an array of ",(0,i.jsx)(n.code,{children:"availablePlayoffProfiles"})," with entries for each structure in a loaded ",(0,i.jsx)(n.code,{children:"drawDefinition"}),"."]}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-js",children:"const { availablePlayoffProfiles, positionsPlayedOff } =\n  drawEngine.getAvailablePlayoffProfiles();\n"})}),"\n",(0,i.jsx)(n.hr,{}),"\n",(0,i.jsx)(n.h2,{id:"getcheckedinparticipantids",children:"getCheckedInParticipantIds"}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-js",children:"const {\n  allParticipantsCheckedIn, // boolean\n  checkedInParticipantIds, // array of participantIds\n} = drawEngine.getCheckedInParticipantIds({ matchUp });\n"})}),"\n",(0,i.jsx)(n.hr,{}),"\n",(0,i.jsx)(n.h2,{id:"getdrawstructures",children:"getDrawStructures"}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-js",children:"const { structures, stageStructures } = drawEngine.getDrawStructures({\n  withStageGrouping, // optinal, return structures collated by stage\n  stageSequences, // optional - specify stageSequences to include\n  stageSequence, // optional - filter by stageSequence\n  stages, // optional - specify stageSequences to include\n  stage, // optional - filter by stage\n});\n"})}),"\n",(0,i.jsx)(n.hr,{}),"\n",(0,i.jsx)(n.h2,{id:"geteliminationdrawsize",children:"getEliminationDrawSize"}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-js",children:"const { drawSize } = drawEngine.getEliminationDrawSize({ participantsCount });\n"})}),"\n",(0,i.jsx)(n.hr,{}),"\n",(0,i.jsx)(n.h2,{id:"getmatchupcontextids",children:"getMatchUpContextIds"}),"\n",(0,i.jsxs)(n.p,{children:["Convenience method to find a ",(0,i.jsx)(n.code,{children:"matchUp"})," by ",(0,i.jsx)(n.code,{children:"matchUpId"}),' and return "context ids". Does NOT require that drawEngine state be set, but does require an array of "inContext" ',(0,i.jsx)(n.code,{children:"matchUps"}),"."]}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-js",children:"const { matchUpId, drawId, eventId, structureId, tournamentId } =\n  drawEngine.getMatchUpContextIds({ matchUps, matchUpId });\n"})}),"\n",(0,i.jsx)(n.hr,{}),"\n",(0,i.jsx)(n.h2,{id:"getmatchupparticipantids",children:"getMatchUpParticipantIds"}),"\n",(0,i.jsx)(n.p,{children:"Convenience function; requires inContext matchUp."}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-js",children:"const { sideParticipantIds, individualParticipantIds } =\n  drawEngine.getMatchUpParticipantIds({ matchUp });\n"})}),"\n",(0,i.jsx)(n.hr,{}),"\n",(0,i.jsx)(n.h2,{id:"getmatchupscheduledetails",children:"getMatchUpScheduleDetails"}),"\n",(0,i.jsxs)(n.p,{children:["Returns the latest values for all ",(0,i.jsx)(n.code,{children:"matchUp.timeItems"}),", along with calculated values, that relate to the scheduling of a ",(0,i.jsx)(n.code,{children:"matchUp"}),"."]}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-js",children:"const {\n  schedule: {\n    time,\n    courtId,\n    venueId,\n    startTime,\n    endTime,\n    milliseconds,\n    scheduledDate,\n    scheduledTime,\n    allocatedCourts: [{ venueId, courtid }], // applies only to TEAM matchUps\n  },\n} = drawEngine.getMatchUpScheduleDetails({\n  scheduleVisibilityFilters, // { visibilityThreshold: Date, eventIds, drawIds }\n  matchUp,\n});\n"})}),"\n",(0,i.jsx)(n.hr,{}),"\n",(0,i.jsx)(n.h2,{id:"getnextseedblock",children:"getNextSeedBlock"}),"\n",(0,i.jsx)(n.p,{children:"Returns the next block of drawPositions which are to be assigned seeded participants."}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-js",children:"const {\n  nextSeedBlock,\n  unplacedSeedParticipantIds,\n  unplacedSeedNumbers,\n  unfilledPositions,\n  unplacedSeedAssignments,\n} = drawEngine.getNextSeedBlock({\n  structureId,\n});\n"})}),"\n",(0,i.jsx)(n.hr,{}),"\n",(0,i.jsx)(n.h2,{id:"getnextunfilleddrawpositions",children:"getNextUnfilledDrawPositions"}),"\n",(0,i.jsx)(n.p,{children:"Returns the next valid block of unfilled drawPositions. Useful for UI to give visual indication of drawPostions valid to assign."}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-js",children:"const { nextUnfilledDrawPositions } = drawEngine.getNextUnfilledDrawPositions({\n  structureId,\n});\n"})}),"\n",(0,i.jsx)(n.hr,{}),"\n",(0,i.jsx)(n.h2,{id:"getparticipantidfinishingpositions",children:"getParticipantIdFinishingPositions"}),"\n",(0,i.jsx)(n.p,{children:"Returns the Range of finishing positions possible for all participantIds within a draw"}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-js",children:"const idMap = drawEngine.getParticipantIdFinishingPositions({\n  byeAdvancements, // optional boolean - whether or not to consider byeAdvancements\n});\n\nconst { relevantMatchUps, finishingPositionRanges, finishingPositionRange } =\n  idMap[participantId];\n"})}),"\n",(0,i.jsx)(n.hr,{}),"\n",(0,i.jsx)(n.h2,{id:"getpositionsplayedoff",children:"getPositionsPlayedOff"}),"\n",(0,i.jsx)(n.p,{children:"Determines which finishing positions will be returned by a draw. For example, a First Match Loser Consolation with a draw size of 16 will playoff possitions 1, 2, 9 and 10."}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-js",children:"const { positionsPlayedOff } = drawEngine.getPositionsPlayedOff({\n  drawDefinition,\n});\n"})}),"\n",(0,i.jsx)(n.hr,{}),"\n",(0,i.jsx)(n.h2,{id:"getroundmatchups",children:"getRoundMatchUps"}),"\n",(0,i.jsxs)(n.p,{children:["Organizes matchUps by roundNumber. ",(0,i.jsx)(n.strong,{children:"roundMatchUps"})," contains matchUp objects; ",(0,i.jsx)(n.strong,{children:"roundProfile"})," provides an overview of drawPositions which have advanced to each round, a matchUpsCount, finishingPositionRange for winners and losers, and finishingRound."]}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-js",children:"const { roundMatchUps, roundProfile } = drawEngine.getRoundMatchUps({\n  matchUps,\n});\n"})}),"\n",(0,i.jsx)(n.hr,{}),"\n",(0,i.jsx)(n.h2,{id:"getseedingthresholds",children:"getSeedingThresholds"}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-js",children:"const { seedingThresholds } = drawEngine.getSeedingThresholds({\n  roundRobinGroupsCount,\n  participantsCount,\n});\n"})}),"\n",(0,i.jsx)(n.hr,{}),"\n",(0,i.jsx)(n.h2,{id:"getsourcerounds",children:"getSourceRounds"}),"\n",(0,i.jsx)(n.p,{children:"Returns the round numbers for desired playoff positions."}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-js",children:"const {\n  sourceRounds, // all source rounds for playedOff positions and specified playoffPositions\n  playoffSourceRounds,\n  playedOffSourceRounds,\n  playoffPositionsReturned,\n} = drawEngine.getSourceRounds({\n  structureId,\n  playoffPositions: [3, 4],\n});\n"})}),"\n",(0,i.jsx)(n.hr,{}),"\n",(0,i.jsx)(n.h2,{id:"getstructureseedassignments",children:"getStructureSeedAssignments"}),"\n",(0,i.jsx)(n.p,{children:"Returns seedAssignments for a specific structure based on structureId or structure"}),"\n",(0,i.jsxs)(n.p,{children:["The structure of an ",(0,i.jsx)(n.strong,{children:(0,i.jsx)(n.em,{children:"assignment object"})})," is as follows:"]}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-json",children:'{\n  "seedNumber": 1,\n  "seedValue": "1",\n  "participantId": "uuid-of-participant"\n}\n'})}),"\n",(0,i.jsx)(n.p,{children:"The most basic usage is to retrieve seed assignments for a draw which has a single main stage structure"}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-js",children:"const { seedAssignments } = drawEngine.getStructureSeedAssignments({\n  structureId,\n});\n"})}),"\n",(0,i.jsx)(n.hr,{}),"\n",(0,i.jsx)(n.h2,{id:"getstate",children:"getState"}),"\n",(0,i.jsx)(n.p,{children:"No parameters."}),"\n",(0,i.jsx)(n.p,{children:"Returns a deep copy of the current drawEngine state."}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-js",children:"const { drawDefinition } = drawEngine.getState({\n  convertExtensions, // optional - convert extensions to '_' prefixed attributes\n  removeExtensions, // optional - strip all extensions out of tournamentRecord\n});\n"})}),"\n",(0,i.jsx)(n.hr,{}),"\n",(0,i.jsx)(n.h2,{id:"getvalidgroupsizes",children:"getValidGroupSizes"}),"\n",(0,i.jsxs)(n.p,{children:["Returns valid Round Robin group sizes for specified ",(0,i.jsx)(n.code,{children:"drawSize"}),"."]}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-js",children:"const { validGroupSizes } = drawEngine.getValidGroupSies({\n  groupSizeLimit, // optional - defaults to 10\n  drawSize,\n});\n"})}),"\n",(0,i.jsx)(n.hr,{}),"\n",(0,i.jsx)(n.h2,{id:"initializestructureseedassignments",children:"initializeStructureSeedAssignments"}),"\n",(0,i.jsxs)(n.p,{children:["Creates the ",(0,i.jsx)(n.code,{children:"seedAssignments"})," attribute for the specified structure."]}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-js",children:"drawEngine.initializeStructureSeedAssignments({\n  structureId,\n  seedsCount,\n});\n"})}),"\n",(0,i.jsx)(n.hr,{}),"\n",(0,i.jsx)(n.h2,{id:"iscompletedstructure",children:"isCompletedStructure"}),"\n",(0,i.jsx)(n.p,{children:"Returns boolean whether all matchUps in a given structure have been completed"}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-js",children:"const structureIsComplete = drawEngine.isCompletedStructure({\n  structureId,\n});\n"})}),"\n",(0,i.jsx)(n.hr,{}),"\n",(0,i.jsx)(n.h2,{id:"matchupactions",children:"matchUpActions"}),"\n",(0,i.jsx)(n.p,{children:"Return an array of all validActions for a specific matchUp."}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-js",children:"const {\n  isByeMatchUp, // boolean; true if matchUp includes a BYE\n  structureIsComplete, // boolean; true if structure is ready for positioning\n  validActions, // array of possible actions given current matchUpStatus\n} = drawEngine.matchUpActions({\n  restrictAdHocRoundParticipants, // optional - true by default; applies to AD_HOC; disallow the same participant being in the same round multiple times\n  sideNumber, // optional - select side to which action should apply; applies to AD_HOC position assignments\n  matchUpId,\n});\n\nconst {\n  type, // 'REFEREE', 'SCHEDULE', 'PENALTY', 'STATUS', 'SCORE', 'START', 'END'.\n  method, // tournamentEngine method relating to action type\n  payload, // attributes to be passed to method\n  // additional method-specific options for values to be added to payload when calling method\n} = validAction;\n"})}),"\n",(0,i.jsx)(n.hr,{}),"\n",(0,i.jsx)(n.h2,{id:"matchupduration",children:"matchUpDuration"}),"\n",(0,i.jsx)(n.p,{children:"Calculates matchUp duration from START, STOP, RESUME, END timeItems."}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-js",children:'const {\n  milliseconds,\n  time, // string representation of elapsed time, e.g. "01:10:00" for an hour and 10 seconds\n  relevantTimeItems,\n} = drawEngine.matchUpDuration({\n  matchUp,\n});\n'})}),"\n",(0,i.jsx)(n.hr,{}),"\n",(0,i.jsx)(n.h2,{id:"newdrawdefinition",children:"newDrawDefinition"}),"\n",(0,i.jsx)(n.p,{children:"Creates a new drawDefinition within drawEngine state."}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-js",children:"const { drawId } = drawEngine.newDrawDefinition();\nconst { drawDefinition } = drawEngine.getState();\n"})}),"\n",(0,i.jsx)(n.hr,{}),"\n",(0,i.jsx)(n.h2,{id:"positionactions",children:"positionActions"}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-js",children:"const positionActions = drawEngine.positionActions({\n  policyDefinitions: positionActionsPolicy, // optional - policy defining what actions are allowed in client context\n  returnParticipants, // optional boolean; defaults to true; performance optimization when false requires client to provide participants.\n  drawPosition,\n  structureId,\n});\n\nconst {\n  isActiveDrawPosition, // boolean\n  isByePosition, // boolean\n  isDrawPosition, // boolean\n  hasPositionAssiged, // boolean\n  validActions,\n} = positionActions;\n\nconst {\n  type, // 'ASSIGN', 'LUCKY', 'SWAP', 'BYE', 'REMOVE'\n  method, // tournamentEngine method relating to action type\n  payload, // attributes to be passed to method\n  // additional method-specific options for values to be added to payload when calling method\n} = validAction;\n"})}),"\n",(0,i.jsx)(n.hr,{}),"\n",(0,i.jsx)(n.h2,{id:"removeentry",children:"removeEntry"}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-js",children:"drawEngine.removeEntry({\n  participantId,\n  autoEntryPositions, // optional - keeps entries ordered by entryStage/entryStatus\n});\n"})}),"\n",(0,i.jsx)(n.hr,{}),"\n",(0,i.jsx)(n.h2,{id:"removestructure",children:"removeStructure"}),"\n",(0,i.jsxs)(n.p,{children:["Removes targeted ",(0,i.jsx)(n.code,{children:"drawDefinition.structure"})," and all other child ",(0,i.jsx)(n.code,{children:"structures"})," along with all associated ",(0,i.jsx)(n.code,{children:"drawDefinition.links"}),"."]}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-js",children:"const { removedMatchUpIds } = drawEngine.removeStructure({\n  structureId,\n});\n"})}),"\n",(0,i.jsx)(n.hr,{}),"\n",(0,i.jsx)(n.h2,{id:"renamestructures",children:"renameStructures"}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-js",children:"drawEngine.renameStructures({\n  structureDetails: [{ structureId, structureName }],\n});\n"})}),"\n",(0,i.jsx)(n.h2,{id:"reset",children:"reset"}),"\n",(0,i.jsx)(n.p,{children:"Clears the drawEngine state."}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-js",children:"drawEngine.reset();\n"})}),"\n",(0,i.jsx)(n.hr,{}),"\n",(0,i.jsx)(n.h2,{id:"resetmatchuptimeitems",children:"resetMatchUpTimeItems"}),"\n",(0,i.jsx)(n.p,{children:"Removes all timeItems from a specified matchUp."}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-js",children:"drawEngine.resetMatchUpTimeItems({ matchUpId });\n"})}),"\n",(0,i.jsx)(n.hr,{}),"\n",(0,i.jsx)(n.h2,{id:"resolvedrawpositions",children:"resolveDrawPositions"}),"\n",(0,i.jsx)(n.p,{children:"Provides an algorithmic approach to assigning drawPositions based on participant nomination of an arbitrary number of preferred positions."}),"\n",(0,i.jsx)(n.p,{children:"Simple use case would be to pre-position all seeded participants, then resolve all remaining participants."}),"\n",(0,i.jsx)(n.p,{children:"Variations could include grouping participants into quarters based on rankings/ratings and resolving drawPositions for each group in a sequence which gives preference to higher ranked/rated participants"}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-js",children:"const { drawPositionResolutions, report } = drawEngine.resolveDrawPositions({\n  participantFactors, // { [participantId]: { preferences: [1, 2, 3] }} - the length of the preference array is arbitrary\n  positionAssignments, // object from target structure containing any already assigned positions\n});\n"})}),"\n",(0,i.jsx)(n.h2,{id:"setdrawdescription",children:"setDrawDescription"}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-js",children:"const drawDescription = 'Draw Description';\ndrawEngine.setDrawDescription({ description: drawDescription });\n"})}),"\n",(0,i.jsx)(n.hr,{}),"\n",(0,i.jsx)(n.h2,{id:"setmatchupformat",children:"setMatchUpFormat"}),"\n",(0,i.jsxs)(n.p,{children:["Sets the default ",(0,i.jsx)(n.code,{children:"matchUpFormat"})," for a ",(0,i.jsx)(n.code,{children:"drawDefintion"})," or a ",(0,i.jsx)(n.code,{children:"structure"}),", or for a specific ",(0,i.jsx)(n.code,{children:"matchUp"}),"."]}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-js",children:"drawEngine.setMatchUpFormat({\n  matchUpFormat,\n  structureId, // optional - if structureId is present and not matchUpId is present, then set for structure\n  matchUpId, // optional - if matchUpId is present then only set for matchUp\n});\n"})}),"\n",(0,i.jsx)(n.hr,{}),"\n",(0,i.jsx)(n.h2,{id:"setmatchupstatus",children:"setMatchUpStatus"}),"\n",(0,i.jsx)(n.p,{children:"Sets either matchUpStatus or score and winningSide. Handles any winner/loser participant movements within or across structures."}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-js",children:"drawEngine.setMatchUpStatus({\n  disableScoreValidation, // optional boolean\n  allowChangePropagation, // optional boolean - allow winner/loser to be swapped and propgate change throughout draw structures\n  disableAutoCalc, // optional - applies only to { matchUpType: TEAM }\n  enableAutoCalc, // optional - applies only to { matchUpType: TEAM }\n  matchUpTieId, // optional - if part of a TIE matchUp\n  matchUpStatus, // optional - if matchUpFormat differs from event/draw/structure defaults\n  matchUpId,\n  score, // optional - { sets }\n  winningSide,\n  schedule: {\n    // optional - set schedule items\n    scheduledDate,\n    scheduledTime,\n    startTime,\n    endTime,\n  },\n  notes, // optional - add note (string) to matchUp object\n});\n"})}),"\n",(0,i.jsx)(n.hr,{}),"\n",(0,i.jsx)(n.h2,{id:"setorderoffinish",children:"setOrderOfFinish"}),"\n",(0,i.jsxs)(n.p,{children:["Sets the ",(0,i.jsx)(n.code,{children:"orderOfFinish"})," attribute for ",(0,i.jsx)(n.code,{children:"matchUps"})," specified by ",(0,i.jsx)(n.code,{children:"matchUpId"})," in the ",(0,i.jsx)(n.code,{children:"finishingOrder"})," array."]}),"\n",(0,i.jsx)(n.h3,{id:"validation",children:"Validation"}),"\n",(0,i.jsxs)(n.p,{children:["Validation is done within a ",(0,i.jsx)(n.em,{children:"cohort"})," of ",(0,i.jsx)(n.code,{children:"matchUps"})," which have equivalent ",(0,i.jsx)(n.code,{children:"structureId"}),", ",(0,i.jsx)(n.code,{children:"matchUpType"}),", ",(0,i.jsx)(n.code,{children:"roundNumber"}),", and ",(0,i.jsx)(n.code,{children:"matchUpTieId"})," (if applicable)."]}),"\n",(0,i.jsxs)(n.ul,{children:["\n",(0,i.jsxs)(n.li,{children:[(0,i.jsx)(n.code,{children:"matchUpIds"})," in ",(0,i.jsx)(n.code,{children:"finishingOrder"})," must be part of the same ",(0,i.jsx)(n.em,{children:"cohort"})]}),"\n",(0,i.jsxs)(n.li,{children:[(0,i.jsx)(n.code,{children:"orderOfFinish"})," values must be unique positive integers within the ",(0,i.jsx)(n.em,{children:"cohort"})]}),"\n"]}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-js",children:"drawEngine.setOrderOfFinish({\n  finishingOrder: [{ matchUpId, orderOfFinish: 1 }],\n});\n"})}),"\n",(0,i.jsx)(n.hr,{}),"\n",(0,i.jsx)(n.h2,{id:"setparticipants",children:"setParticipants"}),"\n",(0,i.jsxs)(n.p,{children:["Participants are not managed by the ",(0,i.jsx)(n.code,{children:"drawEngine"}),", but they can be used when returning 'inContext' matchUps as well as when automated positioning relies on avoidance policies."]}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-js",children:"drawEngine.setParticipants(participants);\n"})}),"\n",(0,i.jsx)(n.hr,{}),"\n",(0,i.jsx)(n.h2,{id:"setstagealternatescount",children:"setStageAlternatesCount"}),"\n",(0,i.jsx)(n.p,{children:"Sets an (optional) limit to the number of accepted alternates."}),"\n",(0,i.jsx)(n.p,{children:"Modifies the 'entryProfile' of a drawDefinition before the structures have been generated."}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-js",children:"drawEngine.setStageAlternatesCount({ alternatesCount: 8 });\n"})}),"\n",(0,i.jsx)(n.hr,{}),"\n",(0,i.jsx)(n.h2,{id:"setstagedrawsize",children:"setStageDrawSize"}),"\n",(0,i.jsx)(n.p,{children:"Modifies the 'entryProfile' of a drawDefinition before the structures have been generated."}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-js",children:"drawEngine.setStageDrawSize({ stage: QUALIFYING, stageSequence, drawSize: 8 });\ndrawEngine.setStageDrawSize({ stage: MAIN, drawSize: 16 });\n"})}),"\n",(0,i.jsx)(n.hr,{}),"\n",(0,i.jsx)(n.h2,{id:"setstagequalifierscount",children:"setStageQualifiersCount"}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-js",children:"drawEngine.setStageQualifiersCount({\n  qualifiersCount: 4,\n  stageSequence,\n  stage,\n});\n"})}),"\n",(0,i.jsx)(n.hr,{}),"\n",(0,i.jsx)(n.h2,{id:"setstagewildcardscount",children:"setStageWildcardsCount"}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-js",children:"drawEngine.setStageWildcardsCount({ stage, stageSequence, wildcardsCount: 2 });\n"})}),"\n",(0,i.jsx)(n.hr,{}),"\n",(0,i.jsx)(n.h2,{id:"setstate",children:"setState"}),"\n",(0,i.jsx)(n.p,{children:"Loads a drawDefinition into drawEngine."}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-js",children:"drawEngine.setsState(drawDefinition, deepCopy, deepCopyConfig);\n"})}),"\n",(0,i.jsx)(n.admonition,{type:"info",children:(0,i.jsxs)(n.p,{children:["By default a deep copy of the tournament record is made so that mutations made by drawEngine do not affect the source object. An optional boolean parameter, ",(0,i.jsx)(n.em,{children:"deepCopy"})," can be set to false to override this default behavior."]})}),"\n",(0,i.jsx)(n.admonition,{type:"note",children:(0,i.jsxs)(n.p,{children:[(0,i.jsx)(n.code,{children:"deepCopyConfig"})," is an optional configuration for ",(0,i.jsx)(n.code,{children:"makeDeepCopy"}),". In server configurations when ",(0,i.jsx)(n.code,{children:"deepCopy"})," is FALSE and ",(0,i.jsx)(n.code,{children:"tournamentRecords"})," are retrieved from Mongo, for instance, there are scenarios where nodes of the JSON structure contain prototypes which cannot be converted."]})}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-js",children:"const deepCopyConfig = {\n  ignore, // optional - either an array of attributes to ignore or a function which processes attributes to determine whether to ignore them\n  toJSON, // optional - an array of attributes to convert to JSON if the attribute in question is an object with .toJSON property\n  stringify, // optional - an array of attributes to stringify\n  modulate, // optional - function to process every attribute and return custom values, or undefined, which continues normal processing\n};\n"})}),"\n",(0,i.jsx)(n.hr,{}),"\n",(0,i.jsx)(n.h2,{id:"setsuborder",children:"setSubOrder"}),"\n",(0,i.jsx)(n.p,{children:"Used to order ROUND_ROBIN participants when finishingPosition ties cannot be broken algorithmically. Assigns a subOrder value to a participant within a structure by drawPosition."}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-js",children:"drawEngine.setSubOrder({\n  structureId, // structure identifier within drawDefinition\n  drawPosition: 1, // drawPosition of the participant where subOrder is to be added\n  subOrder: 2, // order in which tied participant should receive finishing position\n});\n"})}),"\n",(0,i.jsx)(n.hr,{}),"\n",(0,i.jsx)(n.h2,{id:"swapdrawpositionassignments",children:"swapDrawPositionAssignments"}),"\n",(0,i.jsxs)(n.p,{children:["Swaps the ",(0,i.jsx)(n.code,{children:"participantIds"})," of two ",(0,i.jsx)(n.code,{children:"drawPositions"}),"."]}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-js",children:"drawEngine.swapDrawPositionAssignments({ structureId, drawPositions });\n"})}),"\n",(0,i.jsx)(n.hr,{}),"\n",(0,i.jsx)(n.h2,{id:"getstructurematchups",children:"getStructureMatchUps"}),"\n",(0,i.jsx)(n.p,{children:"Returns categorized matchUps from a single structure."}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-js",children:"const {\n  upcomingMatchUps,\n  pendingMatchUps,\n  completedMatchUps,\n  abandonedMatchUps,\n  byeMatchUps,\n} = drawEngine.getStructureMatchUps({\n  structureId,\n  context, // optional context to be added into matchUps\n  inContext, // boolean - add context { drawId, structureId, participant, individualParticipants ... }\n  nextMatchUps, // optioanl - boolean - to include winnerTo and loserTo\n  matchUpFilters, // attribute filters\n  contextFilters, // filters based on context attributes\n  tournamentParticipants, // optional - provide an array of tournamentParticipants to add into matchUps\n  requireParticipants, // optional - require that participants be loaded into drawEngine or passed into method\n  tournamentAppliedPolicies, // any policies, such as privacy, to be applied to matchUps\n  scheduleVisibilityFilters, // { visibilityThreshold: Date, eventIds, drawIds }\n});\n"})}),"\n",(0,i.jsx)(n.hr,{}),"\n",(0,i.jsx)(n.h2,{id:"validdrawpositions",children:"validDrawPositions"}),"\n",(0,i.jsx)(n.p,{children:"Returns boolean indicating whether all matchUps have valid draw positions"}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-js",children:"drawEngine.validDrawPositions({ matchUps });\n"})}),"\n",(0,i.jsx)(n.hr,{}),"\n",(0,i.jsx)(n.h2,{id:"version",children:"version"}),"\n",(0,i.jsx)(n.p,{children:"Returns NPM package version. Can be used in configurations that utilize Competition Factory engines on both client and server to ensure equivalency."}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-js",children:"const version = drawEngine.version();\n"})}),"\n",(0,i.jsx)(n.hr,{})]})}function h(e={}){const{wrapper:n}={...(0,a.ah)(),...e.components};return n?(0,i.jsx)(n,{...e,children:(0,i.jsx)(l,{...e})}):l(e)}},7942:(e,n,t)=>{t.d(n,{ah:()=>c});var i=t(959);function a(e,n,t){return n in e?Object.defineProperty(e,n,{value:t,enumerable:!0,configurable:!0,writable:!0}):e[n]=t,e}function s(e,n){var t=Object.keys(e);if(Object.getOwnPropertySymbols){var i=Object.getOwnPropertySymbols(e);n&&(i=i.filter((function(n){return Object.getOwnPropertyDescriptor(e,n).enumerable}))),t.push.apply(t,i)}return t}function r(e){for(var n=1;n<arguments.length;n++){var t=null!=arguments[n]?arguments[n]:{};n%2?s(Object(t),!0).forEach((function(n){a(e,n,t[n])})):Object.getOwnPropertyDescriptors?Object.defineProperties(e,Object.getOwnPropertyDescriptors(t)):s(Object(t)).forEach((function(n){Object.defineProperty(e,n,Object.getOwnPropertyDescriptor(t,n))}))}return e}function o(e,n){if(null==e)return{};var t,i,a=function(e,n){if(null==e)return{};var t,i,a={},s=Object.keys(e);for(i=0;i<s.length;i++)t=s[i],n.indexOf(t)>=0||(a[t]=e[t]);return a}(e,n);if(Object.getOwnPropertySymbols){var s=Object.getOwnPropertySymbols(e);for(i=0;i<s.length;i++)t=s[i],n.indexOf(t)>=0||Object.prototype.propertyIsEnumerable.call(e,t)&&(a[t]=e[t])}return a}var d=i.createContext({}),c=function(e){var n=i.useContext(d),t=n;return e&&(t="function"==typeof e?e(n):r(r({},n),e)),t},l={inlineCode:"code",wrapper:function(e){var n=e.children;return i.createElement(i.Fragment,{},n)}},h=i.forwardRef((function(e,n){var t=e.components,a=e.mdxType,s=e.originalType,d=e.parentName,h=o(e,["components","mdxType","originalType","parentName"]),u=c(t),p=a,g=u["".concat(d,".").concat(p)]||u[p]||l[p]||s;return t?i.createElement(g,r(r({ref:n},h),{},{components:t})):i.createElement(g,r({ref:n},h))}));h.displayName="MDXCreateElement"}}]);