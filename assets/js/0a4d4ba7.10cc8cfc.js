"use strict";(self.webpackChunkdocumentation=self.webpackChunkdocumentation||[]).push([[196],{3905:(e,t,n)=>{n.d(t,{Zo:()=>p,kt:()=>m});var a=n(7294);function i(e,t,n){return t in e?Object.defineProperty(e,t,{value:n,enumerable:!0,configurable:!0,writable:!0}):e[t]=n,e}function r(e,t){var n=Object.keys(e);if(Object.getOwnPropertySymbols){var a=Object.getOwnPropertySymbols(e);t&&(a=a.filter((function(t){return Object.getOwnPropertyDescriptor(e,t).enumerable}))),n.push.apply(n,a)}return n}function o(e){for(var t=1;t<arguments.length;t++){var n=null!=arguments[t]?arguments[t]:{};t%2?r(Object(n),!0).forEach((function(t){i(e,t,n[t])})):Object.getOwnPropertyDescriptors?Object.defineProperties(e,Object.getOwnPropertyDescriptors(n)):r(Object(n)).forEach((function(t){Object.defineProperty(e,t,Object.getOwnPropertyDescriptor(n,t))}))}return e}function l(e,t){if(null==e)return{};var n,a,i=function(e,t){if(null==e)return{};var n,a,i={},r=Object.keys(e);for(a=0;a<r.length;a++)n=r[a],t.indexOf(n)>=0||(i[n]=e[n]);return i}(e,t);if(Object.getOwnPropertySymbols){var r=Object.getOwnPropertySymbols(e);for(a=0;a<r.length;a++)n=r[a],t.indexOf(n)>=0||Object.prototype.propertyIsEnumerable.call(e,n)&&(i[n]=e[n])}return i}var s=a.createContext({}),d=function(e){var t=a.useContext(s),n=t;return e&&(n="function"==typeof e?e(t):o(o({},t),e)),n},p=function(e){var t=d(e.components);return a.createElement(s.Provider,{value:t},e.children)},u={inlineCode:"code",wrapper:function(e){var t=e.children;return a.createElement(a.Fragment,{},t)}},c=a.forwardRef((function(e,t){var n=e.components,i=e.mdxType,r=e.originalType,s=e.parentName,p=l(e,["components","mdxType","originalType","parentName"]),c=d(n),m=i,h=c["".concat(s,".").concat(m)]||c[m]||u[m]||r;return n?a.createElement(h,o(o({ref:t},p),{},{components:n})):a.createElement(h,o({ref:t},p))}));function m(e,t){var n=arguments,i=t&&t.mdxType;if("string"==typeof e||i){var r=n.length,o=new Array(r);o[0]=c;var l={};for(var s in t)hasOwnProperty.call(t,s)&&(l[s]=t[s]);l.originalType=e,l.mdxType="string"==typeof e?e:i,o[1]=l;for(var d=2;d<r;d++)o[d]=n[d];return a.createElement.apply(null,o)}return a.createElement.apply(null,n)}c.displayName="MDXCreateElement"},1719:(e,t,n)=>{n.r(t),n.d(t,{assets:()=>s,contentTitle:()=>o,default:()=>u,frontMatter:()=>r,metadata:()=>l,toc:()=>d});var a=n(7462),i=(n(7294),n(3905));const r={title:"tournamentEngine API"},o=void 0,l={unversionedId:"apis/tournament-engine-api",id:"apis/tournament-engine-api",title:"tournamentEngine API",description:"All _tournamentEngine_ methods which make a mutation return either { success: true } or { error }",source:"@site/docs/apis/tournament-engine-api.md",sourceDirName:"apis",slug:"/apis/tournament-engine-api",permalink:"/tods-competition-factory/docs/apis/tournament-engine-api",draft:!1,tags:[],version:"current",frontMatter:{title:"tournamentEngine API"},sidebar:"docs",previous:{title:"Tournament Engine",permalink:"/tods-competition-factory/docs/engines/tournament-engine-overview"},next:{title:"Draw Engine",permalink:"/tods-competition-factory/docs/engines/draw-engine-overview"}},s={},d=[{value:"addAdHocMatchUps",id:"addadhocmatchups",level:2},{value:"addCollectionDefinition",id:"addcollectiondefinition",level:2},{value:"addCollectionGroup",id:"addcollectiongroup",level:2},{value:"addCourt",id:"addcourt",level:2},{value:"addCourts",id:"addcourts",level:2},{value:"addDrawDefinition",id:"adddrawdefinition",level:2},{value:"addDrawDefinitionExtension",id:"adddrawdefinitionextension",level:2},{value:"addDrawEntries",id:"adddrawentries",level:2},{value:"addEvent",id:"addevent",level:2},{value:"addEventEntries",id:"addevententries",level:2},{value:"addEventEntryPairs",id:"addevententrypairs",level:2},{value:"addEventExtension",id:"addeventextension",level:2},{value:"addFlight",id:"addflight",level:2},{value:"addIndividualParticipantIds",id:"addindividualparticipantids",level:2},{value:"addMatchUpEndTime",id:"addmatchupendtime",level:2},{value:"addMatchUpOfficial",id:"addmatchupofficial",level:2},{value:"addMatchUpResumeTime",id:"addmatchupresumetime",level:2},{value:"addMatchUpScheduledDate",id:"addmatchupscheduleddate",level:2},{value:"addMatchUpScheduledTime",id:"addmatchupscheduledtime",level:2},{value:"addMatchUpScheduleItems",id:"addmatchupscheduleitems",level:2},{value:"addMatchUpStartTime",id:"addmatchupstarttime",level:2},{value:"addMatchUpStopTime",id:"addmatchupstoptime",level:2},{value:"addParticipant",id:"addparticipant",level:2},{value:"addParticipants",id:"addparticipants",level:2},{value:"addPenalty",id:"addpenalty",level:2},{value:"addPersons",id:"addpersons",level:2},{value:"addPlayoffStructures",id:"addplayoffstructures",level:2},{value:"addQualifyingStructure",id:"addqualifyingstructure",level:2},{value:"addTournamentExtension",id:"addtournamentextension",level:2},{value:"addVenue",id:"addvenue",level:2},{value:"addVoluntaryConsolationStage",id:"addvoluntaryconsolationstage",level:2},{value:"addVoluntaryConsolationStructure",id:"addvoluntaryconsolationstructure",level:2},{value:"allDrawMatchUps",id:"alldrawmatchups",level:2},{value:"allEventMatchUps",id:"alleventmatchups",level:2},{value:"allTournamentMatchUps",id:"alltournamentmatchups",level:2},{value:"alternateDrawPositionAssignment",id:"alternatedrawpositionassignment",level:2},{value:"applyLinueUps",id:"applylinueups",level:2},{value:"assignDrawPosition",id:"assigndrawposition",level:2},{value:"assignMatchUpCourt",id:"assignmatchupcourt",level:2},{value:"assignMatchUpVenue",id:"assignmatchupvenue",level:2},{value:"assignSeedPositions",id:"assignseedpositions",level:2},{value:"assignTieMatchUpParticipantId",id:"assigntiematchupparticipantid",level:2},{value:"attachEventPolicies",id:"attacheventpolicies",level:2},{value:"attachFlightProfile",id:"attachflightprofile",level:2},{value:"attachPlayoffStructures",id:"attachplayoffstructures",level:2},{value:"attachPolicies",id:"attachpolicies",level:2},{value:"attachQualifyingStructure",id:"attachqualifyingstructure",level:2},{value:"attachStructures",id:"attachstructures",level:2},{value:"automatedPlayoffPositioning",id:"automatedplayoffpositioning",level:2},{value:"automatedPositioning",id:"automatedpositioning",level:2},{value:"autoSeeding",id:"autoseeding",level:2},{value:"bulkMatchUpStatusUpdate",id:"bulkmatchupstatusupdate",level:2},{value:"bulkRescheduleMatchUps",id:"bulkreschedulematchups",level:2},{value:"bulkScheduleMatchUps",id:"bulkschedulematchups",level:2},{value:"bulkUpdatePublishedEventIds",id:"bulkupdatepublishedeventids",level:2},{value:"checkInParticipant",id:"checkinparticipant",level:2},{value:"checkOutParticipant",id:"checkoutparticipant",level:2},{value:"clearMatchUpSchedule",id:"clearmatchupschedule",level:2},{value:"clearScheduledMatchUps",id:"clearscheduledmatchups",level:2},{value:"deleteAdHocMatchUps",id:"deleteadhocmatchups",level:2},{value:"deleteCourt",id:"deletecourt",level:2},{value:"deleteDrawDefinitions",id:"deletedrawdefinitions",level:2},{value:"deleteFlightAndFlightDraw",id:"deleteflightandflightdraw",level:2},{value:"deleteFlightProfileAndFlightDraws",id:"deleteflightprofileandflightdraws",level:2},{value:"deleteEvents",id:"deleteevents",level:2},{value:"deleteParticipants",id:"deleteparticipants",level:2},{value:"deleteVenue",id:"deletevenue",level:2},{value:"deleteVenues",id:"deletevenues",level:2},{value:"destroyGroupEntry",id:"destroygroupentry",level:2},{value:"destroyPairEntry",id:"destroypairentry",level:2},{value:"devContext",id:"devcontext",level:2},{value:"disableCourts",id:"disablecourts",level:2},{value:"disableTiaAutoCalc",id:"disabletiaautocalc",level:2},{value:"disableVenues",id:"disablevenues",level:2},{value:"drawMatic",id:"drawmatic",level:2},{value:"enableCourts",id:"enablecourts",level:2},{value:"enableTiaAutoCalc",id:"enabletiaautocalc",level:2},{value:"enableVenues",id:"enablevenues",level:2},{value:"eventMatchUps",id:"eventmatchups",level:2},{value:"executionQueue",id:"executionqueue",level:2},{value:"findCourt",id:"findcourt",level:2},{value:"findDrawDefinitionExtension",id:"finddrawdefinitionextension",level:2},{value:"findEventExtension",id:"findeventextension",level:2},{value:"findMatchUp",id:"findmatchup",level:2},{value:"findParticipant",id:"findparticipant",level:2},{value:"findParticipantExtension",id:"findparticipantextension",level:2},{value:"findPolicy",id:"findpolicy",level:2},{value:"findTournamentExtension",id:"findtournamentextension",level:2},{value:"findVenue",id:"findvenue",level:2},{value:"generateAdHocMatchUps",id:"generateadhocmatchups",level:2},{value:"generateAndPopulatePlayoffStructures",id:"generateandpopulateplayoffstructures",level:2},{value:"generateDrawDefinition",id:"generatedrawdefinition",level:2},{value:"generateFlightProfile",id:"generateflightprofile",level:2},{value:"generateQualifyingStructure",id:"generatequalifyingstructure",level:2},{value:"generateSeedingScaleItems",id:"generateseedingscaleitems",level:2},{value:"generateTeamsFromParticipantAttribute",id:"generateteamsfromparticipantattribute",level:2},{value:"generateVolunataryConsolation",id:"generatevolunataryconsolation",level:2},{value:"getAllEventData",id:"getalleventdata",level:2},{value:"getAllowedDrawTypes",id:"getalloweddrawtypes",level:2},{value:"getAllowedMatchUpFormats",id:"getallowedmatchupformats",level:2},{value:"getAvailablePlayoffRounds",id:"getavailableplayoffrounds",level:2},{value:"getCourtInfo",id:"getcourtinfo",level:2},{value:"getCourts",id:"getcourts",level:2},{value:"getDrawData",id:"getdrawdata",level:2},{value:"getDrawParticipantRepresentativeIds",id:"getdrawparticipantrepresentativeids",level:2},{value:"getEligibleVoluntaryConsolationParticipants",id:"geteligiblevoluntaryconsolationparticipants",level:2},{value:"getEntriesAndSeedsCount",id:"getentriesandseedscount",level:2},{value:"getEntryStatusReports",id:"getentrystatusreports",level:2},{value:"getEvent",id:"getevent",level:2},{value:"getEvents",id:"getevents",level:2},{value:"getEventData",id:"geteventdata",level:2},{value:"getEventProperties",id:"geteventproperties",level:2},{value:"getEventMatchUpFormatTiming",id:"geteventmatchupformattiming",level:2},{value:"getEventStructures",id:"geteventstructures",level:2},{value:"getFlightProfile",id:"getflightprofile",level:2},{value:"getMatchUpCompetitiveness",id:"getmatchupcompetitiveness",level:2},{value:"getMatchUpFormat",id:"getmatchupformat",level:2},{value:"getMatchUpFormatTiming",id:"getmatchupformattiming",level:2},{value:"getMatchUpFormatTimingUpdate",id:"getmatchupformattimingupdate",level:2},{value:"getMatchUpScheduleDetails",id:"getmatchupscheduledetails",level:2},{value:"getMatchUpsStats",id:"getmatchupsstats",level:2},{value:"getMatchUpDailyLimits",id:"getmatchupdailylimits",level:2},{value:"getModifiedMatchUpFormatTiming",id:"getmodifiedmatchupformattiming",level:2},{value:"getPairedParticipant",id:"getpairedparticipant",level:2},{value:"getParticipantEventDetails",id:"getparticipanteventdetails",level:2},{value:"getParticipantIdFinishingPositions",id:"getparticipantidfinishingpositions",level:2},{value:"getParticipantMembership",id:"getparticipantmembership",level:2},{value:"getParticipantScaleItem",id:"getparticipantscaleitem",level:2},{value:"getParticipantSchedules",id:"getparticipantschedules",level:2},{value:"getParticipantSignInStatus",id:"getparticipantsigninstatus",level:2},{value:"getPolicyDefinitions",id:"getpolicydefinitions",level:2},{value:"getPositionAssignments",id:"getpositionassignments",level:2},{value:"getPredictiveAccuracy",id:"getpredictiveaccuracy",level:2},{value:"getScaledEntries",id:"getscaledentries",level:2},{value:"getSeedsCount",id:"getseedscount",level:2},{value:"getState",id:"getstate",level:2},{value:"getStructureReports",id:"getstructurereports",level:2},{value:"getTeamLineUp",id:"getteamlineup",level:2},{value:"getTieFormat",id:"gettieformat",level:2},{value:"getTournamentInfo",id:"gettournamentinfo",level:2},{value:"getTournamentParticipants",id:"gettournamentparticipants",level:2},{value:"Implemented participantFilters",id:"implemented-participantfilters",level:3},{value:"getTournamentPersons",id:"gettournamentpersons",level:2},{value:"getTournamentPenalties",id:"gettournamentpenalties",level:2},{value:"getTournamentStructures",id:"gettournamentstructures",level:2},{value:"getVenuesAndCourts",id:"getvenuesandcourts",level:2},{value:"getVenueData",id:"getvenuedata",level:2},{value:"isValidMatchUpFormat",id:"isvalidmatchupformat",level:2},{value:"luckyLoserDrawPositionAssignment",id:"luckyloserdrawpositionassignment",level:2},{value:"matchUpActions",id:"matchupactions",level:2},{value:"mergeParticipants",id:"mergeparticipants",level:2},{value:"modifyCollectionDefinition",id:"modifycollectiondefinition",level:2},{value:"modifyCourt",id:"modifycourt",level:2},{value:"modifyCourtAvailability",id:"modifycourtavailability",level:2},{value:"modifyDrawName",id:"modifydrawname",level:2},{value:"modifyEventMatchUpFormatTiming",id:"modifyeventmatchupformattiming",level:2},{value:"modifyMatchUpFormatTiming",id:"modifymatchupformattiming",level:2},{value:"modifyEntriesStatus",id:"modifyentriesstatus",level:2},{value:"modifyEventEntries",id:"modifyevententries",level:2},{value:"modifyIndividualParticipantIds",id:"modifyindividualparticipantids",level:2},{value:"modifyParticipant",id:"modifyparticipant",level:2},{value:"modifyPenalty",id:"modifypenalty",level:2},{value:"modifyParticipantsSignInStatus",id:"modifyparticipantssigninstatus",level:2},{value:"modifySeedAssignment",id:"modifyseedassignment",level:2},{value:"modifyVenue",id:"modifyvenue",level:2},{value:"newTournamentRecord",id:"newtournamentrecord",level:2},{value:"orderCollectionDefinitions",id:"ordercollectiondefinitions",level:2},{value:"participantScaleItem",id:"participantscaleitem",level:2},{value:"participantScheduledMatchUps",id:"participantscheduledmatchups",level:2},{value:"positionActions",id:"positionactions",level:2},{value:"promoteAlternates",id:"promotealternates",level:2},{value:"publishEvent",id:"publishevent",level:2},{value:"publishEventSeeding",id:"publisheventseeding",level:2},{value:"publishOrderOfPlay",id:"publishorderofplay",level:2},{value:"qualifierDrawPositionAssignment",id:"qualifierdrawpositionassignment",level:2},{value:"removeCollectionDefinition",id:"removecollectiondefinition",level:2},{value:"removeCollectionGroup",id:"removecollectiongroup",level:2},{value:"removeDrawDefinitionExtension",id:"removedrawdefinitionextension",level:2},{value:"removeDrawPositionAssignment",id:"removedrawpositionassignment",level:2},{value:"removeDrawEntries",id:"removedrawentries",level:2},{value:"removeEventEntries",id:"removeevententries",level:2},{value:"removeEventExtension",id:"removeeventextension",level:2},{value:"removeEventMatchUpFormatTiming",id:"removeeventmatchupformattiming",level:2},{value:"removeEventPolicy",id:"removeeventpolicy",level:2},{value:"removeIndividualParticipantIds",id:"removeindividualparticipantids",level:2},{value:"removeParticipantIdsFromAllTeams",id:"removeparticipantidsfromallteams",level:2},{value:"removeParticipantExtension",id:"removeparticipantextension",level:2},{value:"removePenalty",id:"removepenalty",level:2},{value:"removeScaleValues",id:"removescalevalues",level:2},{value:"removeSeeding",id:"removeseeding",level:2},{value:"removeStructure",id:"removestructure",level:2},{value:"removeTieMatchUpParticipantId",id:"removetiematchupparticipantid",level:2},{value:"removeTournamentExtension",id:"removetournamentextension",level:2},{value:"replaceTieMatchUpParticipantId",id:"replacetiematchupparticipantid",level:2},{value:"resetDrawDefinition",id:"resetdrawdefinition",level:2},{value:"resetScorecard",id:"resetscorecard",level:2},{value:"resetTieFormat",id:"resettieformat",level:2},{value:"resetVoluntaryConsolationStructure",id:"resetvoluntaryconsolationstructure",level:2},{value:"scaledTeamAssignment",id:"scaledteamassignment",level:2},{value:"Example use with <code>individualParticipantIds</code> and <code>scaleAttributes</code>",id:"example-use-with-individualparticipantids-and-scaleattributes",level:3},{value:"Example use with <code>scaledParticipants</code>",id:"example-use-with-scaledparticipants",level:3},{value:"Example use with sequential assignment where there are 8 teams",id:"example-use-with-sequential-assignment-where-there-are-8-teams",level:3},{value:"setDrawParticipantRepresentativeIds",id:"setdrawparticipantrepresentativeids",level:2},{value:"setEventDates",id:"seteventdates",level:2},{value:"setEventEndDate",id:"seteventenddate",level:2},{value:"setEventStartDate",id:"seteventstartdate",level:2},{value:"setMatchUpDailyLimits",id:"setmatchupdailylimits",level:2},{value:"setMatchUpFormat",id:"setmatchupformat",level:2},{value:"setMatchUpStatus",id:"setmatchupstatus",level:2},{value:"setOrderOfFinish",id:"setorderoffinish",level:2},{value:"Validation",id:"validation",level:3},{value:"setParticipantScaleItem",id:"setparticipantscaleitem",level:2},{value:"setParticipantScaleItems",id:"setparticipantscaleitems",level:2},{value:"setPositionAssignments",id:"setpositionassignments",level:2},{value:"setState",id:"setstate",level:2},{value:"setSubOrder",id:"setsuborder",level:2},{value:"setTournamentCategories",id:"settournamentcategories",level:2},{value:"setTournamentDates",id:"settournamentdates",level:2},{value:"setTournamentEndDate",id:"settournamentenddate",level:2},{value:"setTournamentId",id:"settournamentid",level:2},{value:"setTournamentName",id:"settournamentname",level:2},{value:"setTournamentNotes",id:"settournamentnotes",level:2},{value:"setTournamentStartDate",id:"settournamentstartdate",level:2},{value:"toggleParticipantCheckInState",id:"toggleparticipantcheckinstate",level:2},{value:"tournamentMatchUps",id:"tournamentmatchups",level:2},{value:"unPublishEvent",id:"unpublishevent",level:2},{value:"unPublishEventSeeding",id:"unpublisheventseeding",level:2},{value:"unPublishOrderOfPlay",id:"unpublishorderofplay",level:2},{value:"updateDrawIdsOrder",id:"updatedrawidsorder",level:2},{value:"updateTeamLineUp",id:"updateteamlineup",level:2},{value:"withdrawParticipantAtDrawPosition",id:"withdrawparticipantatdrawposition",level:2},{value:"validateTeamLineUp",id:"validateteamlineup",level:2},{value:"version",id:"version",level:2}],p={toc:d};function u(e){let{components:t,...n}=e;return(0,i.kt)("wrapper",(0,a.Z)({},p,n,{components:t,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"All ",(0,i.kt)("strong",{parentName:"p"},(0,i.kt)("em",{parentName:"strong"},"tournamentEngine"))," methods which make a mutation return either ",(0,i.kt)("inlineCode",{parentName:"p"},"{ success: true }")," or ",(0,i.kt)("inlineCode",{parentName:"p"},"{ error }")),(0,i.kt)("hr",null),(0,i.kt)("h2",{id:"addadhocmatchups"},"addAdHocMatchUps"),(0,i.kt)("p",null,"Adds ",(0,i.kt)("inlineCode",{parentName:"p"},"matchUps")," generated by ",(0,i.kt)("a",{parentName:"p",href:"#generateAdHocMatchUps"},"generateAdHocMatchUps")," to specified structure within an AD_HOC ",(0,i.kt)("inlineCode",{parentName:"p"},"drawDefinition"),"."),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-js"},"  tournamentEngine.addAdHocMatchUps({\n    structureId,\n    matchUps,\n    drawId,\n  }\n")),(0,i.kt)("hr",null),(0,i.kt)("h2",{id:"addcollectiondefinition"},"addCollectionDefinition"),(0,i.kt)("p",null,"Adds a ",(0,i.kt)("inlineCode",{parentName:"p"},"collectionDefinition")," to the specified target, either ",(0,i.kt)("inlineCode",{parentName:"p"},"matchUp"),", ",(0,i.kt)("inlineCode",{parentName:"p"},"structure"),", ",(0,i.kt)("inlineCode",{parentName:"p"},"drawDefinition")," or ",(0,i.kt)("inlineCode",{parentName:"p"},"event"),"."),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-js"},"tournamentEngine.addCollectionDefinition({\n  updateInProgressMatchUps, // defaults to true; in progress matchUps have matchUpStatus: IN_PROGRESS\n  collectionDefinition, // will be validated\n  tieFormatName, // if not provided, existing tieFormatName will be deleted\n  structureId, // optional - if provided only tieFormat on structure will be modified\n  matchUpId, // optional - if provided only tieFormat on matchUp will be modified\n  eventId, // optional - if provided only tieFormat on event will be modified\n  drawId, // required if structureId is specified; if provided without structureId only tieFormat on drawDefinition will be modified\n  uuids, // optional - array of UUIDs to use for newly created matchUps\n});\n")),(0,i.kt)("hr",null),(0,i.kt)("h2",{id:"addcollectiongroup"},"addCollectionGroup"),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-js"},"tournamentEngine.addCollectionGroup({\n  collectionIds: result.modifiedCollectionIds,\n  tieFormatName: 'Swelled',\n  groupDefinition,\n  structureId, // optional - if provided only tieFormat on structure will be modified\n  matchUpId, // optional - if provided only tieFormat on matchUp will be modified\n  eventId, // optional - if provided only tieFormat on event will be modified\n  drawId, // required if structureId is specified; if provided without structureId only tieFormat on drawDefinition will be modified\n});\n")),(0,i.kt)("hr",null),(0,i.kt)("h2",{id:"addcourt"},"addCourt"),(0,i.kt)("p",null,"Add a court to a Venue. See ",(0,i.kt)("strong",{parentName:"p"},"court")," under ",(0,i.kt)("strong",{parentName:"p"},"venue")," in ",(0,i.kt)("a",{parentName:"p",href:"/docs/types/typedefs#venue"},"Type Defs"),"."),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-js"},"const court = {\n  altitude, // optional\n  courtDimensions, // optional\n  courtId, // generated automatically if not provided\n  courtName,\n  dateAvailability, // optional - see below\n  latitude, // optional\n  longitude, // optional\n  onlineResources,  // optional\n  pace, // optional - string; ITF enums\n  surfaceCategory, // optional - surface constant, e.g. CLAY, HARD, GRASS, CARPET, or ARTIFICIAL\n  surfaceType, // string; see: https://www.itftennis.com/en/about-us/tennis-tech/recognised-courts/\n  surfacedDate?: Date;\n}\n\ntournamentEngine.addCourt({ venueId, court });\n")),(0,i.kt)("hr",null),(0,i.kt)("h2",{id:"addcourts"},"addCourts"),(0,i.kt)("p",null,"Convenience function to bulk add courts to a Venue. Only adds ",(0,i.kt)("strong",{parentName:"p"},"dataAvailability")," and ",(0,i.kt)("strong",{parentName:"p"},"courtName"),". See ",(0,i.kt)("a",{parentName:"p",href:"/docs/concepts/scheduling"},"Scheduling"),"."),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-js"},"const dateAvailability = [\n  {\n    date: '2020-01-01T00:00', // if no date is provided then this profile will be used as default\n    startTime: '07:00',\n    endTime: '19:00',\n    bookings: [\n      { startTime: '07:00', endTime: '08:30', bookingType: 'PRACTICE' },\n      { startTime: '08:30', endTime: '09:00', bookingType: 'MAINTENANCE' },\n      { startTime: '13:30', endTime: '14:00', bookingType: 'MAINTENANCE' },\n    ],\n  },\n];\ntournamentEngine.addCourts({\n  courtNames: ['Court 1', 'Court 2', 'Court 3'], // optional\n  courtsCount: 3, // optional, can be added/modified later; also can be derived from courtNames.length\n  dateAvailability, // optional\n  venueId,\n});\n")),(0,i.kt)("hr",null),(0,i.kt)("h2",{id:"adddrawdefinition"},"addDrawDefinition"),(0,i.kt)("p",null,"Adds a drawDefinition to an event in a tournamentRecord. Called after ",(0,i.kt)("a",{parentName:"p",href:"#generatedrawdefinition"},"generateDrawDefinition"),"."),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-js"},"const { drawDefinition, error } =\n  tournamentEngine.generateDrawDefinition(drawDefinitionValues);\nif (!error) {\n  const result = tournamentEngine.addDrawDefinition({\n    modifyEventEntries, // event.entries[{entryStatus}] are modified to match draw.entries[{entryStatus}]\n    existingDrawCount, // number of draws that exist in the event, used to check that two clients don't attempt to add simultaneously\n    allowReplacement, // optional - defaults to false\n    checkEntryStatus, // optional - defualts to false\n    drawDefinition,\n    eventId,\n    flight, // optional - pass flight definition object for integrity check\n  });\n}\n")),(0,i.kt)("hr",null),(0,i.kt)("h2",{id:"adddrawdefinitionextension"},"addDrawDefinitionExtension"),(0,i.kt)("p",null,"Add an extension to a drawDefinition."),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-js"},"tournamentEngine.addDrawDefinitionExtension({\n  extension: {\n    name: 'extension name',\n    value: {},\n  },\n});\n")),(0,i.kt)("hr",null),(0,i.kt)("h2",{id:"adddrawentries"},"addDrawEntries"),(0,i.kt)("p",null,"Bulk add an array of ",(0,i.kt)("inlineCode",{parentName:"p"},"participantIds")," to a specific ",(0,i.kt)("strong",{parentName:"p"},"stage")," of a draw with a specific ",(0,i.kt)("strong",{parentName:"p"},"entryStatus"),". Will fail if ",(0,i.kt)("inlineCode",{parentName:"p"},"participantIds")," are not already present in ",(0,i.kt)("inlineCode",{parentName:"p"},"event.entries"),". Use ",(0,i.kt)("inlineCode",{parentName:"p"},"addEventEntries")," to add to both ",(0,i.kt)("inlineCode",{parentName:"p"},"event")," and ",(0,i.kt)("inlineCode",{parentName:"p"},"drawDefinition")," at the same time."),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-js"},"tournamentEngine.addDrawEntries({\n  entryStage: MAIN, // optional\n  entryStatus: ALTERNATE, // optional\n  ignoreStageSpace, // optional boolean to disable checking available positions\n  entryStageSequence, // optional - applies to qualifying\n  autoEntryPositions, // optional - keeps entries ordered by entryStage/entryStatus and auto-increments\n  participantIds,\n  eventId,\n  drawId,\n});\n")),(0,i.kt)("hr",null),(0,i.kt)("h2",{id:"addevent"},"addEvent"),(0,i.kt)("p",null,"Add an event object to a tournamentRecord."),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-js"},"tournamentEngine.addEvent({ event });\n")),(0,i.kt)("hr",null),(0,i.kt)("h2",{id:"addevententries"},"addEventEntries"),(0,i.kt)("p",null,"Adds ",(0,i.kt)("inlineCode",{parentName:"p"},"participantIds")," to ",(0,i.kt)("inlineCode",{parentName:"p"},"event.entries"),"; optionally pass drawId to add participantIds to ",(0,i.kt)("inlineCode",{parentName:"p"},"flightProfile.drawEntries")," at the same time."),(0,i.kt)("admonition",{type:"note"},(0,i.kt)("p",{parentName:"admonition"},"Will ",(0,i.kt)("strong",{parentName:"p"},(0,i.kt)("em",{parentName:"strong"},"not"))," throw an error if unable to add entries into specified ",(0,i.kt)("inlineCode",{parentName:"p"},"flightProfile.drawEntries"),",\nwhich can occur if a ",(0,i.kt)("inlineCode",{parentName:"p"},"drawDefinition")," has already been generated and an attempt is made to add\na participant with ",(0,i.kt)("inlineCode",{parentName:"p"},"entryStatus: DIRECT_ACCEPTANCE"),".")),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-js"},"tournamentEngine.addEventEntries({\n  eventId,\n  participantIds,\n  stage: MAIN, // optional\n  entryStatus: ALTERNATE, // optional\n  autoEntryPositions, // optional - keeps entries ordered by entryStage/entryStatus and auto-increments\n  drawId, // optional - will add participantIds to specified flightProfile.flight[].drawEntries and drawDefinition.entries (if possible)\n});\n")),(0,i.kt)("hr",null),(0,i.kt)("h2",{id:"addevententrypairs"},"addEventEntryPairs"),(0,i.kt)("p",null,"Add ",(0,i.kt)("strong",{parentName:"p"},"PAIR")," participant to an event. Creates new ",(0,i.kt)("inlineCode",{parentName:"p"},"{ participantType: PAIR }")," participants if the combination of ",(0,i.kt)("inlineCode",{parentName:"p"},"individualParticipantIds")," does not already exist."),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-js"},"tournamentEngine.addEventEntryPairs({\n  allowDuplicateParticipantIdPairs, // optional - boolean - allow multiple pair participants with the same individualParticipantIds\n  uuids, // optional - array of UUIDs to use for newly created pairs\n  entryStatus: ALTERNATE, // optional\n  entryStage: QUALIFYING, // optional\n  participantIdPairs,\n  eventId,\n});\n")),(0,i.kt)("hr",null),(0,i.kt)("h2",{id:"addeventextension"},"addEventExtension"),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-js"},"tournamentEngine.addEventExtension({\n  extension: {\n    name: 'extension name',\n    value: {},\n  },\n});\n")),(0,i.kt)("hr",null),(0,i.kt)("h2",{id:"addflight"},"addFlight"),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-js"},"tournamentEngine.addFlight({\n  eventId,\n  stage,\n  drawName,\n  drawId, // optional -- if scenario involves client and server side tournamentEngines, provide { drawId: UUID() }\n  drawEntries, // optional\n});\n")),(0,i.kt)("hr",null),(0,i.kt)("h2",{id:"addindividualparticipantids"},"addIndividualParticipantIds"),(0,i.kt)("p",null,"Adds individualParticipantIds to GROUP or TEAM participants"),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-js"},"tournamentEngine.addIndividualParticipantIds({\n  groupingParticipantId,\n  individualParticipantIds,\n  removeFromOtherTeams, // optional boolean\n});\n")),(0,i.kt)("hr",null),(0,i.kt)("h2",{id:"addmatchupendtime"},"addMatchUpEndTime"),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-js"},"const endTime = '2020-01-01T09:05:00Z';\ntournamentEngine.addMatchUpEndTime({\n  validateTimeSeries, // optional - true by default - when false does not verify endTime is later than startTime\n  disableNotice, // when disabled subscribers will not be notified\n  matchUpId,\n  endTime,\n  drawId,\n});\n")),(0,i.kt)("hr",null),(0,i.kt)("h2",{id:"addmatchupofficial"},"addMatchUpOfficial"),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-js"},"tournamentEngine.addMatchUpOfficial({\n  drawId,\n  matchUpId,\n  participantId,\n  officialType,\n  disableNotice, // when disabled subscribers will not be notified\n});\n")),(0,i.kt)("hr",null),(0,i.kt)("h2",{id:"addmatchupresumetime"},"addMatchUpResumeTime"),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-js"},"const resumeTime = '2020-01-01T09:00:00Z';\ntournamentEngine.addMatchUpResumeTime({\n  drawId,\n  matchUpId,\n  resumeTime,\n  disableNotice, // when disabled subscribers will not be notified\n});\n")),(0,i.kt)("hr",null),(0,i.kt)("h2",{id:"addmatchupscheduleddate"},"addMatchUpScheduledDate"),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-js"},"const scheduledDate = '2020-01-01';\ntournamentEngine.addMatchUpScheduledDate({\n  drawId,\n  matchUpId,\n  scheduledDate,\n  disableNotice, // when disabled subscribers will not be notified\n});\n")),(0,i.kt)("hr",null),(0,i.kt)("h2",{id:"addmatchupscheduledtime"},"addMatchUpScheduledTime"),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-js"},"const scheduledTime = '08:00';\ntournamentEngine.addMatchUpScheduledTime({\n  drawId,\n  matchUpId,\n  scheduledTime,\n  disableNotice, // when disabled subscribers will not be notified\n});\n")),(0,i.kt)("hr",null),(0,i.kt)("h2",{id:"addmatchupscheduleitems"},"addMatchUpScheduleItems"),(0,i.kt)("p",null,"Convenience function to add several schedule items at once."),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-js"},"tournamentEngine.addMatchUpScheduleItems({\n  drawId,\n  matchUpId,\n  schedule: {\n    courtId, // requires scheduledDate\n    venueId,\n    scheduledTime,\n    scheduledDate,\n    startTime,\n    endTime,\n  },\n  disableNotice, // when disabled subscribers will not be notified\n});\n")),(0,i.kt)("hr",null),(0,i.kt)("h2",{id:"addmatchupstarttime"},"addMatchUpStartTime"),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-js"},"const startTime = '2020-01-01T08:05:00Z';\ntournamentEngine.addMatchUpStartTime({\n  drawId,\n  matchUpId,\n  startTime,\n  disableNotice, // when disabled subscribers will not be notified\n});\n")),(0,i.kt)("hr",null),(0,i.kt)("h2",{id:"addmatchupstoptime"},"addMatchUpStopTime"),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-js"},"const stopTime = '2020-01-01T08:15:00Z';\ntournamentEngine.addMatchUpStopTime({\n  drawId,\n  matchUpId,\n  stopTime,\n  disableNotice, // when disabled subscribers will not be notified\n});\n")),(0,i.kt)("hr",null),(0,i.kt)("h2",{id:"addparticipant"},"addParticipant"),(0,i.kt)("p",null,"Adds an INDIVIDUAL, PAIR or TEAM participant to tournament participants. Includes integrity checks for ",(0,i.kt)("inlineCode",{parentName:"p"},"{ participantType: PAIR }")," to ensure ",(0,i.kt)("inlineCode",{parentName:"p"},"participant.individualParticipantIds")," are valid."),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-js"},"const participantId = UUID();\nconst participant = {\n  participantId, // automatically generated if not provided\n  participantRole: COMPETITOR,\n  participantType: INDIVIDUAL,\n  person: {\n    standardFamilyName: 'Family',\n    standardGivenName: 'Given',\n    nationalityCode, // optional\n    sex, // optional\n  },\n};\n\ntournamentEngine.addParticipant({ participant });\n")),(0,i.kt)("hr",null),(0,i.kt)("h2",{id:"addparticipants"},"addParticipants"),(0,i.kt)("p",null,"Bulk add participants to a tournamentRecord."),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-js"},"tournamentEngine.addParticipants({ participants });\n")),(0,i.kt)("hr",null),(0,i.kt)("h2",{id:"addpenalty"},"addPenalty"),(0,i.kt)("p",null,"Add a penaltyItem to one or more participants."),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-js"},"const createdAt = new Date().toISOString();\nconst penaltyData = {\n  refereeParticipantId, // optional\n  participantIds: [participantId],\n  penaltyType: BALL_ABUSE,\n  penaltyCode: 'Organization specific code', // optional\n  matchUpId,\n  issuedAt, // optional ISO timeStamp for time issued to participant\n  createdAt,\n  notes: 'Hit ball into sea',\n};\nlet result = tournamentEngine.addPenalty(penaltyData);\n")),(0,i.kt)("hr",null),(0,i.kt)("h2",{id:"addpersons"},"addPersons"),(0,i.kt)("p",null,"Creates tournament ",(0,i.kt)("inlineCode",{parentName:"p"},"participants")," from an array of defined persons. Useful for adding registered persons to a tournament record.\nSee ",(0,i.kt)("strong",{parentName:"p"},"person")," under ",(0,i.kt)("strong",{parentName:"p"},"participant")," in ",(0,i.kt)("a",{parentName:"p",href:"../types/typedefs#participant"},"Type Definitions")," for additional ",(0,i.kt)("inlineCode",{parentName:"p"},"person")," attributes."),(0,i.kt)("admonition",{type:"note"},(0,i.kt)("ul",{parentName:"admonition"},(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("inlineCode",{parentName:"li"},"participantIds")," are unique within a tournament"),(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("inlineCode",{parentName:"li"},"personIds")," are unique to an individual, and should be identical across tournaments."))),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-js"},"const persons = [\n  {\n    personId, // optional - providing a personId allows person to be tracked across tournaments\n    participantExtensions, // optional - any relevant extensions for created participant\n    participantTimeItems, // optional - any relevant timeItems (e.g. rankings/ratings) for created participant\n    standardFamilyName,\n    standardGivenName,\n    nationalityCode,\n    sex,\n\n    // optional - will create pair participants\n    pairedPersons: [\n      {\n        participantExtensions, // optional - any relevant extensions for created participant\n        participantTimeItems, // optional - any relevant timeItems (e.g. rankings/ratings) for created participant\n        personId,\n      },\n    ],\n  },\n];\n\ntournamentEngine.addPersons({\n  participantRole, // optional - defaults to COMPETITOR\n  persons,\n});\n")),(0,i.kt)("hr",null),(0,i.kt)("h2",{id:"addplayoffstructures"},"addPlayoffStructures"),(0,i.kt)("p",null,"Adds playoff structures to an existing drawDefinition."),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-js"},"tournamentEngine.addPlayoffStructures({\n  drawId,\n  structureId,\n  roundNumbers: [3], // required if no playoffPositions - source roundNumbers which will feed target structures, e.g. [1, 2]\n  roundProfiles, // optional - source roundNumbers as Object.keys with depth as Object.values, e.g. [{ 1: 2}, {2: 1}]\n  playoffPositions: [3, 4], // required if not provided roundNumbers\n  playoffAttributes, // optional - object mapping exitProfiles to structure names, e.g. 0-1-1 for SOUTH\n  exitProfileLimit, // limit playoff rounds generated by the attributes present in playoffAttributes\n  playoffStructureNameBase, // optional - base word for default playoff naming, e.g. 'Playoff'\n});\n\n// example use of playoffAttributes - will generated playoff structure from 2nd round with structureName: 'BRONZE'\nconst playoffAttributes = {\n  '0-2': { name: 'BRONZE', abbreviation: 'B' },\n};\n")),(0,i.kt)("hr",null),(0,i.kt)("h2",{id:"addqualifyingstructure"},"addQualifyingStructure"),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-js"},"tournamentEngine.addQualifyingStructure({\n  targetStructureId, // required: structure for which participants will qualify\n  qualifyingPositions, // optional: specify the # of qualifyingPositions\n  qualifyingRoundNumber, // optional: determine qualifyingPositions by # of matchUps in specified round; does not apply to ROUND_ROBIN\n  structureOptions, // optional: specific to ROUND_ROBIN generation\n  structureName, // optional\n  drawSize,\n  drawType, // optional: defaults to SINGLE_ELIMINATION\n  drawId, // required: draw within which target structure appears\n});\n")),(0,i.kt)("hr",null),(0,i.kt)("h2",{id:"addtournamentextension"},"addTournamentExtension"),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-js"},"tournamentEngine.addTournamentExtension({\n  extension: {\n    name: 'extension name',\n    value: {},\n  },\n});\n")),(0,i.kt)("hr",null),(0,i.kt)("h2",{id:"addvenue"},"addVenue"),(0,i.kt)("p",null,"Adds ",(0,i.kt)("strong",{parentName:"p"},"venueId")," if not provided."),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-js"},"tournamentEngine.addVenue({\n  venue: { venueName },\n  context, // optional - adds detail in CONTEXT extension\n});\n")),(0,i.kt)("hr",null),(0,i.kt)("h2",{id:"addvoluntaryconsolationstage"},"addVoluntaryConsolationStage"),(0,i.kt)("p",null,"Modifies the entryProfile for a draw to allow ",(0,i.kt)("inlineCode",{parentName:"p"},"{ entryStage: VOLUNTARY_CONSOLATION }")),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-js"},"tournamentEngine.addVoluntaryConsolationStage({\n  drawSize,\n  drawId,\n});\n")),(0,i.kt)("hr",null),(0,i.kt)("h2",{id:"addvoluntaryconsolationstructure"},"addVoluntaryConsolationStructure"),(0,i.kt)("p",null,"Generates a new structure within a ",(0,i.kt)("inlineCode",{parentName:"p"},"drawDefinition")," if any draw entries are present for ",(0,i.kt)("inlineCode",{parentName:"p"},"{ entryStage: VOLUNTARY_CONSOLATION }"),"."),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-js"},"tournamentEngine.addVoluntaryConsolationStructure({\n  structureAbbreviation, // optional\n  structureName, // optional - defaults to 'VOLUNTARY_CONSOLATION'\n  drawId,\n});\n")),(0,i.kt)("hr",null),(0,i.kt)("h2",{id:"alldrawmatchups"},"allDrawMatchUps"),(0,i.kt)("p",null,"Returns all matchUps from all structures within a draw."),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-js"},"const { matchUps } = tournamentEngine.allDrawMatchUps({\n  participantsProfile, // optional - ability to specify additions to context (see parameters of getTournamentParticipants())\n  contextFilters, // filters based on context attributes\n  matchUpFilters, // attribute filters\n  nextMatchUps, // optioanl - boolean - to include winnerTo and loserTo\n  inContext, // boolean - add context { drawId, structureId, participant, individualParticipants ... }\n  context, // optional context to be added into matchUps\n  drawId,\n});\n")),(0,i.kt)("hr",null),(0,i.kt)("h2",{id:"alleventmatchups"},"allEventMatchUps"),(0,i.kt)("p",null,"Returns all matchUps for an event."),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-js"},"const { matchUps } = allEventMatchUps({\n  participantsProfile, // optional - ability to specify additions to context (see parameters of getTournamentParticipants())\n  scheduleVisibilityFilters, // { visibilityThreshold: Date, eventIds, drawIds }\n  matchUpFilters, // optional; [ scheduledDates: [], courtIds: [], stages: [], roundNumbers: [], matchUpStatuses: [], matchUpFormats: []]\n  contextFilters, // filters based on context attributes\n  nextMatchUps: true, // include winner/loser target matchUp details\n  inContext: true, // include contextual details\n  eventId,\n});\n")),(0,i.kt)("hr",null),(0,i.kt)("h2",{id:"alltournamentmatchups"},"allTournamentMatchUps"),(0,i.kt)("p",null,"Return an array of all matchUps contained within a tournament. These matchUps are returned ",(0,i.kt)("strong",{parentName:"p"},"inContext"),"."),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-js"},"const { matchUps } = tournamentEngine.allTournamentMatchUps({\n  scheduleVisibilityFilters, // { visibilityThreshold: Date, eventIds, drawIds }\n  participantsProfile, // optional - ability to specify additions to context (see parameters of getTournamentParticipants())\n  matchUpFilters, // optional; [ scheduledDates: [], courtIds: [], stages: [], roundNumbers: [], matchUpStatuses: [], matchUpFormats: []]\n  contextFilters, // filters based on context attributes\n  nextMatchUps, // include winnerTo and loserTo matchUps\n  contextProfile, // optional: { inferGender: true }\n});\n")),(0,i.kt)("hr",null),(0,i.kt)("h2",{id:"alternatedrawpositionassignment"},"alternateDrawPositionAssignment"),(0,i.kt)("p",null,"Replaces an existing drawPosition assignment with an alternateParticipantId. This method is included in ",(0,i.kt)("inlineCode",{parentName:"p"},"validActions")," for ",(0,i.kt)("a",{parentName:"p",href:"../policies/positionActions"},"positionActions")),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-js"},"tournamentEngine.alternateDrawPositionAssignment({\n  drawId,\n  structureId,\n  drawPosition,\n  alternateParticipantId,\n});\n")),(0,i.kt)("hr",null),(0,i.kt)("h2",{id:"applylinueups"},"applyLinueUps"),(0,i.kt)("p",null,"Applies ",(0,i.kt)("inlineCode",{parentName:"p"},"lineUps")," to the ",(0,i.kt)("inlineCode",{parentName:"p"},"sides")," of a ",(0,i.kt)("em",{parentName:"p"},"TEAM")," matchUp. Order is not important as team side is determined automatically. Does not check to ensure that participants in ",(0,i.kt)("inlineCode",{parentName:"p"},"lineUps")," are part of teams; this is assumed. It is possible to have ",(0,i.kt)("strong",{parentName:"p"},(0,i.kt)("em",{parentName:"strong"},"some"))," participants assigned to a team side who are not part of a team."),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-js"},"result = tournamentEngine.applyLineUps({\n  matchUpId, // must be { matchUpType: TEAM }\n  lineUps, // array of at most two lineUps (see TODS)\n  drawId, // reference to draw in which matchUp occurs\n});\n")),(0,i.kt)("hr",null),(0,i.kt)("h2",{id:"assigndrawposition"},"assignDrawPosition"),(0,i.kt)("p",null,"Low level function normally called by higher order convenience functions."),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-js"},"tournamentEngine.assignDrawPosition({\n  drawId,\n  structureId,\n  drawPosition,\n  participantId, // optional - if assigning position to a participant\n  qualifier, // optional boolean, if assigning a space for a qualifier\n  bye, // optional boolean, if assigning a bye\n});\n")),(0,i.kt)("hr",null),(0,i.kt)("h2",{id:"assignmatchupcourt"},"assignMatchUpCourt"),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-js"},"tournamentEngine.assignMatchUpCourt({\n  drawId, // drawId where matchUp is found\n  matchUpId,\n  courtId,\n  courtDayDate, // ISO date string\n});\n")),(0,i.kt)("hr",null),(0,i.kt)("h2",{id:"assignmatchupvenue"},"assignMatchUpVenue"),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-js"},"tournamentEngine.assignMatchUVenue({\n  drawId, // drawId where matchUp is found\n  matchUpId,\n  venueId,\n});\n")),(0,i.kt)("hr",null),(0,i.kt)("h2",{id:"assignseedpositions"},"assignSeedPositions"),(0,i.kt)("p",null,"Assign ",(0,i.kt)("strong",{parentName:"p"},"seedNumbers")," to ",(0,i.kt)("strong",{parentName:"p"},"participantIds")," within a target draw structure."),(0,i.kt)("ul",null,(0,i.kt)("li",{parentName:"ul"},"Provides the ability to assign seeding ",(0,i.kt)("em",{parentName:"li"},"after")," a structure has been generated"),(0,i.kt)("li",{parentName:"ul"},"To be used ",(0,i.kt)("em",{parentName:"li"},"before")," participants are positioned")),(0,i.kt)("p",null,(0,i.kt)("strong",{parentName:"p"},"seedNumber")," is unique while ",(0,i.kt)("strong",{parentName:"p"},"seedValue")," can be any string representation, e.g ",(0,i.kt)("inlineCode",{parentName:"p"},'"5-8"')),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-js"},"let assignments = [{ seedNumber: 1, seedValue: '1', participantId }];\ntournamentEngine.assignSeedPositions({\n  eventId,\n  drawId,\n  structureId,\n  assignments,\n\n  stage, // opional; defaults to { stage: MAIN }\n  stageSequence, // optional; defaults to { stageSequence: 1 }\n  useExistingSeedLimits, // optional; restrict ability to assign seedNumbers beyond established limit\n});\n")),(0,i.kt)("hr",null),(0,i.kt)("h2",{id:"assigntiematchupparticipantid"},"assignTieMatchUpParticipantId"),(0,i.kt)("p",null,"Used when interactively assigning participants to ",(0,i.kt)("inlineCode",{parentName:"p"},"matchUps"),". When individual ",(0,i.kt)("inlineCode",{parentName:"p"},"participantIds")," are assigned to ",(0,i.kt)("inlineCode",{parentName:"p"},"{ matchUpType: 'DOUBLES' }")," it handles creating ",(0,i.kt)("inlineCode",{parentName:"p"},"{ participantType: PAIR }")," participants dynamically."),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-js"},'tournamentEngine.assignTieMatchUpParticipantId({\n  teamParticipantId, // optional - participant team can be derived from participantId. This supports assigning "borrowed" players from other teams.\n  participantId, // participantId of INDIVIDUAL or PAIR participant to be assigned to a matchUp\n  tieMatchUpId, // matchUpId of a SINGLES or DOUBLES that is part of a matchUp between teams\n  drawId, // identifies draw in which matchUp is present\n});\n')),(0,i.kt)("hr",null),(0,i.kt)("h2",{id:"attacheventpolicies"},"attachEventPolicies"),(0,i.kt)("p",null,"Attaches a policy to an event within a tournamentRecord."),(0,i.kt)("p",null,"See ",(0,i.kt)("a",{parentName:"p",href:"../concepts/policies"},"Policies"),"."),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-js"},"tournamentEngine.attachEventPolicies({\n  policyDefinitions: SEEDING_POLICY,\n  eventId,\n});\n")),(0,i.kt)("hr",null),(0,i.kt)("h2",{id:"attachflightprofile"},"attachFlightProfile"),(0,i.kt)("p",null,"Attaches a ",(0,i.kt)("inlineCode",{parentName:"p"},"flightProfile")," to the ",(0,i.kt)("inlineCode",{parentName:"p"},"event")," specified by ",(0,i.kt)("inlineCode",{parentName:"p"},"eventId"),". A ",(0,i.kt)("inlineCode",{parentName:"p"},"flightProfile")," is first generated with ",(0,i.kt)("inlineCode",{parentName:"p"},"generateFlightProfile()"),"."),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-js"},"tournamentEngine.attachFlightProfile({ flightProfile, eventId });\n")),(0,i.kt)("hr",null),(0,i.kt)("h2",{id:"attachplayoffstructures"},"attachPlayoffStructures"),(0,i.kt)("p",null,"Attaches the results of ",(0,i.kt)("inlineCode",{parentName:"p"},"generateAndPopulatePlayoffStructures")," to a ",(0,i.kt)("inlineCode",{parentName:"p"},"drawDefinition"),".\nUsed primarily when multiple instances of ",(0,i.kt)("inlineCode",{parentName:"p"},"drawEngine")," are in use and the generation step is performed by one instance."),(0,i.kt)("admonition",{type:"note"},(0,i.kt)("p",{parentName:"admonition"},(0,i.kt)("inlineCode",{parentName:"p"},"tournamentEngine.addPlayoffStructures()")," calls both ",(0,i.kt)("inlineCode",{parentName:"p"},"generateAndPoplulatePlayoffStructures")," and ",(0,i.kt)("inlineCode",{parentName:"p"},"attachPlayoffStructures")," and is used when there is only one instance of ",(0,i.kt)("inlineCode",{parentName:"p"},"drawEngine"),".")),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-js"},"tournamentEngine.attachPlayoffStructures({ drawId, structures, links });\n")),(0,i.kt)("hr",null),(0,i.kt)("h2",{id:"attachpolicies"},"attachPolicies"),(0,i.kt)("p",null,"Attaches a policy to a tournamentRecord."),(0,i.kt)("p",null,"See ",(0,i.kt)("a",{parentName:"p",href:"../concepts/policies"},"Policies"),"."),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-js"},"tournamentEngine.attachPolicies({\n  policyDefinitions: SEEDING_POLICY,\n  allowReplacement, // optional boolean\n});\n")),(0,i.kt)("hr",null),(0,i.kt)("h2",{id:"attachqualifyingstructure"},"attachQualifyingStructure"),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-js"},"tournamentEngine.attachQualifyingStructure({\n  structure, // required: structure object; see `generateQualifyingStructure`\n  drawId, // required: id of drawDedfinition to which structure will be attached\n  link, // required\n});\n")),(0,i.kt)("hr",null),(0,i.kt)("h2",{id:"attachstructures"},"attachStructures"),(0,i.kt)("p",null,"Use to attach structures and links which are generated by ",(0,i.kt)("inlineCode",{parentName:"p"},"generateVoluntaryConsolation"),"."),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-js"},"tournamentEngine.attachStructures({ drawId, structures, links });\n")),(0,i.kt)("hr",null),(0,i.kt)("h2",{id:"automatedplayoffpositioning"},"automatedPlayoffPositioning"),(0,i.kt)("p",null,"Uses Round Robin Tallies to position participants in playoff structure(s)."),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-js"},"tournamentEngine.automatedPlayoffPositioning({\n  structureId: mainStructure.structureId,\n  drawId,\n});\n")),(0,i.kt)("hr",null),(0,i.kt)("h2",{id:"automatedpositioning"},"automatedPositioning"),(0,i.kt)("p",null,"Positions participants in a draw structure."),(0,i.kt)("p",null,"See ",(0,i.kt)("a",{parentName:"p",href:"../concepts/policies"},"Policies"),"."),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-js"},"tournamentEngine.automatedPositioning({ drawId, structureId });\n")),(0,i.kt)("hr",null),(0,i.kt)("h2",{id:"autoseeding"},"autoSeeding"),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-js"},"const { scaleItemsWithParticipantIds } = tournamentEngine.autoSeeding({\n  eventId,\n  policyDefinitions, // seeding policyDefinition determines the # of seeds for given participantCount/drawSize\n  scaleAttributes, // { scaleType, scaleName, }\n  scaleName, // Optional - defaults to scaleAttributes.scaleName\n  drawSize, // Optional - defaults to calculation based on # of entries\n  drawId, // Optional - will use flight.drawEntries or drawDefinition.entries rather than event.entries\n  stage, // Optional - filters entries by specified stage\n\n  scaleSortMethod, // Optional - user defined sorting method\n  sortDescending, // Optional - defaults to false\n});\n\ntournamentEngine.setParticipantScaleItems({\n  scaleItemsWithParticipantIds,\n});\n")),(0,i.kt)("hr",null),(0,i.kt)("h2",{id:"bulkmatchupstatusupdate"},"bulkMatchUpStatusUpdate"),(0,i.kt)("p",null,"Provides the ability to update the outcomes of multiple matchUps at once."),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-js"},"const outcomes = [\n  {\n    eventId,\n    drawId,\n    matchUpId,\n    matchUpFormat,\n    matchUpStatus,\n    winningSide,\n    score,\n  },\n];\ntournamentEngine.bulkMatchUpStatusUpdate({ outcomes });\n")),(0,i.kt)("hr",null),(0,i.kt)("h2",{id:"bulkreschedulematchups"},"bulkRescheduleMatchUps"),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-js"},"const {\n  rescheduled, // array of inContext matchUps which have been rescheduled\n  notRescheduled, // array of inContext matchUps which have NOT been rescheduled\n  allRescheduled, // boolean indicating whether all matchUps have been rescheduled\n  dryRun, // boolean - only report what would happen without making modifications\n} = tournamentEngine.bulkRescheduleMatchUps({\n  matchUpIds, // array of matchUupIds for matchUps which are to be rescheduled\n  scheduleChange: {\n    daysChange: 1, // number of days +/-\n    minutesChange: 30, // number of minutes +/-\n  },\n});\n")),(0,i.kt)("hr",null),(0,i.kt)("h2",{id:"bulkschedulematchups"},"bulkScheduleMatchUps"),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-js"},"const schedule = {\n  scheduledTime: '08:00',\n  scheduledDate: '2021-01-01T00:00', // best practice to provide ISO date string\n  venueId,\n};\ntournamentEngine.bulkScheduleMatchUps({ matchUpIds, schedule });\n")),(0,i.kt)("h2",{id:"bulkupdatepublishedeventids"},"bulkUpdatePublishedEventIds"),(0,i.kt)("p",null,"Returns a filtered array of publishedEventIds from all eventIds which are included in a bulkMatchUpStatusUpdate. publishedEventIds can be used to determine which events to re-publish."),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-js"},"const { publishedEventIds } = tournamentEngine.bulkUpdatePublishedEventIds({\n  outcomes,\n});\n")),(0,i.kt)("hr",null),(0,i.kt)("h2",{id:"checkinparticipant"},"checkInParticipant"),(0,i.kt)("p",null,"Set the check-in state for a participant. Used to determine when both participants in a matchUp are available to be assigned to a court."),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-js"},"tournamentEngine.checkInParticipant({\n  drawId,\n  matchUpId,\n  participantId,\n});\n")),(0,i.kt)("hr",null),(0,i.kt)("h2",{id:"checkoutparticipant"},"checkOutParticipant"),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-js"},"tournamentEngine.checkOutParticipant({\n  drawId,\n  matchUpId,\n  participantId,\n});\n")),(0,i.kt)("hr",null),(0,i.kt)("h2",{id:"clearmatchupschedule"},"clearMatchUpSchedule"),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-js"},"tournamentEngine.clearMatchUpSchedule({\n  scheduleAttributes, // optional array of schedule constants\n  matchUpId,\n  drawId, // optional optimizes matchUp lookup, triggers drawModificationNotice\n});\n")),(0,i.kt)("hr",null),(0,i.kt)("h2",{id:"clearscheduledmatchups"},"clearScheduledMatchUps"),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-js"},"tournamentEngine.clearScheduledMatchUps({\n  ignoreMatchUpStatuses, // optional - specify matchUpStatus values to be ignored; defaults to all completed matchUpStatuses\n  scheduleAttributes, // optional - specify which attributes should be considered; defaults to ['scheduledDate', 'scheduledTime']\n  scheduledDates, // optional - array of dates to be cleared; only matchUps with specified scheduledDate will be cleared\n  venueIds, // optional - array of venueIds; only matchUps at specified venues will be cleared\n});\n")),(0,i.kt)("hr",null),(0,i.kt)("h2",{id:"deleteadhocmatchups"},"deleteAdHocMatchUps"),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-js"},"const result = tournamentEngine.deleteAdHocMatchUps({\n  drawId, // required - drawId of drawDefinition in which target structure is found\n  structureId, // required - structureId of structure for which matchUps are being generated\n  matchUpIds, // array of matchUpIds identifying matchUps to be deleted\n});\n")),(0,i.kt)("hr",null),(0,i.kt)("h2",{id:"deletecourt"},"deleteCourt"),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-js"},"tournamentEngine.deleteCourt({\n  courtId,\n  force, // override warnings about matchUps scheduled on specified court\n});\n")),(0,i.kt)("hr",null),(0,i.kt)("h2",{id:"deletedrawdefinitions"},"deleteDrawDefinitions"),(0,i.kt)("p",null,"Remove ",(0,i.kt)("inlineCode",{parentName:"p"},"drawDefinitions")," from an ",(0,i.kt)("inlineCode",{parentName:"p"},"event"),". An audit timeItem is added to the tournamentRecord whenever this method is called. If ",(0,i.kt)("inlineCode",{parentName:"p"},"autoPublish: true")," (default behavior) then if a deleted draw was published then the ",(0,i.kt)("inlineCode",{parentName:"p"},"event")," to which it belongs will be re-published."),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-js"},"tournamentEngine.deleteDrawDefinitions({\n  autoPublish, // optional - defaults to true.\n  drawIds: [drawId],\n  eventId,\n});\n")),(0,i.kt)("hr",null),(0,i.kt)("h2",{id:"deleteflightandflightdraw"},"deleteFlightAndFlightDraw"),(0,i.kt)("p",null,"Removes flight from ",(0,i.kt)("inlineCode",{parentName:"p"},"event")," flightProfile as well as associated ",(0,i.kt)("inlineCode",{parentName:"p"},"drawDefinition")," (if generated)."),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-js"},"tournamentEngine.deleteFlightAndFlightDraw({\n  autoPublish, // optional - defaults to true.\n  eventId,\n  drawId,\n});\n")),(0,i.kt)("hr",null),(0,i.kt)("h2",{id:"deleteflightprofileandflightdraws"},"deleteFlightProfileAndFlightDraws"),(0,i.kt)("p",null,"Removes flightProfiles and all associated drawDefinitions from a specified event."),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-js"},"tournamentEngine.deleteFlightProfileAndFlightDraws({ eventId });\n")),(0,i.kt)("hr",null),(0,i.kt)("h2",{id:"deleteevents"},"deleteEvents"),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-js"},"tournamentEngine.deleteEvents({ eventIds });\n")),(0,i.kt)("hr",null),(0,i.kt)("h2",{id:"deleteparticipants"},"deleteParticipants"),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-js"},"tournamentEngine.deleteParticipants({\n  addIndividualParticipantsToEvents, // optional boolean\n  paricipantIds,\n});\n")),(0,i.kt)("hr",null),(0,i.kt)("h2",{id:"deletevenue"},"deleteVenue"),(0,i.kt)("p",null,"If a venue has scheduled matchUps then it will not be deleted unless ",(0,i.kt)("inlineCode",{parentName:"p"},"{ force: true }")," in which case all relevant matchUps will be unscheduled."),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-js"},"tournamentEngine.deleteVenue({ venueId, force });\n")),(0,i.kt)("hr",null),(0,i.kt)("h2",{id:"deletevenues"},"deleteVenues"),(0,i.kt)("p",null,"If a venue has scheduled matchUps then it will not be deleted unless ",(0,i.kt)("inlineCode",{parentName:"p"},"{ force: true }")," in which case all relevant matchUps will be unscheduled."),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-js"},"tournamentEngine.deleteVenues({ venueIds, force });\n")),(0,i.kt)("hr",null),(0,i.kt)("h2",{id:"destroygroupentry"},"destroyGroupEntry"),(0,i.kt)("p",null,'Removes a "grouping" entry from a event and adds the ',(0,i.kt)("inlineCode",{parentName:"p"},"individualParticipantIds")," to entries. Grouping entries are ",(0,i.kt)("inlineCode",{parentName:"p"},"participantType")," ",(0,i.kt)("strong",{parentName:"p"},"TEAM")," and ",(0,i.kt)("strong",{parentName:"p"},"PAIR"),", both of which include ",(0,i.kt)("inlineCode",{parentName:"p"},"individualParticipantIds"),"."),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-js"},"tournamentEngine.destroyGroupEntry({\n  participantId,\n  eventId,\n\n  entryStatus, // optional - new entryStatus for individualParticipantIds\n  removeGroupParticipant, // optional - removes group participant from tournament participants\n});\n")),(0,i.kt)("hr",null),(0,i.kt)("h2",{id:"destroypairentry"},"destroyPairEntry"),(0,i.kt)("p",null,"Removes a ",(0,i.kt)("inlineCode",{parentName:"p"},"{ participantType: PAIR }")," entry from an event and adds the individualParticipantIds to entries as entryStatus: UNGROUPED"),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-js"},"tournamentEngine.destroyPairEntry({\n  eventId,\n  participantId,\n});\n")),(0,i.kt)("hr",null),(0,i.kt)("h2",{id:"devcontext"},"devContext"),(0,i.kt)("p",null,"Setting devContext(true) bypasses ",(0,i.kt)("strong",{parentName:"p"},"try {} catch (err) {}")," code block and in some cases enables enhanced logging"),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-js"},"tournamentEngine.devContext(true);\n")),(0,i.kt)("hr",null),(0,i.kt)("h2",{id:"disablecourts"},"disableCourts"),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-js"},"tournamentEngine.disableCourts({\n  courtIds,\n  dates, // optional - if not provided, courts will be disalbed for all dates\n});\n")),(0,i.kt)("hr",null),(0,i.kt)("h2",{id:"disabletiaautocalc"},"disableTiaAutoCalc"),(0,i.kt)("p",null,"Disable default behavior of auto calculating TEAM matchUp scores."),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-js"},"tournamentEngine.disableTieAutoCalc({ drawId, matchUpId });\n")),(0,i.kt)("hr",null),(0,i.kt)("h2",{id:"disablevenues"},"disableVenues"),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-js"},"tournamentEngine.disableVenues({ venueIds });\n")),(0,i.kt)("hr",null),(0,i.kt)("h2",{id:"drawmatic"},"drawMatic"),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-js"},"const { matchUps } = tournamentEngine.drawMatic({\n  addToStructure, // optional - defaults to true\n  drawId,\n});\n")),(0,i.kt)("hr",null),(0,i.kt)("h2",{id:"enablecourts"},"enableCourts"),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-js"},"tournamentEngine.enableCourts({\n  enableAll, // optional boolean\n  courtIds,\n  dates, // optional - array of dates to enable (if they have been disabled)\n});\n")),(0,i.kt)("hr",null),(0,i.kt)("h2",{id:"enabletiaautocalc"},"enableTiaAutoCalc"),(0,i.kt)("p",null,"Re-enable default behavior of auto calculating TEAM matchUp scores, and trigger auto calculation."),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-js"},"tournamentEngine.enableTieAutoCalc({ drawId, matchUpId });\n")),(0,i.kt)("hr",null),(0,i.kt)("h2",{id:"enablevenues"},"enableVenues"),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-js"},"tournamentEngine.enableVenues({ venueIds, enableAll });\n")),(0,i.kt)("hr",null),(0,i.kt)("h2",{id:"eventmatchups"},"eventMatchUps"),(0,i.kt)("p",null,"Returns matchUps for an event grouped by status."),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-js"},"const {\n  abandonedMatchUps,\n  byeMatchUps,\n  completedMatchUps,\n  pendingMatchUps,\n  upcomingMatchUps,\n} = tournamentEngine.eventMatchUps({\n  eventId,\n  nextMatchUps, // optional boolean; include winner/loser target matchUp details\n  matchUpFilters, // optional; [ scheduledDates: [], courtIds: [], stages: [], roundNumbers: [], matchUpStatuses: [], matchUpFormats: []]\n  contextFilters,\n  tournamentAppliedPolicies,\n  scheduleVisibilityFilters, // { visibilityThreshold: Date, eventIds, drawIds }\n  inContext: true, // optional - adds context details to all matchUps\n});\n")),(0,i.kt)("hr",null),(0,i.kt)("h2",{id:"executionqueue"},"executionQueue"),(0,i.kt)("p",null,"The ",(0,i.kt)("inlineCode",{parentName:"p"},"executionQueue")," method accepts an array of ",(0,i.kt)("inlineCode",{parentName:"p"},"tournamentEngine")," methods and associated parameters,\nallowing for multiple queries or mutations in a single API call, which is significant if a client is making a\nrequest of a server and the server needs to prepare context by loading a tournament record."),(0,i.kt)("p",null,"An additional benefit of the ",(0,i.kt)("inlineCode",{parentName:"p"},"executionQueue")," is that subscribers to ",(0,i.kt)("inlineCode",{parentName:"p"},"tournamentEngine")," events are not notified\nuntil all methods in the queue have completed successfully, and a failure of any one method can be used to roll back state\nwith the assurance that there are no side-effects caused by subscribers responding to notifications. This also means\nthat the server context can not be blocked by any long-running external processes."),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-js"},"const result = tournamentEngine.executionQueue([\n  {\n    method: 'getTournamentParticipants',\n    params: { participantFilters: { participantTypes: [PAIR] } },\n  },\n  {\n    method: 'getTournamentParticipants',\n    params: { participantFilters: { participantTypes: [INDIVIDUAL] } },\n  },\n]);\n")),(0,i.kt)("hr",null),(0,i.kt)("h2",{id:"findcourt"},"findCourt"),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-js"},"const { court, venue } = tournamentEngine.findCourt({ courtId });\n")),(0,i.kt)("hr",null),(0,i.kt)("h2",{id:"finddrawdefinitionextension"},"findDrawDefinitionExtension"),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-js"},"const { extension } = tournamentEngine.findDrawDefinitionExtension({\n  drawId,\n  eventId,\n  name,\n});\n")),(0,i.kt)("hr",null),(0,i.kt)("h2",{id:"findeventextension"},"findEventExtension"),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-js"},"const { extension } = tournamentEngine.findEventExtension({ eventId, name });\n")),(0,i.kt)("hr",null),(0,i.kt)("h2",{id:"findmatchup"},"findMatchUp"),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-js"},"const {\n  matchUp,\n  structure, // returned for convenience\n} = tournamentEngine.findMatchUp({\n  inContext, // optional - boolean - returns matchUp with additional attributes\n  matchUpId,\n  drawId,\n});\n")),(0,i.kt)("hr",null),(0,i.kt)("h2",{id:"findparticipant"},"findParticipant"),(0,i.kt)("p",null,"Find tournament participant by either ",(0,i.kt)("inlineCode",{parentName:"p"},"participantId")," or ",(0,i.kt)("inlineCode",{parentName:"p"},"personId"),"."),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-js"},"const { participant } = tournamentEngine.findParticipant({\n  participantId,\n  personId, // required only if no participantId provided\n});\n")),(0,i.kt)("hr",null),(0,i.kt)("h2",{id:"findparticipantextension"},"findParticipantExtension"),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-js"},"const { extension } = tournamentEngine.findParticipantExtension({\n  participantId,\n  name,\n});\n")),(0,i.kt)("hr",null),(0,i.kt)("h2",{id:"findpolicy"},"findPolicy"),(0,i.kt)("p",null,"Find ",(0,i.kt)("inlineCode",{parentName:"p"},"policyType")," either on an event object or the tournamentRecord."),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-js"},"const { policy } = tournamentEngine.findPolicy({\n  policyType: POLICY_TYPE_SCORING,\n  eventId, // optional\n});\n")),(0,i.kt)("hr",null),(0,i.kt)("h2",{id:"findtournamentextension"},"findTournamentExtension"),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-js"},"const { extension } = tournamentEngine.findTournamentExtension({ name });\n")),(0,i.kt)("hr",null),(0,i.kt)("h2",{id:"findvenue"},"findVenue"),(0,i.kt)("p",null,"Returns a complete venue object. Primarily used internally."),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-js"},"tournamentEngine.findVenue({ venueId });\n")),(0,i.kt)("hr",null),(0,i.kt)("h2",{id:"generateadhocmatchups"},"generateAdHocMatchUps"),(0,i.kt)("p",null,"Draws with ",(0,i.kt)("inlineCode",{parentName:"p"},"{ drawType: AD_HOC }")," allow ",(0,i.kt)("inlineCode",{parentName:"p"},"matchUps")," to be dynamically added. In this type of draw there is no automatic participant progression between rounds. Participant assignment to ",(0,i.kt)("inlineCode",{parentName:"p"},"matchUps")," is done manually, or via ",(0,i.kt)("strong",{parentName:"p"},"DrawMatic"),". The only restriction is that a participant may appear once per round. To generate only, and not add to the structure/draw, use the boolean ",(0,i.kt)("inlineCode",{parentName:"p"},"addToStructure")," and then subsequently use ",(0,i.kt)("a",{parentName:"p",href:"#addadhocmatchups"},"addAddHocMatchUps"),"."),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-js"},"const result = tournamentEngine.generateAdHocMatchUps({\n  addToStructure, // boolean - defaults to true\n  participantIdPairings, // required - array of array of pairings [['id1', 'id2'], ['id3', 'id4']]\n  drawId, // required - drawId of drawDefinition in which target structure is found\n  structureId, // required when more than one structure is present - structureId of structure for which matchUps are being generated\n  matchUpIds, // optional - if matchUpIds are not specified UUIDs are generated\n  roundNumber, // optional - specify round for which matchUps will be generated\n  newRound, // optional - boolean defaults to false - whether to auto-increment to next roundNumber\n});\n")),(0,i.kt)("hr",null),(0,i.kt)("h2",{id:"generateandpopulateplayoffstructures"},"generateAndPopulatePlayoffStructures"),(0,i.kt)("p",null,"Generates ",(0,i.kt)("inlineCode",{parentName:"p"},"structures")," and ",(0,i.kt)("inlineCode",{parentName:"p"},"links")," but does not attach them to the ",(0,i.kt)("inlineCode",{parentName:"p"},"drawDefinition"),". Used in conjunction with ",(0,i.kt)("inlineCode",{parentName:"p"},"attachPlayoffStructures"),"."),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-js"},"const { structures, links } =\n  tournamentEngine.generateAndPopulatePlayoffStructures({\n    roundNumbers: [3], // optional if playoffPositions not provided; roundNumbers of structure to be played off.\n    roundProfiles, // optional - source roundNumbers as Object.keys with depth as Object.values, e.g. [{ 1: 2}, {2: 1}]\n    playoffPositions: [3, 4], // optional if roundNumbers not provided; finishing positions to be played off.\n    playoffStructureNameBase, // optional - Root word for default playoff naming, e.g. 'Playoff' for 'Playoff 3-4'\n    exitProfileLimit, // limit playoff rounds generated by the attributes present in playoffAttributes\n    playoffAttributes, // optional - mapping of exitProfile to structure names, e.g. 0-1-1 for SOUTH\n    structureId,\n    drawId,\n  });\n")),(0,i.kt)("hr",null),(0,i.kt)("h2",{id:"generatedrawdefinition"},"generateDrawDefinition"),(0,i.kt)("p",null,"This is a convenience method which handles most use cases for draw generation."),(0,i.kt)("p",null,"The ",(0,i.kt)("inlineCode",{parentName:"p"},"automated"),' parameter is "truthy" and supports placing only seeded participants and any byes which are adjacent to seeded positions.\nSupport for this scenario is provided to enable some unique positioning strategies where unseeded participants have some agency in the selection process.'),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-js"},"const drawDefinitionValues = {\n  eventId, // optional - used to find any avoidance policies to be applied\n  drawSize, // number of drawPositions in the first draw structure\n  drawType, // optional - defaults to SINGLE_ELIMINATION\n  drawName, // cutom name for generated draw structure(s)\n  automated, // optional - whether or not to automatically place participants in structures; true/false or 'truthy' { seedsOnly: true }\n  matchUpType, // optional - SINGLES, DOUBLES, or TEAM\n  matchUpFormat, // optional - default matchUpFormatCode for all contained matchUps\n  playoffMatchUpFormat, // optional - relevant for ROUND_ROBIN_WITH_PLAYOFFS\n  tieFormat, // optional - { collectionDefinitions, winCriteria } for 'dual' or 'tie' matchUps\n  seedsCount, // optional - number of seeds to generate if no seededParticipants provided\n  seededParticipants, // optional - { participantId, seedNumber, seedValue }\n  seedingScaleName, // optional - custom scale for determining seeded participants\n\n  // { positioing: WATERFALL } seeding for ROUND_ROBIN structures\n  // { positioning: CLUSTER } or { positioning: SEPARATE } seeding for elimination structures\n  // { groupSeedingThreshold: 5 } will set seedValue to lowest value within all groups where seedNumber is > 5\n  seedingProfile, // optional { positioning, groupSeedingThreshold }\n\n  qualifyingPlaceholder, // optional boolean - generate a placeholder qualifying structure if qualifiersCount and no qualifyingProfiles\n  qualifiersCount, // optional - how many positionsAssignments will have { qualifier: true }\n  qualifyingOnly, // optional boolean - ignore event.entries that are not entryStage: QUALIFYING\n  qualifyingProfiles, // optional array [{ roundTarget, structureProfiles: [{ drawSize, seedsCount, seedingScaleName, qualifyingPositions }]}]\n\n  structureOptions: {\n    // optional - for ROUND_ROBIN - { groupSize, playoffGroups }\n    groupSize, // e.g. 4 participants per group\n    groupSizeLimit: 8,\n    playoffGroups: [\n      { finishingPositions: [1], structureName: 'Gold Flight', drawType }, // drawype defaults to SINGLE_ELIMINATION\n      { finishingPositions: [2], structureName: 'Silver Flight', drawType }, // drawType can also be COMPASS or FIRST_MATCH_LOSER_CONSOLATION\n    ],\n  },\n\n  staggeredEntry, // optional - accepts non-base-2 drawSizes and generates feed arms for \"extra\" drawPositions\n  policyDefinitions, // optional - seeding or avoidance policies to be used when placing participants\n  qualifyingPositions, // optional - number of positions in draw structure to be filled by qualifiers\n  finishingPositionNaming, // optional - map of { [finishingPositionRange]: { name: 'customName', abbreviation: 'A' } }\n  enforcePolicyLimits, // optional boolean - defaults to true - constrains seedsCount to policyDefinition limits\n  voluntaryConsolation, // optional { structureName, structureAbbreviation } - causes voluntary consolation structure to be added\n  enforceMinimumDrawSize, // optional boolean - defaults to true - false will allow generation of multi-structure drawTypes with only 2 participants\n  drawTypeCoercion, // optional boolean - coerce multi-structure drawTypes to SINGLE_ELIMINATION for drawSize: 2\n  ignoreStageSpace, // optional boolean - ignore wildcards count & etc.\n\n  compassAttributes, // optional - provide translations for name mappings\n  olympicAttributes, // optional - provide translations for name mappings\n};\n\nconst { drawDefinition } =\n  tournamentEngine.generateDrawDefinition(drawDefinitionValues);\n")),(0,i.kt)("hr",null),(0,i.kt)("h2",{id:"generateflightprofile"},"generateFlightProfile"),(0,i.kt)("p",null,"Splits event entries into ",(0,i.kt)("inlineCode",{parentName:"p"},"flightsCount")," (# of draws). ",(0,i.kt)("inlineCode",{parentName:"p"},"flightProfile")," is an extension on an event which contains attributes to be used by ",(0,i.kt)("inlineCode",{parentName:"p"},"generateDrawDefinition"),"."),(0,i.kt)("p",null,"NOTE: The method returns ",(0,i.kt)("inlineCode",{parentName:"p"},"{ flightProfile, splitEntries }")," for testing; ",(0,i.kt)("inlineCode",{parentName:"p"},"splitEntries")," provides a breakdown on how ",(0,i.kt)("inlineCode",{parentName:"p"},"event.entries")," were split across each ",(0,i.kt)("inlineCode",{parentName:"p"},"flight")," within the ",(0,i.kt)("inlineCode",{parentName:"p"},"event"),"."),(0,i.kt)("p",null,"For an explanation of ",(0,i.kt)("inlineCode",{parentName:"p"},"scaleAttributes")," see ",(0,i.kt)("a",{parentName:"p",href:"../concepts/scaleItems"},"Scale Items"),"."),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-js"},"const scaleAttributes = {\n  scaleType: RATING,\n  eventType: SINGLES,\n  scaleName: 'WTN',\n  accessor, // optional - string determining how to access attribute if scaleValue is an object\n};\n\nconst { flightProfile, splitEntries } = tournamentEngine.generateFlightProfile({\n  eventId, // event for which entries will be split\n  attachFlightProfile, // boolean - also attach to event after generation\n  scaledEntries, // optional - overrides the use of scaleAttributes, scaleSortMethod, and sortDescending\n  scaleAttributes, // defines participant sort method prior to split\n  scaleSortMethod, // optional - function(a, b) {} sort method, useful when scaleValue is an object or further proessing is required\n  sortDescending, // optional - default sorting is ASCENDING; only applies to default sorting method.\n  flightsCount: 3, // number of draws to be created\n  deleteExisting: true, // optional - remove existing flightProfile\n  splitMethod: SPLIT_WATERFALL, // optional - defaults to SPLIT_LEVEL_BASED\n  drawNames: ['Green Flight', 'Blue Flight'], // optional\n  drawNameRoot: 'Flight', // optional - used to generate drawNames, e.g. 'Flight 1', 'Flight 2'\n});\n\nconst {\n  flights: [\n    {\n      drawId, // unique identifier for generating drawDefinitions\n      drawName, // custom name for generated draw\n      drawEntries, // entries allocated to target draw\n    },\n  ],\n} = flightProfile;\n\n// use flight information to generate drawDefinition\nconst {\n  flights: [flight],\n} = flightProfile;\n\nObject.assign(drawDefinitionValues, flight);\nconst { drawDefinition } =\n  tournamentEngine.generateDrawDefinition(drawDefinitionValues);\n")),(0,i.kt)("hr",null),(0,i.kt)("h2",{id:"generatequalifyingstructure"},"generateQualifyingStructure"),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-js"},"let { structure, link } = tournamentEngine.generateQualifyingStructure({\n  targetStructureId, // required: structure for which participants will qualify\n  qualifyingPositions, // optional: specify the # of qualifyingPositions\n  qualifyingRoundNumber, // optional: determine qualifyingPositions by # of matchUps in specified round; does not apply to ROUND_ROBIN\n  structureOptions, // optional: specific to ROUND_ROBIN generation\n  structureName, // optional\n  drawSize,\n  drawType, // optional: defaults to SINGLE_ELIMINATION\n  drawId, // required: draw within which target structure appears\n});\n")),(0,i.kt)("hr",null),(0,i.kt)("h2",{id:"generateseedingscaleitems"},"generateSeedingScaleItems"),(0,i.kt)("p",null,"Used in conjunction with ",(0,i.kt)("inlineCode",{parentName:"p"},"getEntriesAndSeedsCount")," when it is necessary to make use of a custom function for generating ",(0,i.kt)("inlineCode",{parentName:"p"},"scaledEntries"),"."),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-js"},"const { scaleItemsWithParticipantIds } =\n  tournamentEngine.generateSeedingScaleItems({\n    scaleAttributes,\n    scaledEntries,\n    stageEntries,\n    seedsCount,\n    scaleName,\n  });\n")),(0,i.kt)("hr",null),(0,i.kt)("h2",{id:"generateteamsfromparticipantattribute"},"generateTeamsFromParticipantAttribute"),(0,i.kt)("p",null,"Uses attributes of individual participnts or persons to generate ",(0,i.kt)("inlineCode",{parentName:"p"},"{ participantType: TEAM }")," participants."),(0,i.kt)("p",null,"Returns count of # of TEAM participants added;"),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-js"},"const { participantsAdded } =\n  tournamentEngine.generateTeamsFromParticipantAttribute({\n    participantAttribute, // optional -- attribute of participant object\n    personAttribute, // optional - attribute of person object\n    accessor, // optional - use accessor string to retrieve nested value (even from person address arrays)\n    uuids, // optional - uuids to assign to generated participants\n  });\n")),(0,i.kt)("hr",null),(0,i.kt)("h2",{id:"generatevolunataryconsolation"},"generateVolunataryConsolation"),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-js"},"const { structures, links } = tournamentEngine.generateVoluntaryConsolation({\n  attachConsolation: false, // optional - defaults to true\n  automated: true,\n  drawId,\n});\n\n// if { attachConsolation: false } then it will be necessary to subsequently attach the structures and links\ntournamentEngine.attachConsolationStructures({ drawId, structures, links });\n")),(0,i.kt)("hr",null),(0,i.kt)("h2",{id:"getalleventdata"},"getAllEventData"),(0,i.kt)("p",null,"Returns all ",(0,i.kt)("inlineCode",{parentName:"p"},"matchUps")," for all draws in all events along with ",(0,i.kt)("inlineCode",{parentName:"p"},"tournamentInfo"),", ",(0,i.kt)("inlineCode",{parentName:"p"},"eventInfo"),", and ",(0,i.kt)("inlineCode",{parentName:"p"},"drawInfo"),"."),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-js"},"const { allEventData } = tournamentEngine.getAllEventData({\n  policyDefinitions, // optional - allows participant data to be filtered via a privacy policy\n});\n\nconst { tournamentInfo, eventsData, venuesData } = allEventData;\n")),(0,i.kt)("hr",null),(0,i.kt)("h2",{id:"getalloweddrawtypes"},"getAllowedDrawTypes"),(0,i.kt)("p",null,"Returns an array of names of allowed Draw Types, if any applicable policies have been applied to the tournamentRecord."),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-js"},"const drawTypes = tournamentEngine.getAllowedDrawTypes();\n")),(0,i.kt)("hr",null),(0,i.kt)("h2",{id:"getallowedmatchupformats"},"getAllowedMatchUpFormats"),(0,i.kt)("p",null,"Returns an array of TODS matchUpFormat codes for allowed scoring formats, if any applicable policies have been applied to the tournamentRecord."),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-js"},"const drawTypes = tournamentEngine.getAllowedMatchUpFormats();\n")),(0,i.kt)("hr",null),(0,i.kt)("h2",{id:"getavailableplayoffrounds"},"getAvailablePlayoffRounds"),(0,i.kt)("p",null,"If provided a ",(0,i.kt)("inlineCode",{parentName:"p"},"structureId"),", returns rounds of the selected structure which are available for adding playoff structures."),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-js"},"const { playoffRounds, playoffRoundsRanges, positionsPlayedOff } =\n  tournamentEngine.getAvailablePlayoffRounds({\n    drawId,\n    structureId,\n  });\n")),(0,i.kt)("p",null,"...For a SINGLE_ELIMINATION struture with drawSize: 16 this would return:"),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-js"},"    {\n      playoffRounds: [ 1, 2, 3 ],\n      playoffRoundsRanges: [\n        { round: 1, range: '9-16' },\n        { round: 2, range: '5-8' },\n        { round: 3, range: '3-4' }\n      ]\n    }\n\n")),(0,i.kt)("p",null,"When no ",(0,i.kt)("inlineCode",{parentName:"p"},"structureId")," is provided, returns an array of ",(0,i.kt)("inlineCode",{parentName:"p"},"availablePlayoffRounds")," with entries for each structure in a specified ",(0,i.kt)("inlineCode",{parentName:"p"},"drawDefinition"),"."),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-js"},"const { availablePlayoffRounds, positionsPlayedOff } =\n  tournamentEngine.getAvailablePlayoffRounds({ drawId });\n")),(0,i.kt)("hr",null),(0,i.kt)("h2",{id:"getcourtinfo"},"getCourtInfo"),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-js"},"const {\n  altitude,\n  courtId,\n  courtName,\n  courtDimensions,\n  latitude,\n  longitude,\n  surfaceCategory,\n  surfaceType,\n  surfaceDate,\n  pace,\n  notes,\n} = tournamentEngine.getCourtInfo({ courtId });\n")),(0,i.kt)("hr",null),(0,i.kt)("h2",{id:"getcourts"},"getCourts"),(0,i.kt)("p",null,"Returns courts associated with a tournaments; optionally filter by venue(s)."),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-js"},"const { courts } = tournamentEngine.getCourts({\n  venueId, // optional - return courts for a specific venue\n  venueIds, // optional - return courts for specified venues\n});\n")),(0,i.kt)("hr",null),(0,i.kt)("h2",{id:"getdrawdata"},"getDrawData"),(0,i.kt)("p",null,"Primarily used by ",(0,i.kt)("inlineCode",{parentName:"p"},"getEventData")," for publishing purposes."),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-js"},"const {\n  drawInfo: {\n    drawActive, // boolean - draw has active matchUps\n    drawCompleted, // boolean - all draw matchUps are complete\n    drawGenerated, // boolean - draw has structures containing matchUps\n    participantPlacements, // boolean - whether any participants have been placed in the draw\n  },\n  structures,\n} = tournamentEngine.getDrawData({ drawDefinition });\n")),(0,i.kt)("hr",null),(0,i.kt)("h2",{id:"getdrawparticipantrepresentativeids"},"getDrawParticipantRepresentativeIds"),(0,i.kt)("p",null,"Get the participantIds of participants in the draw who are representing players by observing the creation of the draw."),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-js"},"const { representativeParticipantIds } =\n  tournamentEngine.getDrawParticipantRepresentativeIds({\n    drawId,\n  });\n")),(0,i.kt)("hr",null),(0,i.kt)("h2",{id:"geteligiblevoluntaryconsolationparticipants"},"getEligibleVoluntaryConsolationParticipants"),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-js"},"const { eligibleParticipants } =\n  tournamentEngine.getEligibleVoluntaryConsolationParticipants({\n    excludedMatchUpStatuses, // optional - array of matchUpStatuses which are excluded from matchUpsLimit\n    includeQualifyingStage, // optional - allow losers in qualifying\n    finishingRoundLimit, // optional number - limits considered matchUps by finishingRound, e.g. 3 doesn't consider past QF\n    roundNumberLimit, // optional number - limits matchUps by roundNumber\n    matchUpsLimit, // optional number - limits the number of considered matchUps; works in tandem with excludedMatchUpStatuses\n    winsLimit, // defaults to 0, meaning only participants with no wins are eligible\n    requireLoss, // optional boolean - defaults to true; if false then all participants who have played and appear in MAIN draw are considered\n    requirePlay, // optional boolean - defaults to true; if false then all participants who appear in MAIN draw are considered\n    allEntries, // optional boolean - consider all entries, regardless of whether placed in draw\n    includeEventParticipants, // optional boolean - consider event entries rather than draw entries (if event is present)\n    drawId,\n  });\n")),(0,i.kt)("hr",null),(0,i.kt)("h2",{id:"getentriesandseedscount"},"getEntriesAndSeedsCount"),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-js"},"const { error, entries, seedsCount, stageEntries } =\n  tournamentEngine.getEntriesAndSeedsCount({\n    policyDefinitions, // seeding policy which determines # of seeds for # of participants/drawSize\n    eventId,\n    drawSize, // optional - overrides number calculaed from entries in either event or draw\n    drawId, // optional - scopes entries to a specific flight/drawDefinition\n    stage, // optional - scopes entries to a specific stage\n  });\n")),(0,i.kt)("hr",null),(0,i.kt)("h2",{id:"getentrystatusreports"},"getEntryStatusReports"),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-js"},"const {\n  tournamentEntryReport: {\n    nonParticipatingEntriesCount,\n    individualParticipantsCount,\n    drawDefinitionsCount,\n    eventsCount,\n  },\n  entryStatusReports, // count and pct of total for all entryStatuses for each event\n  personEntryReports, // person entryStatus, ranking, seeding, WTN and confidence for each event\n  eventReports, // primarily internal use - entries for each event with main/qualifying seeding\n} = tournamentEngine.getEntryStatusReports();\n")),(0,i.kt)("p",null,"To export reports as CSV:"),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-js"},"const entryStatusCSV = utilities.JSON2CSV(entryStatusReports);\nconst personEntryCSV = utilities.JSON2CSV(personEntryReports);\n")),(0,i.kt)("hr",null),(0,i.kt)("h2",{id:"getevent"},"getEvent"),(0,i.kt)("p",null,"Get an event by either its ",(0,i.kt)("inlineCode",{parentName:"p"},"eventId")," or by a ",(0,i.kt)("inlineCode",{parentName:"p"},"drawId")," which it contains. Also returns ",(0,i.kt)("inlineCode",{parentName:"p"},"drawDefinition")," if a ",(0,i.kt)("inlineCode",{parentName:"p"},"drawId")," is specified."),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-js"},"const {\n  event,\n  drawDefinition, // only returned if drawId is specified\n} = tournamentEngine.getEvent({\n  eventId, // optional - find event by eventId\n  drawId, // optional - find the event which contains specified drawId\n});\n")),(0,i.kt)("ul",null,(0,i.kt)("li",{parentName:"ul"},"@param {string} eventId - id of the event to retreive"),(0,i.kt)("li",{parentName:"ul"},"@param {object} context - attributes to be added into each event object.")),(0,i.kt)("hr",null),(0,i.kt)("h2",{id:"getevents"},"getEvents"),(0,i.kt)("p",null,"Return ",(0,i.kt)("strong",{parentName:"p"},"deepCopies")," of all events in a tournament record."),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-js"},"const { events } = tournamentEngine.getEvents();\n")),(0,i.kt)("hr",null),(0,i.kt)("h2",{id:"geteventdata"},"getEventData"),(0,i.kt)("p",null,"Returns event information optimized for publishing: ",(0,i.kt)("inlineCode",{parentName:"p"},"matchUps")," have context and separated into rounds for consumption by visualization libraries such as ",(0,i.kt)("inlineCode",{parentName:"p"},"tods-react-draws"),"."),(0,i.kt)("p",null,"See ",(0,i.kt)("a",{parentName:"p",href:"#publishEvent"},"publishEvent")," for details on ",(0,i.kt)("inlineCode",{parentName:"p"},"policyDefinitions"),"."),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-js"},"const { eventData } = tournamentEngine.getEventData({\n  participantsProfile, // optional - ability to specify additions to context (see parameters of getTournamentParticipants())\n  policyDefinitions, // optional\n  usePublishState, // optional - filter out draws which are not published\n  eventId,\n});\nconst { drawsData, venuesData, eventInfo, tournamentInfo } = eventData;\n")),(0,i.kt)("hr",null),(0,i.kt)("h2",{id:"geteventproperties"},"getEventProperties"),(0,i.kt)("p",null,"Gather attributes of events which come from other tournament elements, e.g. participants which have rankings/ratings/seedings for a given event."),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-js"},"const {\n  entryScaleAttributes,\n  hasSeededParticipants,\n  hasRankedParticipants,\n  hasRatedParticipants,\n} = tournamentEngine.getEventProperties({ eventId });\n")),(0,i.kt)("p",null,"... where ",(0,i.kt)("strong",{parentName:"p"},"entryScaleAttributes")," is an array of { prticipantId, participantName, seed, ranking, rating }"),(0,i.kt)("hr",null),(0,i.kt)("h2",{id:"geteventmatchupformattiming"},"getEventMatchUpFormatTiming"),(0,i.kt)("p",null,"Method is used internally in advanced scheduling to determine averageMatchUp times for matchUps within an event."),(0,i.kt)("p",null,"Requires an array of ",(0,i.kt)("inlineCode",{parentName:"p"},"matchUpFormats")," either be defined in scoring policy that is attached to the tournamentRecord or an event, or passed in as parameter. ",(0,i.kt)("inlineCode",{parentName:"p"},"matchUpFormats")," can be passed either as an array of strings, or an array of ",(0,i.kt)("inlineCode",{parentName:"p"},"[{ matchUpFormat }]"),"."),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-js"},"const { eventMatchUpFormatTiming } =\n  tournamentEngine.getEventMatchUpFormatTiming({\n    matchUpFormats, // optional - can be retrieved from policy\n    categoryType, // optional - categoryType is not part of TODS or event attributes, but can be defined in a policy\n    eventId,\n  });\n")),(0,i.kt)("hr",null),(0,i.kt)("h2",{id:"geteventstructures"},"getEventStructures"),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-js"},"const { structures, stageStructures } = tournamentEngine.getEventStructures({\n  withStageGrouping: true, // optional return structures grouped by stages\n  stageSequences, // optional - specify stageSequences to include\n  stageSequence, // optional - filter by stageSequence\n  stages, // optional - specify stageSequences to include\n  stage, // optional - filter by stage\n  eventId, // REQUIRED\n});\n")),(0,i.kt)("hr",null),(0,i.kt)("h2",{id:"getflightprofile"},"getFlightProfile"),(0,i.kt)("p",null,"A ",(0,i.kt)("inlineCode",{parentName:"p"},"flightProfile")," is an extension on an ",(0,i.kt)("inlineCode",{parentName:"p"},"event")," detailing the parameters that will be used to generate ",(0,i.kt)("inlineCode",{parentName:"p"},"drawDefinitions")," within the ",(0,i.kt)("inlineCode",{parentName:"p"},"event"),". There is an array of ",(0,i.kt)("inlineCode",{parentName:"p"},"flights")," which specify attributes of a draw such as ",(0,i.kt)("inlineCode",{parentName:"p"},"drawEntries, drawName, drawId, flightNumber")," as well as ",(0,i.kt)("inlineCode",{parentName:"p"},"stage"),', which is significant for flights which are only intended to reflect VOLUNTARY_CONSOLATION structures. A Voluntary Consolation flight is "linked" to the flight from which competitors originate and will be automatically deleted if the source flight is deleted.'),(0,i.kt)("p",null,"If a ",(0,i.kt)("inlineCode",{parentName:"p"},"flight")," has already been used to generate a draw, the ",(0,i.kt)("inlineCode",{parentName:"p"},"drawDefinition")," will be returned with the profile."),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-js"},"const { flightProfile } = tournamentEngine.getFlightProfile({ eventId });\n")),(0,i.kt)("hr",null),(0,i.kt)("h2",{id:"getmatchupcompetitiveness"},"getMatchUpCompetitiveness"),(0,i.kt)("p",null,'Returns a categorization of a matchUp as "Competitive", "Routine" or "Decisive"'),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-js"},"const { competitiveness } = tournamentEngine.getMatchUpCompetitiveness({\n  competitiveProfile, // optional { [DECISIVE]: 20, [ROUTINE]: 50 } // can be attached to tournamentRecord as a policy\n  matchUp,\n});\n")),(0,i.kt)("hr",null),(0,i.kt)("h2",{id:"getmatchupformat"},"getMatchUpFormat"),(0,i.kt)("p",null,"Returns ",(0,i.kt)("inlineCode",{parentName:"p"},"matchUpFormat")," codes for specified context(s). Refer to ",(0,i.kt)("inlineCode",{parentName:"p"},"getMatchUpFormat.test.js")," for specfic use cases."),(0,i.kt)("p",null,(0,i.kt)("inlineCode",{parentName:"p"},"matchUpFormat")," for each matchUp is determined by traversing the hierarchy: ",(0,i.kt)("inlineCode",{parentName:"p"},"matchUp => stucture => drawDefinition => event")),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-js"},"const {\n  matchUpFormat,\n  structureDefaultMatchUpFormat,\n  drawDefaultMatchUpFormat,\n  eventDefaultMatchUpFormat,\n} = tournamentEngine.getMatchUpFormat({\n  eventId,\n  drawId,\n  structureId,\n  matchUpId,\n});\n")),(0,i.kt)("hr",null),(0,i.kt)("h2",{id:"getmatchupformattiming"},"getMatchUpFormatTiming"),(0,i.kt)("p",null,"Searches for policy definitions or extensions to determine the ",(0,i.kt)("inlineCode",{parentName:"p"},"averageMinutes")," and ",(0,i.kt)("inlineCode",{parentName:"p"},"recoveryMinutes")," for a given ",(0,i.kt)("inlineCode",{parentName:"p"},"matchUpFormat"),". Extensions are considered to be overrides of policy definitions."),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-js"},"const { averageMinutes, recoveryMinutes } =\n  tournamentEngine.getMatchUpFormatTiming({\n    defaultAverageMinutes, // optional setting if no matching definition found\n    defaultRecoveryMinutes, // optional setting if no matching definition found\n    matchUpFormat,\n    categoryName, // optional\n    categoryType, // optional\n    eventType, // optional - defaults to SINGLES; SINGLES, DOUBLES\n    eventId, // optional - prioritizes policy definition attached to event before tournament record\n  });\n")),(0,i.kt)("hr",null),(0,i.kt)("h2",{id:"getmatchupformattimingupdate"},"getMatchUpFormatTimingUpdate"),(0,i.kt)("p",null,'Returns an array of methods/params necessary for updating a remote instance of a tournamentRecord to match a local instance. This method enables multiple "provisional" updates to be made on a local document without contacting a server; support deployments where a server is considered "master".'),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-js"},"const { methods } = tournamentEngine.getMatchUpFormatTimingUpdate();\n")),(0,i.kt)("hr",null),(0,i.kt)("h2",{id:"getmatchupscheduledetails"},"getMatchUpScheduleDetails"),(0,i.kt)("p",null,"Returns the latest values for all ",(0,i.kt)("inlineCode",{parentName:"p"},"matchUp.timeItems"),", along with calculated values, that relate to the scheduling of a ",(0,i.kt)("inlineCode",{parentName:"p"},"matchUp"),"."),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-js"},"const {\n  schedule: {\n    time,\n    courtId,\n    venueId,\n    startTime,\n    endTime,\n    milliseconds,\n    scheduledDate,\n    scheduledTime,\n  },\n} = tournamentEngine.getMatchUpScheduleDetails({\n  scheduleVisibilityFilters, // { visibilityThreshold: Date, eventIds, drawIds }\n  matchUp,\n});\n")),(0,i.kt)("hr",null),(0,i.kt)("h2",{id:"getmatchupsstats"},"getMatchUpsStats"),(0,i.kt)("p",null,"Returns percentages of matchUps which fall into ",(0,i.kt)("inlineCode",{parentName:"p"},"cmpetitiveBands"),' defined as "Competitive", "Routine", and "Decisive".'),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-js"},"const { competitiveBands } = tournamentEngine.getMatchUpsStats({\n  competitiveProfile, // optional { [DECISIVE]: 20, [ROUTINE]: 50 } // can also be set in policyDefinitions\n  matchUps,\n});\n")),(0,i.kt)("hr",null),(0,i.kt)("h2",{id:"getmatchupdailylimits"},"getMatchUpDailyLimits"),(0,i.kt)("p",null,"Returns player daily match limits for singles/doubles/total matches."),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-js"},"const { matchUpDailyLimits } = tournamentId.getMatchUpDailyLimits();\nconst { DOUBLES, SINGLES, total } = matchUpDailyLimits;\n")),(0,i.kt)("hr",null),(0,i.kt)("h2",{id:"getmodifiedmatchupformattiming"},"getModifiedMatchUpFormatTiming"),(0,i.kt)("p",null,"Returns ",(0,i.kt)("inlineCode",{parentName:"p"},"averageTimes")," and ",(0,i.kt)("inlineCode",{parentName:"p"},"recoveryTimes")," configuration objects for specified ",(0,i.kt)("inlineCode",{parentName:"p"},"matchUpFormat"),". Useful before calling ",(0,i.kt)("inlineCode",{parentName:"p"},"modifyMatchUpFormatTiming")," to preserve existing modifications."),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-js"},"const { matchUpFormat, averageTimes, recoveryTimes } =\n  tournamentEngine.getModifiedMatchUpFormatTiming({\n    matchUpFormat, // TODS matchUpFormat code\n    event, // optional - include event in scope for search\n  });\n")),(0,i.kt)("hr",null),(0,i.kt)("h2",{id:"getpairedparticipant"},"getPairedParticipant"),(0,i.kt)("p",null,"Returns the ",(0,i.kt)("inlineCode",{parentName:"p"},"{ participantType: PAIR }"),", if any, which contains the specified ",(0,i.kt)("inlineCode",{parentName:"p"},"individualParticipantIds"),"."),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-js"},"const { participant } = tournamentEngine.getPairedParticipant({\n  participantIds: individualParticipantIds,\n});\n")),(0,i.kt)("hr",null),(0,i.kt)("h2",{id:"getparticipanteventdetails"},"getParticipantEventDetails"),(0,i.kt)("p",null,"Returns an array of eventDetails in which a specified ",(0,i.kt)("inlineCode",{parentName:"p"},"participantId")," appears. For details on draw entry within events use ",(0,i.kt)("inlineCode",{parentName:"p"},"tournamentEngine.getTournamentParticipants({ inContext: true })"),"."),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-js"},"const { eventDetails } = tournamentEngine.getParticipantEventDetails({\n  participantId,\n});\n\nconst [{ eventName, eventId }] = eventDetails;\n")),(0,i.kt)("hr",null),(0,i.kt)("h2",{id:"getparticipantidfinishingpositions"},"getParticipantIdFinishingPositions"),(0,i.kt)("p",null,"Returns the Range of finishing positions possible for all participantIds within a draw"),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-js"},"const idMap = tournamentEngine.getParticipantIdFinishingPositions({\n  byeAdvancements, // optional boolean - whether or not to consider byeAdvancements\n  drawId,\n});\n\nconst { relevantMatchUps, finishingPositionRanges, finishingPositionRange } =\n  idMap[participantId];\n")),(0,i.kt)("hr",null),(0,i.kt)("h2",{id:"getparticipantmembership"},"getParticipantMembership"),(0,i.kt)("p",null,"Returns all grouping participants which include ",(0,i.kt)("inlineCode",{parentName:"p"},"participantId")," in ",(0,i.kt)("inlineCode",{parentName:"p"},"{ individualParticipantIds }"),"."),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-js"},"const {\n  [PAIR]: doublesParticipantIds,\n  [GROUP]: groupParticipantIds,\n  [TEAM]: teamParticipantIds,\n} = tournamentEngine.getParticipantMembership({\n  participantId,\n});\n")),(0,i.kt)("hr",null),(0,i.kt)("h2",{id:"getparticipantscaleitem"},"getParticipantScaleItem"),(0,i.kt)("p",null,"Return a ranking or rating or seeding value for a participant, referenced by participantId."),(0,i.kt)("p",null,"See ",(0,i.kt)("a",{parentName:"p",href:"../concepts/scaleItems"},"Scale Items"),"."),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-js"},"const scaleAttributes = {\n  scaleType: RATING,\n  eventType: SINGLES,\n  scaleName: 'WTN',\n  accessor, // optional - string determining how to access attribute if scaleValue is an object\n};\nconst {\n  scaleItem: { scaleValue },\n} = tournamentEngine.getParticipantScaleItem({\n  participantId,\n  scaleAttributes,\n});\n")),(0,i.kt)("hr",null),(0,i.kt)("h2",{id:"getparticipantschedules"},"getParticipantSchedules"),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-js"},"const { participantSchedules } = tournamentEngine.getParticipantSchedules({\n  participantFilters: { participantIds, participantTypes, eventIds },\n});\n")),(0,i.kt)("hr",null),(0,i.kt)("h2",{id:"getparticipantsigninstatus"},"getParticipantSignInStatus"),(0,i.kt)("p",null,"Participant signInStatus can be either 'SIGNED_IN' or 'SIGNED_OUT' (or undefined). See ",(0,i.kt)("a",{parentName:"p",href:"#modifyParticipantsSignInStatus"},"modifyParticipantsSignInStatus"),"."),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-js"},"const signInStatus = tournamentEngine.getParticipantSignInStatus({\n  participantId,\n});\n")),(0,i.kt)("hr",null),(0,i.kt)("h2",{id:"getpolicydefinitions"},"getPolicyDefinitions"),(0,i.kt)("p",null,"Finds policies which have been attached to the tournamentRecord, or to a target event, or target drawDefinition, in reverse order.\nOnce a matching ",(0,i.kt)("inlineCode",{parentName:"p"},"policyType")," has been found, higher level policies of the same type are ignored, enabling a default policy to be attached to the tournamentRecord and for event-specific or draw-specific policies to override the default(s)."),(0,i.kt)("p",null,"The constructed ",(0,i.kt)("inlineCode",{parentName:"p"},"policyDefinitions")," object contains targeted policies from all levels, scoped to the lowest level specified."),(0,i.kt)("p",null,"See ",(0,i.kt)("a",{parentName:"p",href:"../concepts/policies"},"Policies"),"."),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-js"},"const { policyDefinitions } = tournamentEngine.getPolicyDefinitions({\n  policyTypes: [POLICY_TYPE_SEEDING],\n  eventId, // optional\n  drawId, // optional\n});\n")),(0,i.kt)("hr",null),(0,i.kt)("h2",{id:"getpositionassignments"},"getPositionAssignments"),(0,i.kt)("p",null,"Returns an array of ",(0,i.kt)("inlineCode",{parentName:"p"},"positionAssignments")," for a structure. Combines ",(0,i.kt)("inlineCode",{parentName:"p"},"positionAssginments")," for child structures in the case of ROUND_ROBIN where ",(0,i.kt)("inlineCode",{parentName:"p"},"{ structureType: CONTAINER }"),"."),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-js"},"let { positionAssignments } = tournamentEngine.getPositionAssignments({\n  structureId, // optional if { structure } is provided\n  structure, // optional if { drawId, structureId } are provided\n  drawId, // optional if { structure } is provided\n});\n\nconst [{ drawPosition, participantId, qualifier, bye }] = positionAssignments;\n")),(0,i.kt)("hr",null),(0,i.kt)("h2",{id:"getpredictiveaccuracy"},"getPredictiveAccuracy"),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-js"},"const { accuracy, zoneDistribution } = tournamentEngine.getPredictiveAccuracy({\n  exclusionRule: { valueAccessor: 'confidence', range: [0, 70] }, // exclude low confidence values\n  zoneMargin: 3, // optional - creates +/- range and report competitiveness distribution\n  matchUpFilters: { matchUpStatuses: [COMPLETED] }, // only consider COMPLETED matchUps\n  ascending: true, // scale goes from low to high\n  valueAccessor: 'wtnRating',\n  scaleName: WTN,\n});\n")),(0,i.kt)("hr",null),(0,i.kt)("h2",{id:"getscaledentries"},"getScaledEntries"),(0,i.kt)("p",null,"See ",(0,i.kt)("a",{parentName:"p",href:"../concepts/scaleItems"},"Scale Items"),"."),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-js"},"const { scaledEntries } = tournamentEngine.getScaledEntries({\n  eventId, // optional - not required if provided array of entries\n  entries, // optional - overrides use of event.entries\n  stage, // optional - filter entries by stage\n\n  scaleAttributes,\n  scaleSortMethod, // optional - function(a, b) {} sort method, useful when scaleValue is an object or further proessing is required\n  sortDescending, // optional - default sorting is ASCENDING; only applies to default sorting method.\n});\n")),(0,i.kt)("hr",null),(0,i.kt)("h2",{id:"getseedscount"},"getSeedsCount"),(0,i.kt)("p",null,"Takes a policyDefinition, drawSize and participantCount and returrns the number of seeds valid for the specified drawSize"),(0,i.kt)("admonition",{type:"note"},(0,i.kt)("p",{parentName:"admonition"},(0,i.kt)("inlineCode",{parentName:"p"},"drawSizeProgression")," will be overridden by a ",(0,i.kt)("inlineCode",{parentName:"p"},"{ drawSizeProgression }")," value in a policyDefinition.")),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-js"},"const { seedsCount, error } = tournamentEngine.getSeedsCount({\n  drawSizeProgression, // optional - fits the seedsCount to the participantsCount rather than the drawSize\n  policyDefinitions: SEEDING_USTA,\n  participantCount: 15,\n  drawSize: 128,\n});\n")),(0,i.kt)("hr",null),(0,i.kt)("h2",{id:"getstate"},"getState"),(0,i.kt)("p",null,"Returns a deep copy of the current tournamentEngine state."),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-js"},"const { tournamentRecord } = tournamentEngine.getState({\n  convertExtensions, // optional - convert extensions to '_' prefixed attributes\n  removeExtensions, // optional - strip all extensions out of tournamentRecord\n});\n")),(0,i.kt)("hr",null),(0,i.kt)("h2",{id:"getstructurereports"},"getStructureReports"),(0,i.kt)("p",null,"Returns details of all structures within a tournamentRecord, as well as aggregated details per event."),(0,i.kt)("p",null,(0,i.kt)("inlineCode",{parentName:"p"},"tournamentId, eventId, structureId, drawId, eventType, category: subType, categoryName, ageCategoryCode, flightNumber, drawType, stage, winningPersonId, winningPersonWTNrating, winningPersonWTNconfidence, winningPerson2Id, winningPerson2WTNrating, winningPerson2WTNconfidence, positionManipulations, pctNoRating, matchUpFormat, pctInitialMatchUpFormat, matchUpsCount, tieFormatDesc, tieFormatName, avgConfidence, avgWTN")),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-js"},"const {\n  structureReports,\n  eventStructureReports: {\n    totalPositionManipulations,\n    maxPositionManipulations,\n    generatedDrawsCount,\n    drawDeletionsCount,\n  },\n} = tournamentEngine.getStructureReports({\n  firstFlightOnly, // boolean - defaults to true - only return first flight when multiple drawDefinitions per event\n  extensionProfiles: [\n    {\n      name, // extension name\n      label, // label for generated attribute\n      accessor, // dot-notation accessor for extension value, e.g. 'attribute.attribute'\n    },\n  ],\n});\n")),(0,i.kt)("p",null,"To export report as CSV:"),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-js"},"const csv = utilities.JSON2CSV(structureReports);\n")),(0,i.kt)("hr",null),(0,i.kt)("h2",{id:"getteamlineup"},"getTeamLineUp"),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-js"},"const { lineUp } = tournamentEngine.getTeamLineUp({ drawId, participantId });\n")),(0,i.kt)("hr",null),(0,i.kt)("h2",{id:"gettieformat"},"getTieFormat"),(0,i.kt)("p",null,"Returns ",(0,i.kt)("inlineCode",{parentName:"p"},"tieFormat")," definition objects for specified context(s)."),(0,i.kt)("p",null,(0,i.kt)("inlineCode",{parentName:"p"},"tieFormat")," for each matchUp is determined by traversing the hierarchy: ",(0,i.kt)("inlineCode",{parentName:"p"},"matchUp => stucture => drawDefinition => event")),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-js"},"const {\n  tieFormat,\n  structureDefaultTieFormat,\n  drawDefaultTieFormat,\n  eventDefaultTieFormat,\n} = tournamentEngine.getTieFormat({\n  structureId,\n  matchUpId,\n  eventId,\n  drawId,\n});\n")),(0,i.kt)("hr",null),(0,i.kt)("h2",{id:"gettournamentinfo"},"getTournamentInfo"),(0,i.kt)("p",null,"Returns tournament attributes. Used to attach details to publishing payload by ",(0,i.kt)("inlineCode",{parentName:"p"},"getEventData"),"."),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-js"},"const { tournamentInfo } = getTournamentInfo({ tournamentRecord });\nconst {\n  tournamentId,\n  tournamentRank,\n\n  formalName,\n  tournamentName,\n  promotionalName,\n  onlineResources,\n\n  localTimeZone,\n  startDate,\n  endDate,\n\n  hostCountryCode,\n  tournamentContacts,\n  tournamentAddresses,\n} = tournamentInfo;\n")),(0,i.kt)("hr",null),(0,i.kt)("h2",{id:"gettournamentparticipants"},"getTournamentParticipants"),(0,i.kt)("p",null,"Returns ",(0,i.kt)("strong",{parentName:"p"},"deepCopies")," of tournament participants filtered by participantFilters which are arrays of desired participant attribute values."),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-js"},"const participantFilters = {\n  accessorValues: [{ accessor, value }], // optional - see Accessors in Concepts\n  eventEntryStatuses, // boolean\n  participantTypes: [INDIVIDUAL],\n  participantRoles, [COMPETITOR],\n  signInStatus, // specific signIn status\n  eventIds, // events in which participants appear\n};\nconst {\n  tournamentParticipants,\n  participantIdsWithConflicts //  returns array of participantIds which have scheduling conflicts\n  eventsPublishStatuses: { publishedDrawIds, publishedSeeding }, // useful for presenting tournament participants on public sites\n} = tournamentEngine.getTournamentParticipants({\n  inContext, // optional - adds individualParticipants for all individualParticipantIds\n\n  withMatchUps, // optional - include all matchUps in which the participant appears, as well as potentialMatchUps\n  withScaleValues, // optional - include { ratings, rankings } attributes extracted from timeItems\n  withStatistics, // optional - adds events, machUps and statistics, e.g. 'winRatio'\n  withGroupings, // optional - include membership in group, pair, and team participants\n  withOpponents, // optional - include opponent participantIds\n  withSeeding, // optionsl - add event seeding\n  withEvents, // optional - defaults to true if any other context options are specified\n  withDraws, // optional - defaults to true if any other context options are specified\n  withISO2, // optional - will add ISO2 country code and countryName to participant persons\n  withIOC, // optional - will add IOC country code and countryName to participant persons\n\n  scheduleAnalysis: {\n    scheduledMinutesDifference // optional - scheduling conflicts determined by scheduledTime difference between matchUps\n  },\n\n  convertExtensions, // optional - BOOLEAN - convert extensions so _extensionName attributes\n  policyDefinitions, // optional - can accept a privacy policy to filter participant attributes\n  participantFilters, // optional - filters\n  usePublishState, // optional - BOOLEAN - don't add seeding information when not published\n});\n")),(0,i.kt)("h3",{id:"implemented-participantfilters"},"Implemented participantFilters"),(0,i.kt)("ul",null,(0,i.kt)("li",{parentName:"ul"},"enableOrFiltering: boolean - use OR logic instead of default AND"),(0,i.kt)("li",{parentName:"ul"},"accessorValues: array of accessors and targeted value ",(0,i.kt)("inlineCode",{parentName:"li"},"[{ accessor, value }]")),(0,i.kt)("li",{parentName:"ul"},"drawEntryStatuses: array of ",(0,i.kt)("inlineCode",{parentName:"li"},"entryStatus")," values for participantIds found in draw.entries"),(0,i.kt)("li",{parentName:"ul"},"eventEntryStatuses: array of ",(0,i.kt)("inlineCode",{parentName:"li"},"entryStatus")," values for participantIds found in event.entries"),(0,i.kt)("li",{parentName:"ul"},"eventIds: array of targeted eventIds"),(0,i.kt)("li",{parentName:"ul"},"participantIds: array of targeted participantIds"),(0,i.kt)("li",{parentName:"ul"},"participantRoles: array of targeted participantRoles"),(0,i.kt)("li",{parentName:"ul"},"participantTypes: array of targeted participantTypes"),(0,i.kt)("li",{parentName:"ul"},"positionedParticipants: participantIds positioned in structures ",(0,i.kt)("inlineCode",{parentName:"li"},"[true, false, undefined]")),(0,i.kt)("li",{parentName:"ul"},"signInStatus: SIGNED_IN or SIGNED_OUT")),(0,i.kt)("hr",null),(0,i.kt)("h2",{id:"gettournamentpersons"},"getTournamentPersons"),(0,i.kt)("p",null,"Returns ",(0,i.kt)("strong",{parentName:"p"},"deepCopies")," of persons extracted from tournament participants. Each person includes an array of ",(0,i.kt)("inlineCode",{parentName:"p"},"participantIds")," from which person data was retrieved."),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-js"},"const { tournamentPersons } = tournamentEngine.getTournamentPersons({\n  participantFilters: { participantRoles: [COMPETITOR] }, // optional - filters\n});\n")),(0,i.kt)("hr",null),(0,i.kt)("h2",{id:"gettournamentpenalties"},"getTournamentPenalties"),(0,i.kt)("p",null,"Returns an array of all penalties issued during a tournament."),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-js"},"const { penalties } = tournamentEngine.getTournamentPenalties();\n")),(0,i.kt)("hr",null),(0,i.kt)("h2",{id:"gettournamentstructures"},"getTournamentStructures"),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-js"},"const { structures, stageStructures } =\n  tournamentEngine.getTournamentStructures({\n    withStageGrouping: true, // optional return structures grouped by stages\n    stageSequences, // optional - specify stageSequences to include\n    stageSequence, // optional - filter by stageSequence\n    stages, // optional - specify stageSequences to include\n    stage, // optional - filter by stage\n  });\n")),(0,i.kt)("hr",null),(0,i.kt)("h2",{id:"getvenuesandcourts"},"getVenuesAndCourts"),(0,i.kt)("p",null,"Returns an array of all Venues which are part of a tournamentRecord and an aggregation of courts across all venues."),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-js"},"const { venues, courts } = tournamentEngine.getVenuesAndCourts({\n  convertExtensions, // optional boolean\n  ignoreDisabled, // optional boolean\n  dates, // optional - used with ignoreDisabled - applies to courts\n});\n")),(0,i.kt)("hr",null),(0,i.kt)("h2",{id:"getvenuedata"},"getVenueData"),(0,i.kt)("p",null,"Returns restricted venue attributes along with information for all associated courts. Used primarily by ",(0,i.kt)("inlineCode",{parentName:"p"},"getEventData")," to return a subset of venue/courts information for publishing purposes."),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-js"},"const {\n  venueName,\n  venueAbbreviation,\n  courtsInfo, // array of courts and associated attributes\n} = tournamentEngine.getVenueData({ venueId });\n")),(0,i.kt)("hr",null),(0,i.kt)("h2",{id:"isvalidmatchupformat"},"isValidMatchUpFormat"),(0,i.kt)("p",null,"Returns boolean indicating whether matchUpFormat code is valid."),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-js"},"const valid = tournamentEngine.isValidMatchUpFormat(matchUpFormat);\n")),(0,i.kt)("hr",null),(0,i.kt)("h2",{id:"luckyloserdrawpositionassignment"},"luckyLoserDrawPositionAssignment"),(0,i.kt)("p",null,"Replaces an existing drawPosition assignment with a luckyLoserParticipantId. This method is included in ",(0,i.kt)("inlineCode",{parentName:"p"},"validActions")," for ",(0,i.kt)("a",{parentName:"p",href:"../policies/positionActions"},"positionActions")),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-js"},"tournamentEngine.luckyLoserDrawPositionAssignment({\n  luckyLoserParticipantId,\n  drawPosition,\n  structureId,\n  drawId,\n});\n")),(0,i.kt)("hr",null),(0,i.kt)("h2",{id:"matchupactions"},"matchUpActions"),(0,i.kt)("p",null,"Return an array of all validActions for a specific matchUp."),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-js"},"const {\n  isByeMatchUp, // boolean; true if matchUp includes a BYE\n  structureIsComplete, // boolean; true if structure is ready for positioning\n  validActions, // array of possible actions given current matchUpStatus\n} = tournamentEngine.matchUpActions({\n  restrictAdHocRoundParticipants, // optional - true by default; applies to AD_HOC; disallow the same participant being in the same round multiple times\n  sideNumber, // optional - select side to which action should apply; applies to AD_HOC position assignments\n  drawId, // optional - not strictly required; method will find matchUp by brute force without it\n  matchUpId,\n});\n\nconst {\n  type, // 'REFEREE', 'SCHEDULE', 'PENALTY', 'STATUS', 'SCORE', 'START', 'END'.\n  method, // tournamentEngine method relating to action type\n  payload, // attributes to be passed to method\n  // additional method-specific options for values to be added to payload when calling method\n} = validAction;\n")),(0,i.kt)("hr",null),(0,i.kt)("h2",{id:"mergeparticipants"},"mergeParticipants"),(0,i.kt)("p",null,"Merge ",(0,i.kt)("inlineCode",{parentName:"p"},"participants")," array with existing tournament participants. Useful when synchronizing with a remote registration service, for example."),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-js"},"tournamentEngine.mergeParticipants({ participants });\n")),(0,i.kt)("hr",null),(0,i.kt)("h2",{id:"modifycollectiondefinition"},"modifyCollectionDefinition"),(0,i.kt)("p",null,"Modifies the ",(0,i.kt)("inlineCode",{parentName:"p"},"collectionName")," and/or ",(0,i.kt)("inlineCode",{parentName:"p"},"matchUpFormat")," for targeted ",(0,i.kt)("inlineCode",{parentName:"p"},"collectionId")," within the ",(0,i.kt)("inlineCode",{parentName:"p"},"tieFormat")," specified by ",(0,i.kt)("inlineCode",{parentName:"p"},"eventId"),", ",(0,i.kt)("inlineCode",{parentName:"p"},"drawId"),", ",(0,i.kt)("inlineCode",{parentName:"p"},"structureId")," or ",(0,i.kt)("inlineCode",{parentName:"p"},"matchUpId"),"."),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-js"},"tournamentEngine.modifyCollectionDefinition({\n  collectionName, // optional\n  matchUpFormat, // optional\n  collectionId, // required\n  structureId, // required if modifying tieFormat for a structure\n  matchUpId, // required if modifying tieFormat for a matchUp\n  eventId, // required if modifying tieFormat for a event\n  drawId, // required if modifying tieFormat for a drawDefinition or a structure\n  gender, // optional\n\n  // value assignment, only one is allowed to have a value\n  collectionValueProfile, // optional - [{ collectionPosition: 1, value: 2 }] - there must be a value provided for all matchUp positions\n  collectionValue, // optional - value awarded for winning more than half of the matchUps in the collection\n  matchUpValue, // optional - value awarded for each matchUp won\n  scoreValue, // optional - value awarded for each game or point won (points for tiebreak sets)\n  setValue, // optional - value awarded for each set won\n});\n")),(0,i.kt)("hr",null),(0,i.kt)("h2",{id:"modifycourt"},"modifyCourt"),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-js"},"tournamentEngine.modifyCourt({\n  courtId,\n  force, // applies only to dateAvailability, will remove scheduling information from matchUps where court is no longer available\n  modifications: {\n    courtName,\n    dateAvailability,\n    courtDimensions,\n    onlineResources,\n    surfaceCategory,\n    surfaceDate,\n    surfaceType,\n    altitude,\n    latitude,\n    longitude,\n    notes,\n    pace,\n  },\n});\n")),(0,i.kt)("hr",null),(0,i.kt)("h2",{id:"modifycourtavailability"},"modifyCourtAvailability"),(0,i.kt)("p",null,"Modifies the ",(0,i.kt)("inlineCode",{parentName:"p"},"dateAvailability")," attribute of a specified court. Warns if existing scheduled matchUps would be affected. See ",(0,i.kt)("a",{parentName:"p",href:"/docs/concepts/scheduling"},"Scheduling"),"."),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-js"},"const result = tournamentEngine.modifyCourtAvailability({\n  courtId,\n  dateAvailability,\n  force, // override warning that existing scheduled matchUps exist\n});\n")),(0,i.kt)("hr",null),(0,i.kt)("h2",{id:"modifydrawname"},"modifyDrawName"),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-js"},"tournamentEngine.modifyDrawName({\n  eventId,\n  drawId,\n  drawName,\n});\n")),(0,i.kt)("hr",null),(0,i.kt)("h2",{id:"modifyeventmatchupformattiming"},"modifyEventMatchUpFormatTiming"),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-js"},"tournamentEngine.modifyEventMatchUpFormatTiming({\n  eventId,\n  matchUpFormat,\n  averageMinutes,\n  recoveryMinutes,\n});\n")),(0,i.kt)("hr",null),(0,i.kt)("h2",{id:"modifymatchupformattiming"},"modifyMatchUpFormatTiming"),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-js"},"tournamentEngine.modifyMatchUpFormatTiming({\n  matchUpFormat: 'SET3-S:6/TB7',\n  averageTimes: [\n    {\n      categoryNames: [U12, U14],\n      minutes: { [DOUBLES]: 110, default: 130 },\n    },\n    {\n      categoryNames: [U16, U18],\n      minutes: { [DOUBLES]: 100, default: 120 },\n    },\n  ],\n  recoveryTimes: [\n    { categoryNames: [], minutes: { default: 15, [DOUBLES]: 15 } },\n  ],\n});\n")),(0,i.kt)("hr",null),(0,i.kt)("h2",{id:"modifyentriesstatus"},"modifyEntriesStatus"),(0,i.kt)("p",null,"Modify the entryStatus of participants already in an event or flight/draw. Does not allow participants assigned positions in structures to have an entryStatus of WITHDRAWN."),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-js"},"const result = tournamentEngine.modifyEntriesStatus({\n  participantIds, // ids of participants whose entryStatus will be modified\n  entryStatus, // new entryStatus\n  entryStage, // optional - e.g. QUALIFYING\n  extension, // optional - { name, value } - add if value; removes if value is undefined\n  eventId, // id of event where the modification(s) will occur\n  drawId, // optional - scope to a specific flight/draw\n  stage, // optional - scope to a specific stage\n\n  eventSync, // optional - if there is only a single drawDefinition in event, keep event.entries in sync\n  autoEntryPositions, // optional - keeps entries ordered by entryStage/entryStatus and auto-increments\n});\n")),(0,i.kt)("hr",null),(0,i.kt)("h2",{id:"modifyevententries"},"modifyEventEntries"),(0,i.kt)("p",null,"Modify the entries for an event. For DOUBLES events automatically create PAIR participants if not already present."),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-js"},"tournamentEngine.modifyEventEntries({\n  entryStatus = DIRECT_ACCEPTANCE,\n  unpairedParticipantIds = [],\n  participantIdPairs = [],\n  entryStage = MAIN,\n  eventId,\n})\n")),(0,i.kt)("hr",null),(0,i.kt)("h2",{id:"modifyindividualparticipantids"},"modifyIndividualParticipantIds"),(0,i.kt)("p",null,"Modify ",(0,i.kt)("inlineCode",{parentName:"p"},"individualParticipantIds")," of a grouping participant ",(0,i.kt)("inlineCode",{parentName:"p"},"{ participantType: TEAM || GROUP }"),"."),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-js"},"tournamentEngine.devContext(true).modifyIndividualParticipantIds({\n  groupingParticipantId, // participant (TEAM or GROUP) to which participantIds are to be added\n  individualParticipantIds: newIndividualParticipantIds,\n});\n")),(0,i.kt)("hr",null),(0,i.kt)("h2",{id:"modifyparticipant"},"modifyParticipant"),(0,i.kt)("p",null,"Modifies attributes of a participant with integrity checks to ensure valid values for e.g. ",(0,i.kt)("inlineCode",{parentName:"p"},"{ participantType, participantRole }"),". Adds participant if not found."),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-js"},"tournamentEngine.modifyParticipant({\n  participant: updatedIndividualParticipant,\n});\n")),(0,i.kt)("hr",null),(0,i.kt)("h2",{id:"modifypenalty"},"modifyPenalty"),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-js"},"const penaltyData = {\n  participantIds: [participantId],\n  penaltyType: BALL_ABUSE,\n  matchUpId,\n  issuedAt,\n  notes: 'Hit ball into sea',\n};\nlet result = tournamentEngine.addPenalty(penaltyData);\nconst { penaltyId } = result;\n\nconst notes = 'Hit ball into spectator';\nconst modifications = { notes };\ntournamentEngine.modifyPenalty({ penaltyId, modifications });\n")),(0,i.kt)("hr",null),(0,i.kt)("h2",{id:"modifyparticipantssigninstatus"},"modifyParticipantsSignInStatus"),(0,i.kt)("p",null,"Modify the signInStatus of multiple participants, referenced by participantId."),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-js"},"tournamentEngine.modifyParticipantsSignInStatus({\n  participantIds: [participantId],\n  signInState: SIGNED_IN,\n});\n")),(0,i.kt)("hr",null),(0,i.kt)("h2",{id:"modifyseedassignment"},"modifySeedAssignment"),(0,i.kt)("p",null,"Change the display representation of a seedNumber for a specified ",(0,i.kt)("inlineCode",{parentName:"p"},"participantId"),". This method is included in ",(0,i.kt)("inlineCode",{parentName:"p"},"validActions")," for ",(0,i.kt)("a",{parentName:"p",href:"../policies/positionActions"},"positionActions"),"."),(0,i.kt)("p",null,"The rationale for ",(0,i.kt)("inlineCode",{parentName:"p"},"seedValue")," is to be able to, for instance, represent the fifth through the eighth seed as ",(0,i.kt)("inlineCode",{parentName:"p"},"5-8"),", or simply as ",(0,i.kt)("inlineCode",{parentName:"p"},"5"),". When there are no restrictions on seed positioning ",(0,i.kt)("inlineCode",{parentName:"p"},"seedValue")," allows assigning seeding to arbitrary ",(0,i.kt)("inlineCode",{parentName:"p"},"participants"),"."),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-js"},"tournamentEngine.modifySeedAssignment({\n  drawId,\n  structureId,\n  participantId,\n  seedValue, // display representation such as '5-8'\n});\n")),(0,i.kt)("hr",null),(0,i.kt)("h2",{id:"modifyvenue"},"modifyVenue"),(0,i.kt)("p",null,"See ",(0,i.kt)("a",{parentName:"p",href:"/docs/concepts/scheduling"},"Scheduling"),"."),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-js"},"const modifications = {\n  venueName,\n  venueAbbreviation,\n  courts: [\n    {\n      courtId: 'b9df6177-e430-4a70-ba47-9b9ff60258cb',\n      courtName: 'Custom Court 1',\n      dateAvailability: [\n        {\n          date: '2020-01-01', // if no date is provided then `startTime` and `endTime` will be considered default values\n          startTime: '16:30',\n          endTime: '17:30',\n        },\n      ],\n    },\n  ],\n};\ntournamentEngine.modifyVenue({ venueId, modifications });\n")),(0,i.kt)("hr",null),(0,i.kt)("h2",{id:"newtournamentrecord"},"newTournamentRecord"),(0,i.kt)("p",null,"Creates a new tournamentRecord in tournamentEngine state."),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-js"},"tournamentEngine.newTournamentRecord({\n  tournamentId, // optional - will be generated if not provided\n});\n\nconst { tournamentRecord } = tournamentEngine.getState();\n")),(0,i.kt)("hr",null),(0,i.kt)("h2",{id:"ordercollectiondefinitions"},"orderCollectionDefinitions"),(0,i.kt)("p",null,"Modify the array order of ",(0,i.kt)("inlineCode",{parentName:"p"},"tieFormat.collectionDefinitions")," for an ",(0,i.kt)("inlineCode",{parentName:"p"},"event"),", a ",(0,i.kt)("inlineCode",{parentName:"p"},"drawDefinition"),", ",(0,i.kt)("inlineCode",{parentName:"p"},"structure"),", or ",(0,i.kt)("inlineCode",{parentName:"p"},"matchUp"),"."),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-js"},"tournamentEngine.orderCollectionDefinitions({\n  orderMap: { collectionId1: 1, collectionId2: 2 },\n  structureId, // required if modifying tieFormat for a structure\n  matchUpId, // required if modifying tieFormat for a matchUp\n  eventId, // required if modifying tieFormat for a event\n  drawId, // required if modifying tieFormat for a drawDefinition or a structure\n});\n")),(0,i.kt)("hr",null),(0,i.kt)("h2",{id:"participantscaleitem"},"participantScaleItem"),(0,i.kt)("p",null,"Similar to ",(0,i.kt)("a",{parentName:"p",href:"#getParticipantScaleItem"},"getParticipantScaleItem")," but takes a ",(0,i.kt)("inlineCode",{parentName:"p"},"participant")," object and doesn't require ",(0,i.kt)("inlineCode",{parentName:"p"},"tournamentEngine.setState(tournamentRecord)"),"."),(0,i.kt)("p",null,"See ",(0,i.kt)("a",{parentName:"p",href:"../concepts/scaleItems"},"Scale Items"),"."),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-js"},"const scaleAttributes = {\n  scaleType: RATING,\n  eventType: SINGLES,\n  scaleName: 'WTN',\n  accessor, // optional - string determining how to access attribute if scaleValue is an object\n};\nconst {\n  scaleItem: { scaleValue },\n} = tournamentEngine.participantScaleItem({\n  scaleAttributes,\n  participant,\n});\n")),(0,i.kt)("hr",null),(0,i.kt)("h2",{id:"participantscheduledmatchups"},"participantScheduledMatchUps"),(0,i.kt)("p",null,"Returns ",(0,i.kt)("inlineCode",{parentName:"p"},"matchUps")," which have been scheduled, organized by ",(0,i.kt)("inlineCode",{parentName:"p"},"scheduledDate")," and sorted by ",(0,i.kt)("inlineCode",{parentName:"p"},"scheduledTime"),"."),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-js"},"const { scheduledMatchUps } = tournamentEngine.participantScheduledMatchUps({\n  matchUps,\n});\n")),(0,i.kt)("hr",null),(0,i.kt)("h2",{id:"positionactions"},"positionActions"),(0,i.kt)("p",null,"Returns valid actions for a given ",(0,i.kt)("inlineCode",{parentName:"p"},"drawPosition"),". If params includes ",(0,i.kt)("inlineCode",{parentName:"p"},"matchUpId")," will pass through to ",(0,i.kt)("a",{parentName:"p",href:"#matchUpActions"},"matchUpActions")," when called for ",(0,i.kt)("strong",{parentName:"p"},"AD_HOC")," structures."),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-js"},"const positionActions = tournamentEngine.positionActions({\n  policyDefinitions: positionActionsPolicy, // optional - policy defining what actions are allowed in client context\n  returnParticipants, // optional boolean; defaults to true; performance optimization when false requires client to provide participants.\n  drawPosition,\n  structureId,\n  drawId,\n});\n\nconst {\n  isActiveDrawPosition, // boolean\n  isByePosition, // boolean\n  isDrawPosition, // boolean\n  hasPositionAssiged, // boolean\n  validActions,\n} = positionActions;\n\nconst {\n  type, // 'ASSIGN', 'LUCKY', 'SWAP', 'BYE', 'REMOVE'\n  method, // tournamentEngine method relating to action type\n  payload, // attributes to be passed to method\n  // additional method-specific options for values to be added to payload when calling method\n} = validAction;\n")),(0,i.kt)("hr",null),(0,i.kt)("h2",{id:"promotealternates"},"promoteAlternates"),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-js"},"tournamentEngine.promoteAlternates({\n  tournamentEngine,\n  participantIds,\n  // either drawId or eventId are REQUIRED\n  eventId, // optional if drawId proided\n  drawId, // optional if eventId proided\n});\n")),(0,i.kt)("hr",null),(0,i.kt)("h2",{id:"publishevent"},"publishEvent"),(0,i.kt)("p",null,"Utilizes ",(0,i.kt)("a",{parentName:"p",href:"#getEventData"},"getEventData")," to prepare data for display. Differs from ",(0,i.kt)("a",{parentName:"p",href:"#getEventData"},"getEventData")," in that it modifies the ",(0,i.kt)("inlineCode",{parentName:"p"},"publishState")," of the event. Subscriptions or middleware may be used to deliver the generated payload for presentation on a public website."),(0,i.kt)("p",null,"See ",(0,i.kt)("a",{parentName:"p",href:"../concepts/policies"},"Policies")," for more details on ",(0,i.kt)("inlineCode",{parentName:"p"},"policyDefinitions"),"."),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-js"},"const policyDefinitions = Object.assign(\n  {},\n  ROUND_NAMING_POLICY,\n  PARTICIPANT_PRIVACY_DEFAULT\n);\n\nconst { eventData } = tournamentEngine.publishEvent({\n  removePriorValues, // optional boolean - when true will delete prior timeItems\n  drawIdsToRemove, // optional - add these drawIds to drawIds already published\n  drawIdsToAdd, // optional - remove these drawIds from drawIds published\n  drawIds, // optional - array of drawIds within the event to publish\n  structureIds = [], // optional - specify structureIds\n  policyDefinitions,\n  eventId,\n});\n")),(0,i.kt)("hr",null),(0,i.kt)("h2",{id:"publisheventseeding"},"publishEventSeeding"),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-js"},"tournamentEngine.publishEventSeeding({\n  removePriorValues, // optional boolean - when true will delete prior timeItems\n  stageSeedingScaleNames, // { MAIN: 'mainScaleName', QUALIFYING: 'qualifyingScaleName' } - required if a distinction is made between MAIN and QUALIFYING seeding\n  seedingScaleNames, // optional\n  drawIds, // optional - publish specific drawIds (flights) within the event\n  eventId,\n});\n")),(0,i.kt)("hr",null),(0,i.kt)("h2",{id:"publishorderofplay"},"publishOrderOfPlay"),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-js"},"tournamentEngine.publishOrderOfPlay({\n  removePriorValues, // optional boolean - when true will delete prior timeItems\n  scheduledDates, // optional - if not provided will publish all scheduledDates\n  eventIds, // optional - if not provided will publish all eventIds\n});\n")),(0,i.kt)("hr",null),(0,i.kt)("h2",{id:"qualifierdrawpositionassignment"},"qualifierDrawPositionAssignment"),(0,i.kt)("p",null,"Replaces an existing drawPosition assignment with a qualifierParticipantId. This method is included in ",(0,i.kt)("inlineCode",{parentName:"p"},"validActions")," for ",(0,i.kt)("a",{parentName:"p",href:"../policies/positionActions"},"positionActions")),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-js"},"tournamentEngine.qualifierDrawPositionAssignment({\n  qualifierParticipantId,\n  drawPosition,\n  structureId,\n  drawId,\n});\n")),(0,i.kt)("hr",null),(0,i.kt)("h2",{id:"removecollectiondefinition"},"removeCollectionDefinition"),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-js"},"tournamentEngine.removeCollectionDefinition({\n  tieFormatName, // any time a collectionDefinition is modified a new name must be provided\n  collectionId, // required - id of collectionDefinition to be removed\n  structureId, // optional - if removing from tieFormat associated with a specific structure\n  matchUpId, // optional - if removing from tieFormat asscoiated with a specific matchUp\n  eventId, // optional - if removing from tieFormat asscoiated with an event\n  drawId, // required if structureId is specified or if tieFormat associated with drawDefinition is to be modified\n});\n")),(0,i.kt)("hr",null),(0,i.kt)("h2",{id:"removecollectiongroup"},"removeCollectionGroup"),(0,i.kt)("p",null,"Removes a ",(0,i.kt)("inlineCode",{parentName:"p"},"collectionGroup")," from the ",(0,i.kt)("inlineCode",{parentName:"p"},"tieFormat")," found for the ",(0,i.kt)("inlineCode",{parentName:"p"},"event"),", ",(0,i.kt)("inlineCode",{parentName:"p"},"drawDefinition"),", ",(0,i.kt)("inlineCode",{parentName:"p"},"structure")," or ",(0,i.kt)("inlineCode",{parentName:"p"},"matchUp"),"; recalculates"),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-js"},"tournamentEngine.removeCollectionGroup({\n  updateInProgressMatchUps, // optional - defaults to true\n  tieFormatName: 'New tieFormat', // if no name is provided then there will be no name\n  collectionGroupNumber: 1,\n  structureId, // optional\n  eventId, // optional\n  drawId, // optional; required if structureId is targeted\n  matchUpId, // optional\n});\n")),(0,i.kt)("hr",null),(0,i.kt)("h2",{id:"removedrawdefinitionextension"},"removeDrawDefinitionExtension"),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-js"},"tournamentEngine.removeDrawDefintionExtension({ eventId, drawId, name });\n")),(0,i.kt)("hr",null),(0,i.kt)("h2",{id:"removedrawpositionassignment"},"removeDrawPositionAssignment"),(0,i.kt)("p",null,"Clear draw position and optionally replace with a BYE, change entryStatus, or decompose a PAIR participant into UNGROUPED participants (DOUBLES only)."),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-js"},"removeDrawPositionAssignment({\n  drawDefinition,\n  structureId,\n  drawPosition,\n  replaceWithBye, // optional\n  entryStatus, // optional - change the entryStatus of the removed participant\n  destroyPair, // optional - decompose PAIR participant into UNGROUPED participants\n});\n")),(0,i.kt)("hr",null),(0,i.kt)("h2",{id:"removedrawentries"},"removeDrawEntries"),(0,i.kt)("p",null,"Removes participantIds from ",(0,i.kt)("inlineCode",{parentName:"p"},"drawDefinition.entries")," (if generated) as well as any relevent ",(0,i.kt)("inlineCode",{parentName:"p"},"flightProfile.flights"),"."),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-js"},"tournamentEngine.removeDrawEntries({\n  autoEntryPositions, // optional - keeps entries ordered by entryStage/entryStatus and auto-increments\n  participantIds\n  eventId,\n  stages, // optional array of stages to consider, e.g. [VOLUNTARY_CONSOLATION]\n  drawId,\n  });\n")),(0,i.kt)("hr",null),(0,i.kt)("h2",{id:"removeevententries"},"removeEventEntries"),(0,i.kt)("p",null,"Removes ",(0,i.kt)("inlineCode",{parentName:"p"},"participantIds")," from ",(0,i.kt)("inlineCode",{parentName:"p"},"event.entries")," with integrity checks."),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-js"},"tournamentEngine.removeEventEntries({\n  eventId,\n  participantIds,\n  autoEntryPositions, // optional - keeps entries ordered by entryStage/entryStatus and auto-increments\n});\n")),(0,i.kt)("hr",null),(0,i.kt)("h2",{id:"removeeventextension"},"removeEventExtension"),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-js"},"tournamentEngine.removeEventExtension({ eventId, name });\n")),(0,i.kt)("hr",null),(0,i.kt)("h2",{id:"removeeventmatchupformattiming"},"removeEventMatchUpFormatTiming"),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-js"},"tournamentEngine.removeEventMatchUpFormatTiming({ eventId });\n")),(0,i.kt)("hr",null),(0,i.kt)("h2",{id:"removeeventpolicy"},"removeEventPolicy"),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-js"},"tournamentEngine.removeEventPolicy({ policyType });\n")),(0,i.kt)("hr",null),(0,i.kt)("h2",{id:"removeindividualparticipantids"},"removeIndividualParticipantIds"),(0,i.kt)("p",null,"Remove an array of individualParticipantIds from a grouping participant ","[TEAM, GROUP]"),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-js"},"tournamentEngine.removeIndividualParticipantIds({\n  addIndividualParticipantsToEvents, // optional boolean\n  individualParticipantIds,\n  groupingParticipantId,\n});\n")),(0,i.kt)("hr",null),(0,i.kt)("h2",{id:"removeparticipantidsfromallteams"},"removeParticipantIdsFromAllTeams"),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-js"},"tournamentEngine.removeParticipantIdsFromAllTeams({\n  individualParticipantIds,\n  groupingType, // optional - restrict to removing from only specified groupingType\n});\n")),(0,i.kt)("hr",null),(0,i.kt)("h2",{id:"removeparticipantextension"},"removeParticipantExtension"),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-js"},"tournamentEngine.removeParticipantExtension({ participantId, name });\n")),(0,i.kt)("hr",null),(0,i.kt)("h2",{id:"removepenalty"},"removePenalty"),(0,i.kt)("p",null,"Removes a penalty from all relevant tournament participants."),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-js"},"tournamentEngine.removePenalty({ penaltyId });\n")),(0,i.kt)("hr",null),(0,i.kt)("h2",{id:"removescalevalues"},"removeScaleValues"),(0,i.kt)("p",null,"Removes scale values for participants in a particular event. Optionally restrict by draw or stage."),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-js"},"tournamentEngine.removeScaleValues({\n  eventId,\n  scaleAttributes, // { scaleType, scaleName, eventType }\n  scaleName, // optional - override default scaleName, event.category.categoryName || event.category.ageCategoryCode\n  drawId, // optional - to scope participants to entries in a specific draw\n  stage, // optinal - scope participants to entries in a specific stage of draw\n});\n")),(0,i.kt)("hr",null),(0,i.kt)("h2",{id:"removeseeding"},"removeSeeding"),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-js"},"tournamentEngine.removeSeeding({\n  eventId,\n  entryStatuses, // optional array of entryStatues to consider\n  scaleName, // optional - override default scaleName, event.category.categoryName || event.category.ageCategoryCode\n  drawId, // optional - to scope participants to entries in a specific draw\n  stage, // optinal - scope participants to entries in a specific stage of draw\n});\n")),(0,i.kt)("hr",null),(0,i.kt)("h2",{id:"removestructure"},"removeStructure"),(0,i.kt)("p",null,"Removes targeted ",(0,i.kt)("inlineCode",{parentName:"p"},"drawDefinition.structure")," and all other child ",(0,i.kt)("inlineCode",{parentName:"p"},"structures")," along with all associated ",(0,i.kt)("inlineCode",{parentName:"p"},"drawDefinition.links"),"."),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-js"},"const { removedMatchUpIds } = tournamentEngine.removeStructure({\n  drawId,\n  structureId,\n});\n")),(0,i.kt)("hr",null),(0,i.kt)("h2",{id:"removetiematchupparticipantid"},"removeTieMatchUpParticipantId"),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-js"},"tournamentEngine.removeTieMatchUpParticipantId({\n  participantId, // participantId of INDIVIDUAL or PAIR be removed\n  tieMatchUpId, // tieMatchUp, matchUpType either DOUBLES or SINGLES\n  drawId, // draw within which tieMatchUp is found\n});\n")),(0,i.kt)("hr",null),(0,i.kt)("h2",{id:"removetournamentextension"},"removeTournamentExtension"),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-js"},"tournamentEngine.removeTournamentExtension({ name });\n")),(0,i.kt)("hr",null),(0,i.kt)("h2",{id:"replacetiematchupparticipantid"},"replaceTieMatchUpParticipantId"),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-js"},"tournamentEngine.replaceTieMatchUpParticipantId({\n  existingParticipantId,\n  newParticipantId,\n  tieMatchUpId,\n  drawId,\n});\n")),(0,i.kt)("hr",null),(0,i.kt)("h2",{id:"resetdrawdefinition"},"resetDrawDefinition"),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-js"},"tournamentEngine.resetDrawDefinition({ drawId });\n")),(0,i.kt)("hr",null),(0,i.kt)("h2",{id:"resetscorecard"},"resetScorecard"),(0,i.kt)("p",null,"Removes all scores from ",(0,i.kt)("inlineCode",{parentName:"p"},"tieMatchUps")," within a TEAM ",(0,i.kt)("inlineCode",{parentName:"p"},"matchUp"),"; preserves ",(0,i.kt)("inlineCode",{parentName:"p"},"lineUps"),"."),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-js"},"tournamentEngine.resetScorecard({\n  matchUpId,\n  drawId,\n});\n")),(0,i.kt)("hr",null),(0,i.kt)("h2",{id:"resettieformat"},"resetTieFormat"),(0,i.kt)("p",null,"Remove the ",(0,i.kt)("inlineCode",{parentName:"p"},"tieFormat")," from a TEAM ",(0,i.kt)("inlineCode",{parentName:"p"},"matchUp")," if there is a ",(0,i.kt)("inlineCode",{parentName:"p"},"tieFormat")," further up the hierarchy; modifies ",(0,i.kt)("inlineCode",{parentName:"p"},"matchUp.tieMatchUps")," to correspond."),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-js"},"tournamentEngine.resetTieFormat({\n  matchUpId, // must be a TEAM matchUp\n  drawId, // required\n  uuids, // optional - in client/server scenarios generated matchUps must have equivalent matchUpIds\n});\n")),(0,i.kt)("hr",null),(0,i.kt)("h2",{id:"resetvoluntaryconsolationstructure"},"resetVoluntaryConsolationStructure"),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-js"},"tournamentEngine.resetVoluntaryConsolationStructure({\n  resetEntries, // optional - remove all { entryStage: VOLUNTARY_CONSOLATION }\n  drawId,\n});\n")),(0,i.kt)("p",null,"--"),(0,i.kt)("h2",{id:"scaledteamassignment"},"scaledTeamAssignment"),(0,i.kt)("p",null,"Assigns individual participants to teams using a waterfall pattern; removes UNGROUPED entries as appropriate for TEAM events. May be called with either ",(0,i.kt)("inlineCode",{parentName:"p"},"individualParticpantIds")," and ",(0,i.kt)("inlineCode",{parentName:"p"},"scaleAttributes")," or with an array of ",(0,i.kt)("inlineCode",{parentName:"p"},"scaledParticipants"),"."),(0,i.kt)("admonition",{type:"info"},(0,i.kt)("p",{parentName:"admonition"},"By default existing ",(0,i.kt)("inlineCode",{parentName:"p"},"individualParticipant")," assignments are cleared. If existing assignments are retained, any ",(0,i.kt)("inlineCode",{parentName:"p"},"individualParticipant")," already assigned will be excluded from further assignment. It may be desirable to retain existing assignments if sequential assignment of different groups of ",(0,i.kt)("inlineCode",{parentName:"p"},"individualParticipants")," is desired.")),(0,i.kt)("admonition",{type:"note"},(0,i.kt)("p",{parentName:"admonition"},'Modifying team assignments has "global" effect, meaning that if a team appears in multiple events, team membership will be changed for all events.')),(0,i.kt)("h3",{id:"example-use-with-individualparticipantids-and-scaleattributes"},"Example use with ",(0,i.kt)("inlineCode",{parentName:"h3"},"individualParticipantIds")," and ",(0,i.kt)("inlineCode",{parentName:"h3"},"scaleAttributes")),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-js"},"const scaleAttributes = {\n  scaleType: RANKING,\n  eventType: SINGLES,\n  scaleName: '18U',\n};\ntournamentEngine.scaledTeamAssignment({\n  reverseAssignmentOrder, // optional - reverses team order; useful for sequential assignment of participant groupings to ensure balanced distribution\n  initialTeamIndex, // optional - allows assignment to begin at a specified array index; useful for sequential assignment of groups of scaledParticipants\n  clearExistingAssignments, // optional - true by default remove all existing individualParticipantIds from targeted teams\n  descendingScaleSort, // optional - allow use of scales where the higher value denotes a stronger participant\n\n  individualParticipantIds,\n  teamParticipantIds,\n  scaleAttributes,\n});\n")),(0,i.kt)("h3",{id:"example-use-with-scaledparticipants"},"Example use with ",(0,i.kt)("inlineCode",{parentName:"h3"},"scaledParticipants")),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-js"},"const scaleAttributes = {\n  scaleType: RANKING,\n  eventType: SINGLES,\n  scaleName: '18U',\n};\n\nconst scaledParticipants = individualParticipants.map((participant) => ({\n  participantId: participant.participantId,\n  scaleValue: participantScaleItem({ participant, scaleAttributes }).scaleItem\n    .scaleValue,\n}));\n\nconst teamParticipantIds = teamParticipants.map(getParticipantId);\n\ntournamentEngine.scaledTeamAssignment({\n  teamParticipantIds,\n  scaledParticipants, // [{ participantId, scaleValue}]\n});\n")),(0,i.kt)("h3",{id:"example-use-with-sequential-assignment-where-there-are-8-teams"},"Example use with sequential assignment where there are 8 teams"),(0,i.kt)("p",null,"In this scenario scaled MALE participants are assigned in a waterfall pattern beginning with the first team (default behavior); scaled FEMALE participants are then assigned in a reverse waterfall pattern beginning with the last team. The goal is to balance the teams to the greatest extent possible. This pattern can be used with an arbitrary number of groups of ",(0,i.kt)("inlineCode",{parentName:"p"},"individualParticipants"),"."),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-js"},"tournamentEngine.scaledTeamAssignment({\n  teamParticipantIds,\n  scaledParticipants: maleScaleParticipants,\n});\n\ntournamentEngine.scaledTeamAssignment({\n  teamParticipantIds,\n  scaledParticipants: femaleScaleParticipants,\n  clearExistingAssignments: false,\n  reverseAssignmentOrder: true,\n  initialTeamIndex: 7,\n});\n")),(0,i.kt)("hr",null),(0,i.kt)("h2",{id:"setdrawparticipantrepresentativeids"},"setDrawParticipantRepresentativeIds"),(0,i.kt)("p",null,"Set the participantIds of participants in the draw who are representing players by observing the creation of the draw."),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-js"},"tournamentEngine.setDrawParticipantRepresentativeIds({\n  drawId,\n  representativeParticipantIds,\n});\n")),(0,i.kt)("hr",null),(0,i.kt)("h2",{id:"seteventdates"},"setEventDates"),(0,i.kt)("p",null,"Where startDate and/or endDate are strings 'YYYY-MM-DD'."),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-js"},"tournamentEngine.setEventDates({ eventId, startDate, endDate });\n")),(0,i.kt)("hr",null),(0,i.kt)("h2",{id:"seteventenddate"},"setEventEndDate"),(0,i.kt)("p",null,"Where endDate is a string 'YYYY-MM-DD'."),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-js"},"tournamentEngine.setEventEndDate({ eventId, endDate });\n")),(0,i.kt)("hr",null),(0,i.kt)("h2",{id:"seteventstartdate"},"setEventStartDate"),(0,i.kt)("p",null,"Where startDate is a string 'YYYY-MM-DD'."),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-js"},"tournamentEngine.setEventStartDate({ eventId, startDate });\n")),(0,i.kt)("hr",null),(0,i.kt)("h2",{id:"setmatchupdailylimits"},"setMatchUpDailyLimits"),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-js"},"tournamentEngine.setMatchUpDailyLimits({\n  dailyLimits: { SINGLES: 2, DOUBLES: 1, total: 3 },\n});\n")),(0,i.kt)("hr",null),(0,i.kt)("h2",{id:"setmatchupformat"},"setMatchUpFormat"),(0,i.kt)("p",null,"Sets the ",(0,i.kt)("inlineCode",{parentName:"p"},"matchUpFormat")," for a specific ",(0,i.kt)("inlineCode",{parentName:"p"},"matchUp")," or for any scope within the hierarchy of a ",(0,i.kt)("inlineCode",{parentName:"p"},"tournamentRecord"),"."),(0,i.kt)("admonition",{type:"info"},(0,i.kt)("p",{parentName:"admonition"},"If an array of ",(0,i.kt)("inlineCode",{parentName:"p"},"scheduledDates")," is provided then ",(0,i.kt)("inlineCode",{parentName:"p"},"matchUps")," which have ",(0,i.kt)("inlineCode",{parentName:"p"},"matchUpStatus: TO_BE_PLAYED")," and are scheduled to be played on the specified dates will have their ",(0,i.kt)("inlineCode",{parentName:"p"},"matchUpFormat")," fixed rather than inherited. This means that subsequent changes to the parent ",(0,i.kt)("inlineCode",{parentName:"p"},"structure.matchUpFormat")," will have no effect on such ",(0,i.kt)("inlineCode",{parentName:"p"},"matchUps"),"."),(0,i.kt)("p",{parentName:"admonition"},"The ",(0,i.kt)("inlineCode",{parentName:"p"},"force")," attribute will remove the ",(0,i.kt)("inlineCode",{parentName:"p"},"matchUpFormat")," from all targeted ",(0,i.kt)("inlineCode",{parentName:"p"},"matchUps")," which have ",(0,i.kt)("inlineCode",{parentName:"p"},"matchUpStatus: TO_BE_PLAYED"),"; this allows the effect of using ",(0,i.kt)("inlineCode",{parentName:"p"},"scheduledDates")," to be reversed. Use of this attribute will have no effect if ",(0,i.kt)("inlineCode",{parentName:"p"},"scheduledDates")," is also provided.")),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-js"},"tournamentEngine.setMatchUpFormat({\n  matchUpFormat, // TODS matchUpFormatCode\n  eventType, // optional - restrict to SINGLES or DOUBLES\n\n  matchUpId, // optional - set matchUpFormat for a specific matchUp\n  drawId, // required only if matchUpId, structureId or structureIds is present\n  force, // optional boolean - when setting for structure, draws or events, strip any defined matchUpFormat from all TO_BE_PLAYED matchUps\n\n  // scoping options\n  scheduledDates, // optional - ['2022-01-01']\n  stageSequences, // optional - [1, 2]\n  structureIds, // optional - ['structureId1', 'structureId2']\n  structureId, // optional\n  eventIds, // optional - ['eventId1', 'eventId2']\n  eventId, // optional\n  drawIds, // optional - ['drawId1', 'drawId2']\n  stages, // optional - ['MAIN', 'CONSOLATION']\n});\n")),(0,i.kt)("hr",null),(0,i.kt)("h2",{id:"setmatchupstatus"},"setMatchUpStatus"),(0,i.kt)("p",null,"Sets either ",(0,i.kt)("inlineCode",{parentName:"p"},"matchUpStatus")," or ",(0,i.kt)("inlineCode",{parentName:"p"},"score")," and ",(0,i.kt)("inlineCode",{parentName:"p"},"winningSide"),"; values to be set are passed in ",(0,i.kt)("inlineCode",{parentName:"p"},"outcome")," object. Handles any winner/loser participant movements within or across ",(0,i.kt)("inlineCode",{parentName:"p"},"structures"),"."),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-js"},"const outcome = {\n  matchUpStatus, // optional\n  winningSide, // optional\n  score, // optional\n};\n\ntournamentEngine.setMatchUpStatus({\n  disableScoreValidation, // optional boolean\n  allowChangePropagation, // optional boolean - allow winner/loser to be swapped and propgate change throughout draw structures\n  disableAutoCalc, // optional - applies only to { matchUpType: TEAM }\n  enableAutoCalc, // optional - applies only to { matchUpType: TEAM }\n  matchUpTieId, // optional - if part of a TIE matchUp\n  matchUpId,\n  outcome, // optional\n  drawId,\n  schedule: {\n    // optional - set schedule items\n    courtId, // requires scheduledDate\n    venueId,\n    scheduledDate,\n    scheduledTime,\n    startTime,\n    endTime,\n  },\n  notes, // optional - add note (string) to matchUp object\n});\n")),(0,i.kt)("hr",null),(0,i.kt)("h2",{id:"setorderoffinish"},"setOrderOfFinish"),(0,i.kt)("p",null,"Sets the ",(0,i.kt)("inlineCode",{parentName:"p"},"orderOfFinish")," attribute for ",(0,i.kt)("inlineCode",{parentName:"p"},"matchUps")," specified by ",(0,i.kt)("inlineCode",{parentName:"p"},"matchUpId")," in the ",(0,i.kt)("inlineCode",{parentName:"p"},"finishingOrder")," array."),(0,i.kt)("h3",{id:"validation"},"Validation"),(0,i.kt)("p",null,"Validation is done within a ",(0,i.kt)("em",{parentName:"p"},"cohort")," of ",(0,i.kt)("inlineCode",{parentName:"p"},"matchUps")," which have equivalent ",(0,i.kt)("inlineCode",{parentName:"p"},"structureId"),", ",(0,i.kt)("inlineCode",{parentName:"p"},"matchUpType"),", ",(0,i.kt)("inlineCode",{parentName:"p"},"roundNumber"),", and ",(0,i.kt)("inlineCode",{parentName:"p"},"matchUpTieId")," (if applicable)."),(0,i.kt)("ul",null,(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("inlineCode",{parentName:"li"},"matchUpIds")," in ",(0,i.kt)("inlineCode",{parentName:"li"},"finishingOrder")," must be part of the same ",(0,i.kt)("em",{parentName:"li"},"cohort")),(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("inlineCode",{parentName:"li"},"orderOfFinish")," values must be unique positive integers within the ",(0,i.kt)("em",{parentName:"li"},"cohort"))),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-js"},"tournamentEngine.setOrderOfFinish({\n  finishingOrder: [{ matchUpId, orderOfFinish: 1 }],\n  drawId,\n});\n")),(0,i.kt)("hr",null),(0,i.kt)("h2",{id:"setparticipantscaleitem"},"setParticipantScaleItem"),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-js"},"scaleItem = {\n  scaleValue: 12,\n  scaleName: 'U16',\n  scaleType: RANKING,\n  eventType: SINGLES,\n  scaleDate: '2020-06-06',\n};\n\nresult = tournamentEngine.setParticipantScaleItem({\n  removePriorValues, // optional boolean - when true will delete prior timeItems\n  participantId,\n  scaleItem,\n});\n")),(0,i.kt)("hr",null),(0,i.kt)("h2",{id:"setparticipantscaleitems"},"setParticipantScaleItems"),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-js"},"const scaleItemsWithParticipantIds = [\n  {\n    participantId,\n    scaleItems: [\n      {\n        scaleValue: 8.3,\n        scaleName: 'WTN',\n        scaleType: RATING,\n        eventType: SINGLES,\n        scaleDate: '2021-01-01',\n      },\n    ],\n  },\n];\ntournamentEngine.setParticipantScaleItems({\n  removePriorValues, // optional boolean - when true will delete prior timeItems\n  scaleItemsWithParticipantIds,\n});\n")),(0,i.kt)("hr",null),(0,i.kt)("h2",{id:"setpositionassignments"},"setPositionAssignments"),(0,i.kt)("p",null,"Intended to be used in conjunction with ",(0,i.kt)("inlineCode",{parentName:"p"},"automatedPlayoffPositioning")," in deployments where a client instance gets the positioning which is then set on both the client and the server, to ensure that both client and server are identical. If ",(0,i.kt)("inlineCode",{parentName:"p"},"automatedPlayoffPositioning")," is invoked on both client and server independently then it is likely that the positioning on client and server will be different."),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-js"},"// executed only on the client\nconst { structurePositionAssignments } =\n  tournamentEngine.automatedPlayoffPositioning({\n    applyPositioning: false, // instructs tournamentEngine to only return values, not apply them\n    structureId,\n    drawId,\n  });\n\n// executed on both client and server\nresult = tournamentEngine.setPositionAssignments({\n  structurePositionAssignments,\n  drawId,\n});\n")),(0,i.kt)("hr",null),(0,i.kt)("h2",{id:"setstate"},"setState"),(0,i.kt)("p",null,"Loads a tournament record into tournamentEngine."),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-js"},"tournamentEngine.setsState(tournamentRecord, deepCopy, deepCopyConfig);\n")),(0,i.kt)("admonition",{type:"info"},(0,i.kt)("p",{parentName:"admonition"},"By default a deep copy of the ",(0,i.kt)("inlineCode",{parentName:"p"},"tournamentRecord")," is made so that mutations made by ",(0,i.kt)("inlineCode",{parentName:"p"},"tournamentEngine")," do not affect the source object. An optional boolean parameter, ",(0,i.kt)("em",{parentName:"p"},"deepCopy")," can be set to false to override this default behavior.")),(0,i.kt)("admonition",{type:"note"},(0,i.kt)("p",{parentName:"admonition"},(0,i.kt)("inlineCode",{parentName:"p"},"deepCopyConfig")," is an optional configuration for ",(0,i.kt)("inlineCode",{parentName:"p"},"makeDeepCopy"),". In server configurations when ",(0,i.kt)("inlineCode",{parentName:"p"},"deepCopy")," is FALSE and ",(0,i.kt)("inlineCode",{parentName:"p"},"tournamentRecords")," are retrieved from Mongo, for instance, there are scenarios where nodes of the JSON structure contain prototypes which cannot be converted.")),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-js"},"const deepCopyConfig = {\n  ignore, // optional - either an array of attributes to ignore or a function which processes attributes to determine whether to ignore them\n  toJSON, // optional - an array of attributes to convert to JSON if the attribute in question is an object with .toJSON property\n  stringify, // optional - an array of attributes to stringify\n  modulate, // optional - function to process every attribute and return custom values, or undefined, which continues normal processing\n};\n")),(0,i.kt)("hr",null),(0,i.kt)("h2",{id:"setsuborder"},"setSubOrder"),(0,i.kt)("p",null,"Used to order ROUND_ROBIN participants when finishingPosition ties cannot be broken algorithmically. Assigns a ",(0,i.kt)("inlineCode",{parentName:"p"},"subOrder")," value to a participant within a ",(0,i.kt)("inlineCode",{parentName:"p"},"structure")," by ",(0,i.kt)("inlineCode",{parentName:"p"},"drawPosition"),"."),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-js"},"tournamentEngine.setSubOrder({\n  drawPosition: 1,\n  subOrder: 2,\n  structureId,\n  drawId,\n});\n")),(0,i.kt)("hr",null),(0,i.kt)("h2",{id:"settournamentcategories"},"setTournamentCategories"),(0,i.kt)("p",null,"Define categories to be used in ",(0,i.kt)("inlineCode",{parentName:"p"},"event")," creation for tournament record."),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-js"},"const categories = [\n  {\n    categoryName: 'U18',\n    type: eventConstants.AGE,\n  },\n  {\n    categoryName: 'U16',\n    type: eventConstants.AGE,\n  },\n  {\n    categoryName: 'WTN',\n    type: eventConstants.RATING,\n  },\n];\ntournamentEngine.setTournamentCategories({ categories });\n")),(0,i.kt)("hr",null),(0,i.kt)("h2",{id:"settournamentdates"},"setTournamentDates"),(0,i.kt)("p",null,"Set tournament ",(0,i.kt)("inlineCode",{parentName:"p"},"startDate")," and ",(0,i.kt)("inlineCode",{parentName:"p"},"endDate")," in one method call. Also cleans up ",(0,i.kt)("inlineCode",{parentName:"p"},"matchUp")," schedules that are invalid due to date changes, and updates court ",(0,i.kt)("inlineCode",{parentName:"p"},"dateAvailability"),"."),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-js"},"tournamentEngine.setTournamentDates({ startDate, endDate });\n")),(0,i.kt)("hr",null),(0,i.kt)("h2",{id:"settournamentenddate"},"setTournamentEndDate"),(0,i.kt)("p",null,"Accepts an ISO String Date;"),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-js"},"tournamentEngine.setTournamentEndDate({ endDate });\n")),(0,i.kt)("hr",null),(0,i.kt)("h2",{id:"settournamentid"},"setTournamentId"),(0,i.kt)("p",null,"Points ",(0,i.kt)("inlineCode",{parentName:"p"},"tournamentEngine")," to a tournamentRecord that is in shared state, e.g. loaded by ",(0,i.kt)("inlineCode",{parentName:"p"},"competitionEngine"),"."),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-js"},"tournamentEngine.setTournamentId(tournamentId);\n")),(0,i.kt)("hr",null),(0,i.kt)("h2",{id:"settournamentname"},"setTournamentName"),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-js"},"const tournamentName = 'CourtHive Challenge';\ntournamentEngine.setTournamentName({\n  tournamentName,\n});\n")),(0,i.kt)("hr",null),(0,i.kt)("h2",{id:"settournamentnotes"},"setTournamentNotes"),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-js"},"tournamentEngine.setTournamentNotes({ notes });\n")),(0,i.kt)("hr",null),(0,i.kt)("h2",{id:"settournamentstartdate"},"setTournamentStartDate"),(0,i.kt)("p",null,"Accepts an ISO String Date;"),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-js"},"tournamentEngine.setTournamentStartDate({ StartDate });\n")),(0,i.kt)("hr",null),(0,i.kt)("h2",{id:"toggleparticipantcheckinstate"},"toggleParticipantCheckInState"),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-js"},"tournamentEngine.toggleParticipantCheckInState({\n  drawId,\n  matchUpId,\n  participantId,\n});\n")),(0,i.kt)("hr",null),(0,i.kt)("h2",{id:"tournamentmatchups"},"tournamentMatchUps"),(0,i.kt)("p",null,"Returns tournament matchUps grouped by matchUpStatus. These matchUps are returned with ",(0,i.kt)("em",{parentName:"p"},"context"),"."),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-js"},"const {\n  abandonedMatchUps,\n  byeMatchUps,\n  completedMatchUps,\n  pendingMatchUps,\n  upcomingMatchUps,\n} = tournamentEngine.tournamentMatchUps({\n  matchUpFilters, // optional; [ scheduledDates: [], courtIds: [], stages: [], roundNumbers: [], matchUpStatuses: [], matchUpFormats: []]\n  policyDefinitions, // optional - seeding or avoidance policies to be used when placing participants\n  scheduleVisibilityFilters, // { visibilityThreshold: Date, eventIds, drawIds }\n});\n")),(0,i.kt)("hr",null),(0,i.kt)("h2",{id:"unpublishevent"},"unPublishEvent"),(0,i.kt)("p",null,"Modifies the ",(0,i.kt)("inlineCode",{parentName:"p"},"publishState")," of an event. ",(0,i.kt)("inlineCode",{parentName:"p"},"Subscriptions")," or middleware can be used to trigger messaging to services which make event data visible on public websites."),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-js"},"tournamentEngine.unPublishEvent({\n  removePriorValues, // optional boolean, defaults to true - when true will delete prior timeItems\n  eventId,\n});\n")),(0,i.kt)("hr",null),(0,i.kt)("h2",{id:"unpublisheventseeding"},"unPublishEventSeeding"),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-js"},"tournamentEngine.unPublishEventSeeding({\n  removePriorValues, // optional boolean, defaults to true - when true will delete prior timeItems\n  stages, // optionally specify array of stages to be unpublished, otherwise unpublish all stages\n  eventId,\n});\n")),(0,i.kt)("hr",null),(0,i.kt)("h2",{id:"unpublishorderofplay"},"unPublishOrderOfPlay"),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-js"},"tournamentEngine.unPublishOrderOfPlay({\n  removePriorValues, // optional boolean, defaults to true - when true will delete prior timeItems\n});\n")),(0,i.kt)("hr",null),(0,i.kt)("h2",{id:"updatedrawidsorder"},"updateDrawIdsOrder"),(0,i.kt)("p",null,"Updates the ",(0,i.kt)("inlineCode",{parentName:"p"},"drawOrder")," attribute of all ",(0,i.kt)("inlineCode",{parentName:"p"},"drawDefinitions")," within an event. The ",(0,i.kt)("inlineCode",{parentName:"p"},"drawOrder")," attribute can be used for sorting or for differentiating ",(0,i.kt)("inlineCode",{parentName:"p"},"drawDefinitions"),' for the award of rankings points, when "flighting" separates participants by some ',(0,i.kt)("inlineCode",{parentName:"p"},"scaleValue"),"."),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-js"},"tournamentEngine.updateDrawIdsOrder({\n  eventId,\n  orderedDrawIdsMap: {\n    'id-Of-draw-1': 1,\n    'id-of-draw-2': 2,\n  },\n});\n")),(0,i.kt)("hr",null),(0,i.kt)("h2",{id:"updateteamlineup"},"updateTeamLineUp"),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-js"},"tournamentEngine.updateTeamLineUp({\n  participantId, // participantId of the team for which lineUp is being updated\n  tieFormat, // valid tieFormat - used to validate collectionIds\n  lineUp, // valid lineUp array - see tournamentEngine.validateTeamLineUp\n  drawId, // required as latest lineUp modification is stored in an extension on drawDefinition\n});\n")),(0,i.kt)("hr",null),(0,i.kt)("h2",{id:"withdrawparticipantatdrawposition"},"withdrawParticipantAtDrawPosition"),(0,i.kt)("p",null,"Thin wrapper around ",(0,i.kt)("a",{parentName:"p",href:"#removeDrawPositionAssignment"},"removeDrawPositionAssignment"),". This method is included in ",(0,i.kt)("inlineCode",{parentName:"p"},"validActions")," for ",(0,i.kt)("a",{parentName:"p",href:"../policies/positionActions"},"positionActions"),"."),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-js"},"tournamentEngine.withdrawParticipantAtDrawPosition({\n  entryStatus = WITHDRAWN,\n  replaceWithBye, // optional\n  drawDefinition,\n  drawPosition,\n  structureId,\n  destroyPair, // optional - decompose PAIR participant into UNPAIRED participants\n});\n")),(0,i.kt)("hr",null),(0,i.kt)("h2",{id:"validateteamlineup"},"validateTeamLineUp"),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-js"},"const { valid, error, errors } = tournamentEngine.validateLineUp({\n  tieFormat, // required to validate collectionIds in lineUp\n  lineUp,\n});\n")),(0,i.kt)("hr",null),(0,i.kt)("h2",{id:"version"},"version"),(0,i.kt)("p",null,"Returns NPM package version. Can be used in configurations that utilize Competition Factory engines on both client and server to ensure equivalency."),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-js"},"const version = tournamentEngine.version();\n")))}u.isMDXComponent=!0}}]);