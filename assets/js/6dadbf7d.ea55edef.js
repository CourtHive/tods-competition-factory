"use strict";(self.webpackChunkdocumentation=self.webpackChunkdocumentation||[]).push([[6307],{3298:(e,n,a)=>{a.d(n,{A:()=>m});var t=a(758),i=a(4809),s=a(7345);const r=JSON.parse('{"monokai":{"scheme":"monokai","author":"wimer hazenberg (http://www.monokai.nl)","base00":"#272822","base01":"#383830","base02":"#49483e","base03":"#75715e","base04":"#a59f85","base05":"#f8f8f2","base06":"#f5f4f1","base07":"#f9f8f5","base08":"#f92672","base09":"#fd971f","base0A":"#f4bf75","base0B":"#a6e22e","base0C":"#a1efe4","base0D":"#66d9ef","base0E":"#ae81ff","base0F":"#cc6633"},"summerfruit":{"scheme":"summerfruit","author":"christopher corley (http://cscorley.github.io/)","base00":"#151515","base01":"#202020","base02":"#303030","base03":"#505050","base04":"#B0B0B0","base05":"#D0D0D0","base06":"#E0E0E0","base07":"#FFFFFF","base08":"#FF0086","base09":"#FD8900","base0A":"#ABA800","base0B":"#00C918","base0C":"#1faaaa","base0D":"#3777E6","base0E":"#AD00A1","base0F":"#cc6633"},"solarized":{"scheme":"solarized","author":"ethan schoonover (http://ethanschoonover.com/solarized)","base00":"#002b36","base01":"#073642","base02":"#586e75","base03":"#657b83","base04":"#839496","base05":"#93a1a1","base06":"#eee8d5","base07":"#fdf6e3","base08":"#dc322f","base09":"#cb4b16","base0A":"#b58900","base0B":"#859900","base0C":"#2aa198","base0D":"#268bd2","base0E":"#6c71c4","base0F":"#d33682"}}'),c=(e,n,a)=>{let{style:t}=e;return{style:{...t,color:Number.isNaN(a[0])||parseInt(a,10)%2?t.color:"#33F"}}},o=(e,n,a)=>{let{style:t}=e;return{style:{...t,fontWeight:a?"bold":t.textTransform}}},l=(e,n)=>{let{style:a}=e;return{style:{...a,borderRadius:"Boolean"===n?3:a.borderRadius}}},p=(e,n,a)=>{const s="object"==typeof n,r=s&&Object.values(n)[0],c="string"==typeof r&&"{"===r[0];let o;if(s){const e=Object.keys(n);2!==i.Yl.intersection(e,["drawId","drawType"]).length||e.includes("drawRepresentativeIds")||(o="drawDefinition"),2!==i.Yl.intersection(e,["entryPosition","entryStatus"]).length||e.includes("entryStageSequence")||(o="entry"),3!==i.Yl.intersection(e,["eventId","sortOrder","notBeforeTime"]).length||e.includes("tennisOfficialIds")?2!==i.Yl.intersection(e,["eventId","eventName"]).length||e.includes("tennisOfficialIds")||(o="event"):o="round",2===i.Yl.intersection(e,["flightNumber","drawId"]).length&&(o="flight"),2===i.Yl.intersection(e,["name","value"]).length&&(o="extension"),2!==i.Yl.intersection(e,["linkType","source"]).length||e.includes("linkCondition")||(o="link"),2!==i.Yl.intersection(e,["matchUpId","drawPositions"]).length||e.includes("surfaceCategory")||(o="matchUp"),2===i.Yl.intersection(e,["drawPosition","participantId","bye"]).length&&(o="positionAssignment"),2!==i.Yl.intersection(e,["courtId","dateAvailability"]).length||e.includes("altitude")||(o="court"),2!==i.Yl.intersection(e,["participantId","participantName"]).length||e.includes("onlineResources")||(o="participant"),2===i.Yl.intersection(e,["structureId","structureName"]).length&&(o="structure"),2!==i.Yl.intersection(e,["venueId","courts"]).length||e.includes("venueOtherIds")||(o="venue")}return t.createElement("span",null,o||(c?e:a))},d=e=>{return"string"==typeof(n=e)&&n.length>2&&"{"===n[1]?(e=>{try{const n=JSON.parse(JSON.parse(e)),a="true"===n.required?"":"? ",t="true"===n.array?"[]":"";return`${a}: ${["any","boolean","number","string"].includes(n.type)&&n.type||"object"===n.type&&n.object||"enum"===n.type?`enum ${n.enum}`:""}${t}${n.note?` \\\\ ${n.note}`:""}`}catch(n){return""}})(e):"string"==typeof e&&e.length>40?e.slice(0,40)+"...":e;var n},u=e=>{let[n]=e;return t.createElement("strong",null,n)},m=e=>{let{colorScheme:n="summerfruit",sortObjectKeys:a=!0,invertTheme:i=!0,expandRoot:m=!0,expandToLevel:g=1,hideRoot:y=!1,root:v="root",data:h}=e;return t.createElement("div",{style:{marginBottom:"1em"}},t.createElement(s.d,{theme:{valueLabel:c,nestedNodeLabel:o,extend:r[n],value:l},shouldExpandNode:(e,n,a)=>!!m&&(("object"!=typeof n||!n._typeDef)&&(a<g||void 0)),sortObjectKeys:a,getItemString:p,labelRenderer:u,valueRenderer:d,invertTheme:i,hideRoot:y,keyPath:[v],data:h}))}},4955:(e,n,a)=>{a.r(n),a.d(n,{assets:()=>o,contentTitle:()=>r,default:()=>u,frontMatter:()=>s,metadata:()=>c,toc:()=>l});var t=a(2232),i=(a(758),a(3805));a(3298);const s={title:"Accessors"},r=void 0,c={unversionedId:"concepts/accessors",id:"concepts/accessors",title:"Accessors",description:"Overview",source:"@site/docs/concepts/accessors.mdx",sourceDirName:"concepts",slug:"/concepts/accessors",permalink:"/tods-competition-factory/docs/concepts/accessors",draft:!1,tags:[],version:"current",frontMatter:{title:"Accessors"},sidebar:"docs",previous:{title:"Type Definitions",permalink:"/tods-competition-factory/docs/types/typedefs"},next:{title:"Time Items",permalink:"/tods-competition-factory/docs/concepts/timeItems"}},o={},l=[{value:"Overview",id:"overview",level:2},{value:"Key Concepts",id:"key-concepts",level:3},{value:"Basic Syntax",id:"basic-syntax",level:2},{value:"Simple Property Access",id:"simple-property-access",level:3},{value:"Nested Property Access",id:"nested-property-access",level:3},{value:"Array Property Access",id:"array-property-access",level:3},{value:"Common Use Cases",id:"common-use-cases",level:2},{value:"Participant Filtering",id:"participant-filtering",level:3},{value:"Scale Item Values",id:"scale-item-values",level:3},{value:"Avoidance Policies",id:"avoidance-policies",level:3},{value:"Team/Pair Participant Filtering",id:"teampair-participant-filtering",level:3},{value:"Advanced Patterns",id:"advanced-patterns",level:2},{value:"Multiple Accessor Filters",id:"multiple-accessor-filters",level:3},{value:"Partial String Matching",id:"partial-string-matching",level:3},{value:"Array Value Extraction",id:"array-value-extraction",level:3},{value:"Accessor Validation",id:"accessor-validation",level:2},{value:"Valid Accessor Paths",id:"valid-accessor-paths",level:3},{value:"Invalid Accessor Paths",id:"invalid-accessor-paths",level:3},{value:"Performance Considerations",id:"performance-considerations",level:2},{value:"Accessor Efficiency",id:"accessor-efficiency",level:3},{value:"Caching Considerations",id:"caching-considerations",level:3},{value:"Practical Examples",id:"practical-examples",level:2},{value:"Tournament Entry Filters",id:"tournament-entry-filters",level:3},{value:"Nationality-Based Draws",id:"nationality-based-draws",level:3},{value:"Complex Scale Item Retrieval",id:"complex-scale-item-retrieval",level:3},{value:"Multi-Level Team Filtering",id:"multi-level-team-filtering",level:3},{value:"Live Editor Example",id:"live-editor-example",level:2},{value:"Related Documentation",id:"related-documentation",level:2}],p={toc:l},d="wrapper";function u(e){let{components:n,...a}=e;return(0,i.yg)(d,(0,t.A)({},p,a,{components:n,mdxType:"MDXLayout"}),(0,i.yg)("h2",{id:"overview"},"Overview"),(0,i.yg)("p",null,(0,i.yg)("strong",{parentName:"p"},"Accessors")," are path strings that specify the location of data values within nested JSON objects. They provide a simple dot-notation syntax for accessing deeply nested attributes without writing complex traversal code. Accessors are used throughout TODS for filtering, policy evaluation, and data extraction."),(0,i.yg)("h3",{id:"key-concepts"},"Key Concepts"),(0,i.yg)("p",null,(0,i.yg)("strong",{parentName:"p"},"Dot Notation"),": Use dots to traverse object properties (e.g., ",(0,i.yg)("inlineCode",{parentName:"p"},"person.standardFamilyName"),")",(0,i.yg)("br",{parentName:"p"}),"\n",(0,i.yg)("strong",{parentName:"p"},"Array Handling"),": Automatically extracts values from arrays",(0,i.yg)("br",{parentName:"p"}),"\n",(0,i.yg)("strong",{parentName:"p"},"Type Safety"),": Works with any JSON-compatible data structure",(0,i.yg)("br",{parentName:"p"}),"\n",(0,i.yg)("strong",{parentName:"p"},"Use Cases"),": Participant filtering, avoidance policies, scale item values"),(0,i.yg)("h2",{id:"basic-syntax"},"Basic Syntax"),(0,i.yg)("h3",{id:"simple-property-access"},"Simple Property Access"),(0,i.yg)("p",null,"Access top-level properties:"),(0,i.yg)("pre",null,(0,i.yg)("code",{parentName:"pre",className:"language-js"},"// Participant object\nconst participant = {\n  participantId: 'player-123',\n  participantType: 'INDIVIDUAL',\n  person: {\n    standardFamilyName: 'Federer',\n    standardGivenName: 'Roger',\n    nationalityCode: 'SUI',\n    sex: 'MALE'\n  }\n};\n\n// Accessor for family name\nconst accessor = 'person.standardFamilyName';\n// Returns: 'Federer'\n\n// Accessor for nationality\nconst accessor2 = 'person.nationalityCode';\n// Returns: 'SUI'\n")),(0,i.yg)("h3",{id:"nested-property-access"},"Nested Property Access"),(0,i.yg)("p",null,"Traverse multiple levels:"),(0,i.yg)("pre",null,(0,i.yg)("code",{parentName:"pre",className:"language-js"},"const participant = {\n  participantId: 'player-123',\n  person: {\n    addresses: [{\n      city: 'Basel',\n      country: 'Switzerland'\n    }],\n    contacts: [{\n      type: 'email',\n      value: 'roger@example.com'\n    }]\n  }\n};\n\n// Accessor for nested data\nconst accessor = 'person.addresses.country';\n// Returns: ['Switzerland'] (array because addresses is an array)\n")),(0,i.yg)("h3",{id:"array-property-access"},"Array Property Access"),(0,i.yg)("p",null,"Accessors automatically handle arrays:"),(0,i.yg)("pre",null,(0,i.yg)("code",{parentName:"pre",className:"language-js"},"// PAIR participant with individual participants\nconst participant = {\n  participantType: 'PAIR',\n  individualParticipants: [\n    {\n      person: {\n        standardFamilyName: 'Bryan',\n        nationalityCode: 'USA'\n      }\n    },\n    {\n      person: {\n        standardFamilyName: 'Bryan',\n        nationalityCode: 'USA'\n      }\n    }\n  ]\n};\n\n// Accessor extracts from all array elements\nconst accessor = 'individualParticipants.person.nationalityCode';\n// Returns: ['USA', 'USA']\n")),(0,i.yg)("h2",{id:"common-use-cases"},"Common Use Cases"),(0,i.yg)("h3",{id:"participant-filtering"},"Participant Filtering"),(0,i.yg)("p",null,"Filter participants using accessor-based criteria:"),(0,i.yg)("pre",null,(0,i.yg)("code",{parentName:"pre",className:"language-js"},"// Get all female participants\nconst { participants } = tournamentEngine.getParticipants({\n  participantFilters: {\n    accessorValues: [\n      {\n        accessor: 'person.sex',\n        value: 'FEMALE'\n      }\n    ]\n  }\n});\n\n// Get participants from specific country\nconst { participants: french } = tournamentEngine.getParticipants({\n  participantFilters: {\n    accessorValues: [\n      {\n        accessor: 'person.nationalityCode',\n        value: 'FRA'\n      }\n    ]\n  }\n});\n\n// Multiple filters (AND logic)\nconst { participants: filtered } = tournamentEngine.getParticipants({\n  participantFilters: {\n    accessorValues: [\n      { accessor: 'person.sex', value: 'MALE' },\n      { accessor: 'person.nationalityCode', value: 'ESP' }\n    ]\n  }\n});\n")),(0,i.yg)("h3",{id:"scale-item-values"},"Scale Item Values"),(0,i.yg)("p",null,"Extract numeric values from complex scale items:"),(0,i.yg)("pre",null,(0,i.yg)("code",{parentName:"pre",className:"language-js"},"// Complex NTRP scale item\nconst scaleItem = {\n  scaleType: 'RATING',\n  scaleValue: {\n    ntrpRating: 4.5,\n    ratingYear: '2024',\n    ustaRatingType: 'C',\n    district: 'SoCal'\n  },\n  scaleName: 'NTRP',\n  eventType: 'DOUBLES',\n  scaleDate: '2024-06-15'\n};\n\n// Use accessor to extract the numeric rating\nconst scaleAttributes = {\n  scaleType: 'RATING',\n  scaleName: 'NTRP',\n  eventType: 'DOUBLES',\n  accessor: 'ntrpRating'  // Points to scaleValue.ntrpRating\n};\n\nconst { scaleItem: retrieved } = tournamentEngine.getParticipantScaleItem({\n  participantId: 'player-123',\n  scaleAttributes\n});\n// The accessor extracts 4.5 from scaleValue for comparisons\n")),(0,i.yg)("p",null,(0,i.yg)("strong",{parentName:"p"},"See:")," ",(0,i.yg)("a",{parentName:"p",href:"./scaleItems"},"Scale Items")," for detailed scale item documentation."),(0,i.yg)("h3",{id:"avoidance-policies"},"Avoidance Policies"),(0,i.yg)("p",null,"Define matchUp avoidance based on participant attributes:"),(0,i.yg)("pre",null,(0,i.yg)("code",{parentName:"pre",className:"language-js"},"// Avoid matching participants from same country\nconst policyDefinitions = {\n  avoidance: {\n    policyName: 'Nationality Avoidance',\n    roundsToSeparate: 2,  // Keep apart for 2 rounds\n    accessor: 'person.nationalityCode'\n  }\n};\n\ntournamentEngine.attachPolicies({ policyDefinitions });\n\n// When generating draw, participants with matching nationalityCode\n// will be placed to avoid early-round matchups\ntournamentEngine.generateDrawDefinition({\n  eventId: 'singles-main',\n  policyDefinitions\n});\n")),(0,i.yg)("p",null,(0,i.yg)("strong",{parentName:"p"},"See:")," ",(0,i.yg)("a",{parentName:"p",href:"/docs/policies/avoidance"},"Avoidance Policies")," for complete avoidance documentation."),(0,i.yg)("h3",{id:"teampair-participant-filtering"},"Team/Pair Participant Filtering"),(0,i.yg)("p",null,"Access properties of individual participants within teams or pairs:"),(0,i.yg)("pre",null,(0,i.yg)("code",{parentName:"pre",className:"language-js"},"// Get all pairs containing at least one USA player\nconst { participants } = tournamentEngine.getParticipants({\n  participantFilters: {\n    participantTypes: ['PAIR'],\n    accessorValues: [\n      {\n        accessor: 'individualParticipants.person.nationalityCode',\n        value: 'USA'\n      }\n    ]\n  }\n});\n\n// Get teams with specific club affiliation\nconst { participants: teams } = tournamentEngine.getParticipants({\n  participantFilters: {\n    participantTypes: ['TEAM'],\n    accessorValues: [\n      {\n        accessor: 'teamParticipants.person.club',\n        value: 'Tennis Club America'\n      }\n    ]\n  }\n});\n")),(0,i.yg)("h2",{id:"advanced-patterns"},"Advanced Patterns"),(0,i.yg)("h3",{id:"multiple-accessor-filters"},"Multiple Accessor Filters"),(0,i.yg)("p",null,"Combine multiple accessor-based filters:"),(0,i.yg)("pre",null,(0,i.yg)("code",{parentName:"pre",className:"language-js"},"const { participants } = tournamentEngine.getParticipants({\n  participantFilters: {\n    accessorValues: [\n      { accessor: 'person.sex', value: 'FEMALE' },\n      { accessor: 'person.nationalityCode', value: 'GBR' },\n      { accessor: 'person.birthDate', value: '2005' }  // Birth year matching\n    ]\n  }\n});\n\n// All conditions must match (AND logic)\n")),(0,i.yg)("h3",{id:"partial-string-matching"},"Partial String Matching"),(0,i.yg)("p",null,"Some filter contexts support partial matching:"),(0,i.yg)("pre",null,(0,i.yg)("code",{parentName:"pre",className:"language-js"},"// Filter by birth year from full date\nconst { participants } = tournamentEngine.getParticipants({\n  participantFilters: {\n    accessorValues: [\n      {\n        accessor: 'person.birthDate',\n        value: '2005'  // Matches any birthDate containing '2005'\n      }\n    ]\n  }\n});\n")),(0,i.yg)("h3",{id:"array-value-extraction"},"Array Value Extraction"),(0,i.yg)("p",null,"When accessor path includes arrays, values are extracted from all elements:"),(0,i.yg)("pre",null,(0,i.yg)("code",{parentName:"pre",className:"language-js"},"// PAIR participant\nconst pair = {\n  participantType: 'PAIR',\n  individualParticipants: [\n    {\n      person: { nationalityCode: 'USA', standardFamilyName: 'Sock' }\n    },\n    {\n      person: { nationalityCode: 'AUS', standardFamilyName: 'Peers' }\n    }\n  ]\n};\n\n// Accessor extracts both nationalities\nconst accessor = 'individualParticipants.person.nationalityCode';\n// Returns: ['USA', 'AUS']\n\n// Can match if ANY element matches the filter value\n")),(0,i.yg)("h2",{id:"accessor-validation"},"Accessor Validation"),(0,i.yg)("h3",{id:"valid-accessor-paths"},"Valid Accessor Paths"),(0,i.yg)("pre",null,(0,i.yg)("code",{parentName:"pre",className:"language-js"},"// \u2713 Simple property\n'participantType'\n\n// \u2713 Nested property\n'person.standardFamilyName'\n\n// \u2713 Deeply nested\n'person.addresses.city'\n\n// \u2713 Through arrays\n'individualParticipants.person.nationalityCode'\n\n// \u2713 Multiple levels with arrays\n'teamParticipants.person.contacts.value'\n")),(0,i.yg)("h3",{id:"invalid-accessor-paths"},"Invalid Accessor Paths"),(0,i.yg)("pre",null,(0,i.yg)("code",{parentName:"pre",className:"language-js"},"// \u2717 Empty string\n''\n\n// \u2717 Starting with dot\n'.person.name'\n\n// \u2717 Ending with dot\n'person.name.'\n\n// \u2717 Double dots\n'person..name'\n\n// \u2717 Array indices (not supported)\n'individualParticipants[0].person.name'\n")),(0,i.yg)("h2",{id:"performance-considerations"},"Performance Considerations"),(0,i.yg)("h3",{id:"accessor-efficiency"},"Accessor Efficiency"),(0,i.yg)("p",null,"Accessors are evaluated for each participant/item, so keep paths as short as necessary:"),(0,i.yg)("pre",null,(0,i.yg)("code",{parentName:"pre",className:"language-js"},"// \u2713 Efficient - direct path\naccessor: 'person.nationalityCode'\n\n// \u2713 Efficient - necessary depth\naccessor: 'individualParticipants.person.nationalityCode'\n\n// \u26a0 Less efficient - unnecessary depth\naccessor: 'person.details.info.data.nationality'  // If flatter structure possible\n")),(0,i.yg)("h3",{id:"caching-considerations"},"Caching Considerations"),(0,i.yg)("p",null,"When filtering large participant sets repeatedly:"),(0,i.yg)("pre",null,(0,i.yg)("code",{parentName:"pre",className:"language-js"},"// \u2713 Good - filter once, reuse results\nconst { participants: females } = tournamentEngine.getParticipants({\n  participantFilters: {\n    accessorValues: [{ accessor: 'person.sex', value: 'FEMALE' }]\n  }\n});\n\n// Use 'females' array for subsequent operations\n\n// \u2717 Less efficient - filtering multiple times\n// (If you need the same filtered set multiple times)\n")),(0,i.yg)("h2",{id:"practical-examples"},"Practical Examples"),(0,i.yg)("h3",{id:"tournament-entry-filters"},"Tournament Entry Filters"),(0,i.yg)("p",null,"Filter participants for event entry:"),(0,i.yg)("pre",null,(0,i.yg)("code",{parentName:"pre",className:"language-js"},"// Get all junior female players\nconst { participants } = tournamentEngine.getParticipants({\n  participantFilters: {\n    accessorValues: [\n      { accessor: 'person.sex', value: 'FEMALE' },\n      { accessor: 'person.birthDate', value: '2006' }  // U18 players\n    ]\n  }\n});\n\n// Add them to junior girls event\ntournamentEngine.addEventEntries({\n  eventId: 'girls-u18',\n  participantIds: participants.map(p => p.participantId)\n});\n")),(0,i.yg)("h3",{id:"nationality-based-draws"},"Nationality-Based Draws"),(0,i.yg)("p",null,"Create draws avoiding same-nation matchups:"),(0,i.yg)("pre",null,(0,i.yg)("code",{parentName:"pre",className:"language-js"},"// Set nationality avoidance policy\nconst policyDefinitions = {\n  avoidance: {\n    policyName: 'National Federation Avoidance',\n    roundsToSeparate: 3,\n    accessor: 'person.nationalityCode'\n  }\n};\n\n// Generate draw with avoidance\ntournamentEngine.generateDrawDefinition({\n  eventId: 'singles-main',\n  drawSize: 32,\n  seedsCount: 8,\n  policyDefinitions\n});\n\n// Participants from same country will be separated for 3 rounds\n")),(0,i.yg)("h3",{id:"complex-scale-item-retrieval"},"Complex Scale Item Retrieval"),(0,i.yg)("p",null,"Work with multi-attribute scale values:"),(0,i.yg)("pre",null,(0,i.yg)("code",{parentName:"pre",className:"language-js"},"// Set complex scale item\ntournamentEngine.setParticipantScaleItem({\n  participantId: 'player-123',\n  scaleItem: {\n    scaleType: 'RATING',\n    scaleValue: {\n      combinedRating: 9.2,\n      singlesRating: 9.5,\n      doublesRating: 8.9,\n      lastUpdated: '2024-06-15'\n    },\n    scaleName: 'CustomRating',\n    eventType: 'SINGLES',\n    scaleDate: '2024-06-15'\n  }\n});\n\n// Retrieve using accessor to combined rating\nconst { scaleItem } = tournamentEngine.getParticipantScaleItem({\n  participantId: 'player-123',\n  scaleAttributes: {\n    scaleType: 'RATING',\n    scaleName: 'CustomRating',\n    eventType: 'SINGLES',\n    accessor: 'combinedRating'\n  }\n});\n\nconsole.log(scaleItem.scaleValue.combinedRating);  // 9.2\n")),(0,i.yg)("h3",{id:"multi-level-team-filtering"},"Multi-Level Team Filtering"),(0,i.yg)("p",null,"Filter team participants by individual member attributes:"),(0,i.yg)("pre",null,(0,i.yg)("code",{parentName:"pre",className:"language-js"},"// Get teams with at least one member from specific region\nconst { participants: regionalTeams } = tournamentEngine.getParticipants({\n  participantFilters: {\n    participantTypes: ['TEAM'],\n    accessorValues: [\n      {\n        accessor: 'teamParticipants.person.region',\n        value: 'Northern California'\n      }\n    ]\n  }\n});\n\n// Teams where ANY member matches the region will be included\n")),(0,i.yg)("h2",{id:"live-editor-example"},"Live Editor Example"),(0,i.yg)("p",null,"In the ",(0,i.yg)("strong",{parentName:"p"},"Live Editor")," below, the accessor ",(0,i.yg)("inlineCode",{parentName:"p"},'"person.sex"')," is used to target ",(0,i.yg)("inlineCode",{parentName:"p"},"FEMALE")," participants.\nChange the accessor value or uncomment the ",(0,i.yg)("inlineCode",{parentName:"p"},"person.nationalityCode")," filter to see the results change."),(0,i.yg)("pre",null,(0,i.yg)("code",{parentName:"pre",className:"language-jsx",metastring:"live",live:!0},"function AccessorsDemo(props) {\n  // Generate a tournament record with some MALE participants\n  const { tournamentRecord } = mocksEngine.generateTournamentRecord({\n    participantsProfile: { sex: 'MALE' },\n  });\n  tournamentEngine.setState(tournamentRecord);\n\n  // Now generate some FEMALE participants...\n  const { participants } = mocksEngine.generateParticipants({\n    participantsCount: 16,\n    sex: 'FEMALE',\n  });\n  // ... and add them to the tournament\n  tournamentEngine.addParticipants({ participants });\n\n  const { participants: tournamentParticipants } = tournamentEngine.getParticipants({\n    participantFilters: {\n      accessorValues: [\n        { accessor: 'person.sex', value: 'FEMALE' },\n        // { accessor: 'person.nationalityCode', value: 'FRA' },\n      ],\n    },\n  });\n\n  return <Participants data={tournamentParticipants} />;\n}\n")),(0,i.yg)("h2",{id:"related-documentation"},"Related Documentation"),(0,i.yg)("ul",null,(0,i.yg)("li",{parentName:"ul"},(0,i.yg)("strong",{parentName:"li"},(0,i.yg)("a",{parentName:"strong",href:"./scaleItems"},"Scale Items"))," - Using accessors with scale values"),(0,i.yg)("li",{parentName:"ul"},(0,i.yg)("strong",{parentName:"li"},(0,i.yg)("a",{parentName:"strong",href:"./participants"},"Participants"))," - Participant data structure"),(0,i.yg)("li",{parentName:"ul"},(0,i.yg)("strong",{parentName:"li"},(0,i.yg)("a",{parentName:"strong",href:"/docs/policies/avoidance"},"Avoidance Policies"))," - Matchup avoidance configuration"),(0,i.yg)("li",{parentName:"ul"},(0,i.yg)("strong",{parentName:"li"},(0,i.yg)("a",{parentName:"strong",href:"/docs/governors/participant-governor"},"Participant Governor"))," - Participant management methods")))}u.isMDXComponent=!0}}]);