"use strict";(globalThis.webpackChunkdocumentation=globalThis.webpackChunkdocumentation||[]).push([[9805],{7069(e,n,i){i.r(n),i.d(n,{assets:()=>o,contentTitle:()=>s,default:()=>h,frontMatter:()=>l,metadata:()=>t,toc:()=>c});const t=JSON.parse('{"id":"temporal-engine/block-types-and-algorithms","title":"Block Types & Algorithms","description":"This page covers the domain-specific technical details of the TemporalEngine: the inverted availability paradigm, block types, the sweep-line rail derivation algorithm, capacity curves, collision detection, time granularity, and the TODS bridge.","source":"@site/docs/temporal-engine/block-types-and-algorithms.md","sourceDirName":"temporal-engine","slug":"/temporal-engine/block-types-and-algorithms","permalink":"/competition-factory/docs/temporal-engine/block-types-and-algorithms","draft":false,"unlisted":false,"tags":[],"version":"current","frontMatter":{"title":"Block Types & Algorithms"},"sidebar":"docs","previous":{"title":"Event System & Validation","permalink":"/competition-factory/docs/temporal-engine/event-system-and-validation"},"next":{"title":"UI Integration Scenarios","permalink":"/competition-factory/docs/temporal-engine/ui-integration-scenarios"}}');var r=i(6070),a=i(8322);const l={title:"Block Types & Algorithms"},s=void 0,o={},c=[{value:"The Inverted Paradigm",id:"the-inverted-paradigm",level:2},{value:"Block Types",id:"block-types",level:2},{value:"Block Interface",id:"block-interface",level:3},{value:"Rail Derivation Algorithm",id:"rail-derivation-algorithm",level:2},{value:"Algorithm Steps",id:"algorithm-steps",level:3},{value:"Key Interfaces",id:"key-interfaces",level:3},{value:"Visualization Example",id:"visualization-example",level:3},{value:"Key Functions",id:"key-functions",level:3},{value:"Capacity Curves",id:"capacity-curves",level:2},{value:"Key Interfaces",id:"key-interfaces-1",level:3},{value:"Usage",id:"usage",level:3},{value:"Additional Capacity Functions",id:"additional-capacity-functions",level:3},{value:"Collision Detection",id:"collision-detection",level:2},{value:"Key Functions",id:"key-functions-1",level:3},{value:"clampDragToCollisions",id:"clampdragtocollisions",level:3},{value:"Time Granularity",id:"time-granularity",level:2},{value:"Key Functions",id:"key-functions-2",level:3},{value:"TODS Bridge",id:"tods-bridge",level:2},{value:"Engine \u2192 TODS",id:"engine--tods",level:3},{value:"TODS \u2192 Engine",id:"tods--engine",level:3},{value:"Scheduling Profile Bridge",id:"scheduling-profile-bridge",level:3},{value:"BridgeConfig",id:"bridgeconfig",level:3},{value:"Utility Functions",id:"utility-functions",level:3},{value:"Related Documentation",id:"related-documentation",level:2}];function d(e){const n={a:"a",code:"code",em:"em",h2:"h2",h3:"h3",hr:"hr",li:"li",mermaid:"mermaid",ol:"ol",p:"p",pre:"pre",strong:"strong",table:"table",tbody:"tbody",td:"td",th:"th",thead:"thead",tr:"tr",ul:"ul",...(0,a.R)(),...e.components};return(0,r.jsxs)(r.Fragment,{children:[(0,r.jsx)(n.p,{children:"This page covers the domain-specific technical details of the TemporalEngine: the inverted availability paradigm, block types, the sweep-line rail derivation algorithm, capacity curves, collision detection, time granularity, and the TODS bridge."}),"\n",(0,r.jsx)(n.h2,{id:"the-inverted-paradigm",children:"The Inverted Paradigm"}),"\n",(0,r.jsxs)(n.p,{children:["The TemporalEngine uses an ",(0,r.jsx)(n.strong,{children:"inverted model"})," \u2014 instead of tracking when courts are available, it tracks when they are ",(0,r.jsx)(n.em,{children:"unavailable"}),". Available time is whatever remains after all blocks are accounted for."]}),"\n",(0,r.jsxs)(n.table,{children:[(0,r.jsx)(n.thead,{children:(0,r.jsxs)(n.tr,{children:[(0,r.jsx)(n.th,{children:"Aspect"}),(0,r.jsx)(n.th,{children:"Traditional Model"}),(0,r.jsx)(n.th,{children:"Temporal Engine"})]})}),(0,r.jsxs)(n.tbody,{children:[(0,r.jsxs)(n.tr,{children:[(0,r.jsx)(n.td,{children:"Canonical state"}),(0,r.jsx)(n.td,{children:"Available time slots"}),(0,r.jsx)(n.td,{children:"Blocks (unavailable time)"})]}),(0,r.jsxs)(n.tr,{children:[(0,r.jsx)(n.td,{children:"Adding unavailability"}),(0,r.jsx)(n.td,{children:"Remove/split available slots"}),(0,r.jsx)(n.td,{children:"Add a block"})]}),(0,r.jsxs)(n.tr,{children:[(0,r.jsx)(n.td,{children:"Querying availability"}),(0,r.jsx)(n.td,{children:"Read available slot list"}),(0,r.jsx)(n.td,{children:"Derive rails (subtract blocks from day range)"})]}),(0,r.jsxs)(n.tr,{children:[(0,r.jsx)(n.td,{children:"Overlap resolution"}),(0,r.jsx)(n.td,{children:"Merge available slots"}),(0,r.jsx)(n.td,{children:"Precedence-based sweep line"})]}),(0,r.jsxs)(n.tr,{children:[(0,r.jsx)(n.td,{children:"Storage efficiency"}),(0,r.jsx)(n.td,{children:"Grows with available time"}),(0,r.jsx)(n.td,{children:"Grows with constraints"})]})]})]}),"\n",(0,r.jsx)(n.p,{children:"This approach is particularly effective for tournament scheduling where courts start fully available and constraints are added incrementally \u2014 a few maintenance windows, practice blocks, and reserved periods define the day's shape more compactly than enumerating every free slot."}),"\n",(0,r.jsx)(n.h2,{id:"block-types",children:"Block Types"}),"\n",(0,r.jsxs)(n.table,{children:[(0,r.jsx)(n.thead,{children:(0,r.jsxs)(n.tr,{children:[(0,r.jsx)(n.th,{children:"Type"}),(0,r.jsx)(n.th,{children:"Meaning"}),(0,r.jsx)(n.th,{children:"Typical Source"}),(0,r.jsx)(n.th,{children:"Category"})]})}),(0,r.jsxs)(n.tbody,{children:[(0,r.jsxs)(n.tr,{children:[(0,r.jsx)(n.td,{children:(0,r.jsx)(n.code,{children:"MAINTENANCE"})}),(0,r.jsx)(n.td,{children:"Court under maintenance"}),(0,r.jsx)(n.td,{children:"Template / User"}),(0,r.jsx)(n.td,{children:"Hard constraint"})]}),(0,r.jsxs)(n.tr,{children:[(0,r.jsx)(n.td,{children:(0,r.jsx)(n.code,{children:"PRACTICE"})}),(0,r.jsx)(n.td,{children:"Reserved for practice"}),(0,r.jsx)(n.td,{children:"User"}),(0,r.jsx)(n.td,{children:"Soft constraint"})]}),(0,r.jsxs)(n.tr,{children:[(0,r.jsx)(n.td,{children:(0,r.jsx)(n.code,{children:"RESERVED"})}),(0,r.jsx)(n.td,{children:"Reserved (general purpose)"}),(0,r.jsx)(n.td,{children:"User / System"}),(0,r.jsx)(n.td,{children:"Soft constraint"})]}),(0,r.jsxs)(n.tr,{children:[(0,r.jsx)(n.td,{children:(0,r.jsx)(n.code,{children:"BLOCKED"})}),(0,r.jsx)(n.td,{children:"Generically blocked"}),(0,r.jsx)(n.td,{children:"User"}),(0,r.jsx)(n.td,{children:"Hard constraint"})]}),(0,r.jsxs)(n.tr,{children:[(0,r.jsx)(n.td,{children:(0,r.jsx)(n.code,{children:"CLOSED"})}),(0,r.jsx)(n.td,{children:"Court closed for the day"}),(0,r.jsx)(n.td,{children:"System"}),(0,r.jsx)(n.td,{children:"Hard constraint"})]}),(0,r.jsxs)(n.tr,{children:[(0,r.jsx)(n.td,{children:(0,r.jsx)(n.code,{children:"SCHEDULED"})}),(0,r.jsx)(n.td,{children:"Match scheduled here"}),(0,r.jsx)(n.td,{children:"System (import)"}),(0,r.jsx)(n.td,{children:"Informational"})]}),(0,r.jsxs)(n.tr,{children:[(0,r.jsx)(n.td,{children:(0,r.jsx)(n.code,{children:"SOFT_BLOCK"})}),(0,r.jsx)(n.td,{children:"Soft block (can be overridden)"}),(0,r.jsx)(n.td,{children:"User / Rule"}),(0,r.jsx)(n.td,{children:"Soft constraint"})]}),(0,r.jsxs)(n.tr,{children:[(0,r.jsx)(n.td,{children:(0,r.jsx)(n.code,{children:"HARD_BLOCK"})}),(0,r.jsx)(n.td,{children:"Hard block (cannot be overridden)"}),(0,r.jsx)(n.td,{children:"User / Rule"}),(0,r.jsx)(n.td,{children:"Hard constraint"})]}),(0,r.jsxs)(n.tr,{children:[(0,r.jsx)(n.td,{children:(0,r.jsx)(n.code,{children:"LOCKED"})}),(0,r.jsx)(n.td,{children:"Locked \u2014 immutable"}),(0,r.jsx)(n.td,{children:"System"}),(0,r.jsx)(n.td,{children:"Hard constraint"})]}),(0,r.jsxs)(n.tr,{children:[(0,r.jsx)(n.td,{children:(0,r.jsx)(n.code,{children:"AVAILABLE"})}),(0,r.jsx)(n.td,{children:"Explicitly available"}),(0,r.jsx)(n.td,{children:"Derived"}),(0,r.jsx)(n.td,{children:"Free time"})]}),(0,r.jsxs)(n.tr,{children:[(0,r.jsx)(n.td,{children:(0,r.jsx)(n.code,{children:"UNSPECIFIED"})}),(0,r.jsx)(n.td,{children:"Unknown/default"}),(0,r.jsx)(n.td,{children:"Fallback"}),(0,r.jsx)(n.td,{children:"Neutral"})]})]})]}),"\n",(0,r.jsx)(n.p,{children:(0,r.jsxs)(n.strong,{children:["Default ",(0,r.jsx)(n.code,{children:"typePrecedence"}),":"]})}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-js",children:"['HARD_BLOCK', 'LOCKED', 'MAINTENANCE', 'BLOCKED', 'PRACTICE', 'RESERVED', 'SOFT_BLOCK', 'AVAILABLE', 'UNSPECIFIED']\n"})}),"\n",(0,r.jsx)(n.p,{children:"When multiple blocks overlap on the same court at the same time, the block with the highest precedence (leftmost in the array) wins."}),"\n",(0,r.jsx)(n.h3,{id:"block-interface",children:"Block Interface"}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-ts",children:"interface Block extends TimeRange {\n  id: BlockId;\n  court: CourtRef;\n  type: BlockType;\n  reason?: string;\n  priority?: number;\n  hardSoft?: BlockHardness;      // 'HARD' | 'SOFT'\n  recurrenceKey?: string;\n  source?: BlockSource;          // 'USER' | 'TEMPLATE' | 'RULE' | 'SYSTEM'\n  matchUpId?: string;            // For SCHEDULED blocks\n}\n"})}),"\n",(0,r.jsx)(n.h2,{id:"rail-derivation-algorithm",children:"Rail Derivation Algorithm"}),"\n",(0,r.jsxs)(n.p,{children:["The core algorithm transforms overlapping blocks into non-overlapping ",(0,r.jsx)(n.strong,{children:"rail segments"})," using a sweep-line approach. This runs every time you call ",(0,r.jsx)(n.code,{children:"getCourtRail()"}),", ",(0,r.jsx)(n.code,{children:"getDayTimeline()"}),", or ",(0,r.jsx)(n.code,{children:"getVenueTimeline()"}),"."]}),"\n",(0,r.jsx)(n.mermaid,{value:"flowchart TD\n    A[Blocks for court+day] --\x3e B[Clamp to day range]\n    B --\x3e C[Build sorted edges]\n    C --\x3e D[Sweep line scan]\n    D --\x3e E[Resolve status by precedence]\n    E --\x3e F[Merge adjacent same-status segments]\n    F --\x3e G[CourtRail with non-overlapping segments]"}),"\n",(0,r.jsx)(n.h3,{id:"algorithm-steps",children:"Algorithm Steps"}),"\n",(0,r.jsxs)(n.ol,{children:["\n",(0,r.jsxs)(n.li,{children:["\n",(0,r.jsxs)(n.p,{children:[(0,r.jsx)(n.strong,{children:"Clamp"})," \u2014 Each block is clamped to the court's availability window for the day. Blocks entirely outside the window are discarded."]}),"\n"]}),"\n",(0,r.jsxs)(n.li,{children:["\n",(0,r.jsxs)(n.p,{children:[(0,r.jsx)(n.strong,{children:"Build edges"})," \u2014 Each block produces two edges: a ",(0,r.jsx)(n.code,{children:"START"})," edge and an ",(0,r.jsx)(n.code,{children:"END"})," edge. Edges are sorted by time, with ",(0,r.jsx)(n.code,{children:"END"})," edges before ",(0,r.jsx)(n.code,{children:"START"})," edges at the same time (to avoid zero-width overlaps)."]}),"\n"]}),"\n",(0,r.jsxs)(n.li,{children:["\n",(0,r.jsxs)(n.p,{children:[(0,r.jsx)(n.strong,{children:"Sweep"}),' \u2014 A scan pointer moves left-to-right through sorted edges. At each edge, the set of "active" blocks changes (a block is added at its START, removed at its END).']}),"\n"]}),"\n",(0,r.jsxs)(n.li,{children:["\n",(0,r.jsxs)(n.p,{children:[(0,r.jsx)(n.strong,{children:"Resolve"})," \u2014 At each transition point, the effective status is determined by finding the highest-precedence block type among active blocks, using the ",(0,r.jsx)(n.code,{children:"typePrecedence"})," array."]}),"\n"]}),"\n",(0,r.jsxs)(n.li,{children:["\n",(0,r.jsxs)(n.p,{children:[(0,r.jsx)(n.strong,{children:"Merge"})," \u2014 Adjacent segments with the same status are merged into a single segment, reducing the total segment count."]}),"\n"]}),"\n"]}),"\n",(0,r.jsx)(n.h3,{id:"key-interfaces",children:"Key Interfaces"}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-ts",children:"interface RailSegment extends TimeRange {\n  status: BlockType;                  // Effective status after precedence resolution\n  contributingBlocks: BlockId[];      // All blocks that overlap this segment\n}\n\ninterface CourtRail {\n  court: CourtRef;\n  segments: RailSegment[];            // Non-overlapping, sorted by start time\n}\n\ninterface VenueDayTimeline {\n  day: DayId;\n  venueId: VenueId;\n  rails: CourtRail[];                 // One rail per court\n}\n"})}),"\n",(0,r.jsx)(n.h3,{id:"visualization-example",children:"Visualization Example"}),"\n",(0,r.jsx)(n.p,{children:"Given three overlapping blocks on a court:"}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{children:"Block A (PRACTICE):    |\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588|\nBlock B (MAINTENANCE):        |\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588|\nBlock C (RESERVED):                 |\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588|\nTime:              08:00  09:00  10:00  11:00  12:00  13:00\n\nDerived Rail Segments:\n  [08:00\u201309:00] PRACTICE      (only A active)\n  [09:00\u201310:00] MAINTENANCE   (A+B active, MAINTENANCE wins by precedence)\n  [10:00\u201311:00] MAINTENANCE   (A+B+C active, MAINTENANCE still wins)\n  [11:00\u201312:00] RESERVED      (B+C active, but B ends at 11:00 \u2192 only C)\n  [12:00\u201313:00] RESERVED      (only C active)\n"})}),"\n",(0,r.jsxs)(n.p,{children:["After merge: segments at ",(0,r.jsx)(n.code,{children:"[09:00\u201310:00]"})," and ",(0,r.jsx)(n.code,{children:"[10:00\u201311:00]"})," both have status ",(0,r.jsx)(n.code,{children:"MAINTENANCE"}),", so they merge into ",(0,r.jsx)(n.code,{children:"[09:00\u201311:00] MAINTENANCE"}),"."]}),"\n",(0,r.jsx)(n.h3,{id:"key-functions",children:"Key Functions"}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-ts",children:"// Core derivation \u2014 called by TemporalEngine.getCourtRail()\nderiveRailSegments(blocks: Block[], dayRange: TimeRange, config: EngineConfig): RailSegment[]\n\n// Supporting utilities\nclampToDayRange(block: Block, dayRange: TimeRange): Block | null\nbuildEdges(blocks: Block[]): Edge[]\nsortEdges(edges: Edge[]): Edge[]\nresolveStatus(contributingIds: BlockId[], blocksById: Map<BlockId, Block>, precedence: BlockType[]): BlockType\nmergeAdjacentSegments(segments: RailSegment[]): RailSegment[]\n"})}),"\n",(0,r.jsx)(n.h2,{id:"capacity-curves",children:"Capacity Curves"}),"\n",(0,r.jsx)(n.p,{children:"Capacity curves aggregate rail data across all courts to show total availability over time \u2014 how many courts are available, soft-blocked, or hard-blocked at each time point."}),"\n",(0,r.jsx)(n.h3,{id:"key-interfaces-1",children:"Key Interfaces"}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-ts",children:"interface CapacityPoint {\n  time: string;\n  courtsAvailable: number;\n  courtsSoftBlocked: number;\n  courtsHardBlocked: number;\n}\n\ninterface CapacityCurve {\n  day: DayId;\n  points: CapacityPoint[];\n}\n\ninterface CapacityStats {\n  peakAvailable: number;\n  peakTime: string;\n  minAvailable: number;\n  minTime: string;\n  avgAvailable: number;\n  totalCourtHours: number;\n  utilizationPercent: number;\n  totalCourts?: number;\n  totalAvailableHours?: number;\n  totalUnavailableHours?: number;\n  availablePercent?: number;\n  avgBlockedHoursPerCourt?: number;\n}\n"})}),"\n",(0,r.jsx)(n.h3,{id:"usage",children:"Usage"}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-js",children:"const curve = engine.getCapacityCurve('2026-06-15');\n\n// Compute statistics\nimport { calculateCapacityStats } from 'tods-competition-factory';\nconst stats = calculateCapacityStats(curve);\nconsole.log(`Peak: ${stats.peakAvailable} courts at ${stats.peakTime}`);\nconsole.log(`Utilization: ${stats.utilizationPercent}%`);\n\n// Filter to a time window\nimport { filterCapacityCurve } from 'tods-competition-factory';\nconst morning = filterCapacityCurve(curve, {\n  start: '2026-06-15T08:00:00',\n  end: '2026-06-15T12:00:00',\n});\n\n// Compare before/after\nimport { compareCapacityCurves } from 'tods-competition-factory';\nconst diffs = compareCapacityCurves(baselineCurve, modifiedCurve);\n"})}),"\n",(0,r.jsx)(n.h3,{id:"additional-capacity-functions",children:"Additional Capacity Functions"}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-ts",children:"// Resample a curve at a different interval\nsampleCapacityCurve(curve: CapacityCurve, intervalMinutes: number): CapacityCurve\n\n// Compare two curves point by point\ncompareCapacityCurves(baseline: CapacityCurve, modified: CapacityCurve): CapacityDiff[]\n"})}),"\n",(0,r.jsx)(n.h2,{id:"collision-detection",children:"Collision Detection"}),"\n",(0,r.jsxs)(n.p,{children:["Collision detection prevents blocks from overlapping during interactive drag-and-drop operations. The engine uses ",(0,r.jsx)(n.strong,{children:"half-open intervals"})," ",(0,r.jsx)(n.code,{children:"[start, end)"})," \u2014 a block occupying ",(0,r.jsx)(n.code,{children:"[09:00, 10:00)"})," does NOT overlap with a block at ",(0,r.jsx)(n.code,{children:"[10:00, 11:00)"}),". Adjacency is not overlap."]}),"\n",(0,r.jsx)(n.h3,{id:"key-functions-1",children:"Key Functions"}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-ts",children:"// Check if two time ranges overlap (half-open interval semantics)\nintervalsOverlap(a: TimeRange, b: TimeRange): boolean\n\n// Check if a time point falls inside a block\ntimeInsideBlock(time: number, block: Block): boolean\n\n// Find all blocks containing a specific time point\nfindBlocksContainingTime(time: number, blocks: Block[]): Block[]\n\n// Clamp a drag gesture to avoid collisions with existing blocks\nclampDragToCollisions(\n  anchorTime: number,\n  cursorTime: number,\n  blocks: Block[],\n): {\n  start: number;\n  end: number;\n  clamped: boolean;\n  clampedBy?: Block;\n  direction: 'forward' | 'backward';\n}\n"})}),"\n",(0,r.jsx)(n.h3,{id:"clampdragtocollisions",children:"clampDragToCollisions"}),"\n",(0,r.jsx)(n.p,{children:"This is the primary function used during interactive block creation (paint mode). Given an anchor point (where the drag started) and a cursor position (where the drag currently is), it computes the largest valid time range that doesn't overlap any existing blocks:"}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-js",children:"import { clampDragToCollisions } from 'tods-competition-factory';\n\n// User started dragging at 09:00, cursor is now at 11:00\n// But there's a block from 10:00-10:30\nconst result = clampDragToCollisions(540, 660, existingBlocks);\n// result: { start: 540, end: 600, clamped: true, direction: 'forward' }\n// The drag is clamped to 09:00\u201310:00 (stops at the block boundary)\n"})}),"\n",(0,r.jsx)(n.h2,{id:"time-granularity",children:"Time Granularity"}),"\n",(0,r.jsxs)(n.p,{children:["All times in the engine snap to a configurable granularity (default 15 minutes). The ",(0,r.jsx)(n.code,{children:"timeGranularity"})," module provides utilities for snapping and iterating."]}),"\n",(0,r.jsx)(n.h3,{id:"key-functions-2",children:"Key Functions"}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-ts",children:"// Convert 'HH:MM' to minutes since midnight\nhhmmToMinutes(hhmm: string): number\n// hhmmToMinutes('09:30') \u2192 570\n\n// Convert minutes since midnight to 'HH:MM'\nminutesToHhmm(minutes: number): string\n// minutesToHhmm(570) \u2192 '09:30'\n\n// Snap a minute value to the nearest granularity boundary\nsnapToGranularity(minutes: number, granularity: number, mode?: 'floor' | 'ceil' | 'round'): number\n// snapToGranularity(37, 15) \u2192 30   (floor, default)\n// snapToGranularity(37, 15, 'ceil') \u2192 45\n\n// Snap an ISO datetime string to granularity\nsnapIsoToGranularity(iso: string, granularity: number, mode?: 'floor' | 'ceil' | 'round'): string\n\n// Iterate time ticks at granularity intervals\nfunction* iterateDayTicks(startHhmm: string, endHhmm: string, granularity: number): Generator<string>\n// [...iterateDayTicks('08:00', '10:00', 30)] \u2192 ['08:00', '08:30', '09:00', '09:30', '10:00']\n"})}),"\n",(0,r.jsx)(n.h2,{id:"tods-bridge",children:"TODS Bridge"}),"\n",(0,r.jsx)(n.p,{children:"The bridge module provides bidirectional translation between TemporalEngine structures and TODS (Tournament Open Data Standards) tournament record structures."}),"\n",(0,r.jsx)(n.h3,{id:"engine--tods",children:"Engine \u2192 TODS"}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-ts",children:"// Convert derived rails to TODS dateAvailability entries\nrailsToDateAvailability(\n  timelines: VenueDayTimeline[],\n  config?: BridgeConfig,\n): TodsDateAvailability[]\n\n// Write engine availability back into a tournament record\napplyTemporalAvailabilityToTournamentRecord(params: {\n  tournamentRecord: any;\n  timelines: VenueDayTimeline[];\n  config?: BridgeConfig;\n  engine?: TemporalEngine;\n}): any\n"})}),"\n",(0,r.jsx)(n.h3,{id:"tods--engine",children:"TODS \u2192 Engine"}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-ts",children:"// Convert TODS venue availability to engine blocks\ntodsAvailabilityToBlocks(params: {\n  venue: TodsVenue;\n  tournamentId: string;\n  blockType?: BlockType;\n}): Array<{ court: CourtRef; start: string; end: string; type: BlockType }>\n"})}),"\n",(0,r.jsx)(n.h3,{id:"scheduling-profile-bridge",children:"Scheduling Profile Bridge"}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-ts",children:"// Convert UI scheduling selections to a factory scheduling profile\nbuildSchedulingProfileFromUISelections(\n  selections: SchedulingSelection[],\n): SchedulingProfile\n\n// Validate a scheduling profile's structural format\nvalidateSchedulingProfileFormat(profile: SchedulingProfile): {\n  valid: boolean;\n  errors: string[];\n}\n"})}),"\n",(0,r.jsx)(n.h3,{id:"bridgeconfig",children:"BridgeConfig"}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-ts",children:"interface BridgeConfig {\n  courtToCourtId?: (courtRef: CourtRef) => string;\n  isSchedulableStatus?: (status: BlockType) => boolean;\n  aggregateByVenue?: boolean;\n}\n"})}),"\n",(0,r.jsx)(n.h3,{id:"utility-functions",children:"Utility Functions"}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-ts",children:"// Validate date availability entries\nvalidateDateAvailability(entries: TodsDateAvailability[]): { valid: boolean; errors: string[] }\n\n// Merge overlapping availability entries\nmergeOverlappingAvailability(entries: TodsDateAvailability[]): TodsDateAvailability[]\n\n// Calculate total court-hours from availability entries\ncalculateCourtHours(entries: TodsDateAvailability[]): number\n"})}),"\n",(0,r.jsx)(n.hr,{}),"\n",(0,r.jsx)(n.h2,{id:"related-documentation",children:"Related Documentation"}),"\n",(0,r.jsxs)(n.ul,{children:["\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.strong,{children:(0,r.jsx)(n.a,{href:"./temporal-engine-overview",children:"Overview"})})," \u2014 Introduction and architecture"]}),"\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.strong,{children:(0,r.jsx)(n.a,{href:"./temporal-engine-api",children:"Core API Reference"})})," \u2014 Complete method reference"]}),"\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.strong,{children:(0,r.jsx)(n.a,{href:"./event-system-and-validation",children:"Event System & Validation"})})," \u2014 Events, conflict evaluators, and validation pipeline"]}),"\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.strong,{children:(0,r.jsx)(n.a,{href:"./ui-integration-scenarios",children:"UI Integration Scenarios"})})," \u2014 Building UIs with engine data"]}),"\n"]})]})}function h(e={}){const{wrapper:n}={...(0,a.R)(),...e.components};return n?(0,r.jsx)(n,{...e,children:(0,r.jsx)(d,{...e})}):d(e)}},8322(e,n,i){i.d(n,{R:()=>l,x:()=>s});var t=i(758);const r={},a=t.createContext(r);function l(e){const n=t.useContext(a);return t.useMemo(function(){return"function"==typeof e?e(n):{...n,...e}},[n,e])}function s(e){let n;return n=e.disableParentContext?"function"==typeof e.components?e.components(r):e.components||r:l(e.components),t.createElement(a.Provider,{value:n},e.children)}}}]);