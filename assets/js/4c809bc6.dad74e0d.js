"use strict";(globalThis.webpackChunkdocumentation=globalThis.webpackChunkdocumentation||[]).push([[630],{4648(e,n,t){t.r(n),t.d(n,{assets:()=>a,contentTitle:()=>l,default:()=>u,frontMatter:()=>o,metadata:()=>i,toc:()=>c});const i=JSON.parse('{"id":"scale-engine/aggregation","title":"Multi-Tournament Aggregation","description":"The aggregation layer combines point awards from multiple tournaments into ranking lists. It operates as pure computation \u2014 no tournament state is accessed. The consumer is responsible for collecting PointAward[] from multiple getTournamentPoints calls and passing them to generateRankingList.","source":"@site/docs/scale-engine/aggregation.md","sourceDirName":"scale-engine","slug":"/scale-engine/aggregation","permalink":"/competition-factory/docs/scale-engine/aggregation","draft":false,"unlisted":false,"tags":[],"version":"current","frontMatter":{"title":"Multi-Tournament Aggregation"},"sidebar":"docs","previous":{"title":"Quality Win Points","permalink":"/competition-factory/docs/scale-engine/quality-win-points"},"next":{"title":"Overview","permalink":"/competition-factory/docs/scoring-engine/scoring-engine-overview"}}');var s=t(6070),r=t(8322);const o={title:"Multi-Tournament Aggregation"},l=void 0,a={},c=[{value:"Aggregation Pipeline",id:"aggregation-pipeline",level:2},{value:"Typical Pipeline",id:"typical-pipeline",level:2},{value:"Counting Buckets",id:"counting-buckets",level:2},{value:"Point Components",id:"point-components",level:3},{value:"bestOfCount",id:"bestofcount",level:3},{value:"maxResultsPerLevel",id:"maxresultsperlevel",level:3},{value:"Without Counting Buckets",id:"without-counting-buckets",level:2},{value:"Rolling Period",id:"rolling-period",level:2},{value:"Category Filter",id:"category-filter",level:2},{value:"Minimum Countable Results",id:"minimum-countable-results",level:2},{value:"Tiebreakers",id:"tiebreakers",level:2},{value:"RankingListEntry Output",id:"rankinglistentry-output",level:2},{value:"Per-Participant Breakdown",id:"per-participant-breakdown",level:2},{value:"Related Documentation",id:"related-documentation",level:2}];function d(e){const n={a:"a",code:"code",h2:"h2",h3:"h3",li:"li",p:"p",pre:"pre",strong:"strong",table:"table",tbody:"tbody",td:"td",th:"th",thead:"thead",tr:"tr",ul:"ul",...(0,r.R)(),...e.components};return(0,s.jsxs)(s.Fragment,{children:[(0,s.jsxs)(n.p,{children:["The aggregation layer combines point awards from multiple tournaments into ranking lists. It operates as pure computation \u2014 no tournament state is accessed. The consumer is responsible for collecting ",(0,s.jsx)(n.code,{children:"PointAward[]"})," from multiple ",(0,s.jsx)(n.code,{children:"getTournamentPoints"})," calls and passing them to ",(0,s.jsx)(n.code,{children:"generateRankingList"}),"."]}),"\n",(0,s.jsx)(n.h2,{id:"aggregation-pipeline",children:"Aggregation Pipeline"}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{children:"  PointAward[] (from multiple tournaments)\n       |\n  1. Category Filter     ageCategoryCodes, genders, eventTypes\n       |\n  2. Rolling Period       Exclude awards older than rollingPeriodDays\n       |\n  3. Group by Person      Collect all awards per personId\n       |\n  4. Bucket Processing    Per counting bucket:\n       |                    - Filter by eventTypes + pointComponents\n       +-> Sort descending  - Sort by computed value\n       +-> Level cap        - Apply maxResultsPerLevel\n       +-> Best-of-N        - Apply bestOfCount\n       +-> Sum              - Bucket total\n       |\n  5. Total Points         Sum across all buckets\n       |\n  6. Minimum Check        meetsMinimum if countingResults >= minCountableResults\n       |\n  7. Sort + Tiebreak      Sort descending, apply tiebreakCriteria\n       |\n  8. Assign Ranks         1-based, tied ranks for equal positions\n       |\n       v\n  RankingListEntry[]\n"})}),"\n",(0,s.jsx)(n.h2,{id:"typical-pipeline",children:"Typical Pipeline"}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-js",children:"import { generateRankingList } from 'tods-competition-factory';\n\n// Step 1: Collect awards from multiple tournaments\nconst allAwards = [];\n\nfor (const tournamentRecord of seasonTournaments) {\n  scaleEngine.setState(tournamentRecord);\n  const { personPoints } = scaleEngine.getTournamentPoints({\n    policyDefinitions: rankingPolicy,\n    level: tournamentRecord.level,\n  });\n\n  for (const [personId, awards] of Object.entries(personPoints)) {\n    allAwards.push(...awards.map(a => ({ ...a, personId })));\n  }\n}\n\n// Step 2: Generate ranking list\nconst rankingList = generateRankingList({\n  pointAwards: allAwards,\n  aggregationRules,\n  asOfDate: '2025-12-31',\n});\n"})}),"\n",(0,s.jsx)(n.h2,{id:"counting-buckets",children:"Counting Buckets"}),"\n",(0,s.jsxs)(n.p,{children:["Counting buckets define how awards are grouped and counted. Each bucket filters awards by ",(0,s.jsx)(n.code,{children:"eventTypes"})," and extracts point values from ",(0,s.jsx)(n.code,{children:"pointComponents"}),":"]}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-js",children:"aggregationRules: {\n  countingBuckets: [\n    {\n      bucketName: 'Singles',\n      eventTypes: ['SINGLES'],\n      pointComponents: ['positionPoints', 'perWinPoints', 'bonusPoints'],\n      bestOfCount: 6,                    // best 6 results count\n      maxResultsPerLevel: { 7: 2 },     // max 2 level-7 results\n    },\n    {\n      bucketName: 'Doubles',\n      eventTypes: ['DOUBLES'],\n      pointComponents: ['positionPoints', 'perWinPoints', 'bonusPoints'],\n      bestOfCount: 2,                    // best 2 results count\n    },\n    {\n      bucketName: 'Quality Wins',\n      pointComponents: ['qualityWinPoints'],\n      bestOfCount: 0,                    // 0 = count ALL (no limit)\n    },\n  ],\n}\n"})}),"\n",(0,s.jsx)(n.h3,{id:"point-components",children:"Point Components"}),"\n",(0,s.jsxs)(n.p,{children:["The ",(0,s.jsx)(n.code,{children:"pointComponents"})," array specifies which fields on each award to sum for the bucket value:"]}),"\n",(0,s.jsxs)(n.table,{children:[(0,s.jsx)(n.thead,{children:(0,s.jsxs)(n.tr,{children:[(0,s.jsx)(n.th,{children:"Component"}),(0,s.jsx)(n.th,{children:"Source"})]})}),(0,s.jsxs)(n.tbody,{children:[(0,s.jsxs)(n.tr,{children:[(0,s.jsx)(n.td,{children:(0,s.jsx)(n.code,{children:"'positionPoints'"})}),(0,s.jsx)(n.td,{children:"Finishing position points"})]}),(0,s.jsxs)(n.tr,{children:[(0,s.jsx)(n.td,{children:(0,s.jsx)(n.code,{children:"'perWinPoints'"})}),(0,s.jsx)(n.td,{children:"Per-win points"})]}),(0,s.jsxs)(n.tr,{children:[(0,s.jsx)(n.td,{children:(0,s.jsx)(n.code,{children:"'bonusPoints'"})}),(0,s.jsx)(n.td,{children:"Champion/finalist bonus"})]}),(0,s.jsxs)(n.tr,{children:[(0,s.jsx)(n.td,{children:(0,s.jsx)(n.code,{children:"'qualityWinPoints'"})}),(0,s.jsx)(n.td,{children:"Quality win bonus"})]}),(0,s.jsxs)(n.tr,{children:[(0,s.jsx)(n.td,{children:(0,s.jsx)(n.code,{children:"'linePoints'"})}),(0,s.jsx)(n.td,{children:"Team line position points"})]}),(0,s.jsxs)(n.tr,{children:[(0,s.jsx)(n.td,{children:(0,s.jsx)(n.code,{children:"'points'"})}),(0,s.jsx)(n.td,{children:"Combined total (position + perWin + bonus)"})]})]})]}),"\n",(0,s.jsx)(n.h3,{id:"bestofcount",children:"bestOfCount"}),"\n",(0,s.jsxs)(n.ul,{children:["\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.code,{children:"0"})," \u2014 Count all results (no limit)"]}),"\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.code,{children:"N > 0"})," \u2014 Count only the best N results; remaining are dropped"]}),"\n"]}),"\n",(0,s.jsx)(n.h3,{id:"maxresultsperlevel",children:"maxResultsPerLevel"}),"\n",(0,s.jsx)(n.p,{children:"Limits how many results from a specific tournament level count toward the bucket:"}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-js",children:"maxResultsPerLevel: { 7: 2, 6: 3 }\n// At most 2 level-7 results and 3 level-6 results count\n"})}),"\n",(0,s.jsxs)(n.p,{children:["Results exceeding the level cap are moved to ",(0,s.jsx)(n.code,{children:"droppedResults"}),"."]}),"\n",(0,s.jsx)(n.h2,{id:"without-counting-buckets",children:"Without Counting Buckets"}),"\n",(0,s.jsxs)(n.p,{children:["When no ",(0,s.jsx)(n.code,{children:"countingBuckets"})," are defined, all awards are treated as a single group. The value for each award is ",(0,s.jsx)(n.code,{children:"points + qualityWinPoints"}),". Global ",(0,s.jsx)(n.code,{children:"bestOfCount"})," and ",(0,s.jsx)(n.code,{children:"maxResultsPerLevel"})," from ",(0,s.jsx)(n.code,{children:"aggregationRules"})," apply:"]}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-js",children:"aggregationRules: {\n  bestOfCount: 10,              // best 10 results overall\n  maxResultsPerLevel: { 7: 3 }, // max 3 level-7 results\n}\n"})}),"\n",(0,s.jsx)(n.h2,{id:"rolling-period",children:"Rolling Period"}),"\n",(0,s.jsx)(n.p,{children:"Filter awards by date to implement rolling ranking windows:"}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-js",children:"aggregationRules: {\n  rollingPeriodDays: 365, // only awards from the last 365 days\n}\n"})}),"\n",(0,s.jsxs)(n.p,{children:["Awards are filtered by their ",(0,s.jsx)(n.code,{children:"endDate"})," field. Awards without an ",(0,s.jsx)(n.code,{children:"endDate"})," are always included. The cutoff is calculated from ",(0,s.jsx)(n.code,{children:"asOfDate"}),":"]}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-js",children:"generateRankingList({\n  pointAwards: allAwards,\n  aggregationRules: { rollingPeriodDays: 365 },\n  asOfDate: '2025-12-31', // only awards ending after 2024-12-31\n});\n"})}),"\n",(0,s.jsx)(n.h2,{id:"category-filter",children:"Category Filter"}),"\n",(0,s.jsx)(n.p,{children:"Filter awards before aggregation by category, gender, or event type:"}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-js",children:"generateRankingList({\n  pointAwards: allAwards,\n  categoryFilter: {\n    ageCategoryCodes: ['U18'],\n    genders: ['MALE'],\n    eventTypes: ['SINGLES'],\n  },\n});\n"})}),"\n",(0,s.jsx)(n.h2,{id:"minimum-countable-results",children:"Minimum Countable Results"}),"\n",(0,s.jsx)(n.p,{children:"Flag entries that don't have enough results to be considered for official ranking:"}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-js",children:"aggregationRules: {\n  minCountableResults: 3,\n}\n"})}),"\n",(0,s.jsxs)(n.p,{children:["Entries below the threshold have ",(0,s.jsx)(n.code,{children:"meetsMinimum: false"})," but are still included in the output with their points and rank."]}),"\n",(0,s.jsx)(n.h2,{id:"tiebreakers",children:"Tiebreakers"}),"\n",(0,s.jsxs)(n.p,{children:["When two entries have the same ",(0,s.jsx)(n.code,{children:"totalPoints"}),", tiebreak criteria are applied in order:"]}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-js",children:"aggregationRules: {\n  tiebreakCriteria: ['highestSingleResult', 'mostCountingResults', 'mostWins'],\n}\n"})}),"\n",(0,s.jsxs)(n.table,{children:[(0,s.jsx)(n.thead,{children:(0,s.jsxs)(n.tr,{children:[(0,s.jsx)(n.th,{children:"Criterion"}),(0,s.jsx)(n.th,{children:"Resolution"})]})}),(0,s.jsxs)(n.tbody,{children:[(0,s.jsxs)(n.tr,{children:[(0,s.jsx)(n.td,{children:(0,s.jsx)(n.code,{children:"'highestSingleResult'"})}),(0,s.jsxs)(n.td,{children:["Highest individual ",(0,s.jsx)(n.code,{children:"points"})," value among counting results"]})]}),(0,s.jsxs)(n.tr,{children:[(0,s.jsx)(n.td,{children:(0,s.jsx)(n.code,{children:"'mostCountingResults'"})}),(0,s.jsx)(n.td,{children:"More counting results wins"})]}),(0,s.jsxs)(n.tr,{children:[(0,s.jsx)(n.td,{children:(0,s.jsx)(n.code,{children:"'mostWins'"})}),(0,s.jsxs)(n.td,{children:["More total ",(0,s.jsx)(n.code,{children:"winCount"})," across counting results wins"]})]})]})]}),"\n",(0,s.jsx)(n.p,{children:"Tied entries that remain unresolved after all criteria share the same rank."}),"\n",(0,s.jsx)(n.h2,{id:"rankinglistentry-output",children:"RankingListEntry Output"}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-ts",children:"{\n  personId: string;\n  totalPoints: number;\n  rank: number;                    // 1-based, tied for equal positions\n  meetsMinimum: boolean;           // false if below minCountableResults\n  countingResults: PointAward[];   // results that count toward total\n  droppedResults: PointAward[];    // results excluded by bestOfCount or level cap\n  bucketBreakdown?: [{             // present when countingBuckets are used\n    bucketName: string;\n    countingResults: PointAward[];\n    droppedResults: PointAward[];\n    bucketTotal: number;\n  }];\n}\n"})}),"\n",(0,s.jsx)(n.h2,{id:"per-participant-breakdown",children:"Per-Participant Breakdown"}),"\n",(0,s.jsxs)(n.p,{children:["Use ",(0,s.jsx)(n.code,{children:"getParticipantPoints"})," to inspect a single participant's counting/dropped breakdown:"]}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-js",children:"import { getParticipantPoints } from 'tods-competition-factory';\n\nconst { buckets, totalPoints } = getParticipantPoints({\n  pointAwards: allAwards,\n  personId: 'player-abc',\n  aggregationRules,\n});\n"})}),"\n",(0,s.jsx)(n.h2,{id:"related-documentation",children:"Related Documentation"}),"\n",(0,s.jsxs)(n.ul,{children:["\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.strong,{children:(0,s.jsx)(n.a,{href:"./scale-engine-overview",children:"Scale Engine Overview"})})," \u2014 Introduction and architecture"]}),"\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.strong,{children:(0,s.jsx)(n.a,{href:"./scale-engine-api",children:"Core API Reference"})})," \u2014 generateRankingList and getParticipantPoints API"]}),"\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.strong,{children:(0,s.jsx)(n.a,{href:"./ranking-points-pipeline",children:"Ranking Points Pipeline"})})," \u2014 How per-tournament points are computed"]}),"\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.strong,{children:(0,s.jsx)(n.a,{href:"./quality-win-points",children:"Quality Win Points"})})," \u2014 Quality win bonus system"]}),"\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.strong,{children:(0,s.jsx)(n.a,{href:"/docs/policies/rankingPolicy",children:"Ranking Policy"})})," \u2014 Full policy structure including aggregationRules"]}),"\n"]})]})}function u(e={}){const{wrapper:n}={...(0,r.R)(),...e.components};return n?(0,s.jsx)(n,{...e,children:(0,s.jsx)(d,{...e})}):d(e)}},8322(e,n,t){t.d(n,{R:()=>o,x:()=>l});var i=t(758);const s={},r=i.createContext(s);function o(e){const n=i.useContext(r);return i.useMemo(function(){return"function"==typeof e?e(n):{...n,...e}},[n,e])}function l(e){let n;return n=e.disableParentContext?"function"==typeof e.components?e.components(s):e.components||s:o(e.components),i.createElement(r.Provider,{value:n},e.children)}}}]);