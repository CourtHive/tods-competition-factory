"use strict";(globalThis.webpackChunkdocumentation=globalThis.webpackChunkdocumentation||[]).push([[5410],{77(e,n,i){i.r(n),i.d(n,{assets:()=>l,contentTitle:()=>d,default:()=>u,frontMatter:()=>r,metadata:()=>t,toc:()=>c});const t=JSON.parse('{"id":"apis/draw-engine-api","title":"drawEngine API","description":"// NOTEXPORTED: should it be?","source":"@site/docs/apis/draw-engine-api.md","sourceDirName":"apis","slug":"/apis/draw-engine-api","permalink":"/competition-factory/docs/apis/draw-engine-api","draft":false,"unlisted":false,"tags":[],"version":"current","frontMatter":{"title":"drawEngine API"}}');var s=i(6070),a=i(8322);const r={title:"drawEngine API"},d=void 0,l={},c=[{value:"addFinishingRounds",id:"addfinishingrounds",level:2},{value:"allStructureMatchUps",id:"allstructurematchups",level:2},{value:"assignSeed",id:"assignseed",level:2},{value:"clearDrawPosition",id:"cleardrawposition",level:2},{value:"generateQualifyingLink",id:"generatequalifyinglink",level:2},{value:"getDrawStructures",id:"getdrawstructures",level:2},{value:"getEliminationDrawSize",id:"geteliminationdrawsize",level:2},{value:"getMatchUpParticipantIds",id:"getmatchupparticipantids",level:2},{value:"getNextSeedBlock",id:"getnextseedblock",level:2},{value:"getNextUnfilledDrawPositions",id:"getnextunfilleddrawpositions",level:2},{value:"getSourceRounds",id:"getsourcerounds",level:2},{value:"initializeStructureSeedAssignments",id:"initializestructureseedassignments",level:2},{value:"matchUpDuration",id:"matchupduration",level:2},{value:"newDrawDefinition",id:"newdrawdefinition",level:2},{value:"resetMatchUpTimeItems",id:"resetmatchuptimeitems",level:2},{value:"setDrawDescription",id:"setdrawdescription",level:2},{value:"setStageAlternatesCount",id:"setstagealternatescount",level:2},{value:"setStageDrawSize",id:"setstagedrawsize",level:2},{value:"setStageQualifiersCount",id:"setstagequalifierscount",level:2},{value:"setStageWildcardsCount",id:"setstagewildcardscount",level:2},{value:"getStructureMatchUps",id:"getstructurematchups",level:2},{value:"validDrawPositions",id:"validdrawpositions",level:2}];function o(e){const n={code:"code",h2:"h2",hr:"hr",p:"p",pre:"pre",...(0,a.R)(),...e.components};return(0,s.jsxs)(s.Fragment,{children:[(0,s.jsx)(n.p,{children:"// NOTEXPORTED: should it be?"}),"\n",(0,s.jsx)(n.h2,{id:"addfinishingrounds",children:"addFinishingRounds"}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-js",children:"addFinishingRounds({\n  finishingPositionOffset = 0, // required for sub-structures; e.g. consolation fed from R32 would have { finishingPositionOffset: 16 } \u2014 see Finishing Positions concept\n  roundLimit, // for qualifying, offset the final round so that qualifyinground is finishingRound\n  matchUps, // required - matchUps belonging to a single structure\n});\n"})}),"\n",(0,s.jsx)(n.hr,{}),"\n",(0,s.jsx)(n.p,{children:"// NOTEXPORTED: should it be?"}),"\n",(0,s.jsx)(n.h2,{id:"allstructurematchups",children:"allStructureMatchUps"}),"\n",(0,s.jsx)(n.p,{children:"Returns all matchUps from a single structure within a draw."}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-js",children:"const { matchUps } = drawEngine.allStructureMatchUps({\n  structureId,\n  context, // optional context to be added into matchUps\n  inContext, // boolean - add context { drawId, structureId, participant, individualParticipants ... }\n  nextMatchUps, // optioanl - boolean - to include winnerTo and loserTo\n  matchUpFilters, // attribute filters\n  contextFilters, // filters based on context attributes\n  tournamentParticipants, // optional - provide an array of tournamentParticipants to add into matchUps\n  requireParticipants, // optional - require that participants be loaded into drawEngine or passed into method\n  tournamentAppliedPolicies, // any policies, such as privacy, to be applied to matchUps\n});\n"})}),"\n",(0,s.jsx)(n.hr,{}),"\n",(0,s.jsx)(n.p,{children:"// NOTEXPORTED: should it be?"}),"\n",(0,s.jsx)(n.h2,{id:"assignseed",children:"assignSeed"}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-js",children:"result = drawEngine.assignSeed({\n  structureId,\n  seedNumber,\n  seedValue, // optional - display value, e.g. '5-8'\n  participantId,\n});\n"})}),"\n",(0,s.jsx)(n.hr,{}),"\n",(0,s.jsx)(n.p,{children:"// NOTEXPORTED: should it be?"}),"\n",(0,s.jsx)(n.h2,{id:"cleardrawposition",children:"clearDrawPosition"}),"\n",(0,s.jsxs)(n.p,{children:["Removes a ",(0,s.jsx)(n.code,{children:"participantId"})," or ",(0,s.jsx)(n.code,{children:"bye"})," from a specified ",(0,s.jsx)(n.code,{children:"drawPosition"})," within a ",(0,s.jsx)(n.code,{children:"structure"})," or, optionally, removes a specified ",(0,s.jsx)(n.code,{children:"participantId"})," from a ",(0,s.jsx)(n.code,{children:"structure"}),"."]}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-js",children:"drawEngine.clearDrawPosition({\n  structureId,\n  drawPosition, // optional if participantId is provided\n  participantId, // optional if drawPosition is provided\n});\n"})}),"\n",(0,s.jsx)(n.hr,{}),"\n",(0,s.jsx)(n.p,{children:"// NOTEXPORTED: should it be?"}),"\n",(0,s.jsx)(n.h2,{id:"generatequalifyinglink",children:"generateQualifyingLink"}),"\n",(0,s.jsxs)(n.p,{children:["Generates and adds a ",(0,s.jsx)(n.code,{children:"link"})," to ",(0,s.jsx)(n.code,{children:"drawDefinition.links"}),"."]}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-js",children:"drawEngine.generateQualifyingLink({\n  qualifyingStructureId,\n  mainStructureId,\n});\n"})}),"\n",(0,s.jsx)(n.hr,{}),"\n",(0,s.jsx)(n.p,{children:"// NOTEXPORTED: should it be?"}),"\n",(0,s.jsx)(n.h2,{id:"getdrawstructures",children:"getDrawStructures"}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-js",children:"const { structures, stageStructures } = drawEngine.getDrawStructures({\n  withStageGrouping, // optinal, return structures collated by stage\n  stageSequences, // optional - specify stageSequences to include\n  stageSequence, // optional - filter by stageSequence\n  stages, // optional - specify stageSequences to include\n  stage, // optional - filter by stage\n});\n"})}),"\n",(0,s.jsx)(n.hr,{}),"\n",(0,s.jsx)(n.p,{children:"// NOTEXPORTED: should it be?"}),"\n",(0,s.jsx)(n.h2,{id:"geteliminationdrawsize",children:"getEliminationDrawSize"}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-js",children:"const { drawSize } = drawEngine.getEliminationDrawSize({ participantsCount });\n"})}),"\n",(0,s.jsx)(n.hr,{}),"\n",(0,s.jsx)(n.p,{children:"// NOTEXPORTED: should it be?"}),"\n",(0,s.jsx)(n.h2,{id:"getmatchupparticipantids",children:"getMatchUpParticipantIds"}),"\n",(0,s.jsx)(n.p,{children:"Convenience function; requires inContext matchUp."}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-js",children:"const { sideParticipantIds, individualParticipantIds } = drawEngine.getMatchUpParticipantIds({ matchUp });\n"})}),"\n",(0,s.jsx)(n.hr,{}),"\n",(0,s.jsx)(n.p,{children:"// NOTEXPORTED: should it be?"}),"\n",(0,s.jsx)(n.h2,{id:"getnextseedblock",children:"getNextSeedBlock"}),"\n",(0,s.jsx)(n.p,{children:"Returns the next block of drawPositions which are to be assigned seeded participants."}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-js",children:"const { nextSeedBlock, unplacedSeedParticipantIds, unplacedSeedNumbers, unfilledPositions, unplacedSeedAssignments } =\n  drawEngine.getNextSeedBlock({\n    structureId,\n  });\n"})}),"\n",(0,s.jsx)(n.hr,{}),"\n",(0,s.jsx)(n.p,{children:"// NOTEXPORTED: should it be?"}),"\n",(0,s.jsx)(n.h2,{id:"getnextunfilleddrawpositions",children:"getNextUnfilledDrawPositions"}),"\n",(0,s.jsx)(n.p,{children:"Returns the next valid block of unfilled drawPositions. Useful for UI to give visual indication of drawPostions valid to assign."}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-js",children:"const { nextUnfilledDrawPositions } = drawEngine.getNextUnfilledDrawPositions({\n  structureId,\n});\n"})}),"\n",(0,s.jsx)(n.hr,{}),"\n",(0,s.jsx)(n.p,{children:"// NOTEXPORTED: should it be?"}),"\n",(0,s.jsx)(n.h2,{id:"getsourcerounds",children:"getSourceRounds"}),"\n",(0,s.jsx)(n.p,{children:"Returns the round numbers for desired playoff positions."}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-js",children:"const {\n  sourceRounds, // all source rounds for playedOff positions and specified playoffPositions\n  playoffSourceRounds,\n  playedOffSourceRounds,\n  playoffPositionsReturned,\n} = drawEngine.getSourceRounds({\n  structureId,\n  playoffPositions: [3, 4],\n});\n"})}),"\n",(0,s.jsx)(n.hr,{}),"\n",(0,s.jsx)(n.p,{children:"// NOTEXPORTED: should it be?"}),"\n",(0,s.jsx)(n.h2,{id:"initializestructureseedassignments",children:"initializeStructureSeedAssignments"}),"\n",(0,s.jsxs)(n.p,{children:["Creates the ",(0,s.jsx)(n.code,{children:"seedAssignments"})," attribute for the specified structure."]}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-js",children:"drawEngine.initializeStructureSeedAssignments({\n  structureId,\n  seedsCount,\n});\n"})}),"\n",(0,s.jsx)(n.hr,{}),"\n",(0,s.jsx)(n.p,{children:"// NOTEXPORTED: should it be?"}),"\n",(0,s.jsx)(n.h2,{id:"matchupduration",children:"matchUpDuration"}),"\n",(0,s.jsx)(n.p,{children:"Calculates matchUp duration from START, STOP, RESUME, END timeItems."}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-js",children:'const {\n  milliseconds,\n  time, // string representation of elapsed time, e.g. "01:10:00" for an hour and 10 seconds\n  relevantTimeItems,\n} = drawEngine.matchUpDuration({\n  matchUp,\n});\n'})}),"\n",(0,s.jsx)(n.hr,{}),"\n",(0,s.jsx)(n.p,{children:"// NOTEXPORTED: should it be?"}),"\n",(0,s.jsx)(n.h2,{id:"newdrawdefinition",children:"newDrawDefinition"}),"\n",(0,s.jsx)(n.p,{children:"Creates a new drawDefinition within drawEngine state."}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-js",children:"const { drawId } = drawEngine.newDrawDefinition();\nconst { drawDefinition } = drawEngine.getState();\n"})}),"\n",(0,s.jsx)(n.hr,{}),"\n",(0,s.jsx)(n.p,{children:"// NOTEXPORTED: should it be?"}),"\n",(0,s.jsx)(n.h2,{id:"resetmatchuptimeitems",children:"resetMatchUpTimeItems"}),"\n",(0,s.jsx)(n.p,{children:"Removes all timeItems from a specified matchUp."}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-js",children:"drawEngine.resetMatchUpTimeItems({ matchUpId });\n"})}),"\n",(0,s.jsx)(n.hr,{}),"\n",(0,s.jsx)(n.p,{children:"// NOTEXPORTED: should it be?"}),"\n",(0,s.jsx)(n.h2,{id:"setdrawdescription",children:"setDrawDescription"}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-js",children:"const drawDescription = 'Draw Description';\ndrawEngine.setDrawDescription({ description: drawDescription });\n"})}),"\n",(0,s.jsx)(n.hr,{}),"\n",(0,s.jsx)(n.p,{children:"// NOTEXPORTED: should it be?"}),"\n",(0,s.jsx)(n.h2,{id:"setstagealternatescount",children:"setStageAlternatesCount"}),"\n",(0,s.jsx)(n.p,{children:"Sets an (optional) limit to the number of accepted alternates."}),"\n",(0,s.jsx)(n.p,{children:"Modifies the 'entryProfile' of a drawDefinition before the structures have been generated."}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-js",children:"drawEngine.setStageAlternatesCount({ alternatesCount: 8 });\n"})}),"\n",(0,s.jsx)(n.hr,{}),"\n",(0,s.jsx)(n.p,{children:"// NOTEXPORTED: should it be?"}),"\n",(0,s.jsx)(n.h2,{id:"setstagedrawsize",children:"setStageDrawSize"}),"\n",(0,s.jsx)(n.p,{children:"Modifies the 'entryProfile' of a drawDefinition before the structures have been generated."}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-js",children:"drawEngine.setStageDrawSize({ stage: QUALIFYING, stageSequence, drawSize: 8 });\ndrawEngine.setStageDrawSize({ stage: MAIN, drawSize: 16 });\n"})}),"\n",(0,s.jsx)(n.hr,{}),"\n",(0,s.jsx)(n.p,{children:"// NOTEXPORTED: should it be?"}),"\n",(0,s.jsx)(n.h2,{id:"setstagequalifierscount",children:"setStageQualifiersCount"}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-js",children:"drawEngine.setStageQualifiersCount({\n  qualifiersCount: 4,\n  stageSequence,\n  stage,\n});\n"})}),"\n",(0,s.jsx)(n.hr,{}),"\n",(0,s.jsx)(n.p,{children:"// NOTEXPORTED: should it be?"}),"\n",(0,s.jsx)(n.h2,{id:"setstagewildcardscount",children:"setStageWildcardsCount"}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-js",children:"drawEngine.setStageWildcardsCount({ stage, stageSequence, wildcardsCount: 2 });\n"})}),"\n",(0,s.jsx)(n.hr,{}),"\n",(0,s.jsx)(n.p,{children:"// NOTEXPORTED: should it be?"}),"\n",(0,s.jsx)(n.h2,{id:"getstructurematchups",children:"getStructureMatchUps"}),"\n",(0,s.jsx)(n.p,{children:"Returns categorized matchUps from a single structure."}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-js",children:"const { upcomingMatchUps, pendingMatchUps, completedMatchUps, abandonedMatchUps, byeMatchUps } =\n  drawEngine.getStructureMatchUps({\n    tournamentAppliedPolicies, // any policies, such as privacy, to be applied to matchUps\n    scheduleVisibilityFilters, // { visibilityThreshold: Date, eventIds, drawIds }\n    tournamentParticipants, // optional - provide an array of tournamentParticipants to add into matchUps\n    requireParticipants, // optional - require that participants be loaded into drawEngine or passed into method\n    contextFilters, // filters based on context attributes\n    matchUpFilters, // attribute filters\n    structureId,\n    nextMatchUps, // optioanl - boolean - to include winnerTo and loserTo\n    inContext, // boolean - add context { drawId, structureId, participant, individualParticipants ... }\n    context, // optional context to be added into matchUps\n  });\n"})}),"\n",(0,s.jsx)(n.hr,{}),"\n",(0,s.jsx)(n.p,{children:"// NOTEXPORTED: should it be?"}),"\n",(0,s.jsx)(n.h2,{id:"validdrawpositions",children:"validDrawPositions"}),"\n",(0,s.jsx)(n.p,{children:"Returns boolean indicating whether all matchUps have valid draw positions"}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-js",children:"drawEngine.validDrawPositions({ matchUps });\n"})}),"\n",(0,s.jsx)(n.hr,{})]})}function u(e={}){const{wrapper:n}={...(0,a.R)(),...e.components};return n?(0,s.jsx)(n,{...e,children:(0,s.jsx)(o,{...e})}):o(e)}},8322(e,n,i){i.d(n,{R:()=>r,x:()=>d});var t=i(758);const s={},a=t.createContext(s);function r(e){const n=t.useContext(a);return t.useMemo(function(){return"function"==typeof e?e(n):{...n,...e}},[n,e])}function d(e){let n;return n=e.disableParentContext?"function"==typeof e.components?e.components(s):e.components||s:r(e.components),t.createElement(a.Provider,{value:n},e.children)}}}]);