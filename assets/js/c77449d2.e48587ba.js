"use strict";(globalThis.webpackChunkdocumentation=globalThis.webpackChunkdocumentation||[]).push([[3447],{7303(n,e,i){i.r(e),i.d(e,{assets:()=>s,contentTitle:()=>l,default:()=>p,frontMatter:()=>c,metadata:()=>o,toc:()=>a});const o=JSON.parse('{"id":"governors/policy-governor","title":"Policy Governor","description":"The policyGovernor manages policy definitions that control tournament behavior, including seeding, scoring, avoidance rules, and position actions. Policies can be attached at tournament, event, or draw levels with hierarchical inheritance.","source":"@site/docs/governors/policy-governor.md","sourceDirName":"governors","slug":"/governors/policy-governor","permalink":"/tods-competition-factory/docs/governors/policy-governor","draft":false,"unlisted":false,"tags":[],"version":"current","frontMatter":{"title":"Policy Governor"},"sidebar":"docs","previous":{"title":"Participant Governor","permalink":"/tods-competition-factory/docs/governors/participant-governor"},"next":{"title":"Publishing Governor","permalink":"/tods-competition-factory/docs/governors/publishing-governor"}}');var t=i(6070),r=i(8439);const c={title:"Policy Governor"},l=void 0,s={},a=[{value:"attachPolicies",id:"attachpolicies",level:2},{value:"findPolicy",id:"findpolicy",level:2},{value:"removePolicy",id:"removepolicy",level:2}];function d(n){const e={a:"a",code:"code",h2:"h2",hr:"hr",li:"li",p:"p",pre:"pre",strong:"strong",ul:"ul",...(0,r.R)(),...n.components};return(0,t.jsxs)(t.Fragment,{children:[(0,t.jsx)(e.pre,{children:(0,t.jsx)(e.code,{className:"language-js",children:"import { policyGovernor } from 'tods-competition-factory';\n"})}),"\n",(0,t.jsxs)(e.p,{children:["The ",(0,t.jsx)(e.strong,{children:"policyGovernor"})," manages policy definitions that control tournament behavior, including seeding, scoring, avoidance rules, and position actions. Policies can be attached at tournament, event, or draw levels with hierarchical inheritance."]}),"\n",(0,t.jsx)(e.p,{children:(0,t.jsx)(e.strong,{children:"Policy Types Include:"})}),"\n",(0,t.jsxs)(e.ul,{children:["\n",(0,t.jsxs)(e.li,{children:[(0,t.jsx)(e.code,{children:"POLICY_TYPE_SEEDING"})," - Seeding placement rules"]}),"\n",(0,t.jsxs)(e.li,{children:[(0,t.jsx)(e.code,{children:"POLICY_TYPE_SCORING"})," - Scoring and completion requirements"]}),"\n",(0,t.jsxs)(e.li,{children:[(0,t.jsx)(e.code,{children:"POLICY_TYPE_AVOIDANCE"})," - Participant separation rules"]}),"\n",(0,t.jsxs)(e.li,{children:[(0,t.jsx)(e.code,{children:"POLICY_TYPE_POSITION_ACTIONS"})," - Available position actions"]}),"\n",(0,t.jsxs)(e.li,{children:[(0,t.jsx)(e.code,{children:"POLICY_TYPE_SCORING_USTA"})," - USTA-specific scoring rules"]}),"\n",(0,t.jsxs)(e.li,{children:[(0,t.jsx)(e.code,{children:"POLICY_TYPE_SCHEDULING"})," - Scheduling constraints"]}),"\n"]}),"\n",(0,t.jsxs)(e.p,{children:["See ",(0,t.jsx)(e.a,{href:"/docs/concepts/policies",children:"Policies Documentation"})," for detailed policy specifications."]}),"\n",(0,t.jsx)(e.hr,{}),"\n",(0,t.jsx)(e.h2,{id:"attachpolicies",children:"attachPolicies"}),"\n",(0,t.jsx)(e.p,{children:"Attaches policy definitions to tournaments, events, or draws. Policies control various aspects of tournament behavior and are inherited hierarchically (draw policies override event policies, which override tournament policies)."}),"\n",(0,t.jsxs)(e.p,{children:[(0,t.jsx)(e.strong,{children:"Purpose:"})," Apply competition rules and behavioral policies to tournament structures. Enables customization of seeding algorithms, scoring requirements, participant separation rules, and available administrative actions."]}),"\n",(0,t.jsx)(e.p,{children:(0,t.jsx)(e.strong,{children:"When to Use:"})}),"\n",(0,t.jsxs)(e.ul,{children:["\n",(0,t.jsx)(e.li,{children:"Setting tournament-wide default policies"}),"\n",(0,t.jsx)(e.li,{children:"Applying event-specific scoring rules"}),"\n",(0,t.jsx)(e.li,{children:"Configuring draw-level seeding policies"}),"\n",(0,t.jsx)(e.li,{children:"Establishing avoidance policies (e.g., same country/club)"}),"\n",(0,t.jsx)(e.li,{children:"Controlling available position actions for tournament staff"}),"\n",(0,t.jsx)(e.li,{children:"Applying federation-specific rules (ITF, USTA, etc.)"}),"\n"]}),"\n",(0,t.jsx)(e.p,{children:(0,t.jsx)(e.strong,{children:"Parameters:"})}),"\n",(0,t.jsx)(e.pre,{children:(0,t.jsx)(e.code,{className:"language-ts",children:"{\n  policyDefinitions: PolicyDefinitions;   // Required - policies to attach\n  tournamentRecords?: TournamentRecords;  // Apply to multiple tournaments\n  tournamentRecord?: Tournament;          // Apply to single tournament\n  event?: Event;                          // Apply to specific event\n  drawDefinition?: DrawDefinition;        // Apply to specific draw\n  tournamentId?: string;                  // Tournament ID for notifications\n  eventId?: string;                       // Event ID (alternative to event object)\n  drawId?: string;                        // Draw ID (alternative to drawDefinition object)\n  allowReplacement?: boolean;             // Allow replacing existing policies (default: false)\n}\n\n// PolicyDefinitions structure\ntype PolicyDefinitions = {\n  [policyType: string]: {\n    policyName?: string;                  // Optional policy name/description\n    [key: string]: any;                   // Policy-specific configuration\n  };\n};\n"})}),"\n",(0,t.jsx)(e.p,{children:(0,t.jsx)(e.strong,{children:"Returns:"})}),"\n",(0,t.jsx)(e.pre,{children:(0,t.jsx)(e.code,{className:"language-ts",children:"{\n  success: boolean;\n  applied?: string[];                     // Array of applied policy types\n  error?: ErrorType;                      // EXISTING_POLICY_TYPE, INVALID_VALUES, etc.\n}\n"})}),"\n",(0,t.jsx)(e.p,{children:(0,t.jsx)(e.strong,{children:"Examples:"})}),"\n",(0,t.jsx)(e.pre,{children:(0,t.jsx)(e.code,{className:"language-js",children:"import { tournamentEngine } from 'tods-competition-factory';\nimport { POLICY_TYPE_SEEDING, POLICY_TYPE_SCORING } from 'tods-competition-factory';\n\ntournamentEngine.setState(tournamentRecord);\n\n// Attach tournament-level policy\nconst seedingPolicy = {\n  [POLICY_TYPE_SEEDING]: {\n    policyName: 'ITF Seeding',\n    seedingProfile: 'ITF',\n  },\n};\n\nlet result = tournamentEngine.attachPolicies({\n  policyDefinitions: seedingPolicy,\n});\nconsole.log(result.applied); // ['seeding']\n\n// Attach event-specific policy\nconst scoringPolicy = {\n  [POLICY_TYPE_SCORING]: {\n    policyName: 'USTA Scoring',\n    requireParticipantsForScoring: true, // Require participants present\n    requireAllPositionsAssigned: false,\n  },\n};\n\nresult = tournamentEngine.attachPolicies({\n  policyDefinitions: scoringPolicy,\n  eventId: 'event-1',\n});\n\n// Attach draw-specific policy (overrides event/tournament policies)\nconst avoidancePolicy = {\n  [POLICY_TYPE_AVOIDANCE]: {\n    policyName: 'Country Avoidance',\n    policyAttributes: [\n      {\n        key: 'person.nationalityCode', // Path to attribute to check\n        value: true, // Avoid matching values\n      },\n    ],\n  },\n};\n\nresult = tournamentEngine.attachPolicies({\n  policyDefinitions: avoidancePolicy,\n  drawId: 'draw-1',\n});\n\n// Replace existing policy\nresult = tournamentEngine.attachPolicies({\n  policyDefinitions: seedingPolicy,\n  allowReplacement: true, // Allows updating existing policy\n});\n\n// Attach multiple policies at once\nconst multiplePolicies = {\n  [POLICY_TYPE_SEEDING]: {\n    policyName: 'Custom Seeding',\n    seedingProfile: 'WATERFALL',\n  },\n  [POLICY_TYPE_SCORING]: {\n    policyName: 'Custom Scoring',\n    requireParticipantsForScoring: false,\n  },\n};\n\nresult = tournamentEngine.attachPolicies({\n  policyDefinitions: multiplePolicies,\n});\nconsole.log(result.applied); // ['seeding', 'scoring']\n\n// Apply to all tournaments in competition\nimport { competitionEngine } from 'tods-competition-factory';\n\ncompetitionEngine.setState(tournamentRecords);\nresult = competitionEngine.attachPolicies({\n  tournamentRecords,\n  policyDefinitions: seedingPolicy,\n});\n\n// Error handling\nresult = tournamentEngine.attachPolicies({\n  policyDefinitions: seedingPolicy, // Already attached\n});\nconsole.log(result.error); // EXISTING_POLICY_TYPE\n\nresult = tournamentEngine.attachPolicies({\n  policyDefinitions: {\n    [POLICY_TYPE_SEEDING]: { policyName: 'Invalid' }, // Missing required attributes\n  },\n});\nconsole.log(result.error); // INVALID_VALUES\n"})}),"\n",(0,t.jsx)(e.p,{children:(0,t.jsx)(e.strong,{children:"Notes:"})}),"\n",(0,t.jsxs)(e.ul,{children:["\n",(0,t.jsx)(e.li,{children:"Policies are stored in APPLIED_POLICIES extension"}),"\n",(0,t.jsx)(e.li,{children:"Lower-level policies override higher-level (draw > event > tournament)"}),"\n",(0,t.jsxs)(e.li,{children:[(0,t.jsx)(e.code,{children:"allowReplacement: true"})," required to update existing policy of same type"]}),"\n",(0,t.jsxs)(e.li,{children:["Policy definitions must include at least one attribute beyond ",(0,t.jsx)(e.code,{children:"policyName"})]}),"\n",(0,t.jsx)(e.li,{children:"Invalid policy structures return INVALID_VALUES error"}),"\n",(0,t.jsxs)(e.li,{children:["Attempting to attach existing policy without ",(0,t.jsx)(e.code,{children:"allowReplacement"})," returns EXISTING_POLICY_TYPE"]}),"\n",(0,t.jsx)(e.li,{children:"Policy changes at draw level trigger draw modification notifications"}),"\n",(0,t.jsxs)(e.li,{children:["See ",(0,t.jsx)(e.a,{href:"/docs/concepts/policies",children:"Policy Documentation"})," for specific policy schemas"]}),"\n",(0,t.jsxs)(e.li,{children:["Common policy types defined in ",(0,t.jsx)(e.code,{children:"@Constants/policyConstants"})]}),"\n"]}),"\n",(0,t.jsx)(e.hr,{}),"\n",(0,t.jsx)(e.h2,{id:"findpolicy",children:"findPolicy"}),"\n",(0,t.jsx)(e.p,{children:"Finds and returns a specific policy type from the hierarchical policy structure (draw \u2192 event \u2192 tournament), returning the most specific policy found."}),"\n",(0,t.jsxs)(e.p,{children:[(0,t.jsx)(e.strong,{children:"Purpose:"})," Retrieve active policy configuration for a specific policy type, respecting the hierarchical override system. Essential for understanding which rules are currently in effect."]}),"\n",(0,t.jsx)(e.p,{children:(0,t.jsx)(e.strong,{children:"When to Use:"})}),"\n",(0,t.jsxs)(e.ul,{children:["\n",(0,t.jsx)(e.li,{children:"Checking active policy configuration before operations"}),"\n",(0,t.jsx)(e.li,{children:"Validating policy settings for specific contexts"}),"\n",(0,t.jsx)(e.li,{children:"Debugging policy inheritance and overrides"}),"\n",(0,t.jsx)(e.li,{children:"Building UI that displays current policy settings"}),"\n",(0,t.jsx)(e.li,{children:"Verifying policy application in tests"}),"\n"]}),"\n",(0,t.jsx)(e.p,{children:(0,t.jsx)(e.strong,{children:"Parameters:"})}),"\n",(0,t.jsx)(e.pre,{children:(0,t.jsx)(e.code,{className:"language-ts",children:"{\n  policyType: string;                     // Required - type of policy to find\n  tournamentRecord?: Tournament;          // Tournament to search\n  tournamentId?: string;                  // Tournament ID (alternative)\n  event?: Event;                          // Event to search\n  eventId?: string;                       // Event ID (alternative)\n  drawDefinition?: DrawDefinition;        // Draw to search\n  drawId?: string;                        // Draw ID (alternative)\n  structure?: Structure;                  // Structure to search\n}\n"})}),"\n",(0,t.jsx)(e.p,{children:(0,t.jsx)(e.strong,{children:"Returns:"})}),"\n",(0,t.jsx)(e.pre,{children:(0,t.jsx)(e.code,{className:"language-ts",children:"{\n  policy?: PolicyDefinition;              // Found policy object\n  error?: ErrorType;                      // POLICY_NOT_FOUND if not found\n}\n"})}),"\n",(0,t.jsxs)(e.p,{children:[(0,t.jsx)(e.strong,{children:"Hierarchy Resolution:"}),"\nThe method searches in order: structure \u2192 draw \u2192 event \u2192 tournament, returning the first match found (most specific policy wins)."]}),"\n",(0,t.jsx)(e.p,{children:(0,t.jsx)(e.strong,{children:"Examples:"})}),"\n",(0,t.jsx)(e.pre,{children:(0,t.jsx)(e.code,{className:"language-js",children:"import { tournamentEngine } from 'tods-competition-factory';\nimport { POLICY_TYPE_SEEDING } from 'tods-competition-factory';\n\ntournamentEngine.setState(tournamentRecord);\n\n// Find tournament-level policy\nconst { policy } = tournamentEngine.findPolicy({\n  policyType: POLICY_TYPE_SEEDING,\n});\n\nconsole.log(policy);\n// {\n//   policyName: 'ITF Seeding',\n//   seedingProfile: 'ITF'\n// }\n\n// Find event-specific policy (may override tournament policy)\nconst { policy } = tournamentEngine.findPolicy({\n  policyType: POLICY_TYPE_SCORING,\n  eventId: 'event-1',\n});\n\n// Find draw-specific policy (highest priority)\nconst { policy } = tournamentEngine.findPolicy({\n  policyType: POLICY_TYPE_AVOIDANCE,\n  eventId: 'event-1',\n  drawId: 'draw-1',\n});\n\n// Policy not found\nconst { policy, error } = tournamentEngine.findPolicy({\n  policyType: 'NONEXISTENT_POLICY',\n});\nconsole.log(error); // POLICY_NOT_FOUND\n\n// Check for policy existence before using\nconst { policy: scoringPolicy } = tournamentEngine.findPolicy({\n  policyType: POLICY_TYPE_SCORING,\n  drawId: 'draw-1',\n});\n\nif (scoringPolicy) {\n  console.log(`Scoring policy active: ${scoringPolicy.policyName}`);\n  if (scoringPolicy.requireParticipantsForScoring) {\n    console.log('Participants must be present to record scores');\n  }\n}\n\n// Hierarchical override example\n// Tournament has seeding policy A\ntournamentEngine.attachPolicies({\n  policyDefinitions: {\n    [POLICY_TYPE_SEEDING]: { policyName: 'Tournament Default', seedingProfile: 'WATERFALL' },\n  },\n});\n\n// Event has seeding policy B\ntournamentEngine.attachPolicies({\n  policyDefinitions: {\n    [POLICY_TYPE_SEEDING]: { policyName: 'Event Override', seedingProfile: 'ITF' },\n  },\n  eventId: 'event-1',\n});\n\n// Find policy at event level returns event policy (not tournament)\nconst { policy } = tournamentEngine.findPolicy({\n  policyType: POLICY_TYPE_SEEDING,\n  eventId: 'event-1',\n});\nconsole.log(policy.policyName); // \"Event Override\"\n\n// Find policy at tournament level returns tournament policy\nconst { policy: tournamentPolicy } = tournamentEngine.findPolicy({\n  policyType: POLICY_TYPE_SEEDING,\n});\nconsole.log(tournamentPolicy.policyName); // \"Tournament Default\"\n"})}),"\n",(0,t.jsx)(e.p,{children:(0,t.jsx)(e.strong,{children:"Notes:"})}),"\n",(0,t.jsxs)(e.ul,{children:["\n",(0,t.jsx)(e.li,{children:"Returns the most specific policy (draw overrides event, event overrides tournament)"}),"\n",(0,t.jsx)(e.li,{children:"Searches upward in hierarchy: structure \u2192 draw \u2192 event \u2192 tournament"}),"\n",(0,t.jsx)(e.li,{children:"Returns POLICY_NOT_FOUND error if policy type not found at any level"}),"\n",(0,t.jsxs)(e.li,{children:["Use ",(0,t.jsx)(e.code,{children:"getAppliedPolicies()"})," to retrieve all policies at a specific level"]}),"\n",(0,t.jsx)(e.li,{children:"Policy object is deep-copied to prevent external modifications"}),"\n",(0,t.jsx)(e.li,{children:"Useful for pre-flight checks before operations that depend on policies"}),"\n",(0,t.jsx)(e.li,{children:"Does not search across multiple tournaments (tournament-scoped)"}),"\n"]}),"\n",(0,t.jsx)(e.hr,{}),"\n",(0,t.jsx)(e.h2,{id:"removepolicy",children:"removePolicy"}),"\n",(0,t.jsx)(e.p,{children:"Removes a specific policy type from tournaments, events, or draws. If removing the last policy from an element, the entire APPLIED_POLICIES extension is removed."}),"\n",(0,t.jsxs)(e.p,{children:[(0,t.jsx)(e.strong,{children:"Purpose:"})," Remove policy definitions to restore default behavior or remove outdated policies. Allows selective policy removal while preserving other policies."]}),"\n",(0,t.jsx)(e.p,{children:(0,t.jsx)(e.strong,{children:"When to Use:"})}),"\n",(0,t.jsxs)(e.ul,{children:["\n",(0,t.jsx)(e.li,{children:"Removing event-specific policies to fall back to tournament defaults"}),"\n",(0,t.jsx)(e.li,{children:"Cleaning up test policies after tests"}),"\n",(0,t.jsx)(e.li,{children:"Reverting to system defaults"}),"\n",(0,t.jsx)(e.li,{children:"Removing outdated or incorrect policies"}),"\n",(0,t.jsx)(e.li,{children:"Preparing elements for new policy attachments"}),"\n",(0,t.jsx)(e.li,{children:"Bulk policy removal across multiple tournaments"}),"\n"]}),"\n",(0,t.jsx)(e.p,{children:(0,t.jsx)(e.strong,{children:"Parameters:"})}),"\n",(0,t.jsx)(e.pre,{children:(0,t.jsx)(e.code,{className:"language-ts",children:"{\n  policyType: string;                     // Required - type of policy to remove\n  tournamentRecords?: TournamentRecords;  // Remove from multiple tournaments\n  tournamentRecord?: Tournament;          // Remove from single tournament\n  event?: Event;                          // Remove from specific event\n  eventId?: string;                       // Event ID (alternative)\n  drawDefinition?: DrawDefinition;        // Remove from specific draw\n  drawId?: string;                        // Draw ID (alternative)\n  tournamentId?: string;                  // Tournament ID for context\n}\n"})}),"\n",(0,t.jsx)(e.p,{children:(0,t.jsx)(e.strong,{children:"Returns:"})}),"\n",(0,t.jsx)(e.pre,{children:(0,t.jsx)(e.code,{className:"language-ts",children:"{\n  success: boolean;\n  error?: ErrorType;                      // POLICY_NOT_FOUND if policy doesn't exist\n}\n"})}),"\n",(0,t.jsx)(e.p,{children:(0,t.jsx)(e.strong,{children:"Examples:"})}),"\n",(0,t.jsx)(e.pre,{children:(0,t.jsx)(e.code,{className:"language-js",children:"import { tournamentEngine } from 'tods-competition-factory';\nimport { POLICY_TYPE_SEEDING, POLICY_TYPE_SCORING } from 'tods-competition-factory';\n\ntournamentEngine.setState(tournamentRecord);\n\n// Remove policy from tournament\nlet result = tournamentEngine.removePolicy({\n  policyType: POLICY_TYPE_SEEDING,\n});\nconsole.log(result.success); // true\n\n// Remove policy from event\nresult = tournamentEngine.removePolicy({\n  policyType: POLICY_TYPE_SCORING,\n  eventId: 'event-1',\n});\n\n// Remove policy from draw\nresult = tournamentEngine.removePolicy({\n  policyType: POLICY_TYPE_AVOIDANCE,\n  drawId: 'draw-1',\n});\n\n// Error when policy doesn't exist\nresult = tournamentEngine.removePolicy({\n  policyType: 'NONEXISTENT_POLICY',\n});\nconsole.log(result.error); // POLICY_NOT_FOUND\n\n// Remove from all tournaments in competition\nimport { competitionEngine } from 'tods-competition-factory';\n\ncompetitionEngine.setState(tournamentRecords);\nresult = competitionEngine.removePolicy({\n  tournamentRecords,\n  policyType: POLICY_TYPE_SEEDING,\n});\n\n// Hierarchical removal - remove event override, fall back to tournament policy\n// 1. Attach tournament policy\ntournamentEngine.attachPolicies({\n  policyDefinitions: {\n    [POLICY_TYPE_SEEDING]: { policyName: 'Tournament Default', seedingProfile: 'WATERFALL' },\n  },\n});\n\n// 2. Attach event override\ntournamentEngine.attachPolicies({\n  policyDefinitions: {\n    [POLICY_TYPE_SEEDING]: { policyName: 'Event Override', seedingProfile: 'ITF' },\n  },\n  eventId: 'event-1',\n});\n\n// 3. Remove event override - tournament policy now applies to event\ntournamentEngine.removePolicy({\n  policyType: POLICY_TYPE_SEEDING,\n  eventId: 'event-1',\n});\n\n// Now findPolicy returns tournament-level policy\nconst { policy } = tournamentEngine.findPolicy({\n  policyType: POLICY_TYPE_SEEDING,\n  eventId: 'event-1',\n});\nconsole.log(policy.policyName); // \"Tournament Default\"\n\n// Cleanup pattern for tests\nafterEach(() => {\n  tournamentEngine.removePolicy({ policyType: POLICY_TYPE_SEEDING });\n  tournamentEngine.removePolicy({ policyType: POLICY_TYPE_SCORING });\n  tournamentEngine.removePolicy({ policyType: POLICY_TYPE_AVOIDANCE });\n});\n\n// Remove all policies from event (one at a time)\nconst policyTypes = [POLICY_TYPE_SEEDING, POLICY_TYPE_SCORING, POLICY_TYPE_AVOIDANCE, POLICY_TYPE_POSITION_ACTIONS];\n\npolicyTypes.forEach((policyType) => {\n  const result = tournamentEngine.removePolicy({\n    policyType,\n    eventId: 'event-1',\n  });\n  if (result.success) {\n    console.log(`Removed ${policyType}`);\n  }\n});\n"})}),"\n",(0,t.jsx)(e.p,{children:(0,t.jsx)(e.strong,{children:"Notes:"})}),"\n",(0,t.jsxs)(e.ul,{children:["\n",(0,t.jsx)(e.li,{children:"Removes policy only from specified level (does not cascade)"}),"\n",(0,t.jsx)(e.li,{children:"If last policy removed, entire APPLIED_POLICIES extension is deleted"}),"\n",(0,t.jsx)(e.li,{children:"Returns POLICY_NOT_FOUND if policy type doesn't exist at specified level"}),"\n",(0,t.jsx)(e.li,{children:"Does not affect policies at other levels (e.g., removing from event doesn't affect tournament policy)"}),"\n",(0,t.jsx)(e.li,{children:"Removing event policy causes fallback to tournament policy (if exists)"}),"\n",(0,t.jsx)(e.li,{children:"Removing draw policy causes fallback to event/tournament policy"}),"\n",(0,t.jsxs)(e.li,{children:["Use ",(0,t.jsx)(e.code,{children:"attachPolicies"})," with ",(0,t.jsx)(e.code,{children:"allowReplacement: true"})," to replace rather than remove+add"]}),"\n",(0,t.jsx)(e.li,{children:"No undo functionality - policies must be re-attached if removed in error"}),"\n",(0,t.jsx)(e.li,{children:"Tournament ID parameter used for context but doesn't limit scope"}),"\n",(0,t.jsx)(e.li,{children:"Safe to call on non-existent policies in cleanup code (check return value)"}),"\n"]}),"\n",(0,t.jsx)(e.hr,{})]})}function p(n={}){const{wrapper:e}={...(0,r.R)(),...n.components};return e?(0,t.jsx)(e,{...n,children:(0,t.jsx)(d,{...n})}):d(n)}},8439(n,e,i){i.d(e,{R:()=>c,x:()=>l});var o=i(758);const t={},r=o.createContext(t);function c(n){const e=o.useContext(r);return o.useMemo(function(){return"function"==typeof n?n(e):{...e,...n}},[e,n])}function l(n){let e;return e=n.disableParentContext?"function"==typeof n.components?n.components(t):n.components||t:c(n.components),o.createElement(r.Provider,{value:e},n.children)}}}]);