"use strict";(self.webpackChunkdocumentation=self.webpackChunkdocumentation||[]).push([[2228],{4137:(e,t,n)=>{n.d(t,{Zo:()=>p,kt:()=>h});var a=n(7294);function i(e,t,n){return t in e?Object.defineProperty(e,t,{value:n,enumerable:!0,configurable:!0,writable:!0}):e[t]=n,e}function r(e,t){var n=Object.keys(e);if(Object.getOwnPropertySymbols){var a=Object.getOwnPropertySymbols(e);t&&(a=a.filter((function(t){return Object.getOwnPropertyDescriptor(e,t).enumerable}))),n.push.apply(n,a)}return n}function o(e){for(var t=1;t<arguments.length;t++){var n=null!=arguments[t]?arguments[t]:{};t%2?r(Object(n),!0).forEach((function(t){i(e,t,n[t])})):Object.getOwnPropertyDescriptors?Object.defineProperties(e,Object.getOwnPropertyDescriptors(n)):r(Object(n)).forEach((function(t){Object.defineProperty(e,t,Object.getOwnPropertyDescriptor(n,t))}))}return e}function s(e,t){if(null==e)return{};var n,a,i=function(e,t){if(null==e)return{};var n,a,i={},r=Object.keys(e);for(a=0;a<r.length;a++)n=r[a],t.indexOf(n)>=0||(i[n]=e[n]);return i}(e,t);if(Object.getOwnPropertySymbols){var r=Object.getOwnPropertySymbols(e);for(a=0;a<r.length;a++)n=r[a],t.indexOf(n)>=0||Object.prototype.propertyIsEnumerable.call(e,n)&&(i[n]=e[n])}return i}var l=a.createContext({}),d=function(e){var t=a.useContext(l),n=t;return e&&(n="function"==typeof e?e(t):o(o({},t),e)),n},p=function(e){var t=d(e.components);return a.createElement(l.Provider,{value:t},e.children)},u={inlineCode:"code",wrapper:function(e){var t=e.children;return a.createElement(a.Fragment,{},t)}},c=a.forwardRef((function(e,t){var n=e.components,i=e.mdxType,r=e.originalType,l=e.parentName,p=s(e,["components","mdxType","originalType","parentName"]),c=d(n),h=i,m=c["".concat(l,".").concat(h)]||c[h]||u[h]||r;return n?a.createElement(m,o(o({ref:t},p),{},{components:n})):a.createElement(m,o({ref:t},p))}));function h(e,t){var n=arguments,i=t&&t.mdxType;if("string"==typeof e||i){var r=n.length,o=new Array(r);o[0]=c;var s={};for(var l in t)hasOwnProperty.call(t,l)&&(s[l]=t[l]);s.originalType=e,s.mdxType="string"==typeof e?e:i,o[1]=s;for(var d=2;d<r;d++)o[d]=n[d];return a.createElement.apply(null,o)}return a.createElement.apply(null,n)}c.displayName="MDXCreateElement"},2079:(e,t,n)=>{n.r(t),n.d(t,{assets:()=>l,contentTitle:()=>o,default:()=>u,frontMatter:()=>r,metadata:()=>s,toc:()=>d});var a=n(7462),i=(n(7294),n(4137));const r={title:"drawEngine API"},o=void 0,s={unversionedId:"apis/draw-engine-api",id:"apis/draw-engine-api",title:"drawEngine API",description:"All _drawEngine_ methods which make a mutation return either { success: true } or { error }",source:"@site/docs/apis/draw-engine-api.md",sourceDirName:"apis",slug:"/apis/draw-engine-api",permalink:"/tods-competition-factory/docs/apis/draw-engine-api",draft:!1,tags:[],version:"current",frontMatter:{title:"drawEngine API"},sidebar:"docs",previous:{title:"Draw Engine",permalink:"/tods-competition-factory/docs/engines/draw-engine-overview"},next:{title:"MatchUp Engine",permalink:"/tods-competition-factory/docs/engines/matchup-engine-overview"}},l={},d=[{value:"addDrawEntries",id:"adddrawentries",level:2},{value:"addDrawEntry",id:"adddrawentry",level:2},{value:"addFinishingRounds",id:"addfinishingrounds",level:2},{value:"addMatchUpEndTime",id:"addmatchupendtime",level:2},{value:"addMatchUpOfficial",id:"addmatchupofficial",level:2},{value:"addMatchUpResumeTime",id:"addmatchupresumetime",level:2},{value:"addMatchUpScheduledDate",id:"addmatchupscheduleddate",level:2},{value:"addMatchUpScheduledTime",id:"addmatchupscheduledtime",level:2},{value:"addMatchUpScheduleItems",id:"addmatchupscheduleitems",level:2},{value:"addMatchUpStartTime",id:"addmatchupstarttime",level:2},{value:"addMatchUpStopTime",id:"addmatchupstoptime",level:2},{value:"addPlayoffStructures",id:"addplayoffstructures",level:2},{value:"addMatchUpTimeItem",id:"addmatchuptimeitem",level:2},{value:"addVoluntaryConsolationStage",id:"addvoluntaryconsolationstage",level:2},{value:"addVoluntaryConsolationStructure",id:"addvoluntaryconsolationstructure",level:3},{value:"allDrawMatchUps",id:"alldrawmatchups",level:2},{value:"allStructureMatchUps",id:"allstructurematchups",level:2},{value:"assignDrawPosition",id:"assigndrawposition",level:2},{value:"assignDrawPositionBye",id:"assigndrawpositionbye",level:2},{value:"assignSeed",id:"assignseed",level:2},{value:"attachPlayoffStructures",id:"attachplayoffstructures",level:2},{value:"attachPolicies",id:"attachpolicies",level:2},{value:"automatedPositioning",id:"automatedpositioning",level:2},{value:"checkInParticipant",id:"checkinparticipant",level:2},{value:"checkOutParticipant",id:"checkoutparticipant",level:2},{value:"clearDrawPosition",id:"cleardrawposition",level:2},{value:"deleteAdHocMatchUps",id:"deleteadhocmatchups",level:2},{value:"devContext",id:"devcontext",level:2},{value:"drawMatchUps",id:"drawmatchups",level:2},{value:"drawMatic",id:"drawmatic",level:2},{value:"disableTiaAutoCalc",id:"disabletiaautocalc",level:2},{value:"enableTiaAutoCalc",id:"enabletiaautocalc",level:2},{value:"findMatchUp",id:"findmatchup",level:2},{value:"generateAdHocMatchUps",id:"generateadhocmatchups",level:2},{value:"generateAndPopulatePlayoffStructures",id:"generateandpopulateplayoffstructures",level:2},{value:"generateDrawTypeAndModifyDrawDefinition",id:"generatedrawtypeandmodifydrawdefinition",level:2},{value:"generateQualifyingLink",id:"generatequalifyinglink",level:2},{value:"getAvailablePlayoffProfiles",id:"getavailableplayoffprofiles",level:2},{value:"getCheckedInParticipantIds",id:"getcheckedinparticipantids",level:2},{value:"getDrawStructures",id:"getdrawstructures",level:2},{value:"getEliminationDrawSize",id:"geteliminationdrawsize",level:2},{value:"getMatchUpContextIds",id:"getmatchupcontextids",level:2},{value:"getMatchUpParticipantIds",id:"getmatchupparticipantids",level:2},{value:"getMatchUpScheduleDetails",id:"getmatchupscheduledetails",level:2},{value:"getNextSeedBlock",id:"getnextseedblock",level:2},{value:"getNextUnfilledDrawPositions",id:"getnextunfilleddrawpositions",level:2},{value:"getParticipantIdFinishingPositions",id:"getparticipantidfinishingpositions",level:2},{value:"getPositionsPlayedOff",id:"getpositionsplayedoff",level:2},{value:"getRoundMatchUps",id:"getroundmatchups",level:2},{value:"getSeedingThresholds",id:"getseedingthresholds",level:2},{value:"getSourceRounds",id:"getsourcerounds",level:2},{value:"getStructureSeedAssignments",id:"getstructureseedassignments",level:2},{value:"getState",id:"getstate",level:2},{value:"getValidGroupSizes",id:"getvalidgroupsizes",level:2},{value:"initializeStructureSeedAssignments",id:"initializestructureseedassignments",level:2},{value:"isCompletedStructure",id:"iscompletedstructure",level:2},{value:"matchUpActions",id:"matchupactions",level:2},{value:"matchUpDuration",id:"matchupduration",level:2},{value:"newDrawDefinition",id:"newdrawdefinition",level:2},{value:"positionActions",id:"positionactions",level:2},{value:"removeEntry",id:"removeentry",level:2},{value:"removeStructure",id:"removestructure",level:2},{value:"renameStructures",id:"renamestructures",level:2},{value:"reset",id:"reset",level:2},{value:"resetMatchUpTimeItems",id:"resetmatchuptimeitems",level:2},{value:"resolveDrawPositions",id:"resolvedrawpositions",level:2},{value:"setDrawDescription",id:"setdrawdescription",level:2},{value:"setMatchUpFormat",id:"setmatchupformat",level:2},{value:"setMatchUpStatus",id:"setmatchupstatus",level:2},{value:"setOrderOfFinish",id:"setorderoffinish",level:2},{value:"Validation",id:"validation",level:3},{value:"setParticipants",id:"setparticipants",level:2},{value:"setStageAlternatesCount",id:"setstagealternatescount",level:2},{value:"setStageDrawSize",id:"setstagedrawsize",level:2},{value:"setStageQualifiersCount",id:"setstagequalifierscount",level:2},{value:"setStageWildcardsCount",id:"setstagewildcardscount",level:2},{value:"setState",id:"setstate",level:2},{value:"setSubOrder",id:"setsuborder",level:2},{value:"swapDrawPositionAssignments",id:"swapdrawpositionassignments",level:2},{value:"getStructureMatchUps",id:"getstructurematchups",level:2},{value:"validDrawPositions",id:"validdrawpositions",level:2},{value:"version",id:"version",level:2}],p={toc:d};function u(e){let{components:t,...n}=e;return(0,i.kt)("wrapper",(0,a.Z)({},p,n,{components:t,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"All ",(0,i.kt)("strong",{parentName:"p"},(0,i.kt)("em",{parentName:"strong"},"drawEngine"))," methods which make a mutation return either ",(0,i.kt)("inlineCode",{parentName:"p"},"{ success: true }")," or ",(0,i.kt)("inlineCode",{parentName:"p"},"{ error }")),(0,i.kt)("hr",null),(0,i.kt)("h2",{id:"adddrawentries"},"addDrawEntries"),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-js"},"drawEngine.addDrawEntries({\n  participantIds, // an array of participantIds, should all be of the same participantType\n  entryStatus, // optional - defaults to DIRECT_ACCEPTANCE\n  stage, // optional - stage into which participantIds have been entered; defaults to MAIN\n  stageSequence, // optional - applies to qualifying\n  autoEntryPositions, // optional - keeps entries ordered by entryStage/entryStatus and auto-increments\n  ignoreStageSpace, // optional boolean to disable checking available positions\n});\n")),(0,i.kt)("hr",null),(0,i.kt)("h2",{id:"adddrawentry"},"addDrawEntry"),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-js"},"drawEngine.addDrawEntry({\n  participantId,\n  entryStage, // optional - stage into which participantIds have been entered; defaults to MAIN\n  entryStatus, // optional - defaults to DIRECT_ACCEPTANCE\n  entryPosition, // optional - used to order entries, e.g. { entryPosition: 1 } for 1st alternate\n  ignoreStageSpace, // optional boolean to disable checking available positions\n});\n")),(0,i.kt)("hr",null),(0,i.kt)("h2",{id:"addfinishingrounds"},"addFinishingRounds"),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-js"},"addFinishingRounds({\n  finishingPositionOffset = 0, // required for sub-structures; e.g. consolation fed from R32 would have { finishingPositionOffset: 16 }\n  roundLimit, // for qualifying, offset the final round so that qualifyinground is finishingRound\n  matchUps, // required - matchUps belonging to a single structure\n});\n")),(0,i.kt)("hr",null),(0,i.kt)("h2",{id:"addmatchupendtime"},"addMatchUpEndTime"),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-js"},"const endTime = '2020-01-01T09:05:00Z';\ndrawEngine.addMatchUpEndTime({\n  validateTimeSeries, // optional - true by default - when false does not verify endTime is later than startTime\n  disableNotice, // when disabled subscribers will not be notified\n  matchUpId,\n  endTime,\n});\n")),(0,i.kt)("hr",null),(0,i.kt)("h2",{id:"addmatchupofficial"},"addMatchUpOfficial"),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-js"},"drawEngine.addMatchUpOfficial({\n  matchUpId,\n  participantId,\n  officialType,\n  disableNotice, // when disabled subscribers will not be notified\n});\n")),(0,i.kt)("hr",null),(0,i.kt)("h2",{id:"addmatchupresumetime"},"addMatchUpResumeTime"),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-js"},"const resumeTime = '2020-01-01T09:00:00Z';\ndrawEngine.addMatchUpResumeTime({\n  matchUpId,\n  resumeTime,\n  disableNotice, // when disabled subscribers will not be notified\n});\n")),(0,i.kt)("hr",null),(0,i.kt)("h2",{id:"addmatchupscheduleddate"},"addMatchUpScheduledDate"),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-js"},"const scheduledDate = '2020-01-01';\ndrawEngine.addMatchUpScheduledDate({\n  matchUpId,\n  scheduledDate,\n  disableNotice, // when disabled subscribers will not be notified\n});\n")),(0,i.kt)("hr",null),(0,i.kt)("h2",{id:"addmatchupscheduledtime"},"addMatchUpScheduledTime"),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-js"},"const scheduledTime = '08:00';\ndrawEngine.addMatchUpScheduledTime({\n  matchUpId,\n  scheduledTime,\n  disableNotice, // when disabled subscribers will not be notified\n});\n")),(0,i.kt)("hr",null),(0,i.kt)("h2",{id:"addmatchupscheduleitems"},"addMatchUpScheduleItems"),(0,i.kt)("p",null,"Convenience function to add several schedule items at once."),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-js"},"drawEngine.addMatchUpScheduleItems({\n  matchUpId,\n  schedule: {\n    scheduledTime,\n    scheduledDate,\n    startTime,\n    endTime,\n  },\n  disableNotice, // when disabled subscribers will not be notified\n});\n")),(0,i.kt)("hr",null),(0,i.kt)("h2",{id:"addmatchupstarttime"},"addMatchUpStartTime"),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-js"},"const startTime = '2020-01-01T08:05:00Z';\ndrawEngine.addMatchUpStartTime({\n  matchUpId,\n  startTime,\n  disableNotice, // when disabled subscribers will not be notified\n});\n")),(0,i.kt)("hr",null),(0,i.kt)("h2",{id:"addmatchupstoptime"},"addMatchUpStopTime"),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-js"},"const stopTime = '2020-01-01T08:15:00Z';\ndrawEngine.addMatchUpStopTime({\n  matchUpId,\n  stopTime,\n  disableNotice, // when disabled subscribers will not be notified\n});\n")),(0,i.kt)("hr",null),(0,i.kt)("h2",{id:"addplayoffstructures"},"addPlayoffStructures"),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-js"},"drawEngine.addPlayoffStructures({\n  structureId,\n  roundNumbers: [3], // optional if playoffPositions not provided; roundNumbers of structure to be played off.\n  roundProfiles, // optional - source roundNumbers as Object.keys with depth as Object.values, e.g. [{ 1: 2}, {2: 1}]\n  playoffPositions: [3, 4], // optional if roundNumbers not provided; finishing positions to be played off.\n  playoffAttributes, // optional - mapping of exitProfile to structure names, e.g. 0-1-1 for SOUTH\n  exitProfileLimit, // limit playoff rounds generated by the attributes present in playoffAttributes\n  playoffStructureNameBase, // optional - Root word for default playoff naming, e.g. 'Playoff' for 'Playoff 3-4'\n});\n\n// example use of playoffAttributes - will generated playoff structure from 2nd round with structureName: 'BRONZE'\nconst playoffAttributes = {\n  '0-2': { name: 'BRONZE', abbreviation: 'B' },\n};\n")),(0,i.kt)("hr",null),(0,i.kt)("h2",{id:"addmatchuptimeitem"},"addMatchUpTimeItem"),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-js"},"const timeItem = {\n  itemType: SCHEDULED_DATE,\n  itemValue: scheduledDate,\n};\ndrawEngine.addMatchUpTimeItem({\n  matchUpId,\n  timeItem,\n  duplicateValues: false,\n});\n")),(0,i.kt)("hr",null),(0,i.kt)("h2",{id:"addvoluntaryconsolationstage"},"addVoluntaryConsolationStage"),(0,i.kt)("p",null,"Modifies the entryProfile for a draw to allow ",(0,i.kt)("inlineCode",{parentName:"p"},"{ entryStage: VOLUNTARY_CONSOLATION }")),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-js"},"drawEngine.addVoluntaryConsolationStage({\n  drawSize,\n});\n")),(0,i.kt)("hr",null),(0,i.kt)("h3",{id:"addvoluntaryconsolationstructure"},"addVoluntaryConsolationStructure"),(0,i.kt)("p",null,"Generates a new structure within a ",(0,i.kt)("inlineCode",{parentName:"p"},"drawDefinition")," if any draw entries are present for ",(0,i.kt)("inlineCode",{parentName:"p"},"{ entryStage: VOLUNTARY_CONSOLATION }"),"."),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-js"},"drawEngine.addVoluntaryConsolationStructure();\n")),(0,i.kt)("hr",null),(0,i.kt)("h2",{id:"alldrawmatchups"},"allDrawMatchUps"),(0,i.kt)("p",null,"Returns all matchUps from all structures within a draw."),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-js"},"const { matchUps } = drawEngine.allDrawMatchUps({\n  context, // optional context to be added into matchUps\n  inContext, // boolean - add context { drawId, structureId, participant, individualParticipants ... }\n  nextMatchUps, // optioanl - boolean - to include winnerTo and loserTo\n  matchUpFilters, // attribute filters\n  contextFilters, // filters based on context attributes\n  includeByeMatchUps, // return matchUps with { matchUpStatus: BYE }\n  tournamentParticipants, // optional - provide an array of tournamentParticipants to add into matchUps\n  requireParticipants, // optional - require that participants be loaded into drawEngine or passed into method\n  tournamentAppliedPolicies, // any policies, such as privacy, to be applied to matchUps\n  contextProfile, // optional: { inferGender: true, withCompetitiveness: true, withScaleValues, true, exclude: ['attribute', 'to', 'exclude']}\n});\n")),(0,i.kt)("hr",null),(0,i.kt)("h2",{id:"allstructurematchups"},"allStructureMatchUps"),(0,i.kt)("p",null,"Returns all matchUps from a single structure within a draw."),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-js"},"const { matchUps } = drawEngine.allStructureMatchUps({\n  structureId,\n  context, // optional context to be added into matchUps\n  inContext, // boolean - add context { drawId, structureId, participant, individualParticipants ... }\n  nextMatchUps, // optioanl - boolean - to include winnerTo and loserTo\n  matchUpFilters, // attribute filters\n  contextFilters, // filters based on context attributes\n  includeByeMatchUps, // return matchUps with { matchUpStatus: BYE }\n  tournamentParticipants, // optional - provide an array of tournamentParticipants to add into matchUps\n  requireParticipants, // optional - require that participants be loaded into drawEngine or passed into method\n  tournamentAppliedPolicies, // any policies, such as privacy, to be applied to matchUps\n});\n")),(0,i.kt)("hr",null),(0,i.kt)("h2",{id:"assigndrawposition"},"assignDrawPosition"),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-js"},"drawEngine.assignDrawPosition({\n  structureId,\n  drawPosition,\n  participantId,\n});\n")),(0,i.kt)("hr",null),(0,i.kt)("h2",{id:"assigndrawpositionbye"},"assignDrawPositionBye"),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-js"},"drawEngine.assignDrawPositionBye({\n  structureId,\n  drawPosition,\n});\n")),(0,i.kt)("hr",null),(0,i.kt)("h2",{id:"assignseed"},"assignSeed"),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-js"},"result = drawEngine.assignSeed({\n  structureId,\n  seedNumber,\n  seedValue, // optional - display value, e.g. '5-8'\n  participantId,\n});\n")),(0,i.kt)("hr",null),(0,i.kt)("h2",{id:"attachplayoffstructures"},"attachPlayoffStructures"),(0,i.kt)("p",null,"Attaches the results of ",(0,i.kt)("inlineCode",{parentName:"p"},"generateAndPopulatePlayoffStructures")," to a ",(0,i.kt)("inlineCode",{parentName:"p"},"drawDefinition"),".\nUsed primarily when multiple instances of ",(0,i.kt)("inlineCode",{parentName:"p"},"drawEngine")," are in use and the generation step is performed by one instance."),(0,i.kt)("admonition",{type:"note"},(0,i.kt)("p",{parentName:"admonition"},(0,i.kt)("inlineCode",{parentName:"p"},"drawEngine.addPlayoffStructures()")," calls both ",(0,i.kt)("inlineCode",{parentName:"p"},"generateAndPopulatePlayoffStructures")," and ",(0,i.kt)("inlineCode",{parentName:"p"},"attachPlayoffStructures")," and is used when there is only one instance of ",(0,i.kt)("inlineCode",{parentName:"p"},"drawEngine"),".")),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-js"},"drawEngine.attachPlayoffStructures({ structures, links });\n")),(0,i.kt)("hr",null),(0,i.kt)("h2",{id:"attachpolicies"},"attachPolicies"),(0,i.kt)("p",null,"Attaches a policy to a drawDefinition."),(0,i.kt)("p",null,"See ",(0,i.kt)("a",{parentName:"p",href:"../concepts/policies"},"Policies"),"."),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-js"},"drawEngine.attachPolicies({ policyDefinitions: SEEDING_POLICY });\n")),(0,i.kt)("hr",null),(0,i.kt)("h2",{id:"automatedpositioning"},"automatedPositioning"),(0,i.kt)("p",null,"Positions participants in a draw structure. ",(0,i.kt)("inlineCode",{parentName:"p"},"drawEngine")," is agnostic about the type of participants that are placed in a draw structure, but requires tournament participants for avoidance policies to work."),(0,i.kt)("p",null,"See ",(0,i.kt)("a",{parentName:"p",href:"../concepts/policies"},"Policies"),"."),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-js"},"drawEngine.automatedPositioning({\n  structureId,\n  participants, // optional - participants must be passed in for Avoidance Policies to be effective\n});\n")),(0,i.kt)("hr",null),(0,i.kt)("h2",{id:"checkinparticipant"},"checkInParticipant"),(0,i.kt)("p",null,"Set the check-in state for a participant. Used to determine when both participants in a matchUp are available to be assigned to a court."),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-js"},"drawEngine.checkInParticipant({\n  matchUpId,\n  participantId,\n});\n")),(0,i.kt)("hr",null),(0,i.kt)("h2",{id:"checkoutparticipant"},"checkOutParticipant"),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-js"},"drawEngine.checkOutParticipant({\n  matchUpId,\n  participantId,\n});\n")),(0,i.kt)("hr",null),(0,i.kt)("h2",{id:"cleardrawposition"},"clearDrawPosition"),(0,i.kt)("p",null,"Removes a ",(0,i.kt)("inlineCode",{parentName:"p"},"participantId")," or ",(0,i.kt)("inlineCode",{parentName:"p"},"bye")," from a specified ",(0,i.kt)("inlineCode",{parentName:"p"},"drawPosition")," within a ",(0,i.kt)("inlineCode",{parentName:"p"},"structure")," or, optionally, removes a specified ",(0,i.kt)("inlineCode",{parentName:"p"},"participantId")," from a ",(0,i.kt)("inlineCode",{parentName:"p"},"structure"),"."),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-js"},"drawEngine.clearDrawPosition({\n  structureId,\n  drawPosition, // optional if participantId is provided\n  participantId, // optional if drawPosition is provided\n});\n")),(0,i.kt)("hr",null),(0,i.kt)("h2",{id:"deleteadhocmatchups"},"deleteAdHocMatchUps"),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-js"},"const result = drawEngine.deleteAdHocMatchUps({\n  drawDefinition, // required - drawDefinition in which target structure is found\n  structureId, // required - structureId of structure for which matchUps are being generated\n  matchUpIds, // array of matchUpIds identifying matchUps to be deleted\n});\n")),(0,i.kt)("hr",null),(0,i.kt)("h2",{id:"devcontext"},"devContext"),(0,i.kt)("p",null,"Setting devContext(true) bypasses ",(0,i.kt)("strong",{parentName:"p"},"try {} catch (err) {}")," code block and in some cases enables logging"),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-js"},"drawEngine.devContext(true);\n")),(0,i.kt)("hr",null),(0,i.kt)("h2",{id:"drawmatchups"},"drawMatchUps"),(0,i.kt)("p",null,"Returns categorized matchUps from all structures within a draw."),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-js"},"const {\n  upcomingMatchUps,\n  pendingMatchUps,\n  completedMatchUps,\n  abandonedMatchUps,\n  byeMatchUps,\n} = drawEngine.drawMatchUps({\n  context, // optional context to be added into matchUps\n  inContext, // boolean - add context { drawId, structureId, participant, individualParticipants ... }\n  nextMatchUps, // optioanl - boolean - to include winnerTo and loserTo\n  matchUpFilters, // attribute filters\n  contextFilters, // filters based on context attributes\n  includeByeMatchUps, // return matchUps with { matchUpStatus: BYE }\n  tournamentParticipants, // optional - provide an array of tournamentParticipants to add into matchUps\n  requireParticipants, // optional - require that participants be loaded into drawEngine or passed into method\n  tournamentAppliedPolicies, // any policies, such as privacy, to be applied to matchUps\n});\n")),(0,i.kt)("hr",null),(0,i.kt)("h2",{id:"drawmatic"},"drawMatic"),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-js"},"const { matchUps } = drawEngine.drawMatic({\n  addToStructure, // optional - defaults to true\n  drawId,\n});\n")),(0,i.kt)("hr",null),(0,i.kt)("h2",{id:"disabletiaautocalc"},"disableTiaAutoCalc"),(0,i.kt)("p",null,"Disable default behavior of auto calculating TEAM matchUp scores."),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-js"},"drawEngine.disableTieAutoCalc({ matchUpId });\n")),(0,i.kt)("hr",null),(0,i.kt)("h2",{id:"enabletiaautocalc"},"enableTiaAutoCalc"),(0,i.kt)("p",null,"Re-enable default behavior of auto calculating TEAM matchUp scores, and trigger auto calculation."),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-js"},"drawEngine.enableTieAutoCalc({ matchUpId });\n")),(0,i.kt)("hr",null),(0,i.kt)("h2",{id:"findmatchup"},"findMatchUp"),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-js"},"const {\n  matchUp,\n  structure, // returned for convenience\n} = drawEngine.findMatchUp({\n  matchUpId,\n  inContext, // optional - boolean - returns matchUp with additional attributes\n  tournamentParticipants, // optional - enables inContext matchUp to contain full participant objects\n});\n")),(0,i.kt)("hr",null),(0,i.kt)("h2",{id:"generateadhocmatchups"},"generateAdHocMatchUps"),(0,i.kt)("p",null,"Draws with ",(0,i.kt)("inlineCode",{parentName:"p"},"{ drawType: AD_HOC }")," allow ",(0,i.kt)("inlineCode",{parentName:"p"},"matchUps")," to be dynamically added. In this type of draw there is no automatic participant progression between rounds. Participant assignment to ",(0,i.kt)("inlineCode",{parentName:"p"},"matchUps")," is done manually, or via ",(0,i.kt)("strong",{parentName:"p"},"DrawMatic"),". The only restriction is that a participant may appear once per round."),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-js"},"const result = drawEngine.generateAdHocMatchUps({\n  participantIdPairings, // required - array of array of pairings [['id1', 'id2'], ['id3', 'id4']]\n  drawDefinition, // required - drawDefinition in which target structure is found\n  structureId, // required when more than one structure is present - structureId of structure for which matchUps are being generated\n  matchUpIds, // optional - if matchUpIds are not specified UUIDs are generated\n  roundNumber, // optional - specify round for which matchUps will be generated\n  newRound, // optional - boolean defaults to false - whether to auto-increment to next roundNumber\n});\n")),(0,i.kt)("hr",null),(0,i.kt)("h2",{id:"generateandpopulateplayoffstructures"},"generateAndPopulatePlayoffStructures"),(0,i.kt)("p",null,"Generates ",(0,i.kt)("inlineCode",{parentName:"p"},"structures")," and ",(0,i.kt)("inlineCode",{parentName:"p"},"links")," but does not attach them to the ",(0,i.kt)("inlineCode",{parentName:"p"},"drawDefinition"),". Used in conjunction with ",(0,i.kt)("inlineCode",{parentName:"p"},"attachPlayoffStructures"),"."),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-js"},"const { structures, links, matchUpModifications } =\n  drawEngine.generateAndPopulatePlayoffStructures({\n    requireSequential, // boolean defaults to true; only applies to Round Robin; require finishingPositions to be sequential\n    roundNumbers: [3], // optional if playoffPositions not provided; roundNumbers of structure to be played off.\n    roundProfiles, // optional - source roundNumbers as Object.keys with depth as Object.values, e.g. [{ 1: 2}, {2: 1}]\n    playoffPositions: [3, 4], // optional if roundNumbers not provided; finishing positions to be played off.\n    playoffAttributes, // optional - mapping of exitProfile to structure names, e.g. 0-1-1 for SOUTH\n    exitProfileLimit, // limit playoff rounds generated by the attributes present in playoffAttributes\n    playoffStructureNameBase, // optional - Root word for default playoff naming, e.g. 'Playoff' for 'Playoff 3-4'\n    structureId,\n  });\n")),(0,i.kt)("hr",null),(0,i.kt)("h2",{id:"generatedrawtypeandmodifydrawdefinition"},"generateDrawTypeAndModifyDrawDefinition"),(0,i.kt)("p",null,"Convenience method to generate pre-defined drawTypes."),(0,i.kt)("p",null,"For more information on ",(0,i.kt)("inlineCode",{parentName:"p"},"feedPolicy")," see ",(0,i.kt)("a",{parentName:"p",href:"../policies/feedPolicy"},"Feed Policies"),"."),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-js"},"drawEngine.generateDrawTypeAndModifyDrawDefinition({\n  drawType, // defaults to SINGLE_ELIMINATION\n  modifyOriginal, // optional - defaults to true (primarily used by other engines)\n\n  matchUpType, // optional - defaults to SINGLES - will check first on drawDefinition\n  matchUpFormat, // optional - default matchUpFormat\n  tieFormat, // optional - overrides drawDefinition.tieFormat, if present, for TEAM draws\n  playoffMatchUpFormat, // optional - default playoffMatchUpFormat\n\n  staggeredEntry, // optional - accepts non-base-2 drawSizes and generates feed arms for \"extra\" drawPositions\n  seedingProfile, // optional - WATERFALL seeding for ROUND_ROBIN structures, CLUSTER or SEPARATE seeding for elimination structures\n  feedPolicy, // optional - provides fine-grain control for FEED_IN_CONSOLATION feed links\n\n  qualifyingPositions, // optional - number of drawPositions to be filled by qualifiers\n  finishingPositionLimit, // optional - for playoff structures, limit to the number of positions to be played off\n\n  structureOptions: {\n    groupSize, // e.g. 4 participants per group\n    groupSizeLimit: 8,\n    playoffGroups: [\n      { finishingPositions: [1], structureName: 'Gold Flight', drawType }, // drawype defaults to SINGLE_ELIMINATION\n      { finishingPositions: [2], structureName: 'Silver Flight', drawType }, // drawType can also be COMPASS or FIRST_MATCH_LOSER_CONSOLATION\n    ],\n  },\n\n  uuids, // optional - array of UUIDs to be used for structureIds and matchUpIds\n\n  structureName, // optional - defaults to stage\n});\n")),(0,i.kt)("hr",null),(0,i.kt)("h2",{id:"generatequalifyinglink"},"generateQualifyingLink"),(0,i.kt)("p",null,"Generates and adds a ",(0,i.kt)("inlineCode",{parentName:"p"},"link")," to ",(0,i.kt)("inlineCode",{parentName:"p"},"drawDefinition.links"),"."),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-js"},"drawEngine.generateQualifyingLink({\n  qualifyingStructureId,\n  mainStructureId,\n});\n")),(0,i.kt)("hr",null),(0,i.kt)("h2",{id:"getavailableplayoffprofiles"},"getAvailablePlayoffProfiles"),(0,i.kt)("p",null,"If provided a ",(0,i.kt)("inlineCode",{parentName:"p"},"structureId"),", returns rounds of the selected structure which are available for adding playoff structures."),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-js"},"const { playoffRounds, playoffRoundsRanges, positionsPlayedOff } =\n  drawEngine.getAvailablePlayoffProfiles({\n    structureId,\n  });\n")),(0,i.kt)("p",null,"...For a SINGLE_ELIMINATION struture with drawSize: 16 this would return:"),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-js"},"    {\n      playoffRounds: [ 1, 2, 3 ],\n      playoffRoundsRanges: [\n        { round: 1, range: '9-16' },\n        { round: 2, range: '5-8' },\n        { round: 3, range: '3-4' }\n      ]\n    }\n\n")),(0,i.kt)("p",null,"When no ",(0,i.kt)("inlineCode",{parentName:"p"},"structureId")," is provided, returns an array of ",(0,i.kt)("inlineCode",{parentName:"p"},"availablePlayoffProfiles")," with entries for each structure in a loaded ",(0,i.kt)("inlineCode",{parentName:"p"},"drawDefinition"),"."),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-js"},"const { availablePlayoffProfiles, positionsPlayedOff } =\n  drawEngine.getAvailablePlayoffProfiles();\n")),(0,i.kt)("hr",null),(0,i.kt)("h2",{id:"getcheckedinparticipantids"},"getCheckedInParticipantIds"),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-js"},"const {\n  allParticipantsCheckedIn, // boolean\n  checkedInParticipantIds, // array of participantIds\n} = drawEngine.getCheckedInParticipantIds({ matchUp });\n")),(0,i.kt)("hr",null),(0,i.kt)("h2",{id:"getdrawstructures"},"getDrawStructures"),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-js"},"const { structures, stageStructures } = drawEngine.getDrawStructures({\n  withStageGrouping, // optinal, return structures collated by stage\n  stageSequences, // optional - specify stageSequences to include\n  stageSequence, // optional - filter by stageSequence\n  stages, // optional - specify stageSequences to include\n  stage, // optional - filter by stage\n});\n")),(0,i.kt)("hr",null),(0,i.kt)("h2",{id:"geteliminationdrawsize"},"getEliminationDrawSize"),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-js"},"const { drawSize } = drawEngine.getEliminationDrawSize({ participantCount });\n")),(0,i.kt)("hr",null),(0,i.kt)("h2",{id:"getmatchupcontextids"},"getMatchUpContextIds"),(0,i.kt)("p",null,"Convenience method to find a ",(0,i.kt)("inlineCode",{parentName:"p"},"matchUp")," by ",(0,i.kt)("inlineCode",{parentName:"p"},"matchUpId"),' and return "context ids". Does NOT require that drawEngine state be set, but does require an array of "inContext" ',(0,i.kt)("inlineCode",{parentName:"p"},"matchUps"),"."),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-js"},"const { matchUpId, drawId, eventId, structureId, tournamentId } =\n  drawEngine.getMatchUpContextIds({ matchUps, matchUpId });\n")),(0,i.kt)("hr",null),(0,i.kt)("h2",{id:"getmatchupparticipantids"},"getMatchUpParticipantIds"),(0,i.kt)("p",null,"Convenience function; requires inContext matchUp."),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-js"},"const { sideParticipantIds, individualParticipantIds } =\n  drawEngine.getMatchUpParticipantIds({ matchUp });\n")),(0,i.kt)("hr",null),(0,i.kt)("h2",{id:"getmatchupscheduledetails"},"getMatchUpScheduleDetails"),(0,i.kt)("p",null,"Returns the latest values for all ",(0,i.kt)("inlineCode",{parentName:"p"},"matchUp.timeItems"),", along with calculated values, that relate to the scheduling of a ",(0,i.kt)("inlineCode",{parentName:"p"},"matchUp"),"."),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-js"},"const {\n  schedule: {\n    time,\n    courtId,\n    venueId,\n    startTime,\n    endTime,\n    milliseconds,\n    scheduledDate,\n    scheduledTime,\n    allocatedCourts: [{ venueId, courtid }], // applies only to TEAM matchUps\n  },\n} = drawEngine.getMatchUpScheduleDetails({\n  scheduleVisibilityFilters, // { visibilityThreshold: Date, eventIds, drawIds }\n  matchUp,\n});\n")),(0,i.kt)("hr",null),(0,i.kt)("h2",{id:"getnextseedblock"},"getNextSeedBlock"),(0,i.kt)("p",null,"Returns the next block of drawPositions which are to be assigned seeded participants."),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-js"},"const {\n  nextSeedBlock,\n  unplacedSeedParticipantIds,\n  unplacedSeedNumbers,\n  unfilledPositions,\n  unplacedSeedAssignments,\n} = drawEngine.getNextSeedBlock({\n  structureId,\n});\n")),(0,i.kt)("hr",null),(0,i.kt)("h2",{id:"getnextunfilleddrawpositions"},"getNextUnfilledDrawPositions"),(0,i.kt)("p",null,"Returns the next valid block of unfilled drawPositions. Useful for UI to give visual indication of drawPostions valid to assign."),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-js"},"const { nextUnfilledDrawPositions } = drawEngine.getNextUnfilledDrawPositions({\n  structureId,\n});\n")),(0,i.kt)("hr",null),(0,i.kt)("h2",{id:"getparticipantidfinishingpositions"},"getParticipantIdFinishingPositions"),(0,i.kt)("p",null,"Returns the Range of finishing positions possible for all participantIds within a draw"),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-js"},"const idMap = drawEngine.getParticipantIdFinishingPositions({\n  byeAdvancements, // optional boolean - whether or not to consider byeAdvancements\n});\n\nconst { relevantMatchUps, finishingPositionRanges, finishingPositionRange } =\n  idMap[participantId];\n")),(0,i.kt)("hr",null),(0,i.kt)("h2",{id:"getpositionsplayedoff"},"getPositionsPlayedOff"),(0,i.kt)("p",null,"Determines which finishing positions will be returned by a draw. For example, a First Match Loser Consolation with a draw size of 16 will playoff possitions 1, 2, 9 and 10."),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-js"},"const { positionsPlayedOff } = drawEngine.getPositionsPlayedOff({\n  drawDefinition,\n});\n")),(0,i.kt)("hr",null),(0,i.kt)("h2",{id:"getroundmatchups"},"getRoundMatchUps"),(0,i.kt)("p",null,"Organizes matchUps by roundNumber. ",(0,i.kt)("strong",{parentName:"p"},"roundMatchUps")," contains matchUp objects; ",(0,i.kt)("strong",{parentName:"p"},"roundProfile")," provides an overview of drawPositions which have advanced to each round, a matchUpsCount, finishingPositionRange for winners and losers, and finishingRound."),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-js"},"const { roundMatchUps, roundProfile } = drawEngine.getRoundMatchUps({\n  matchUps,\n});\n")),(0,i.kt)("hr",null),(0,i.kt)("h2",{id:"getseedingthresholds"},"getSeedingThresholds"),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-js"},"const { seedingThresholds } = drawEngine.getSeedingThresholds({\n  roundRobinGroupsCount,\n  participantsCount,\n});\n")),(0,i.kt)("hr",null),(0,i.kt)("h2",{id:"getsourcerounds"},"getSourceRounds"),(0,i.kt)("p",null,"Returns the round numbers for desired playoff positions."),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-js"},"const {\n  sourceRounds, // all source rounds for playedOff positions and specified playoffPositions\n  playoffSourceRounds,\n  playedOffSourceRounds,\n  playoffPositionsReturned,\n} = drawEngine.getSourceRounds({\n  structureId,\n  playoffPositions: [3, 4],\n});\n")),(0,i.kt)("hr",null),(0,i.kt)("h2",{id:"getstructureseedassignments"},"getStructureSeedAssignments"),(0,i.kt)("p",null,"Returns seedAssignments for a specific structure based on structureId or structure"),(0,i.kt)("p",null,"The structure of an ",(0,i.kt)("strong",{parentName:"p"},(0,i.kt)("em",{parentName:"strong"},"assignment object"))," is as follows:"),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-json"},'{\n  "seedNumber": 1,\n  "seedValue": "1",\n  "participantId": "uuid-of-participant"\n}\n')),(0,i.kt)("p",null,"The most basic usage is to retrieve seed assignments for a draw which has a single main stage structure"),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-js"},"const { seedAssignments } = drawEngine.getStructureSeedAssignments({\n  structureId,\n});\n")),(0,i.kt)("hr",null),(0,i.kt)("h2",{id:"getstate"},"getState"),(0,i.kt)("p",null,"No parameters."),(0,i.kt)("p",null,"Returns a deep copy of the current drawEngine state."),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-js"},"const { drawDefinition } = drawEngine.getState({\n  convertExtensions, // optional - convert extensions to '_' prefixed attributes\n  removeExtensions, // optional - strip all extensions out of tournamentRecord\n});\n")),(0,i.kt)("hr",null),(0,i.kt)("h2",{id:"getvalidgroupsizes"},"getValidGroupSizes"),(0,i.kt)("p",null,"Returns valid Round Robin group sizes for specified ",(0,i.kt)("inlineCode",{parentName:"p"},"drawSize"),"."),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-js"},"const { validGroupSizes } = drawEngine.getValidGroupSies({\n  groupSizeLimit, // optional - defaults to 10\n  drawSize,\n});\n")),(0,i.kt)("hr",null),(0,i.kt)("h2",{id:"initializestructureseedassignments"},"initializeStructureSeedAssignments"),(0,i.kt)("p",null,"Creates the ",(0,i.kt)("inlineCode",{parentName:"p"},"seedAssignments")," attribute for the specified structure."),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-js"},"drawEngine.initializeStructureSeedAssignments({\n  structureId,\n  seedsCount,\n});\n")),(0,i.kt)("hr",null),(0,i.kt)("h2",{id:"iscompletedstructure"},"isCompletedStructure"),(0,i.kt)("p",null,"Returns boolean whether all matchUps in a given structure have been completed"),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-js"},"const structureIsComplete = drawEngine.isCompletedStructure({\n  structureId,\n});\n")),(0,i.kt)("hr",null),(0,i.kt)("h2",{id:"matchupactions"},"matchUpActions"),(0,i.kt)("p",null,"Return an array of all validActions for a specific matchUp."),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-js"},"const {\n  isByeMatchUp, // boolean; true if matchUp includes a BYE\n  structureIsComplete, // boolean; true if structure is ready for positioning\n  validActions, // array of possible actions given current matchUpStatus\n} = drawEngine.matchUpActions({\n  restrictAdHocRoundParticipants, // optional - true by default; applies to AD_HOC; disallow the same participant being in the same round multiple times\n  sideNumber, // optional - select side to which action should apply; applies to AD_HOC position assignments\n  matchUpId,\n});\n\nconst {\n  type, // 'REFEREE', 'SCHEDULE', 'PENALTY', 'STATUS', 'SCORE', 'START', 'END'.\n  method, // tournamentEngine method relating to action type\n  payload, // attributes to be passed to method\n  // additional method-specific options for values to be added to payload when calling method\n} = validAction;\n")),(0,i.kt)("hr",null),(0,i.kt)("h2",{id:"matchupduration"},"matchUpDuration"),(0,i.kt)("p",null,"Calculates matchUp duration from START, STOP, RESUME, END timeItems."),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-js"},'const {\n  milliseconds,\n  time, // string representation of elapsed time, e.g. "01:10:00" for an hour and 10 seconds\n  relevantTimeItems,\n} = drawEngine.matchUpDuration({\n  matchUp,\n});\n')),(0,i.kt)("hr",null),(0,i.kt)("h2",{id:"newdrawdefinition"},"newDrawDefinition"),(0,i.kt)("p",null,"Creates a new drawDefinition within drawEngine state."),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-js"},"const { drawId } = drawEngine.newDrawDefinition();\nconst { drawDefinition } = drawEngine.getState();\n")),(0,i.kt)("hr",null),(0,i.kt)("h2",{id:"positionactions"},"positionActions"),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-js"},"const positionActions = drawEngine.positionActions({\n  policyDefinitions: positionActionsPolicy, // optional - policy defining what actions are allowed in client context\n  returnParticipants, // optional boolean; defaults to true; performance optimization when false requires client to provide participants.\n  drawPosition,\n  structureId,\n});\n\nconst {\n  isActiveDrawPosition, // boolean\n  isByePosition, // boolean\n  isDrawPosition, // boolean\n  hasPositionAssiged, // boolean\n  validActions,\n} = positionActions;\n\nconst {\n  type, // 'ASSIGN', 'LUCKY', 'SWAP', 'BYE', 'REMOVE'\n  method, // tournamentEngine method relating to action type\n  payload, // attributes to be passed to method\n  // additional method-specific options for values to be added to payload when calling method\n} = validAction;\n")),(0,i.kt)("hr",null),(0,i.kt)("h2",{id:"removeentry"},"removeEntry"),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-js"},"drawEngine.removeEntry({\n  participantId,\n  autoEntryPositions, // optional - keeps entries ordered by entryStage/entryStatus\n});\n")),(0,i.kt)("hr",null),(0,i.kt)("h2",{id:"removestructure"},"removeStructure"),(0,i.kt)("p",null,"Removes targeted ",(0,i.kt)("inlineCode",{parentName:"p"},"drawDefinition.structure")," and all other child ",(0,i.kt)("inlineCode",{parentName:"p"},"structures")," along with all associated ",(0,i.kt)("inlineCode",{parentName:"p"},"drawDefinition.links"),"."),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-js"},"const { removedMatchUpIds } = drawEngine.removeStructure({\n  structureId,\n});\n")),(0,i.kt)("hr",null),(0,i.kt)("h2",{id:"renamestructures"},"renameStructures"),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-js"},"drawEngine.renameStructures({\n  structureDetails: [{ structureId, structureName }],\n});\n")),(0,i.kt)("h2",{id:"reset"},"reset"),(0,i.kt)("p",null,"Clears the drawEngine state."),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-js"},"drawEngine.reset();\n")),(0,i.kt)("hr",null),(0,i.kt)("h2",{id:"resetmatchuptimeitems"},"resetMatchUpTimeItems"),(0,i.kt)("p",null,"Removes all timeItems from a specified matchUp."),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-js"},"drawEngine.resetMatchUpTimeItems({ matchUpId });\n")),(0,i.kt)("hr",null),(0,i.kt)("h2",{id:"resolvedrawpositions"},"resolveDrawPositions"),(0,i.kt)("p",null,"Provides an algorithmic approach to assigning drawPositions based on participant nomination of an arbitrary number of preferred positions."),(0,i.kt)("p",null,"Simple use case would be to pre-position all seeded participants, then resolve all remaining participants."),(0,i.kt)("p",null,"Variations could include grouping participants into quarters based on rankings/ratings and resolving drawPositions for each group in a sequence which gives preference to higher ranked/rated participants"),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-js"},"const { drawPositionResolutions, report } = drawEngine.resolveDrawPositions({\n  participantFactors, // { [participantId]: { preferences: [1, 2, 3] }} - the length of the preference array is arbitrary\n  positionAssignments, // object from target structure containing any already assigned positions\n});\n")),(0,i.kt)("h2",{id:"setdrawdescription"},"setDrawDescription"),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-js"},"const drawDescription = 'Draw Description';\ndrawEngine.setDrawDescription({ description: drawDescription });\n")),(0,i.kt)("hr",null),(0,i.kt)("h2",{id:"setmatchupformat"},"setMatchUpFormat"),(0,i.kt)("p",null,"Sets the default ",(0,i.kt)("inlineCode",{parentName:"p"},"matchUpFormat")," for a ",(0,i.kt)("inlineCode",{parentName:"p"},"drawDefintion")," or a ",(0,i.kt)("inlineCode",{parentName:"p"},"structure"),", or for a specific ",(0,i.kt)("inlineCode",{parentName:"p"},"matchUp"),"."),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-js"},"drawEngine.setMatchUpFormat({\n  matchUpFormat,\n  structureId, // optional - if structureId is present and not matchUpId is present, then set for structure\n  matchUpId, // optional - if matchUpId is present then only set for matchUp\n});\n")),(0,i.kt)("hr",null),(0,i.kt)("h2",{id:"setmatchupstatus"},"setMatchUpStatus"),(0,i.kt)("p",null,"Sets either matchUpStatus or score and winningSide. Handles any winner/loser participant movements within or across structures."),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-js"},"drawEngine.setMatchUpStatus({\n  disableScoreValidation, // optional boolean\n  allowChangePropagation, // optional boolean - allow winner/loser to be swapped and propgate change throughout draw structures\n  disableAutoCalc, // optional - applies only to { matchUpType: TEAM }\n  enableAutoCalc, // optional - applies only to { matchUpType: TEAM }\n  matchUpTieId, // optional - if part of a TIE matchUp\n  matchUpStatus, // optional - if matchUpFormat differs from event/draw/structure defaults\n  matchUpId,\n  score, // optional - { sets }\n  winningSide,\n  schedule: {\n    // optional - set schedule items\n    scheduledDate,\n    scheduledTime,\n    startTime,\n    endTime,\n  },\n  notes, // optional - add note (string) to matchUp object\n});\n")),(0,i.kt)("hr",null),(0,i.kt)("h2",{id:"setorderoffinish"},"setOrderOfFinish"),(0,i.kt)("p",null,"Sets the ",(0,i.kt)("inlineCode",{parentName:"p"},"orderOfFinish")," attribute for ",(0,i.kt)("inlineCode",{parentName:"p"},"matchUps")," specified by ",(0,i.kt)("inlineCode",{parentName:"p"},"matchUpId")," in the ",(0,i.kt)("inlineCode",{parentName:"p"},"finishingOrder")," array."),(0,i.kt)("h3",{id:"validation"},"Validation"),(0,i.kt)("p",null,"Validation is done within a ",(0,i.kt)("em",{parentName:"p"},"cohort")," of ",(0,i.kt)("inlineCode",{parentName:"p"},"matchUps")," which have equivalent ",(0,i.kt)("inlineCode",{parentName:"p"},"structureId"),", ",(0,i.kt)("inlineCode",{parentName:"p"},"matchUpType"),", ",(0,i.kt)("inlineCode",{parentName:"p"},"roundNumber"),", and ",(0,i.kt)("inlineCode",{parentName:"p"},"matchUpTieId")," (if applicable)."),(0,i.kt)("ul",null,(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("inlineCode",{parentName:"li"},"matchUpIds")," in ",(0,i.kt)("inlineCode",{parentName:"li"},"finishingOrder")," must be part of the same ",(0,i.kt)("em",{parentName:"li"},"cohort")),(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("inlineCode",{parentName:"li"},"orderOfFinish")," values must be unique positive integers within the ",(0,i.kt)("em",{parentName:"li"},"cohort"))),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-js"},"drawEngine.setOrderOfFinish({\n  finishingOrder: [{ matchUpId, orderOfFinish: 1 }],\n});\n")),(0,i.kt)("hr",null),(0,i.kt)("h2",{id:"setparticipants"},"setParticipants"),(0,i.kt)("p",null,"Participants are not managed by the ",(0,i.kt)("inlineCode",{parentName:"p"},"drawEngine"),", but they can be used when returning 'inContext' matchUps as well as when automated positioning relies on avoidance policies."),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-js"},"drawEngine.setParticipants(participants);\n")),(0,i.kt)("hr",null),(0,i.kt)("h2",{id:"setstagealternatescount"},"setStageAlternatesCount"),(0,i.kt)("p",null,"Sets an (optional) limit to the number of accepted alternates."),(0,i.kt)("p",null,"Modifies the 'entryProfile' of a drawDefinition before the structures have been generated."),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-js"},"drawEngine.setStageAlternatesCount({ alternatesCount: 8 });\n")),(0,i.kt)("hr",null),(0,i.kt)("h2",{id:"setstagedrawsize"},"setStageDrawSize"),(0,i.kt)("p",null,"Modifies the 'entryProfile' of a drawDefinition before the structures have been generated."),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-js"},"drawEngine.setStageDrawSize({ stage: QUALIFYING, stageSequence, drawSize: 8 });\ndrawEngine.setStageDrawSize({ stage: MAIN, drawSize: 16 });\n")),(0,i.kt)("hr",null),(0,i.kt)("h2",{id:"setstagequalifierscount"},"setStageQualifiersCount"),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-js"},"drawEngine.setStageQualifiersCount({\n  qualifiersCount: 4,\n  stageSequence,\n  stage,\n});\n")),(0,i.kt)("hr",null),(0,i.kt)("h2",{id:"setstagewildcardscount"},"setStageWildcardsCount"),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-js"},"drawEngine.setStageWildcardsCount({ stage, stageSequence, wildcardsCount: 2 });\n")),(0,i.kt)("hr",null),(0,i.kt)("h2",{id:"setstate"},"setState"),(0,i.kt)("p",null,"Loads a drawDefinition into drawEngine."),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-js"},"drawEngine.setsState(drawDefinition, deepCopy, deepCopyConfig);\n")),(0,i.kt)("admonition",{type:"info"},(0,i.kt)("p",{parentName:"admonition"},"By default a deep copy of the tournament record is made so that mutations made by drawEngine do not affect the source object. An optional boolean parameter, ",(0,i.kt)("em",{parentName:"p"},"deepCopy")," can be set to false to override this default behavior.")),(0,i.kt)("admonition",{type:"note"},(0,i.kt)("p",{parentName:"admonition"},(0,i.kt)("inlineCode",{parentName:"p"},"deepCopyConfig")," is an optional configuration for ",(0,i.kt)("inlineCode",{parentName:"p"},"makeDeepCopy"),". In server configurations when ",(0,i.kt)("inlineCode",{parentName:"p"},"deepCopy")," is FALSE and ",(0,i.kt)("inlineCode",{parentName:"p"},"tournamentRecords")," are retrieved from Mongo, for instance, there are scenarios where nodes of the JSON structure contain prototypes which cannot be converted.")),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-js"},"const deepCopyConfig = {\n  ignore, // optional - either an array of attributes to ignore or a function which processes attributes to determine whether to ignore them\n  toJSON, // optional - an array of attributes to convert to JSON if the attribute in question is an object with .toJSON property\n  stringify, // optional - an array of attributes to stringify\n  modulate, // optional - function to process every attribute and return custom values, or undefined, which continues normal processing\n};\n")),(0,i.kt)("hr",null),(0,i.kt)("h2",{id:"setsuborder"},"setSubOrder"),(0,i.kt)("p",null,"Used to order ROUND_ROBIN participants when finishingPosition ties cannot be broken algorithmically. Assigns a subOrder value to a participant within a structure by drawPosition."),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-js"},"drawEngine.setSubOrder({\n  structureId, // structure identifier within drawDefinition\n  drawPosition: 1, // drawPosition of the participant where subOrder is to be added\n  subOrder: 2, // order in which tied participant should receive finishing position\n});\n")),(0,i.kt)("hr",null),(0,i.kt)("h2",{id:"swapdrawpositionassignments"},"swapDrawPositionAssignments"),(0,i.kt)("p",null,"Swaps the ",(0,i.kt)("inlineCode",{parentName:"p"},"participantIds")," of two ",(0,i.kt)("inlineCode",{parentName:"p"},"drawPositions"),"."),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-js"},"drawEngine.swapDrawPositionAssignments({ structureId, drawPositions });\n")),(0,i.kt)("hr",null),(0,i.kt)("h2",{id:"getstructurematchups"},"getStructureMatchUps"),(0,i.kt)("p",null,"Returns categorized matchUps from a single structure."),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-js"},"const {\n  upcomingMatchUps,\n  pendingMatchUps,\n  completedMatchUps,\n  abandonedMatchUps,\n  byeMatchUps,\n} = drawEngine.getStructureMatchUps({\n  structureId,\n  context, // optional context to be added into matchUps\n  inContext, // boolean - add context { drawId, structureId, participant, individualParticipants ... }\n  nextMatchUps, // optioanl - boolean - to include winnerTo and loserTo\n  matchUpFilters, // attribute filters\n  contextFilters, // filters based on context attributes\n  includeByeMatchUps, // return matchUps with { matchUpStatus: BYE }\n  tournamentParticipants, // optional - provide an array of tournamentParticipants to add into matchUps\n  requireParticipants, // optional - require that participants be loaded into drawEngine or passed into method\n  tournamentAppliedPolicies, // any policies, such as privacy, to be applied to matchUps\n  scheduleVisibilityFilters, // { visibilityThreshold: Date, eventIds, drawIds }\n});\n")),(0,i.kt)("hr",null),(0,i.kt)("h2",{id:"validdrawpositions"},"validDrawPositions"),(0,i.kt)("p",null,"Returns boolean indicating whether all matchUps have valid draw positions"),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-js"},"drawEngine.validDrawPositions({ matchUps });\n")),(0,i.kt)("hr",null),(0,i.kt)("h2",{id:"version"},"version"),(0,i.kt)("p",null,"Returns NPM package version. Can be used in configurations that utilize Competition Factory engines on both client and server to ensure equivalency."),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-js"},"const version = drawEngine.version();\n")),(0,i.kt)("hr",null))}u.isMDXComponent=!0}}]);