"use strict";(globalThis.webpackChunkdocumentation=globalThis.webpackChunkdocumentation||[]).push([[5002],{3564(e,n,i){i.r(n),i.d(n,{assets:()=>l,contentTitle:()=>o,default:()=>h,frontMatter:()=>a,metadata:()=>t,toc:()=>c});const t=JSON.parse('{"id":"scale-engine/scale-engine-api","title":"Core API Reference","description":"Complete method reference for the ScaleEngine. The ScaleEngine exposes all methods from the Ranking Governor plus rating functions, accessible through the stateful engine pattern.","source":"@site/docs/scale-engine/scale-engine-api.md","sourceDirName":"scale-engine","slug":"/scale-engine/scale-engine-api","permalink":"/competition-factory/docs/scale-engine/scale-engine-api","draft":false,"unlisted":false,"tags":[],"version":"current","frontMatter":{"title":"Core API Reference"},"sidebar":"docs","previous":{"title":"Overview","permalink":"/competition-factory/docs/scale-engine/scale-engine-overview"},"next":{"title":"Ranking Points Pipeline","permalink":"/competition-factory/docs/scale-engine/ranking-points-pipeline"}}');var s=i(6070),r=i(8322);const a={title:"Core API Reference"},o=void 0,l={},c=[{value:"Ranking Points Methods",id:"ranking-points-methods",level:2},{value:"getTournamentPoints",id:"gettournamentpoints",level:3},{value:"applyTournamentRankingPoints",id:"applytournamentrankingpoints",level:3},{value:"getAwardProfile",id:"getawardprofile",level:3},{value:"getAwardPoints",id:"getawardpoints",level:3},{value:"Aggregation Methods",id:"aggregation-methods",level:2},{value:"generateRankingList",id:"generaterankinglist",level:3},{value:"getParticipantPoints",id:"getparticipantpoints",level:3},{value:"Quality Win Methods",id:"quality-win-methods",level:2},{value:"getQualityWinPoints",id:"getqualitywinpoints",level:3},{value:"Rating Methods",id:"rating-methods",level:2},{value:"generateDynamicRatings",id:"generatedynamicratings",level:3},{value:"calculateNewRatings",id:"calculatenewratings",level:3},{value:"Related Documentation",id:"related-documentation",level:2}];function d(e){const n={a:"a",admonition:"admonition",code:"code",h2:"h2",h3:"h3",hr:"hr",li:"li",p:"p",pre:"pre",strong:"strong",table:"table",tbody:"tbody",td:"td",th:"th",thead:"thead",tr:"tr",ul:"ul",...(0,r.R)(),...e.components};return(0,s.jsxs)(s.Fragment,{children:[(0,s.jsxs)(n.p,{children:["Complete method reference for the ",(0,s.jsx)(n.code,{children:"ScaleEngine"}),". The ScaleEngine exposes all methods from the ",(0,s.jsx)(n.a,{href:"/docs/governors/ranking-governor",children:"Ranking Governor"})," plus rating functions, accessible through the stateful engine pattern."]}),"\n",(0,s.jsx)(n.admonition,{type:"info",children:(0,s.jsxs)(n.p,{children:["The ScaleEngine shares the ",(0,s.jsx)(n.code,{children:"syncEngine"})," singleton. Call ",(0,s.jsx)(n.code,{children:"scaleEngine.setState(tournamentRecord)"})," before invoking methods, or pass ",(0,s.jsx)(n.code,{children:"policyDefinitions"})," explicitly when tournament policies aren't attached."]})}),"\n",(0,s.jsx)(n.h2,{id:"ranking-points-methods",children:"Ranking Points Methods"}),"\n",(0,s.jsx)(n.h3,{id:"gettournamentpoints",children:"getTournamentPoints"}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-ts",children:"getTournamentPoints(params?: {\n  policyDefinitions?: PolicyDefinitions;\n  participantFilters?: ParticipantFilters;\n  level?: number;\n}): {\n  success: boolean;\n  personPoints: Record<string, PointAward[]>;\n  pairPoints: Record<string, PointAward[]>;\n  teamPoints: Record<string, PointAward[]>;\n  participantsWithOutcomes: Participant[];\n}\n"})}),"\n",(0,s.jsx)(n.p,{children:"Computes ranking points for all participants in the loaded tournament. This is the core computation method."}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-js",children:"scaleEngine.setState(tournamentRecord);\nconst result = scaleEngine.getTournamentPoints({\n  policyDefinitions: rankingPolicy,\n  level: 3,\n});\n\n// Iterate personPoints\nfor (const [personId, awards] of Object.entries(result.personPoints)) {\n  const total = awards.reduce((sum, a) => sum + (a.points || 0) + (a.qualityWinPoints || 0), 0);\n  console.log(`${personId}: ${total} points`);\n}\n"})}),"\n",(0,s.jsx)(n.p,{children:(0,s.jsx)(n.strong,{children:"Parameters:"})}),"\n",(0,s.jsxs)(n.table,{children:[(0,s.jsx)(n.thead,{children:(0,s.jsxs)(n.tr,{children:[(0,s.jsx)(n.th,{children:"Parameter"}),(0,s.jsx)(n.th,{children:"Type"}),(0,s.jsx)(n.th,{children:"Description"})]})}),(0,s.jsxs)(n.tbody,{children:[(0,s.jsxs)(n.tr,{children:[(0,s.jsx)(n.td,{children:(0,s.jsx)(n.code,{children:"policyDefinitions"})}),(0,s.jsx)(n.td,{children:(0,s.jsx)(n.code,{children:"PolicyDefinitions"})}),(0,s.jsx)(n.td,{children:"Ranking policy. Falls back to tournament-attached policy if not provided"})]}),(0,s.jsxs)(n.tr,{children:[(0,s.jsx)(n.td,{children:(0,s.jsx)(n.code,{children:"participantFilters"})}),(0,s.jsx)(n.td,{children:(0,s.jsx)(n.code,{children:"ParticipantFilters"})}),(0,s.jsx)(n.td,{children:"Filter which participants to process"})]}),(0,s.jsxs)(n.tr,{children:[(0,s.jsx)(n.td,{children:(0,s.jsx)(n.code,{children:"level"})}),(0,s.jsx)(n.td,{children:(0,s.jsx)(n.code,{children:"number"})}),(0,s.jsx)(n.td,{children:"Tournament level (used for level-keyed point values)"})]})]})]}),"\n",(0,s.jsxs)(n.p,{children:[(0,s.jsx)(n.strong,{children:"Returns:"})," ",(0,s.jsx)(n.code,{children:"personPoints"})," keyed by ",(0,s.jsx)(n.code,{children:"personId"}),", ",(0,s.jsx)(n.code,{children:"pairPoints"})," keyed by pair ",(0,s.jsx)(n.code,{children:"participantId"}),", ",(0,s.jsx)(n.code,{children:"teamPoints"})," keyed by team ",(0,s.jsx)(n.code,{children:"participantId"}),". Each value is an array of ",(0,s.jsx)(n.code,{children:"PointAward"})," objects."]}),"\n",(0,s.jsxs)(n.p,{children:["See ",(0,s.jsx)(n.a,{href:"/docs/scale-engine/ranking-points-pipeline",children:"Ranking Points Pipeline"})," for how points are computed."]}),"\n",(0,s.jsx)(n.hr,{}),"\n",(0,s.jsx)(n.h3,{id:"applytournamentrankingpoints",children:"applyTournamentRankingPoints"}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-ts",children:"applyTournamentRankingPoints(params: {\n  policyDefinitions?: PolicyDefinitions;\n  participantFilters?: ParticipantFilters;\n  scaleName?: string;      // default: 'RANKING_POINTS'\n  level?: number;\n  removePriorValues?: boolean;\n}): {\n  success: boolean;\n  personPoints: Record<string, PointAward[]>;\n  pairPoints: Record<string, PointAward[]>;\n  teamPoints: Record<string, PointAward[]>;\n  modificationsApplied: number;\n}\n"})}),"\n",(0,s.jsxs)(n.p,{children:["Computes ranking points and persists them as ",(0,s.jsx)(n.a,{href:"/docs/concepts/scaleItems",children:"scale items"})," on participant records. This enables multi-tournament workflows where one tournament's points are available for quality win lookups in subsequent tournaments."]}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-js",children:"scaleEngine.setState(tournamentRecord);\n\nconst result = scaleEngine.applyTournamentRankingPoints({\n  policyDefinitions: rankingPolicy,\n  scaleName: 'USTA_JUNIOR',\n  level: 2,\n  removePriorValues: true,\n});\n\n// Points are now persisted and retrievable\nconst { scaleItem } = scaleEngine.getParticipantScaleItem({\n  participantId: 'player-123',\n  scaleAttributes: {\n    scaleType: 'RANKING',\n    scaleName: 'USTA_JUNIOR',\n    eventType: 'SINGLES',\n  },\n});\n// scaleItem.scaleValue = { points: 500, awards: [...] }\n"})}),"\n",(0,s.jsx)(n.p,{children:(0,s.jsx)(n.strong,{children:"Parameters:"})}),"\n",(0,s.jsxs)(n.table,{children:[(0,s.jsx)(n.thead,{children:(0,s.jsxs)(n.tr,{children:[(0,s.jsx)(n.th,{children:"Parameter"}),(0,s.jsx)(n.th,{children:"Type"}),(0,s.jsx)(n.th,{children:"Description"})]})}),(0,s.jsxs)(n.tbody,{children:[(0,s.jsxs)(n.tr,{children:[(0,s.jsx)(n.td,{children:(0,s.jsx)(n.code,{children:"policyDefinitions"})}),(0,s.jsx)(n.td,{children:(0,s.jsx)(n.code,{children:"PolicyDefinitions"})}),(0,s.jsx)(n.td,{children:"Ranking policy"})]}),(0,s.jsxs)(n.tr,{children:[(0,s.jsx)(n.td,{children:(0,s.jsx)(n.code,{children:"participantFilters"})}),(0,s.jsx)(n.td,{children:(0,s.jsx)(n.code,{children:"ParticipantFilters"})}),(0,s.jsx)(n.td,{children:"Filter which participants to process"})]}),(0,s.jsxs)(n.tr,{children:[(0,s.jsx)(n.td,{children:(0,s.jsx)(n.code,{children:"scaleName"})}),(0,s.jsx)(n.td,{children:(0,s.jsx)(n.code,{children:"string"})}),(0,s.jsxs)(n.td,{children:["Name for the scale item (default: ",(0,s.jsx)(n.code,{children:"'RANKING_POINTS'"}),")"]})]}),(0,s.jsxs)(n.tr,{children:[(0,s.jsx)(n.td,{children:(0,s.jsx)(n.code,{children:"level"})}),(0,s.jsx)(n.td,{children:(0,s.jsx)(n.code,{children:"number"})}),(0,s.jsx)(n.td,{children:"Tournament level"})]}),(0,s.jsxs)(n.tr,{children:[(0,s.jsx)(n.td,{children:(0,s.jsx)(n.code,{children:"removePriorValues"})}),(0,s.jsx)(n.td,{children:(0,s.jsx)(n.code,{children:"boolean"})}),(0,s.jsx)(n.td,{children:"Remove existing scale items with the same scaleName before writing"})]})]})]}),"\n",(0,s.jsxs)(n.p,{children:[(0,s.jsx)(n.strong,{children:"Scale item structure:"})," Each participant receives one scale item per ",(0,s.jsx)(n.code,{children:"eventType"}),", with ",(0,s.jsx)(n.code,{children:"scaleValue: { points, awards }"})," where ",(0,s.jsx)(n.code,{children:"points"})," is the total and ",(0,s.jsx)(n.code,{children:"awards"})," is the full ",(0,s.jsx)(n.code,{children:"PointAward[]"})," breakdown."]}),"\n",(0,s.jsx)(n.hr,{}),"\n",(0,s.jsx)(n.h3,{id:"getawardprofile",children:"getAwardProfile"}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-ts",children:"getAwardProfile(params: {\n  awardProfiles: AwardProfile[];\n  participation: StructureParticipation;\n  eventType?: string;\n  drawType?: string;\n  drawSize?: number;\n  category?: Category;\n  gender?: string;\n  wheelchairClass?: string;\n  level?: number;\n  startDate?: string;\n  endDate?: string;\n}): { awardProfile?: AwardProfile }\n"})}),"\n",(0,s.jsxs)(n.p,{children:["Selects the best-matching award profile using ",(0,s.jsx)(n.a,{href:"/docs/scale-engine/ranking-points-pipeline#profile-selection",children:"specificity scoring"}),". Generally called internally by ",(0,s.jsx)(n.code,{children:"getTournamentPoints"}),", but available for inspection and debugging."]}),"\n",(0,s.jsx)(n.hr,{}),"\n",(0,s.jsx)(n.h3,{id:"getawardpoints",children:"getAwardPoints"}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-ts",children:"getAwardPoints(params: {\n  valueObj: PositionValue;\n  level?: number;\n  drawSize?: number;\n  flightNumber?: number;\n  flights?: FlightConfig;\n  participantWon?: boolean;\n}): { awardPoints: number; requireWin?: boolean }\n"})}),"\n",(0,s.jsx)(n.p,{children:"Resolves a position value object into numeric points. Handles level-keyed values, draw size thresholds, flight lookups, and won/lost accessors."}),"\n",(0,s.jsx)(n.hr,{}),"\n",(0,s.jsx)(n.h2,{id:"aggregation-methods",children:"Aggregation Methods"}),"\n",(0,s.jsx)(n.h3,{id:"generaterankinglist",children:"generateRankingList"}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-ts",children:"generateRankingList(params: {\n  pointAwards: PointAward[];\n  aggregationRules?: AggregationRules;\n  categoryFilter?: CategoryFilter;\n  asOfDate?: string;\n}): RankingListEntry[]\n"})}),"\n",(0,s.jsx)(n.p,{children:"Aggregates point awards from multiple tournaments into a sorted ranking list. This is a pure computation function \u2014 it does not access tournament state."}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-js",children:"import { generateRankingList } from 'tods-competition-factory';\n\nconst rankingList = generateRankingList({\n  pointAwards: allAwards, // collected from multiple getTournamentPoints calls\n  aggregationRules: {\n    countingBuckets: [\n      { bucketName: 'Singles', eventTypes: ['SINGLES'], pointComponents: ['positionPoints', 'perWinPoints', 'bonusPoints'], bestOfCount: 6 },\n      { bucketName: 'Doubles', eventTypes: ['DOUBLES'], pointComponents: ['positionPoints', 'perWinPoints', 'bonusPoints'], bestOfCount: 2 },\n      { bucketName: 'Quality Wins', pointComponents: ['qualityWinPoints'], bestOfCount: 0 },\n    ],\n    rollingPeriodDays: 365,\n    minCountableResults: 3,\n    tiebreakCriteria: ['highestSingleResult', 'mostWins'],\n  },\n  asOfDate: '2025-12-31',\n});\n\nfor (const entry of rankingList) {\n  console.log(`#${entry.rank} ${entry.personId}: ${entry.totalPoints}pts (${entry.countingResults.length} counting)`);\n}\n"})}),"\n",(0,s.jsxs)(n.p,{children:["See ",(0,s.jsx)(n.a,{href:"/docs/scale-engine/aggregation",children:"Multi-Tournament Aggregation"})," for detailed documentation."]}),"\n",(0,s.jsx)(n.hr,{}),"\n",(0,s.jsx)(n.h3,{id:"getparticipantpoints",children:"getParticipantPoints"}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-ts",children:"getParticipantPoints(params: {\n  pointAwards: PointAward[];\n  personId: string;\n  aggregationRules?: AggregationRules;\n}): {\n  buckets: BucketBreakdown[];\n  totalPoints: number;\n}\n"})}),"\n",(0,s.jsx)(n.p,{children:"Returns a per-participant breakdown showing which results count and which are dropped, organized by bucket."}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-js",children:"import { getParticipantPoints } from 'tods-competition-factory';\n\nconst { buckets, totalPoints } = getParticipantPoints({\n  pointAwards: allAwards,\n  personId: 'player-abc',\n  aggregationRules: {\n    countingBuckets: [\n      { bucketName: 'Singles', eventTypes: ['SINGLES'], pointComponents: ['positionPoints', 'perWinPoints'], bestOfCount: 6 },\n    ],\n  },\n});\n\nfor (const bucket of buckets) {\n  console.log(`${bucket.bucketName}: ${bucket.bucketTotal}pts (${bucket.countingResults.length} counting, ${bucket.droppedResults.length} dropped)`);\n}\n"})}),"\n",(0,s.jsx)(n.hr,{}),"\n",(0,s.jsx)(n.h2,{id:"quality-win-methods",children:"Quality Win Methods"}),"\n",(0,s.jsx)(n.h3,{id:"getqualitywinpoints",children:"getQualityWinPoints"}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-ts",children:"getQualityWinPoints(params: {\n  qualityWinProfiles: QualityWinProfile[];\n  wonMatchUpIds: string[];\n  mappedMatchUps: Record<string, MatchUp>;\n  participantSideMap: Record<string, number>;\n  tournamentParticipants: Participant[];\n  tournamentStartDate?: string;\n  participantId?: string;\n  level?: number;\n}): {\n  qualityWinPoints: number;\n  qualityWins: QualityWin[];\n}\n"})}),"\n",(0,s.jsxs)(n.p,{children:["Computes quality win bonus points for a participant's won matchUps. Generally called internally by ",(0,s.jsx)(n.code,{children:"getTournamentPoints"}),"."]}),"\n",(0,s.jsxs)(n.p,{children:["See ",(0,s.jsx)(n.a,{href:"/docs/scale-engine/quality-win-points",children:"Quality Win Points"})," for detailed documentation."]}),"\n",(0,s.jsx)(n.hr,{}),"\n",(0,s.jsx)(n.h2,{id:"rating-methods",children:"Rating Methods"}),"\n",(0,s.jsx)(n.h3,{id:"generatedynamicratings",children:"generateDynamicRatings"}),"\n",(0,s.jsx)(n.p,{children:"Generates dynamic ratings for all participants based on match outcomes using configurable algorithms."}),"\n",(0,s.jsx)(n.h3,{id:"calculatenewratings",children:"calculateNewRatings"}),"\n",(0,s.jsx)(n.p,{children:"Calculates updated ratings for two participants based on a match outcome."}),"\n",(0,s.jsx)(n.hr,{}),"\n",(0,s.jsx)(n.h2,{id:"related-documentation",children:"Related Documentation"}),"\n",(0,s.jsxs)(n.ul,{children:["\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.strong,{children:(0,s.jsx)(n.a,{href:"./scale-engine-overview",children:"Scale Engine Overview"})})," \u2014 Introduction and architecture"]}),"\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.strong,{children:(0,s.jsx)(n.a,{href:"./ranking-points-pipeline",children:"Ranking Points Pipeline"})})," \u2014 How points are computed"]}),"\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.strong,{children:(0,s.jsx)(n.a,{href:"./quality-win-points",children:"Quality Win Points"})})," \u2014 Quality win bonus system"]}),"\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.strong,{children:(0,s.jsx)(n.a,{href:"./aggregation",children:"Multi-Tournament Aggregation"})})," \u2014 Counting buckets and ranking lists"]}),"\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.strong,{children:(0,s.jsx)(n.a,{href:"/docs/governors/ranking-governor",children:"Ranking Governor"})})," \u2014 Stateless function reference"]}),"\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.strong,{children:(0,s.jsx)(n.a,{href:"/docs/policies/rankingPolicy",children:"Ranking Policy"})})," \u2014 Policy structure guide"]}),"\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.strong,{children:(0,s.jsx)(n.a,{href:"/docs/concepts/scaleItems",children:"Scale Items"})})," \u2014 Rankings, ratings, and seedings"]}),"\n"]})]})}function h(e={}){const{wrapper:n}={...(0,r.R)(),...e.components};return n?(0,s.jsx)(n,{...e,children:(0,s.jsx)(d,{...e})}):d(e)}},8322(e,n,i){i.d(n,{R:()=>a,x:()=>o});var t=i(758);const s={},r=t.createContext(s);function a(e){const n=t.useContext(r);return t.useMemo(function(){return"function"==typeof e?e(n):{...n,...e}},[n,e])}function o(e){let n;return n=e.disableParentContext?"function"==typeof e.components?e.components(s):e.components||s:a(e.components),t.createElement(r.Provider,{value:n},e.children)}}}]);