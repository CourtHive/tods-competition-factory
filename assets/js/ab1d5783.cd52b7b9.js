"use strict";(globalThis.webpackChunkdocumentation=globalThis.webpackChunkdocumentation||[]).push([[3162],{6204(e,n,t){t.r(n),t.d(n,{assets:()=>c,contentTitle:()=>d,default:()=>h,frontMatter:()=>s,metadata:()=>i,toc:()=>l});const i=JSON.parse('{"id":"governors/matchup-governor","title":"matchUp Governor","description":"addMatchUpEndTime","source":"@site/docs/governors/matchup-governor.md","sourceDirName":"governors","slug":"/governors/matchup-governor","permalink":"/competition-factory/docs/governors/matchup-governor","draft":false,"unlisted":false,"tags":[],"version":"current","frontMatter":{"title":"matchUp Governor"},"sidebar":"docs","previous":{"title":"Generation Governor","permalink":"/competition-factory/docs/governors/generation-governor"},"next":{"title":"matchUpFormat Governor","permalink":"/competition-factory/docs/governors/matchup-format-governor"}}');var a=t(6070),r=t(8322);const s={title:"matchUp Governor"},d=void 0,c={},l=[{value:"addMatchUpEndTime",id:"addmatchupendtime",level:2},{value:"addMatchUpOfficial",id:"addmatchupofficial",level:2},{value:"addMatchUpResumeTime",id:"addmatchupresumetime",level:2},{value:"addMatchUpScheduledDate",id:"addmatchupscheduleddate",level:2},{value:"addMatchUpScheduledTime",id:"addmatchupscheduledtime",level:2},{value:"addMatchUpScheduleItems",id:"addmatchupscheduleitems",level:2},{value:"Features",id:"features",level:3},{value:"Parameters",id:"parameters",level:3},{value:"Return Values",id:"return-values",level:3},{value:"Pro Scheduling Grid Assignment",id:"pro-scheduling-grid-assignment",level:3},{value:"Double Booking Prevention",id:"double-booking-prevention",level:3},{value:"Chronology Validation",id:"chronology-validation",level:3},{value:"Follow-By Scheduling (ITF Style)",id:"follow-by-scheduling-itf-style",level:3},{value:"Time Recording During Match",id:"time-recording-during-match",level:3},{value:"TEAM MatchUp Court Allocation",id:"team-matchup-court-allocation",level:3},{value:"Bulk Scheduling Pattern",id:"bulk-scheduling-pattern",level:3},{value:"Error Handling",id:"error-handling",level:3},{value:"Related Methods",id:"related-methods",level:3},{value:"Related Documentation",id:"related-documentation",level:3},{value:"addMatchUpStartTime",id:"addmatchupstarttime",level:2},{value:"addMatchUpStopTime",id:"addmatchupstoptime",level:2},{value:"addMatchUpCourtOrder",id:"addmatchupcourtorder",level:2},{value:"applyLinueUps",id:"applylinueups",level:2},{value:"assignMatchUpSideParticipant",id:"assignmatchupsideparticipant",level:2},{value:"assignMatchUpCourt",id:"assignmatchupcourt",level:2},{value:"assignMatchUpVenue",id:"assignmatchupvenue",level:2},{value:"assignTieMatchUpParticipantId",id:"assigntiematchupparticipantid",level:2},{value:"bulkMatchUpStatusUpdate",id:"bulkmatchupstatusupdate",level:2},{value:"checkInParticipant",id:"checkinparticipant",level:2},{value:"checkOutParticipant",id:"checkoutparticipant",level:2},{value:"disableTieAutoCalc",id:"disabletieautocalc",level:2},{value:"enableTiaAutoCalc",id:"enabletiaautocalc",level:2},{value:"findMatchUp",id:"findmatchup",level:2},{value:"getHomeParticipantId",id:"gethomeparticipantid",level:2},{value:"modifyMatchUpFormatTiming",id:"modifymatchupformattiming",level:2},{value:"removeMatchUpSideParticipant",id:"removematchupsideparticipant",level:2},{value:"replaceTieMatchUpParticipantId",id:"replacetiematchupparticipantid",level:2},{value:"removeTieMatchUpParticipantId",id:"removetiematchupparticipantid",level:2},{value:"resetAdHocMatchUps",id:"resetadhocmatchups",level:2},{value:"resetScorecard",id:"resetscorecard",level:2},{value:"resetTieFormat",id:"resettieformat",level:2},{value:"setMatchUpDailyLimits",id:"setmatchupdailylimits",level:2},{value:"setMatchUpFormat",id:"setmatchupformat",level:2},{value:"setMatchUpHomeParticipantId",id:"setmatchuphomeparticipantid",level:2},{value:"setMatchUpStatus",id:"setmatchupstatus",level:2},{value:"setOrderOfFinish",id:"setorderoffinish",level:2},{value:"Validation",id:"validation",level:3},{value:"toggleParticipantCheckInState",id:"toggleparticipantcheckinstate",level:2},{value:"updateTieMatchUpScore",id:"updatetiematchupscore",level:2}];function o(e){const n={a:"a",admonition:"admonition",code:"code",em:"em",h2:"h2",h3:"h3",hr:"hr",li:"li",p:"p",pre:"pre",strong:"strong",ul:"ul",...(0,r.R)(),...e.components};return(0,a.jsxs)(a.Fragment,{children:[(0,a.jsx)(n.pre,{children:(0,a.jsx)(n.code,{className:"language-js",children:"import { matchUpGovernor } from 'tods-competition-factory';\n"})}),"\n",(0,a.jsx)(n.h2,{id:"addmatchupendtime",children:"addMatchUpEndTime"}),"\n",(0,a.jsx)(n.pre,{children:(0,a.jsx)(n.code,{className:"language-js",children:"const endTime = '2020-01-01T09:05:00Z';\nengine.addMatchUpEndTime({\n  validateTimeSeries, // optional - true by default - when false does not verify endTime is later than startTime\n  disableNotice, // when disabled subscribers will not be notified\n  matchUpId,\n  endTime,\n  drawId,\n});\n"})}),"\n",(0,a.jsx)(n.hr,{}),"\n",(0,a.jsx)(n.h2,{id:"addmatchupofficial",children:"addMatchUpOfficial"}),"\n",(0,a.jsx)(n.pre,{children:(0,a.jsx)(n.code,{className:"language-js",children:"engine.addMatchUpOfficial({\n  disableNotice, // when disabled subscribers will not be notified\n  participantId,\n  officialType,\n  matchUpId,\n  drawId,\n});\n"})}),"\n",(0,a.jsx)(n.hr,{}),"\n",(0,a.jsx)(n.h2,{id:"addmatchupresumetime",children:"addMatchUpResumeTime"}),"\n",(0,a.jsx)(n.pre,{children:(0,a.jsx)(n.code,{className:"language-js",children:"const resumeTime = '2020-01-01T09:00:00Z';\nengine.addMatchUpResumeTime({\n  removePriorValues, // optional boolean\n  disableNotice, // when disabled subscribers will not be notified\n  resumeTime,\n  matchUpId,\n  drawId,\n});\n"})}),"\n",(0,a.jsx)(n.hr,{}),"\n",(0,a.jsx)(n.h2,{id:"addmatchupscheduleddate",children:"addMatchUpScheduledDate"}),"\n",(0,a.jsx)(n.pre,{children:(0,a.jsx)(n.code,{className:"language-js",children:"const scheduledDate = '2020-01-01';\nengine.addMatchUpScheduledDate({\n  removePriorValues, // optional boolean\n  disableNotice, // when disabled subscribers will not be notified\n  scheduledDate,\n  matchUpId,\n  drawId,\n});\n"})}),"\n",(0,a.jsx)(n.hr,{}),"\n",(0,a.jsx)(n.h2,{id:"addmatchupscheduledtime",children:"addMatchUpScheduledTime"}),"\n",(0,a.jsx)(n.pre,{children:(0,a.jsx)(n.code,{className:"language-js",children:"const scheduledTime = '08:00';\nengine.addMatchUpScheduledTime({\n  removePriorValues, // optional boolean\n  disableNotice, // when disabled subscribers will not be notified\n  scheduledTime,\n  matchUpId,\n  drawId,\n});\n"})}),"\n",(0,a.jsx)(n.hr,{}),"\n",(0,a.jsx)(n.h2,{id:"addmatchupscheduleitems",children:"addMatchUpScheduleItems"}),"\n",(0,a.jsx)(n.p,{children:"Comprehensive scheduling method that adds multiple schedule attributes to a matchUp in a single operation."}),"\n",(0,a.jsx)(n.h3,{id:"features",children:"Features"}),"\n",(0,a.jsxs)(n.ul,{children:["\n",(0,a.jsxs)(n.li,{children:[(0,a.jsx)(n.strong,{children:"Atomic Scheduling"}),": Assigns multiple schedule items (court, time, date, venue) in one transaction"]}),"\n",(0,a.jsxs)(n.li,{children:[(0,a.jsx)(n.strong,{children:"Conflict Detection"}),": Optional validation to prevent double-booking court slots (pro-scheduling)"]}),"\n",(0,a.jsxs)(n.li,{children:[(0,a.jsx)(n.strong,{children:"Chronology Validation"}),": Optional checks for scheduling dependencies and match order"]}),"\n",(0,a.jsxs)(n.li,{children:[(0,a.jsx)(n.strong,{children:"Court Order Assignment"}),": Supports Pro Scheduling grid-based court order (row) assignments"]}),"\n",(0,a.jsxs)(n.li,{children:[(0,a.jsx)(n.strong,{children:"Team MatchUp Support"}),": Handles court allocation for TEAM matchUps with multiple courts"]}),"\n",(0,a.jsxs)(n.li,{children:[(0,a.jsx)(n.strong,{children:"Follow-By Scheduling"}),': Supports ITF-style follow-by and "Not Before" scheduling patterns']}),"\n",(0,a.jsxs)(n.li,{children:[(0,a.jsx)(n.strong,{children:"Time Modifiers"}),': Allows adding schedule modifiers like "Not Before" times']}),"\n",(0,a.jsxs)(n.li,{children:[(0,a.jsx)(n.strong,{children:"Home Participant"}),": Can designate home participant for display purposes"]}),"\n"]}),"\n",(0,a.jsx)(n.h3,{id:"parameters",children:"Parameters"}),"\n",(0,a.jsx)(n.pre,{children:(0,a.jsx)(n.code,{className:"language-js",children:"engine.addMatchUpScheduleItems({\n  // Required\n  matchUpId, // matchUp identifier\n  drawId, // draw containing the matchUp\n\n  // Schedule Object - all fields optional\n  schedule: {\n    scheduledDate, // ISO date string (e.g., '2024-03-20')\n    scheduledTime, // Time string (e.g., '14:00' or ISO timestamp)\n    courtId, // Court identifier (requires scheduledDate and courtOrder for conflict detection)\n    courtOrder, // Grid row number for Pro Scheduling (integer as string, e.g., '1', '2')\n    venueId, // Venue identifier\n    courtIds, // Array of court IDs (applies only to TEAM matchUps)\n    startTime, // Actual start time (ISO timestamp)\n    stopTime, // Pause time for interrupted matches (ISO timestamp)\n    resumeTime, // Resume time after interruption (ISO timestamp)\n    endTime, // Actual completion time (ISO timestamp)\n    timeModifiers, // Array of modifiers (e.g., [{ type: 'NOT_BEFORE', value: '14:00' }])\n    homeParticipantId, // Designate home participant\n  },\n\n  // Optional Control Parameters\n  proConflictDetection, // boolean - default true - validates no existing matchUp occupies { courtId, courtOrder, scheduledDate }\n  checkChronology, // boolean - validates scheduling doesn't create dependency conflicts\n  errorOnAnachronism, // boolean - throw error (vs warning) for chronology violations\n  removePriorValues, // boolean - removes existing schedule values before applying new ones\n  disableNotice, // boolean - when true, subscribers will not be notified of changes\n});\n"})}),"\n",(0,a.jsx)(n.h3,{id:"return-values",children:"Return Values"}),"\n",(0,a.jsx)(n.p,{children:(0,a.jsx)(n.strong,{children:"Success:"})}),"\n",(0,a.jsx)(n.pre,{children:(0,a.jsx)(n.code,{className:"language-js",children:"{\n  success: true;\n}\n"})}),"\n",(0,a.jsx)(n.p,{children:(0,a.jsx)(n.strong,{children:"Error (Double Booking):"})}),"\n",(0,a.jsx)(n.pre,{children:(0,a.jsx)(n.code,{className:"language-js",children:"{\n  error: {\n    message: 'Schedule conflict: court slot already occupied',\n    code: 'ERR_SCHEDULE_CONFLICT_DOUBLE_BOOKING',\n  },\n  info: 'Court slot already occupied by matchUp <matchUpId>',\n}\n"})}),"\n",(0,a.jsx)(n.p,{children:(0,a.jsx)(n.strong,{children:"Warning (Chronology Issue):"})}),"\n",(0,a.jsx)(n.pre,{children:(0,a.jsx)(n.code,{className:"language-js",children:"{\n  success: true,\n  warnings: [\n    {\n      code: 'ANACHRONISM',\n      message: 'Chronological error; time violation.',\n    },\n  ];\n}\n"})}),"\n",(0,a.jsx)(n.h3,{id:"pro-scheduling-grid-assignment",children:"Pro Scheduling Grid Assignment"}),"\n",(0,a.jsxs)(n.p,{children:["When scheduling matchUps in a grid-based format (Pro Scheduling), always provide ",(0,a.jsx)(n.code,{children:"courtId"}),", ",(0,a.jsx)(n.code,{children:"courtOrder"}),", and ",(0,a.jsx)(n.code,{children:"scheduledDate"})," together:"]}),"\n",(0,a.jsx)(n.pre,{children:(0,a.jsx)(n.code,{className:"language-js",children:"// Assign to Court 1, Row 3, on March 20th\nengine.addMatchUpScheduleItems({\n  matchUpId: 'match-123',\n  drawId: 'draw-456',\n  schedule: {\n    courtId: 'court-1',\n    courtOrder: '3', // Row 3 on the grid\n    scheduledDate: '2024-03-20',\n    scheduledTime: '14:00', // Optional display time\n  },\n});\n"})}),"\n",(0,a.jsx)(n.h3,{id:"double-booking-prevention",children:"Double Booking Prevention"}),"\n",(0,a.jsxs)(n.p,{children:["By default, ",(0,a.jsx)(n.code,{children:"proConflictDetection: true"})," validates that no other matchUp is scheduled to the same ",(0,a.jsx)(n.code,{children:"{ courtId, courtOrder, scheduledDate }"})," combination. This prevents accidentally double-booking a court slot in grid-based scheduling."]}),"\n",(0,a.jsxs)(n.p,{children:[(0,a.jsx)(n.strong,{children:"Disable for Performance"}),": When scheduling large tournaments (1000+ matchUps) or when client-side UI already validates conflicts, disable detection to improve performance:"]}),"\n",(0,a.jsx)(n.pre,{children:(0,a.jsx)(n.code,{className:"language-js",children:"engine.addMatchUpScheduleItems({\n  matchUpId: 'match-123',\n  drawId: 'draw-456',\n  schedule: {\n    courtId: 'court-1',\n    courtOrder: '3',\n    scheduledDate: '2024-03-20',\n  },\n  proConflictDetection: false, // Skip validation for performance\n});\n"})}),"\n",(0,a.jsx)(n.p,{children:(0,a.jsx)(n.strong,{children:"When to Disable:"})}),"\n",(0,a.jsxs)(n.ul,{children:["\n",(0,a.jsx)(n.li,{children:"High-volume bulk scheduling operations"}),"\n",(0,a.jsx)(n.li,{children:"Client application already validates conflicts before submission"}),"\n",(0,a.jsx)(n.li,{children:"Multi-user environments with optimistic UI updates"}),"\n",(0,a.jsx)(n.li,{children:"Scheduling is rolled back on error anyway"}),"\n"]}),"\n",(0,a.jsx)(n.p,{children:(0,a.jsx)(n.strong,{children:"When to Keep Enabled:"})}),"\n",(0,a.jsxs)(n.ul,{children:["\n",(0,a.jsx)(n.li,{children:"Interactive scheduling by tournament directors"}),"\n",(0,a.jsx)(n.li,{children:"Automated scheduling scripts without UI validation"}),"\n",(0,a.jsx)(n.li,{children:"Single-user applications"}),"\n",(0,a.jsx)(n.li,{children:"Critical scheduling operations that must not fail"}),"\n"]}),"\n",(0,a.jsx)(n.h3,{id:"chronology-validation",children:"Chronology Validation"}),"\n",(0,a.jsxs)(n.p,{children:["When ",(0,a.jsx)(n.code,{children:"checkChronology: true"}),", the system validates that scheduling doesn't violate match dependencies:"]}),"\n",(0,a.jsx)(n.pre,{children:(0,a.jsx)(n.code,{className:"language-js",children:"// Round 1 match\nengine.addMatchUpScheduleItems({\n  matchUpId: 'round1-match',\n  drawId: 'draw-456',\n  schedule: {\n    scheduledDate: '2024-03-21',\n    scheduledTime: '10:00',\n  },\n  checkChronology: true, // Validate dependencies\n});\n\n// Round 2 match (winner of round1-match)\nengine.addMatchUpScheduleItems({\n  matchUpId: 'round2-match',\n  drawId: 'draw-456',\n  schedule: {\n    scheduledDate: '2024-03-20', // ERROR: Earlier than prerequisite\n  },\n  checkChronology: true,\n  errorOnAnachronism: true, // Throw error vs warning\n});\n"})}),"\n",(0,a.jsx)(n.h3,{id:"follow-by-scheduling-itf-style",children:"Follow-By Scheduling (ITF Style)"}),"\n",(0,a.jsx)(n.p,{children:'For stadium courts with "Follow" or "Not Before" scheduling:'}),"\n",(0,a.jsx)(n.pre,{children:(0,a.jsx)(n.code,{className:"language-js",children:"// First match: fixed time\nengine.addMatchUpScheduleItems({\n  matchUpId: 'match-1',\n  drawId: 'draw-456',\n  schedule: {\n    courtId: 'centre-court',\n    courtOrder: '1',\n    scheduledDate: '2024-03-23',\n    scheduledTime: '13:00',\n  },\n});\n\n// Second match: to follow first match\nengine.addMatchUpScheduleItems({\n  matchUpId: 'match-2',\n  drawId: 'draw-456',\n  schedule: {\n    courtId: 'centre-court',\n    courtOrder: '2',\n    scheduledDate: '2024-03-23',\n    // No scheduledTime - will follow match-1\n    timeModifiers: [\n      {\n        type: 'FOLLOWED_BY',\n        value: { matchUpId: 'match-1' },\n      },\n    ],\n  },\n});\n\n// Third match: Not Before with follow\nengine.addMatchUpScheduleItems({\n  matchUpId: 'match-3',\n  drawId: 'draw-456',\n  schedule: {\n    courtId: 'centre-court',\n    courtOrder: '3',\n    scheduledDate: '2024-03-23',\n    scheduledTime: '18:00', // Not Before 6 PM\n    timeModifiers: [\n      {\n        type: 'FOLLOWED_BY',\n        value: { matchUpId: 'match-2', notBeforeTime: '18:00' },\n      },\n    ],\n  },\n});\n"})}),"\n",(0,a.jsx)(n.h3,{id:"time-recording-during-match",children:"Time Recording During Match"}),"\n",(0,a.jsx)(n.p,{children:"Record actual match times as play progresses:"}),"\n",(0,a.jsx)(n.pre,{children:(0,a.jsx)(n.code,{className:"language-js",children:"// Match starts\nengine.addMatchUpScheduleItems({\n  matchUpId: 'match-123',\n  drawId: 'draw-456',\n  schedule: {\n    startTime: '2024-03-20T14:05:23Z', // Actual start time\n  },\n});\n\n// Match interrupted (rain delay)\nengine.addMatchUpScheduleItems({\n  matchUpId: 'match-123',\n  drawId: 'draw-456',\n  schedule: {\n    stopTime: '2024-03-20T14:45:12Z',\n  },\n});\n\n// Match resumes\nengine.addMatchUpScheduleItems({\n  matchUpId: 'match-123',\n  drawId: 'draw-456',\n  schedule: {\n    resumeTime: '2024-03-20T15:30:00Z',\n  },\n});\n\n// Match completes\nengine.addMatchUpScheduleItems({\n  matchUpId: 'match-123',\n  drawId: 'draw-456',\n  schedule: {\n    endTime: '2024-03-20T16:15:45Z',\n  },\n});\n"})}),"\n",(0,a.jsx)(n.h3,{id:"team-matchup-court-allocation",children:"TEAM MatchUp Court Allocation"}),"\n",(0,a.jsx)(n.p,{children:"For TEAM matchUps (e.g., Davis Cup ties), allocate multiple courts:"}),"\n",(0,a.jsx)(n.pre,{children:(0,a.jsx)(n.code,{className:"language-js",children:"engine.addMatchUpScheduleItems({\n  matchUpId: 'team-tie-123',\n  drawId: 'draw-456',\n  schedule: {\n    scheduledDate: '2024-03-20',\n    courtIds: ['court-1', 'court-2', 'court-3'], // Multiple courts for simultaneous tie matches\n    venueId: 'venue-789',\n  },\n});\n"})}),"\n",(0,a.jsx)(n.h3,{id:"bulk-scheduling-pattern",children:"Bulk Scheduling Pattern"}),"\n",(0,a.jsx)(n.p,{children:"When scheduling multiple matchUps, disable notifications and enable at the end:"}),"\n",(0,a.jsx)(n.pre,{children:(0,a.jsx)(n.code,{className:"language-js",children:"matchAssignments.forEach(({ matchUpId, courtId, courtOrder, scheduledDate }) => {\n  engine.addMatchUpScheduleItems({\n    matchUpId,\n    drawId: 'draw-456',\n    schedule: { courtId, courtOrder, scheduledDate },\n    proConflictDetection: false, // Validated at UI layer\n    disableNotice: true, // Batch notifications\n  });\n});\n\n// Manually trigger notification after bulk operation\nengine.notify({ topic: 'scheduleUpdate', payload: { drawId: 'draw-456' } });\n"})}),"\n",(0,a.jsx)(n.h3,{id:"error-handling",children:"Error Handling"}),"\n",(0,a.jsx)(n.pre,{children:(0,a.jsx)(n.code,{className:"language-js",children:"const result = engine.addMatchUpScheduleItems({\n  matchUpId: 'match-123',\n  drawId: 'draw-456',\n  schedule: {\n    courtId: 'court-1',\n    courtOrder: '2',\n    scheduledDate: '2024-03-20',\n  },\n});\n\nif (result.error) {\n  if (result.error.code === 'ERR_SCHEDULE_CONFLICT_DOUBLE_BOOKING') {\n    console.error('Court slot already occupied:', result.info);\n    // Suggest alternative court or time\n  } else if (result.error.code === 'ANACHRONISM') {\n    console.warn('Scheduling creates dependency conflict');\n    // Allow with confirmation\n  } else {\n    console.error('Scheduling failed:', result.error);\n  }\n} else if (result.warnings) {\n  console.warn('Scheduling completed with warnings:', result.warnings);\n}\n"})}),"\n",(0,a.jsx)(n.h3,{id:"related-methods",children:"Related Methods"}),"\n",(0,a.jsxs)(n.ul,{children:["\n",(0,a.jsxs)(n.li,{children:[(0,a.jsx)(n.strong,{children:(0,a.jsx)(n.a,{href:"#assignmatchupcourt",children:"assignMatchUpCourt"})})," - Assign court only"]}),"\n",(0,a.jsxs)(n.li,{children:[(0,a.jsx)(n.strong,{children:(0,a.jsx)(n.a,{href:"#addmatchupscheduleddate",children:"addMatchUpScheduledDate"})})," - Assign date only"]}),"\n",(0,a.jsxs)(n.li,{children:[(0,a.jsx)(n.strong,{children:(0,a.jsx)(n.a,{href:"#addmatchupscheduledtime",children:"addMatchUpScheduledTime"})})," - Assign time only"]}),"\n",(0,a.jsxs)(n.li,{children:[(0,a.jsx)(n.strong,{children:(0,a.jsx)(n.a,{href:"#addmatchupcourtorder",children:"addMatchUpCourtOrder"})})," - Assign grid row only"]}),"\n"]}),"\n",(0,a.jsx)(n.h3,{id:"related-documentation",children:"Related Documentation"}),"\n",(0,a.jsxs)(n.ul,{children:["\n",(0,a.jsxs)(n.li,{children:[(0,a.jsx)(n.strong,{children:(0,a.jsx)(n.a,{href:"/docs/concepts/pro-scheduling",children:"Pro Scheduling Concepts"})})," - Grid-based scheduling workflows"]}),"\n",(0,a.jsxs)(n.li,{children:[(0,a.jsx)(n.strong,{children:(0,a.jsx)(n.a,{href:"/docs/governors/schedule-governor",children:"Schedule Governor"})})," - Automated scheduling methods"]}),"\n",(0,a.jsxs)(n.li,{children:[(0,a.jsx)(n.strong,{children:(0,a.jsx)(n.a,{href:"/docs/policies/scheduling",children:"Scheduling Policy"})})," - Recovery times and constraints"]}),"\n"]}),"\n",(0,a.jsx)(n.hr,{}),"\n",(0,a.jsx)(n.h2,{id:"addmatchupstarttime",children:"addMatchUpStartTime"}),"\n",(0,a.jsx)(n.pre,{children:(0,a.jsx)(n.code,{className:"language-js",children:"const startTime = '2020-01-01T08:05:00Z';\nengine.addMatchUpStartTime({\n  drawId,\n  matchUpId,\n  startTime,\n  disableNotice, // when disabled subscribers will not be notified\n});\n"})}),"\n",(0,a.jsx)(n.hr,{}),"\n",(0,a.jsx)(n.h2,{id:"addmatchupstoptime",children:"addMatchUpStopTime"}),"\n",(0,a.jsx)(n.pre,{children:(0,a.jsx)(n.code,{className:"language-js",children:"const stopTime = '2020-01-01T08:15:00Z';\nengine.addMatchUpStopTime({\n  drawId,\n  matchUpId,\n  stopTime,\n  disableNotice, // when disabled subscribers will not be notified\n});\n"})}),"\n",(0,a.jsx)(n.hr,{}),"\n",(0,a.jsx)(n.h2,{id:"addmatchupcourtorder",children:"addMatchUpCourtOrder"}),"\n",(0,a.jsx)(n.p,{children:"When using Pro-scheduling, assign order on court"}),"\n",(0,a.jsx)(n.pre,{children:(0,a.jsx)(n.code,{className:"language-js",children:"engine.addMatchUpCourtOrder({\n  removePriorValues, // optional boolean\n  drawId, // drawId where matchUp is found\n  courtOrder,\n  matchUpId,\n  courtId,\n});\n"})}),"\n",(0,a.jsx)(n.hr,{}),"\n",(0,a.jsx)(n.h2,{id:"applylinueups",children:"applyLinueUps"}),"\n",(0,a.jsxs)(n.p,{children:["Applies ",(0,a.jsx)(n.code,{children:"lineUps"})," to the ",(0,a.jsx)(n.code,{children:"sides"})," of a ",(0,a.jsx)(n.em,{children:"TEAM"})," matchUp. Order is not important as team side is determined automatically. Does not check to ensure that participants in ",(0,a.jsx)(n.code,{children:"lineUps"})," are part of teams; this is assumed. It is possible to have ",(0,a.jsx)(n.strong,{children:(0,a.jsx)(n.em,{children:"some"})})," participants assigned to a team side who are not part of a team."]}),"\n",(0,a.jsx)(n.pre,{children:(0,a.jsx)(n.code,{className:"language-js",children:"result = engine.applyLineUps({\n  matchUpId, // must be { matchUpType: TEAM }\n  lineUps, // array of at most two lineUps (see TODS)\n  drawId, // reference to draw in which matchUp occurs\n});\n"})}),"\n",(0,a.jsx)(n.hr,{}),"\n",(0,a.jsx)(n.h2,{id:"assignmatchupsideparticipant",children:"assignMatchUpSideParticipant"}),"\n",(0,a.jsx)(n.p,{children:"Assign participant to AD_HOC matchUp."}),"\n",(0,a.jsx)(n.pre,{children:(0,a.jsx)(n.code,{className:"language-js",children:"engine.assignMatchUpSideParticipant({\n  participantId,\n  sideNumber,\n  matchUpId,\n  drawId,\n});\n"})}),"\n",(0,a.jsx)(n.hr,{}),"\n",(0,a.jsx)(n.h2,{id:"assignmatchupcourt",children:"assignMatchUpCourt"}),"\n",(0,a.jsx)(n.pre,{children:(0,a.jsx)(n.code,{className:"language-js",children:"engine.assignMatchUpCourt({\n  removePriorValues, // optional boolean\n  drawId, // drawId where matchUp is found\n  courtDayDate, // ISO date string\n  matchUpId,\n  courtId,\n});\n"})}),"\n",(0,a.jsx)(n.hr,{}),"\n",(0,a.jsx)(n.h2,{id:"assignmatchupvenue",children:"assignMatchUpVenue"}),"\n",(0,a.jsx)(n.pre,{children:(0,a.jsx)(n.code,{className:"language-js",children:"engine.assignMatchUVenue({\n  removePriorValues, // optional boolean\n  drawId, // drawId where matchUp is found\n  matchUpId,\n  venueId,\n});\n"})}),"\n",(0,a.jsx)(n.hr,{}),"\n",(0,a.jsx)(n.h2,{id:"assigntiematchupparticipantid",children:"assignTieMatchUpParticipantId"}),"\n",(0,a.jsxs)(n.p,{children:["Used when interactively assigning participants to ",(0,a.jsx)(n.code,{children:"matchUps"}),". When individual ",(0,a.jsx)(n.code,{children:"participantIds"})," are assigned to ",(0,a.jsx)(n.code,{children:"{ matchUpType: 'DOUBLES' }"})," it handles creating ",(0,a.jsx)(n.code,{children:"{ participantType: PAIR }"})," participants dynamically."]}),"\n",(0,a.jsx)(n.pre,{children:(0,a.jsx)(n.code,{className:"language-js",children:'engine.assignTieMatchUpParticipantId({\n  teamParticipantId, // optional - participant team can be derived from participantId. This supports assigning "borrowed" players from other teams.\n  participantId, // id of INDIVIDUAL or PAIR participant to be assigned to a matchUp\n  tieMatchUpId, // matchUpId of a SINGLES or DOUBLES that is part of a matchUp between teams\n  sideNumber, // optional - only necessary if a participant is part of both teams (edge case!)\n  drawId, // identifies draw in which matchUp is present\n});\n'})}),"\n",(0,a.jsx)(n.hr,{}),"\n",(0,a.jsx)(n.h2,{id:"bulkmatchupstatusupdate",children:"bulkMatchUpStatusUpdate"}),"\n",(0,a.jsx)(n.p,{children:"Provides the ability to update the outcomes of multiple matchUps at once."}),"\n",(0,a.jsx)(n.pre,{children:(0,a.jsx)(n.code,{className:"language-js",children:"const outcomes = [\n  {\n    eventId,\n    drawId,\n    matchUpId,\n    matchUpFormat,\n    matchUpStatus,\n    winningSide,\n    score,\n  },\n];\nengine.bulkMatchUpStatusUpdate({ outcomes });\n"})}),"\n",(0,a.jsx)(n.hr,{}),"\n",(0,a.jsx)(n.h2,{id:"checkinparticipant",children:"checkInParticipant"}),"\n",(0,a.jsx)(n.p,{children:"Set the check-in state for a participant. Used to determine when both participants in a matchUp are available to be assigned to a court."}),"\n",(0,a.jsx)(n.pre,{children:(0,a.jsx)(n.code,{className:"language-js",children:"engine.checkInParticipant({\n  participantId,\n  matchUpId,\n  drawId,\n});\n"})}),"\n",(0,a.jsx)(n.hr,{}),"\n",(0,a.jsx)(n.h2,{id:"checkoutparticipant",children:"checkOutParticipant"}),"\n",(0,a.jsx)(n.pre,{children:(0,a.jsx)(n.code,{className:"language-js",children:"engine.checkOutParticipant({\n  participantId,\n  matchUpId,\n  drawId,\n});\n"})}),"\n",(0,a.jsx)(n.hr,{}),"\n",(0,a.jsx)(n.h2,{id:"disabletieautocalc",children:"disableTieAutoCalc"}),"\n",(0,a.jsx)(n.p,{children:"Disable default behavior of auto calculating TEAM matchUp scores."}),"\n",(0,a.jsx)(n.pre,{children:(0,a.jsx)(n.code,{className:"language-js",children:"engine.disableTieAutoCalc({ drawId, matchUpId });\n"})}),"\n",(0,a.jsx)(n.hr,{}),"\n",(0,a.jsx)(n.h2,{id:"enabletiaautocalc",children:"enableTiaAutoCalc"}),"\n",(0,a.jsx)(n.p,{children:"Re-enable default behavior of auto calculating TEAM matchUp scores, and trigger auto calculation."}),"\n",(0,a.jsx)(n.pre,{children:(0,a.jsx)(n.code,{className:"language-js",children:"engine.enableTieAutoCalc({ drawId, matchUpId });\n"})}),"\n",(0,a.jsx)(n.hr,{}),"\n",(0,a.jsx)(n.h2,{id:"findmatchup",children:"findMatchUp"}),"\n",(0,a.jsx)(n.pre,{children:(0,a.jsx)(n.code,{className:"language-js",children:"const {\n  matchUp,\n  structure, // returned for convenience\n} = engine.findMatchUp({\n  inContext, // optional - boolean - returns matchUp with additional attributes\n  matchUpId,\n  drawId,\n});\n"})}),"\n",(0,a.jsx)(n.hr,{}),"\n",(0,a.jsx)(n.h2,{id:"gethomeparticipantid",children:"getHomeParticipantId"}),"\n",(0,a.jsx)(n.pre,{children:(0,a.jsx)(n.code,{className:"language-js",children:"const { homeParticipantId } = engine.getHomeParticipantId({ matchUp });\n"})}),"\n",(0,a.jsx)(n.hr,{}),"\n",(0,a.jsx)(n.h2,{id:"modifymatchupformattiming",children:"modifyMatchUpFormatTiming"}),"\n",(0,a.jsx)(n.p,{children:"Modifies the average match duration and recovery time requirements for a specific matchUp format. This function adds an extension to the tournament record that overrides default scheduling policy timing."}),"\n",(0,a.jsx)(n.p,{children:(0,a.jsx)(n.strong,{children:"How it Works:"})}),"\n",(0,a.jsxs)(n.ul,{children:["\n",(0,a.jsx)(n.li,{children:"Adds a tournament-level extension that is read by scheduling functions"}),"\n",(0,a.jsx)(n.li,{children:"Persists across scheduling operations until explicitly modified or removed"}),"\n",(0,a.jsx)(n.li,{children:"Can be scoped to specific age categories (e.g., 'U12', 'U14')"}),"\n",(0,a.jsx)(n.li,{children:"Can specify different timings for SINGLES vs. DOUBLES"}),"\n",(0,a.jsx)(n.li,{children:"Multiple calls will merge/override previous values for the same format"}),"\n"]}),"\n",(0,a.jsx)(n.p,{children:(0,a.jsx)(n.strong,{children:"Parameters:"})}),"\n",(0,a.jsxs)(n.ul,{children:["\n",(0,a.jsxs)(n.li,{children:[(0,a.jsx)(n.code,{children:"matchUpFormat"})," - TODS matchUpFormat code (e.g., 'SET3-S:6/TB7')"]}),"\n",(0,a.jsxs)(n.li,{children:[(0,a.jsx)(n.code,{children:"averageTimes"})," - Array of timing configurations by category","\n",(0,a.jsxs)(n.ul,{children:["\n",(0,a.jsxs)(n.li,{children:[(0,a.jsx)(n.code,{children:"categoryNames"})," - Array of category names (empty array = default for all categories)"]}),"\n",(0,a.jsxs)(n.li,{children:[(0,a.jsx)(n.code,{children:"minutes"})," - Object with ",(0,a.jsx)(n.code,{children:"default"})," and/or event type keys (e.g., SINGLES, DOUBLES)"]}),"\n"]}),"\n"]}),"\n",(0,a.jsxs)(n.li,{children:[(0,a.jsx)(n.code,{children:"recoveryTimes"})," - Array of recovery configurations by category (same structure as averageTimes)"]}),"\n",(0,a.jsxs)(n.li,{children:[(0,a.jsx)(n.code,{children:"event"})," - Optional - Scope modification to specific event"]}),"\n",(0,a.jsxs)(n.li,{children:[(0,a.jsx)(n.code,{children:"drawId"})," - Optional - Scope modification to specific draw"]}),"\n",(0,a.jsxs)(n.li,{children:[(0,a.jsx)(n.code,{children:"eventId"})," - Optional - Scope modification to specific event"]}),"\n"]}),"\n",(0,a.jsxs)(n.p,{children:[(0,a.jsx)(n.strong,{children:"Returns:"})," Standard result object with success/error status"]}),"\n",(0,a.jsx)(n.pre,{children:(0,a.jsx)(n.code,{className:"language-js",children:"// Modify timing for a specific format with category-based differentiation\nengine.modifyMatchUpFormatTiming({\n  matchUpFormat: 'SET3-S:6/TB7',\n  averageTimes: [\n    {\n      categoryNames: ['U12', 'U14'],\n      minutes: { DOUBLES: 110, default: 130 },\n    },\n    {\n      categoryNames: ['U16', 'U18'],\n      minutes: { DOUBLES: 100, default: 120 },\n    },\n  ],\n  recoveryTimes: [{ categoryNames: [], minutes: { default: 15, DOUBLES: 15 } }],\n});\n\n// Retrieve existing modifications before updating\nconst { matchUpFormat, averageTimes, recoveryTimes } = engine.getModifiedMatchUpFormatTiming({\n  matchUpFormat: 'SET3-S:6/TB7',\n});\n"})}),"\n",(0,a.jsx)(n.p,{children:(0,a.jsx)(n.strong,{children:"Related Functions:"})}),"\n",(0,a.jsxs)(n.ul,{children:["\n",(0,a.jsxs)(n.li,{children:[(0,a.jsx)(n.code,{children:"getModifiedMatchUpFormatTiming()"})," - Query existing format timing modifications"]}),"\n",(0,a.jsxs)(n.li,{children:["See ",(0,a.jsx)(n.a,{href:"/docs/concepts/scheduling-policy",children:"Scheduling Policy"})," for policy configuration"]}),"\n"]}),"\n",(0,a.jsx)(n.hr,{}),"\n",(0,a.jsx)(n.h2,{id:"removematchupsideparticipant",children:"removeMatchUpSideParticipant"}),"\n",(0,a.jsx)(n.p,{children:"Removes participant assigned to AD_HOC matchUp."}),"\n",(0,a.jsx)(n.pre,{children:(0,a.jsx)(n.code,{className:"language-js",children:"engine.removeMatchUpSideParticipant({\n  sideNumber, // number - required\n  matchUpId, // required\n  drawId, // required\n});\n"})}),"\n",(0,a.jsx)(n.hr,{}),"\n",(0,a.jsx)(n.h2,{id:"replacetiematchupparticipantid",children:"replaceTieMatchUpParticipantId"}),"\n",(0,a.jsx)(n.pre,{children:(0,a.jsx)(n.code,{className:"language-js",children:"engine.replaceTieMatchUpParticipantId({\n  existingParticipantId,\n  newParticipantId,\n  tieMatchUpId,\n  drawId,\n});\n"})}),"\n",(0,a.jsx)(n.hr,{}),"\n",(0,a.jsx)(n.h2,{id:"removetiematchupparticipantid",children:"removeTieMatchUpParticipantId"}),"\n",(0,a.jsx)(n.pre,{children:(0,a.jsx)(n.code,{className:"language-js",children:"engine.removeTieMatchUpParticipantId({\n  participantId, // id of INDIVIDUAL or PAIR be removed\n  tieMatchUpId, // tieMatchUp, matchUpType either DOUBLES or SINGLES\n  drawId, // draw within which tieMatchUp is found\n});\n"})}),"\n",(0,a.jsx)(n.hr,{}),"\n",(0,a.jsx)(n.h2,{id:"resetadhocmatchups",children:"resetAdHocMatchUps"}),"\n",(0,a.jsx)(n.p,{children:"Will remove all results (scores) and optionally all participant assignments from specified matchUps (via matchUpIds or roundNumbers)."}),"\n",(0,a.jsx)(n.pre,{children:(0,a.jsx)(n.code,{className:"language-js",children:"const result = engine.resetAdHocMatchUps({\n  removeAssignments, // optional; remove all assigned participants\n  roundNumbers, // optional if matchUpids provided\n  matchUpIds, // optional only if roundNumber(s) provided\n  structureId, // optional unless matchUpIds not provided\n  drawId,\n};\n\nexport function resetAdHocMatchUps(params: ResetAdHocMatchUps) {\n  const paramsCheck = checkRequiredParameters(params, [\n    { [DRAW_DEFINITION]: true, [EVENT]: true },\n    {\n      [ONE_OF]: { [MATCHUP_IDS]: false, roundNumbers: false },\n      [INVALID]: INVALID_VALUES,\n      [OF_TYPE]: ARRAY,\n    },\n  ]);\n  if (paramsCheck.error) return paramsCheck;\n\n  const structureResult = getAdHocStructureDetails(params);\n  if (structureResult.error) return structureResult;\n  const { matchUpIds } = structureResult;\n})\n"})}),"\n",(0,a.jsx)(n.hr,{}),"\n",(0,a.jsx)(n.h2,{id:"resetscorecard",children:"resetScorecard"}),"\n",(0,a.jsxs)(n.p,{children:["Removes all scores from ",(0,a.jsx)(n.code,{children:"tieMatchUps"})," within a TEAM ",(0,a.jsx)(n.code,{children:"matchUp"}),"; preserves ",(0,a.jsx)(n.code,{children:"lineUps"}),"."]}),"\n",(0,a.jsx)(n.pre,{children:(0,a.jsx)(n.code,{className:"language-js",children:"engine.resetScorecard({\n  tiebreakReset, // optional boolean - check for tiebreak scenarios and reset tieFormat\n  tournamentId, // required\n  matchUpId, // required - must be a TEAM matchUp\n  drawId, // required\n});\n"})}),"\n",(0,a.jsx)(n.hr,{}),"\n",(0,a.jsx)(n.h2,{id:"resettieformat",children:"resetTieFormat"}),"\n",(0,a.jsxs)(n.p,{children:["Remove the ",(0,a.jsx)(n.code,{children:"tieFormat"})," from a TEAM ",(0,a.jsx)(n.code,{children:"matchUp"})," if there is a ",(0,a.jsx)(n.code,{children:"tieFormat"})," further up the hierarchy; modifies ",(0,a.jsx)(n.code,{children:"matchUp.tieMatchUps"})," to correspond."]}),"\n",(0,a.jsx)(n.pre,{children:(0,a.jsx)(n.code,{className:"language-js",children:"engine.resetTieFormat({\n  tournamentId, // required\n  matchUpId, // must be a TEAM matchUp\n  drawId, // required\n  uuids, // optional - in client/server scenarios generated matchUps must have equivalent matchUpIds\n});\n"})}),"\n",(0,a.jsx)(n.hr,{}),"\n",(0,a.jsx)(n.h2,{id:"setmatchupdailylimits",children:"setMatchUpDailyLimits"}),"\n",(0,a.jsx)(n.p,{children:"Sets daily match limits for participants. This function adds an extension to the tournament record that is enforced by all scheduling functions to prevent over-scheduling players."}),"\n",(0,a.jsx)(n.p,{children:(0,a.jsx)(n.strong,{children:"How it Works:"})}),"\n",(0,a.jsxs)(n.ul,{children:["\n",(0,a.jsx)(n.li,{children:"Adds a tournament-level extension that is checked by scheduling functions"}),"\n",(0,a.jsx)(n.li,{children:"Persists across scheduling operations until explicitly modified"}),"\n",(0,a.jsx)(n.li,{children:"Enforced during both manual and automated scheduling"}),"\n",(0,a.jsx)(n.li,{children:"Can be scoped to specific tournament in multi-tournament scenarios"}),"\n",(0,a.jsx)(n.li,{children:"Multiple calls will override previous values entirely"}),"\n"]}),"\n",(0,a.jsx)(n.p,{children:(0,a.jsx)(n.strong,{children:"Parameters:"})}),"\n",(0,a.jsxs)(n.ul,{children:["\n",(0,a.jsxs)(n.li,{children:[(0,a.jsx)(n.code,{children:"dailyLimits"})," - Object specifying limits:","\n",(0,a.jsxs)(n.ul,{children:["\n",(0,a.jsxs)(n.li,{children:[(0,a.jsx)(n.code,{children:"SINGLES"})," - Maximum singles matches per day per participant"]}),"\n",(0,a.jsxs)(n.li,{children:[(0,a.jsx)(n.code,{children:"DOUBLES"})," - Maximum doubles matches per day per participant"]}),"\n",(0,a.jsxs)(n.li,{children:[(0,a.jsx)(n.code,{children:"total"})," - Maximum total matches per day per participant (across all event types)"]}),"\n"]}),"\n"]}),"\n",(0,a.jsxs)(n.li,{children:[(0,a.jsx)(n.code,{children:"tournamentId"})," - Optional - Scope to specific tournament (for multi-tournament records)"]}),"\n"]}),"\n",(0,a.jsxs)(n.p,{children:[(0,a.jsx)(n.strong,{children:"Returns:"})," Standard result object with success/error status"]}),"\n",(0,a.jsx)(n.pre,{children:(0,a.jsx)(n.code,{className:"language-js",children:"// Set tournament-wide daily limits\nengine.setMatchUpDailyLimits({\n  dailyLimits: { SINGLES: 2, DOUBLES: 1, total: 3 },\n});\n\n// Scope to specific tournament\nengine.setMatchUpDailyLimits({\n  dailyLimits: { SINGLES: 1, DOUBLES: 1, total: 2 },\n  tournamentId: 'tournament-123',\n});\n\n// Retrieve current daily limits\nconst { matchUpDailyLimits } = engine.getMatchUpDailyLimits();\nconst { SINGLES, DOUBLES, total } = matchUpDailyLimits;\n"})}),"\n",(0,a.jsx)(n.p,{children:(0,a.jsx)(n.strong,{children:"Related Functions:"})}),"\n",(0,a.jsxs)(n.ul,{children:["\n",(0,a.jsxs)(n.li,{children:[(0,a.jsx)(n.code,{children:"getMatchUpDailyLimits()"})," - Query current daily limit configuration"]}),"\n",(0,a.jsxs)(n.li,{children:["See ",(0,a.jsx)(n.a,{href:"/docs/concepts/scheduling-policy",children:"Scheduling Policy"})," for policy-based limits"]}),"\n"]}),"\n",(0,a.jsx)(n.hr,{}),"\n",(0,a.jsx)(n.h2,{id:"setmatchupformat",children:"setMatchUpFormat"}),"\n",(0,a.jsxs)(n.p,{children:["Sets the ",(0,a.jsx)(n.code,{children:"matchUpFormat"})," for a specific ",(0,a.jsx)(n.code,{children:"matchUp"})," or for any scope within the hierarchy of a ",(0,a.jsx)(n.code,{children:"tournamentRecord"}),"."]}),"\n",(0,a.jsxs)(n.admonition,{type:"info",children:[(0,a.jsxs)(n.p,{children:["If an array of ",(0,a.jsx)(n.code,{children:"scheduledDates"})," is provided then ",(0,a.jsx)(n.code,{children:"matchUps"})," which have ",(0,a.jsx)(n.code,{children:"matchUpStatus: TO_BE_PLAYED"})," and are scheduled to be played on the specified dates will have their ",(0,a.jsx)(n.code,{children:"matchUpFormat"})," fixed rather than inherited. This means that subsequent changes to the parent ",(0,a.jsx)(n.code,{children:"structure.matchUpFormat"})," will have no effect on such ",(0,a.jsx)(n.code,{children:"matchUps"}),"."]}),(0,a.jsxs)(n.p,{children:["The ",(0,a.jsx)(n.code,{children:"force"})," attribute will remove the ",(0,a.jsx)(n.code,{children:"matchUpFormat"})," from all targeted ",(0,a.jsx)(n.code,{children:"matchUps"})," which have ",(0,a.jsx)(n.code,{children:"matchUpStatus: TO_BE_PLAYED"}),"; this allows the effect of using ",(0,a.jsx)(n.code,{children:"scheduledDates"})," to be reversed. Use of this attribute will have no effect if ",(0,a.jsx)(n.code,{children:"scheduledDates"})," is also provided."]})]}),"\n",(0,a.jsx)(n.pre,{children:(0,a.jsx)(n.code,{className:"language-js",children:"engine.setMatchUpFormat({\n  matchUpFormat, // TODS matchUpFormatCode\n  eventType, // optional - restrict to SINGLES or DOUBLES\n\n  matchUpId, // optional - set matchUpFormat for a specific matchUp\n  drawId, // required only if matchUpId, structureId or structureIds is present\n  force, // optional boolean - when setting for structure, draws or events, strip any defined matchUpFormat from all TO_BE_PLAYED matchUps\n\n  // scoping options\n  scheduledDates, // optional - ['2022-01-01']\n  stageSequences, // optional - [1, 2]\n  structureIds, // optional - ['structureId1', 'structureId2']\n  structureId, // optional\n  eventIds, // optional - ['eventId1', 'eventId2']\n  eventId, // optional\n  drawIds, // optional - ['drawId1', 'drawId2']\n  stages, // optional - ['MAIN', 'CONSOLATION']\n});\n"})}),"\n",(0,a.jsx)(n.hr,{}),"\n",(0,a.jsx)(n.h2,{id:"setmatchuphomeparticipantid",children:"setMatchUpHomeParticipantId"}),"\n",(0,a.jsxs)(n.p,{children:["Value ",(0,a.jsx)(n.code,{children:"homeParticipantId"})," will appear in hydrated ",(0,a.jsx)(n.code,{children:"matchUps.schedule"}),"."]}),"\n",(0,a.jsx)(n.pre,{children:(0,a.jsx)(n.code,{className:"language-js",children:"engine.setMatchUpHomeParticipantId({\n  disableNotice, // when disabled subscribers will not be notified\n  homeParticipantId, // empty string ('') will remove\n  removePriorValues, // optional boolean\n  matchUpId,\n  drawId,\n});\n"})}),"\n",(0,a.jsx)(n.hr,{}),"\n",(0,a.jsx)(n.h2,{id:"setmatchupstatus",children:"setMatchUpStatus"}),"\n",(0,a.jsx)(n.p,{children:"Sets either matchUpStatus or score and winningSide; values to be set are passed in outcome object. Handles any winner/loser participant movements within or across structures."}),"\n",(0,a.jsx)(n.pre,{children:(0,a.jsx)(n.code,{className:"language-js",children:"const outcome = {\n  matchUpStatus, // optional\n  winningSide, // optional\n  score, // optional\n};\n\nengine.setMatchUpStatus({\n  disableScoreValidation, // optional boolean\n  allowChangePropagation, // optional boolean - allow winner/loser to be swapped and propgate change throughout draw structures\n  disableAutoCalc, // optional - applies only to { matchUpType: TEAM }\n  enableAutoCalc, // optional - applies only to { matchUpType: TEAM }\n  tournamentId,\n  matchUpTieId, // optional - if part of a TIE matchUp\n  matchUpId,\n  outcome, // optional\n  drawId,\n  schedule: {\n    // optional - set schedule items\n    courtIds, // optional - applies only to TEAM matchUps => creates .allocatedCourts\n    courtId, // requires scheduledDate\n    venueId,\n    scheduledDate,\n    scheduledTime,\n    startTime,\n    endTime,\n  },\n  notes, // optional - add note (string) to matchUp object\n});\n"})}),"\n",(0,a.jsx)(n.hr,{}),"\n",(0,a.jsx)(n.h2,{id:"setorderoffinish",children:"setOrderOfFinish"}),"\n",(0,a.jsxs)(n.p,{children:["Sets the ",(0,a.jsx)(n.code,{children:"orderOfFinish"})," attribute for ",(0,a.jsx)(n.code,{children:"matchUps"})," specified by ",(0,a.jsx)(n.code,{children:"matchUpId"})," in the ",(0,a.jsx)(n.code,{children:"finishingOrder"})," array."]}),"\n",(0,a.jsx)(n.h3,{id:"validation",children:"Validation"}),"\n",(0,a.jsxs)(n.p,{children:["Validation is done within a ",(0,a.jsx)(n.em,{children:"cohort"})," of ",(0,a.jsx)(n.code,{children:"matchUps"})," which have equivalent ",(0,a.jsx)(n.code,{children:"structureId"}),", ",(0,a.jsx)(n.code,{children:"matchUpType"}),", ",(0,a.jsx)(n.code,{children:"roundNumber"}),", and ",(0,a.jsx)(n.code,{children:"matchUpTieId"})," (if applicable)."]}),"\n",(0,a.jsxs)(n.ul,{children:["\n",(0,a.jsxs)(n.li,{children:[(0,a.jsx)(n.code,{children:"matchUpIds"})," in ",(0,a.jsx)(n.code,{children:"finishingOrder"})," must be part of the same ",(0,a.jsx)(n.em,{children:"cohort"})]}),"\n",(0,a.jsxs)(n.li,{children:[(0,a.jsx)(n.code,{children:"orderOfFinish"})," values must be unique positive integers within the ",(0,a.jsx)(n.em,{children:"cohort"})]}),"\n"]}),"\n",(0,a.jsx)(n.pre,{children:(0,a.jsx)(n.code,{className:"language-js",children:"engine.setOrderOfFinish({\n  finishingOrder: [{ matchUpId, orderOfFinish: 1 }],\n  drawId,\n});\n"})}),"\n",(0,a.jsx)(n.hr,{}),"\n",(0,a.jsx)(n.h2,{id:"toggleparticipantcheckinstate",children:"toggleParticipantCheckInState"}),"\n",(0,a.jsx)(n.pre,{children:(0,a.jsx)(n.code,{className:"language-js",children:"engine.toggleParticipantCheckInState({\n  participantId,\n  tournamentId,\n  matchUpId,\n  drawId,\n});\n"})}),"\n",(0,a.jsx)(n.hr,{}),"\n",(0,a.jsx)(n.h2,{id:"updatetiematchupscore",children:"updateTieMatchUpScore"}),"\n",(0,a.jsx)(n.p,{children:"Trigger automatic calculation of the score of a TEAM matchUp."}),"\n",(0,a.jsx)(n.pre,{children:(0,a.jsx)(n.code,{className:"language-js",children:"engine.updateTieMatchUpScore({\n  tournamentId, // optional if default tournament set\n  matchUpId,\n  drawId,\n});\n"})}),"\n",(0,a.jsx)(n.hr,{})]})}function h(e={}){const{wrapper:n}={...(0,r.R)(),...e.components};return n?(0,a.jsx)(n,{...e,children:(0,a.jsx)(o,{...e})}):o(e)}},8322(e,n,t){t.d(n,{R:()=>s,x:()=>d});var i=t(758);const a={},r=i.createContext(a);function s(e){const n=i.useContext(r);return i.useMemo(function(){return"function"==typeof e?e(n):{...n,...e}},[n,e])}function d(e){let n;return n=e.disableParentContext?"function"==typeof e.components?e.components(a):e.components||a:s(e.components),i.createElement(r.Provider,{value:n},e.children)}}}]);