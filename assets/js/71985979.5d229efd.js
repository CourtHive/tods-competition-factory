"use strict";(globalThis.webpackChunkdocumentation=globalThis.webpackChunkdocumentation||[]).push([[3170],{3366(e,n,t){t.r(n),t.d(n,{assets:()=>l,contentTitle:()=>r,default:()=>h,frontMatter:()=>i,metadata:()=>o,toc:()=>d});const o=JSON.parse('{"id":"concepts/mutation-locks","title":"Mutation Locks","description":"Overview","source":"@site/docs/concepts/mutation-locks.md","sourceDirName":"concepts","slug":"/concepts/mutation-locks","permalink":"/competition-factory/docs/concepts/mutation-locks","draft":false,"unlisted":false,"tags":[],"version":"current","frontMatter":{"title":"Mutation Locks"},"sidebar":"docs","previous":{"title":"Workflows and Best Practices","permalink":"/competition-factory/docs/concepts/publishing/publishing-workflows"},"next":{"title":"Overview","permalink":"/competition-factory/docs/engines/state-engines"}}');var s=t(6070),c=t(8322);const i={title:"Mutation Locks"},r=void 0,l={},d=[{value:"Overview",id:"overview",level:2},{value:"Key Concepts",id:"key-concepts",level:3},{value:"Use Cases",id:"use-cases",level:3},{value:"Enabling Mutation Locks",id:"enabling-mutation-locks",level:2},{value:"Lock Hierarchy",id:"lock-hierarchy",level:2},{value:"Example: Draw-Scoped Scoring Lock",id:"example-draw-scoped-scoring-lock",level:3},{value:"Example: Event-Level Lock",id:"example-event-level-lock",level:3},{value:"Example: Tournament-Level Lock",id:"example-tournament-level-lock",level:3},{value:"Lock Scopes",id:"lock-scopes",level:2},{value:"Method-Level Locks",id:"method-level-locks",level:2},{value:"Lock Expiry",id:"lock-expiry",level:2},{value:"Passing lockToken",id:"passing-locktoken",level:2},{value:"API Reference",id:"api-reference",level:2},{value:"addMutationLock",id:"addmutationlock",level:3},{value:"removeMutationLock",id:"removemutationlock",level:3},{value:"getMutationLocks",id:"getmutationlocks",level:3},{value:"cleanExpiredMutationLocks",id:"cleanexpiredmutationlocks",level:3},{value:"Extension Structure",id:"extension-structure",level:2},{value:"Error Constants",id:"error-constants",level:2},{value:"Interception Architecture",id:"interception-architecture",level:2},{value:"Integration Patterns",id:"integration-patterns",level:2},{value:"Server-Side Token Issuance",id:"server-side-token-issuance",level:3},{value:"ExecutionQueue with Locks",id:"executionqueue-with-locks",level:3},{value:"Admin Force Release",id:"admin-force-release",level:3},{value:"Related Documentation",id:"related-documentation",level:2}];function a(e){const n={a:"a",code:"code",h2:"h2",h3:"h3",hr:"hr",li:"li",ol:"ol",p:"p",pre:"pre",strong:"strong",table:"table",tbody:"tbody",td:"td",th:"th",thead:"thead",tr:"tr",ul:"ul",...(0,c.R)(),...e.components};return(0,s.jsxs)(s.Fragment,{children:[(0,s.jsx)(n.h2,{id:"overview",children:"Overview"}),"\n",(0,s.jsxs)(n.p,{children:["Mutation locks provide concurrency control for scoped mutations within a tournament record. They allow a calling application to restrict who can perform certain operations \u2014 like scheduling, scoring, or draw modifications \u2014 by requiring a matching ",(0,s.jsx)(n.code,{children:"lockToken"})," on mutation calls."]}),"\n",(0,s.jsxs)(n.p,{children:["The factory is ",(0,s.jsx)(n.strong,{children:"agnostic to user identity"}),". It stores locks as ",(0,s.jsx)(n.a,{href:"./extensions",children:"extensions"})," and performs a simple string equality check on ",(0,s.jsx)(n.code,{children:"lockToken"}),". The calling application (TMX, competition-factory-server) handles identity, authorization, and token issuance."]}),"\n",(0,s.jsx)(n.h3,{id:"key-concepts",children:"Key Concepts"}),"\n",(0,s.jsxs)(n.p,{children:[(0,s.jsx)(n.strong,{children:"Opt-in"}),": Mutation lock checking is only active when the tournament-level ",(0,s.jsx)(n.code,{children:"mutationLocks"})," extension has ",(0,s.jsx)(n.code,{children:"enabled: true"}),". Without this, every mutation call bypasses lock logic with zero overhead."]}),"\n",(0,s.jsxs)(n.p,{children:[(0,s.jsx)(n.strong,{children:"Hierarchical"}),": Locks can be placed at the tournament, event, draw, or venue level. A lock at a higher level blocks mutations on all child elements."]}),"\n",(0,s.jsxs)(n.p,{children:[(0,s.jsx)(n.strong,{children:"Scoped"}),": Each lock targets a specific mutation domain (SCHEDULING, SCORING, DRAWS, etc.). Only mutations in that domain are affected."]}),"\n",(0,s.jsxs)(n.p,{children:[(0,s.jsx)(n.strong,{children:"Token-based"}),": Callers pass a ",(0,s.jsx)(n.code,{children:"lockToken"})," parameter on mutation calls. If the token matches the active lock, the call is allowed. The factory never interprets the token."]}),"\n",(0,s.jsxs)(n.p,{children:[(0,s.jsx)(n.strong,{children:"Auto-cleanup"}),": Locks are stored on the element they scope to. If an event or draw is deleted, its locks are automatically deleted with it."]}),"\n",(0,s.jsx)(n.h3,{id:"use-cases",children:"Use Cases"}),"\n",(0,s.jsxs)(n.p,{children:[(0,s.jsx)(n.strong,{children:"Exclusive scheduling"}),": A user takes control of scheduling for offline bulk work. Other users' scheduling mutations are blocked until the lock is released."]}),"\n",(0,s.jsxs)(n.p,{children:[(0,s.jsx)(n.strong,{children:"Scoring assignment"}),": An admin assigns scoring for a specific draw to a specific user. Only that user (with the matching token) can score matchUps in that draw."]}),"\n",(0,s.jsxs)(n.p,{children:[(0,s.jsx)(n.strong,{children:"Permanent restriction"}),": Certain operations (e.g., deleting draws) are permanently blocked for non-admin users by setting ",(0,s.jsx)(n.code,{children:"expiresAt: null"})," with a method-level lock."]}),"\n",(0,s.jsx)(n.hr,{}),"\n",(0,s.jsx)(n.h2,{id:"enabling-mutation-locks",children:"Enabling Mutation Locks"}),"\n",(0,s.jsxs)(n.p,{children:["Mutation locks are opt-in. The feature activates automatically when ",(0,s.jsx)(n.code,{children:"addMutationLock"})," is called \u2014 there is no separate setup step."]}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-js",children:"// This single call enables the feature and creates the lock\nengine.addMutationLock({\n  scope: 'SCHEDULING',\n  lockToken: 'user-session-token',\n});\n"})}),"\n",(0,s.jsxs)(n.p,{children:["Behind the scenes, ",(0,s.jsx)(n.code,{children:"addMutationLock"})," ensures a tournament-level ",(0,s.jsx)(n.code,{children:"mutationLocks"})," extension exists with ",(0,s.jsx)(n.code,{children:"enabled: true"}),". This is the gate that the interceptor checks on every mutation call."]}),"\n",(0,s.jsxs)(n.p,{children:["For tournaments without locks (the vast majority), the interceptor performs a single fast in-memory array scan on ",(0,s.jsx)(n.code,{children:"tournamentRecord.extensions"})," and returns immediately \u2014 no function calls, no hierarchy traversal."]}),"\n",(0,s.jsx)(n.hr,{}),"\n",(0,s.jsx)(n.h2,{id:"lock-hierarchy",children:"Lock Hierarchy"}),"\n",(0,s.jsx)(n.p,{children:"Locks can be placed at four levels. A lock at any level blocks mutations on that level and all child elements:"}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-text",children:"tournamentRecord        \u2190 tournament-level lock blocks everything\n  \u251c\u2500\u2500 event             \u2190 event-level lock blocks all draws in the event\n  \u2502   \u251c\u2500\u2500 drawDefinition \u2190 draw-level lock blocks only this draw\n  \u2502   \u2514\u2500\u2500 drawDefinition\n  \u251c\u2500\u2500 event\n  \u2514\u2500\u2500 venue             \u2190 venue-level lock blocks only this venue\n"})}),"\n",(0,s.jsx)(n.h3,{id:"example-draw-scoped-scoring-lock",children:"Example: Draw-Scoped Scoring Lock"}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-js",children:"// Lock scoring on a specific draw\nengine.addMutationLock({\n  scope: 'SCORING',\n  lockToken: 'scorer-abc',\n  drawId: 'draw-123',\n});\n\n// This call is BLOCKED (no lockToken)\nengine.setMatchUpStatus({\n  matchUpId: 'match-1',\n  drawId: 'draw-123',\n  outcome: { matchUpStatus: 'COMPLETED', winningSide: 1 },\n});\n// \u2192 { error: MUTATION_LOCKED }\n\n// This call PASSES (correct lockToken)\nengine.setMatchUpStatus({\n  matchUpId: 'match-1',\n  drawId: 'draw-123',\n  outcome: { matchUpStatus: 'COMPLETED', winningSide: 1 },\n  lockToken: 'scorer-abc',\n});\n// \u2192 { success: true }\n"})}),"\n",(0,s.jsx)(n.h3,{id:"example-event-level-lock",children:"Example: Event-Level Lock"}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-js",children:"// Lock scoring for all draws in an event\nengine.addMutationLock({\n  scope: 'SCORING',\n  lockToken: 'event-admin-token',\n  eventId: 'event-456',\n});\n\n// Scoring any matchUp in any draw within this event requires the token\n"})}),"\n",(0,s.jsx)(n.h3,{id:"example-tournament-level-lock",children:"Example: Tournament-Level Lock"}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-js",children:"// Lock all scheduling across the tournament\nengine.addMutationLock({\n  scope: 'SCHEDULING',\n  lockToken: 'scheduler-token',\n});\n\n// All scheduling mutations across all draws/events require the token\n"})}),"\n",(0,s.jsx)(n.hr,{}),"\n",(0,s.jsx)(n.h2,{id:"lock-scopes",children:"Lock Scopes"}),"\n",(0,s.jsx)(n.p,{children:"Each lock targets a specific mutation domain. Only mutations mapped to that domain are affected \u2014 query methods are never blocked."}),"\n",(0,s.jsxs)(n.table,{children:[(0,s.jsx)(n.thead,{children:(0,s.jsxs)(n.tr,{children:[(0,s.jsx)(n.th,{children:"Scope"}),(0,s.jsx)(n.th,{children:"Governor"}),(0,s.jsx)(n.th,{children:"Blocked Operations"})]})}),(0,s.jsxs)(n.tbody,{children:[(0,s.jsxs)(n.tr,{children:[(0,s.jsx)(n.td,{children:(0,s.jsx)(n.code,{children:"SCHEDULING"})}),(0,s.jsx)(n.td,{children:"scheduleGovernor"}),(0,s.jsx)(n.td,{children:"scheduleMatchUps, assignMatchUpCourt, clearScheduledMatchUps, ..."})]}),(0,s.jsxs)(n.tr,{children:[(0,s.jsx)(n.td,{children:(0,s.jsx)(n.code,{children:"SCORING"})}),(0,s.jsx)(n.td,{children:"matchUpGovernor, scoreGovernor"}),(0,s.jsx)(n.td,{children:"setMatchUpStatus, setMatchUpState, resetScorecard, addPoint, ..."})]}),(0,s.jsxs)(n.tr,{children:[(0,s.jsx)(n.td,{children:(0,s.jsx)(n.code,{children:"DRAWS"})}),(0,s.jsx)(n.td,{children:"drawsGovernor"}),(0,s.jsx)(n.td,{children:"setPositionAssignments, resetDrawDefinition, assignDrawPosition, generateDrawDefinition, ..."})]}),(0,s.jsxs)(n.tr,{children:[(0,s.jsx)(n.td,{children:(0,s.jsx)(n.code,{children:"MATCHUPS"})}),(0,s.jsx)(n.td,{children:"matchUpGovernor"}),(0,s.jsx)(n.td,{children:"assignMatchUpSideParticipant, substituteParticipant, setMatchUpFormat, ..."})]}),(0,s.jsxs)(n.tr,{children:[(0,s.jsx)(n.td,{children:(0,s.jsx)(n.code,{children:"PARTICIPANTS"})}),(0,s.jsx)(n.td,{children:"participantGovernor"}),(0,s.jsx)(n.td,{children:"addParticipants, modifyParticipant, deleteParticipants, ..."})]}),(0,s.jsxs)(n.tr,{children:[(0,s.jsx)(n.td,{children:(0,s.jsx)(n.code,{children:"ENTRIES"})}),(0,s.jsx)(n.td,{children:"entriesGovernor"}),(0,s.jsx)(n.td,{children:"modifyEventEntries, addEventEntries, promoteAlternate, ..."})]}),(0,s.jsxs)(n.tr,{children:[(0,s.jsx)(n.td,{children:(0,s.jsx)(n.code,{children:"EVENTS"})}),(0,s.jsx)(n.td,{children:"eventGovernor"}),(0,s.jsx)(n.td,{children:"addEvent, deleteEvents, deleteDrawDefinitions, modifyEvent, ..."})]}),(0,s.jsxs)(n.tr,{children:[(0,s.jsx)(n.td,{children:(0,s.jsx)(n.code,{children:"VENUES"})}),(0,s.jsx)(n.td,{children:"venueGovernor"}),(0,s.jsx)(n.td,{children:"addVenue, deleteVenue, addCourt, modifyCourt, ..."})]}),(0,s.jsxs)(n.tr,{children:[(0,s.jsx)(n.td,{children:(0,s.jsx)(n.code,{children:"PUBLISHING"})}),(0,s.jsx)(n.td,{children:"publishingGovernor"}),(0,s.jsx)(n.td,{children:"publishEvent, unPublishEvent, publishOrderOfPlay, ..."})]}),(0,s.jsxs)(n.tr,{children:[(0,s.jsx)(n.td,{children:(0,s.jsx)(n.code,{children:"TOURNAMENT"})}),(0,s.jsx)(n.td,{children:"tournamentGovernor"}),(0,s.jsx)(n.td,{children:"setTournamentName, setTournamentDates, addTournamentExtension, ..."})]}),(0,s.jsxs)(n.tr,{children:[(0,s.jsx)(n.td,{children:(0,s.jsx)(n.code,{children:"TIE_FORMAT"})}),(0,s.jsx)(n.td,{children:"tieFormatGovernor"}),(0,s.jsx)(n.td,{children:"modifyTieFormat, addCollectionDefinition, ..."})]}),(0,s.jsxs)(n.tr,{children:[(0,s.jsx)(n.td,{children:(0,s.jsx)(n.code,{children:"POLICY"})}),(0,s.jsx)(n.td,{children:"policyGovernor"}),(0,s.jsx)(n.td,{children:"attachPolicies, removePolicy"})]}),(0,s.jsxs)(n.tr,{children:[(0,s.jsx)(n.td,{children:(0,s.jsx)(n.code,{children:"COMPETITION"})}),(0,s.jsx)(n.td,{children:"competitionGovernor"}),(0,s.jsx)(n.td,{children:"linkTournaments, unlinkTournament, ..."})]}),(0,s.jsxs)(n.tr,{children:[(0,s.jsx)(n.td,{children:(0,s.jsx)(n.code,{children:"RANKING"})}),(0,s.jsx)(n.td,{children:"rankingGovernor"}),(0,s.jsx)(n.td,{children:"applyTournamentRankingPoints"})]})]})]}),"\n",(0,s.jsxs)(n.p,{children:["Methods not in the scope map (queries, lock management methods) are ",(0,s.jsx)(n.strong,{children:"never blocked"}),"."]}),"\n",(0,s.jsx)(n.hr,{}),"\n",(0,s.jsx)(n.h2,{id:"method-level-locks",children:"Method-Level Locks"}),"\n",(0,s.jsxs)(n.p,{children:["For fine-grained control, a lock can specify a ",(0,s.jsx)(n.code,{children:"methods"})," array to restrict only specific methods within a scope:"]}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-js",children:"// Block only draw deletion, not other event mutations\nengine.addMutationLock({\n  scope: 'EVENTS',\n  lockToken: 'admin-token',\n  methods: ['deleteDrawDefinitions', 'deleteEvents'],\n});\n\n// addEvent still works (not in methods list)\nengine.addEvent({ event: { eventName: 'New Event', eventType: 'SINGLES' } });\n// \u2192 { success: true }\n\n// deleteEvents is blocked\nengine.deleteEvents({ eventIds: ['event-1'] });\n// \u2192 { error: MUTATION_LOCKED }\n\n// deleteEvents with correct token passes\nengine.deleteEvents({ eventIds: ['event-1'], lockToken: 'admin-token' });\n// \u2192 passes lock check\n"})}),"\n",(0,s.jsx)(n.hr,{}),"\n",(0,s.jsx)(n.h2,{id:"lock-expiry",children:"Lock Expiry"}),"\n",(0,s.jsx)(n.p,{children:"Locks can be permanent or time-limited:"}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-js",children:"// Permanent lock (never expires)\nengine.addMutationLock({\n  scope: 'SCHEDULING',\n  lockToken: 'token',\n  expiresAt: null, // default\n});\n\n// Time-limited lock (expires at a specific UTC time)\nengine.addMutationLock({\n  scope: 'SCHEDULING',\n  lockToken: 'token',\n  expiresAt: '2026-03-01T12:00:00.000Z',\n});\n"})}),"\n",(0,s.jsxs)(n.p,{children:["Expired locks are cleaned up lazily (removed when encountered during a lock check) and can also be proactively removed with ",(0,s.jsx)(n.code,{children:"cleanExpiredMutationLocks"}),"."]}),"\n",(0,s.jsx)(n.hr,{}),"\n",(0,s.jsx)(n.h2,{id:"passing-locktoken",children:"Passing lockToken"}),"\n",(0,s.jsxs)(n.p,{children:["Callers include ",(0,s.jsx)(n.code,{children:"lockToken"})," as a parameter on any mutation call:"]}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-js",children:"// Direct engine call\nengine.scheduleMatchUps({ lockToken: 'user-token', ...otherParams });\n\n// Via executionQueue\nengine.executionQueue([\n  { method: 'scheduleMatchUps', params: { lockToken: 'user-token', ... } },\n  { method: 'assignMatchUpCourt', params: { lockToken: 'user-token', ... } },\n]);\n"})}),"\n",(0,s.jsx)(n.hr,{}),"\n",(0,s.jsx)(n.h2,{id:"api-reference",children:"API Reference"}),"\n",(0,s.jsx)(n.h3,{id:"addmutationlock",children:"addMutationLock"}),"\n",(0,s.jsx)(n.p,{children:"Acquires a mutation lock on a tournament element. Automatically enables the mutation locks feature gate."}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-js",children:"const { success, lockId } = engine.addMutationLock({\n  scope,      // required - MutationLockScope (e.g. 'SCHEDULING', 'SCORING')\n  lockToken,  // required - opaque string token\n  expiresAt,  // optional - ISO 8601 UTC string or null for permanent (default: null)\n  methods,    // optional - string[] to restrict lock to specific methods within scope\n  drawId,     // optional - lock on specific draw\n  eventId,    // optional - lock on specific event\n  venueId,    // optional - lock on specific venue\n  // no drawId/eventId/venueId = tournament-level lock\n});\n"})}),"\n",(0,s.jsxs)(n.p,{children:[(0,s.jsx)(n.strong,{children:"Upsert behavior"}),": If a lock already exists on the same scope with the ",(0,s.jsx)(n.strong,{children:"same token"}),", the lock is updated (expiresAt, methods). If the token is ",(0,s.jsx)(n.strong,{children:"different"}),", ",(0,s.jsx)(n.code,{children:"MUTATION_LOCK_EXISTS"})," is returned."]}),"\n",(0,s.jsx)(n.hr,{}),"\n",(0,s.jsx)(n.h3,{id:"removemutationlock",children:"removeMutationLock"}),"\n",(0,s.jsxs)(n.p,{children:["Releases a mutation lock. Requires the matching ",(0,s.jsx)(n.code,{children:"lockToken"})," unless ",(0,s.jsx)(n.code,{children:"forceRelease: true"}),"."]}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-js",children:"const { success } = engine.removeMutationLock({\n  lockId,       // optional - identify lock by ID\n  scope,        // optional - identify lock by scope (alternative to lockId)\n  lockToken,    // required unless forceRelease\n  forceRelease, // optional - bypass token check (for admin override)\n  drawId,       // optional - target element\n  eventId,      // optional - target element\n  venueId,      // optional - target element\n});\n"})}),"\n",(0,s.jsxs)(n.p,{children:[(0,s.jsx)(n.strong,{children:"Errors"}),": ",(0,s.jsx)(n.code,{children:"MUTATION_LOCK_NOT_FOUND"})," if no matching lock exists. ",(0,s.jsx)(n.code,{children:"UNAUTHORIZED_LOCK_OPERATION"})," if token doesn't match."]}),"\n",(0,s.jsx)(n.hr,{}),"\n",(0,s.jsx)(n.h3,{id:"getmutationlocks",children:"getMutationLocks"}),"\n",(0,s.jsx)(n.p,{children:"Returns all active (non-expired) locks across the entire tournament, with element context."}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-js",children:"const { mutationLocks } = engine.getMutationLocks({\n  scope, // optional - filter by scope\n});\n\n// Each lock includes:\n// { lockId, lockToken, scope, methods?, expiresAt, createdAt, drawId?, eventId?, venueId? }\n"})}),"\n",(0,s.jsxs)(n.p,{children:["Tournament-level locks have no ",(0,s.jsx)(n.code,{children:"drawId"}),"/",(0,s.jsx)(n.code,{children:"eventId"}),"/",(0,s.jsx)(n.code,{children:"venueId"}),". Event-level locks include ",(0,s.jsx)(n.code,{children:"eventId"}),". Draw-level locks include both ",(0,s.jsx)(n.code,{children:"eventId"})," and ",(0,s.jsx)(n.code,{children:"drawId"}),"."]}),"\n",(0,s.jsx)(n.hr,{}),"\n",(0,s.jsx)(n.h3,{id:"cleanexpiredmutationlocks",children:"cleanExpiredMutationLocks"}),"\n",(0,s.jsx)(n.p,{children:"Proactively removes expired locks from all elements in the tournament."}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-js",children:"const { success, removedCount } = engine.cleanExpiredMutationLocks();\n"})}),"\n",(0,s.jsx)(n.hr,{}),"\n",(0,s.jsx)(n.h2,{id:"extension-structure",children:"Extension Structure"}),"\n",(0,s.jsxs)(n.p,{children:["Mutation locks are stored as a ",(0,s.jsx)(n.code,{children:"mutationLocks"})," extension on the scoped element. The tournament-level extension includes an ",(0,s.jsx)(n.code,{children:"enabled"})," flag that acts as the feature gate."]}),"\n",(0,s.jsxs)(n.p,{children:[(0,s.jsx)(n.strong,{children:"Tournament-level"})," (feature gate + tournament locks):"]}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-js",children:"{\n  name: 'mutationLocks',\n  value: {\n    enabled: true,\n    locks: [\n      {\n        lockId: 'uuid-1',\n        lockToken: 'opaque-token',\n        scope: 'SCHEDULING',\n        expiresAt: '2026-03-01T12:00:00.000Z',\n        createdAt: '2026-02-27T10:00:00.000Z',\n      }\n    ]\n  }\n}\n"})}),"\n",(0,s.jsxs)(n.p,{children:[(0,s.jsx)(n.strong,{children:"Element-level"})," (draw, event, or venue):"]}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-js",children:"{\n  name: 'mutationLocks',\n  value: {\n    locks: [\n      {\n        lockId: 'uuid-2',\n        lockToken: 'scorer-token',\n        scope: 'SCORING',\n        methods: ['setMatchUpStatus', 'setMatchUpState'],\n        expiresAt: null,\n        createdAt: '2026-02-27T10:00:00.000Z',\n      }\n    ]\n  }\n}\n"})}),"\n",(0,s.jsxs)(n.p,{children:["The ",(0,s.jsx)(n.code,{children:"mutationLocks"})," extension is classified as an internal extension and is excluded during tournament anonymization."]}),"\n",(0,s.jsx)(n.hr,{}),"\n",(0,s.jsx)(n.h2,{id:"error-constants",children:"Error Constants"}),"\n",(0,s.jsxs)(n.table,{children:[(0,s.jsx)(n.thead,{children:(0,s.jsxs)(n.tr,{children:[(0,s.jsx)(n.th,{children:"Constant"}),(0,s.jsx)(n.th,{children:"Code"}),(0,s.jsx)(n.th,{children:"When"})]})}),(0,s.jsxs)(n.tbody,{children:[(0,s.jsxs)(n.tr,{children:[(0,s.jsx)(n.td,{children:(0,s.jsx)(n.code,{children:"MUTATION_LOCKED"})}),(0,s.jsx)(n.td,{children:(0,s.jsx)(n.code,{children:"ERR_MUTATION_LOCKED"})}),(0,s.jsx)(n.td,{children:"Mutation blocked by an active lock (no token or wrong token)"})]}),(0,s.jsxs)(n.tr,{children:[(0,s.jsx)(n.td,{children:(0,s.jsx)(n.code,{children:"MUTATION_LOCK_EXISTS"})}),(0,s.jsx)(n.td,{children:(0,s.jsx)(n.code,{children:"ERR_EXISTING_MUTATION_LOCK"})}),(0,s.jsx)(n.td,{children:"Attempting to add a lock on a scope that already has one with a different token"})]}),(0,s.jsxs)(n.tr,{children:[(0,s.jsx)(n.td,{children:(0,s.jsx)(n.code,{children:"MUTATION_LOCK_NOT_FOUND"})}),(0,s.jsx)(n.td,{children:(0,s.jsx)(n.code,{children:"ERR_NOT_FOUND_MUTATION_LOCK"})}),(0,s.jsx)(n.td,{children:"Attempting to remove a lock that doesn't exist"})]}),(0,s.jsxs)(n.tr,{children:[(0,s.jsx)(n.td,{children:(0,s.jsx)(n.code,{children:"UNAUTHORIZED_LOCK_OPERATION"})}),(0,s.jsx)(n.td,{children:(0,s.jsx)(n.code,{children:"ERR_UNAUTHORIZED_LOCK_OPERATION"})}),(0,s.jsx)(n.td,{children:"Attempting to remove a lock with the wrong token"})]})]})]}),"\n",(0,s.jsx)(n.hr,{}),"\n",(0,s.jsx)(n.h2,{id:"interception-architecture",children:"Interception Architecture"}),"\n",(0,s.jsxs)(n.p,{children:["Lock enforcement is inserted into ",(0,s.jsx)(n.code,{children:"executeFunction"})," (the single chokepoint for all engine calls), between parameter middleware and method invocation:"]}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-text",children:"executeFunction\n  \u251c\u2500\u2500 paramsMiddleware     (resolve tournamentRecord, event, drawDefinition)\n  \u251c\u2500\u2500 checkMutationLock    (check lock, compare lockToken)\n  \u2514\u2500\u2500 invoke               (run the method)\n"})}),"\n",(0,s.jsx)(n.p,{children:"The check follows this logic:"}),"\n",(0,s.jsxs)(n.ol,{children:["\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.strong,{children:"Fast gate"}),": Scan ",(0,s.jsx)(n.code,{children:"tournamentRecord.extensions"})," for a ",(0,s.jsx)(n.code,{children:"mutationLocks"})," extension with ",(0,s.jsx)(n.code,{children:"enabled: true"}),". If not found, return immediately (zero overhead for tournaments without locks)."]}),"\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.strong,{children:"Scope lookup"}),": Look up ",(0,s.jsx)(n.code,{children:"methodName"})," in the scope map. If unmapped, allow."]}),"\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.strong,{children:"Hierarchy walk"}),": Check each element in order \u2014 ",(0,s.jsx)(n.code,{children:"drawDefinition"})," \u2192 ",(0,s.jsx)(n.code,{children:"event"})," \u2192 ",(0,s.jsx)(n.code,{children:"tournamentRecord"})," (and ",(0,s.jsx)(n.code,{children:"venue"})," if ",(0,s.jsx)(n.code,{children:"venueId"})," is in params)."]}),"\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.strong,{children:"Lock match"}),": For each element, find a lock matching the scope (and method, if ",(0,s.jsx)(n.code,{children:"methods"})," is set)."]}),"\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.strong,{children:"Expiry"}),": If the lock has expired, remove it lazily and continue."]}),"\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.strong,{children:"Token check"}),": If ",(0,s.jsx)(n.code,{children:"params.lockToken === lock.lockToken"}),", allow. Otherwise, return ",(0,s.jsx)(n.code,{children:"MUTATION_LOCKED"}),"."]}),"\n"]}),"\n",(0,s.jsx)(n.hr,{}),"\n",(0,s.jsx)(n.h2,{id:"integration-patterns",children:"Integration Patterns"}),"\n",(0,s.jsx)(n.h3,{id:"server-side-token-issuance",children:"Server-Side Token Issuance"}),"\n",(0,s.jsx)(n.p,{children:"The factory doesn't know about users. The server issues tokens and maps them to users:"}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-js",children:"// Server creates a lock and gives the token to the user\nconst lockToken = generateSecureToken();\nawait engine.addMutationLock({\n  scope: 'SCHEDULING',\n  lockToken,\n  expiresAt: addHours(new Date(), 2).toISOString(),\n});\n\n// Store mapping: userId \u2192 lockToken\nawait redis.set(`lock:${userId}`, lockToken, 'EX', 7200);\n\n// When user makes a mutation, server injects the token\nconst userToken = await redis.get(`lock:${userId}`);\nawait engine.scheduleMatchUps({ ...params, lockToken: userToken });\n"})}),"\n",(0,s.jsx)(n.h3,{id:"executionqueue-with-locks",children:"ExecutionQueue with Locks"}),"\n",(0,s.jsxs)(n.p,{children:["When using ",(0,s.jsx)(n.code,{children:"executionQueue"})," for batch operations, include ",(0,s.jsx)(n.code,{children:"lockToken"})," in each directive's params:"]}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-js",children:"engine.executionQueue([\n  {\n    method: 'scheduleMatchUps',\n    params: { lockToken: 'scheduler-token', drawId, matchUpIds, schedule },\n  },\n  {\n    method: 'assignMatchUpCourt',\n    params: { lockToken: 'scheduler-token', matchUpId, courtId, drawId },\n  },\n]);\n"})}),"\n",(0,s.jsx)(n.p,{children:"If any directive fails the lock check, the entire queue is rolled back."}),"\n",(0,s.jsx)(n.h3,{id:"admin-force-release",children:"Admin Force Release"}),"\n",(0,s.jsx)(n.p,{children:"For emergency scenarios, administrators can force-release any lock:"}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-js",children:"// Get all active locks\nconst { mutationLocks } = engine.getMutationLocks();\n\n// Force release without knowing the token\nengine.removeMutationLock({\n  lockId: mutationLocks[0].lockId,\n  forceRelease: true,\n});\n"})}),"\n",(0,s.jsx)(n.hr,{}),"\n",(0,s.jsx)(n.h2,{id:"related-documentation",children:"Related Documentation"}),"\n",(0,s.jsxs)(n.ul,{children:["\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.strong,{children:(0,s.jsx)(n.a,{href:"./extensions",children:"Extensions"})})," - How extensions work on tournament elements"]}),"\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.strong,{children:(0,s.jsx)(n.a,{href:"../engines/engine-middleware",children:"Engine Middleware"})})," - How drawId/eventId resolve to elements"]}),"\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.strong,{children:(0,s.jsx)(n.a,{href:"../governors/tournament-governor",children:"Tournament Governor"})})," - API reference for lock methods"]}),"\n"]})]})}function h(e={}){const{wrapper:n}={...(0,c.R)(),...e.components};return n?(0,s.jsx)(n,{...e,children:(0,s.jsx)(a,{...e})}):a(e)}},8322(e,n,t){t.d(n,{R:()=>i,x:()=>r});var o=t(758);const s={},c=o.createContext(s);function i(e){const n=o.useContext(c);return o.useMemo(function(){return"function"==typeof e?e(n):{...n,...e}},[n,e])}function r(e){let n;return n=e.disableParentContext?"function"==typeof e.components?e.components(s):e.components||s:i(e.components),o.createElement(c.Provider,{value:n},e.children)}}}]);