"use strict";(globalThis.webpackChunkdocumentation=globalThis.webpackChunkdocumentation||[]).push([[450],{5058(e,n,i){i.r(n),i.d(n,{assets:()=>d,contentTitle:()=>a,default:()=>h,frontMatter:()=>l,metadata:()=>t,toc:()=>c});const t=JSON.parse('{"id":"governors/tie-format-governor","title":"tieFormat Governor","description":"addCollectionDefinition","source":"@site/docs/governors/tie-format-governor.md","sourceDirName":"governors","slug":"/governors/tie-format-governor","permalink":"/competition-factory/docs/governors/tie-format-governor","draft":false,"unlisted":false,"tags":[],"version":"current","frontMatter":{"title":"tieFormat Governor"}}');var r=i(6070),o=i(8322);const l={title:"tieFormat Governor"},a=void 0,d={},c=[{value:"addCollectionDefinition",id:"addcollectiondefinition",level:2},{value:"addCollectionGroup",id:"addcollectiongroup",level:2},{value:"aggregateTieFormats",id:"aggregatetieformats",level:2},{value:"compareTieFormats",id:"comparetieformats",level:2},{value:"getTieFormat",id:"gettieformat",level:2},{value:"modifyCollectionDefinition",id:"modifycollectiondefinition",level:2},{value:"modifyTieFormat",id:"modifytieformat",level:2},{value:"orderCollectionDefinitions",id:"ordercollectiondefinitions",level:2},{value:"removeCollectionDefinition",id:"removecollectiondefinition",level:2},{value:"removeCollectionGroup",id:"removecollectiongroup",level:2},{value:"tieFormatGenderValidityCheck",id:"tieformatgendervaliditycheck",level:2},{value:"validateCollectionDefinition",id:"validatecollectiondefinition",level:2}];function s(e){const n={code:"code",h2:"h2",hr:"hr",li:"li",ol:"ol",p:"p",pre:"pre",strong:"strong",ul:"ul",...(0,o.R)(),...e.components};return(0,r.jsxs)(r.Fragment,{children:[(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-js",children:"import { tieFormatGovernor } from 'tods-competition-factory';\n"})}),"\n",(0,r.jsx)(n.h2,{id:"addcollectiondefinition",children:"addCollectionDefinition"}),"\n",(0,r.jsxs)(n.p,{children:["Adds a ",(0,r.jsx)(n.code,{children:"collectionDefinition"})," to the specified target, either ",(0,r.jsx)(n.code,{children:"matchUp"}),", ",(0,r.jsx)(n.code,{children:"structure"}),", ",(0,r.jsx)(n.code,{children:"drawDefinition"})," or ",(0,r.jsx)(n.code,{children:"event"}),"."]}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-js",children:"engine.addCollectionDefinition({\n  updateInProgressMatchUps, // defaults to true; in progress matchUps have matchUpStatus: IN_PROGRESS\n  collectionDefinition, // will be validated\n  tieFormatName, // if not provided, existing tieFormatName will be deleted\n  structureId, // optional - if provided only tieFormat on structure will be modified\n  matchUpId, // optional - if provided only tieFormat on matchUp will be modified\n  eventId, // optional - if provided only tieFormat on event will be modified\n  drawId, // required if structureId is specified; if provided without structureId only tieFormat on drawDefinition will be modified\n  uuids, // optional - array of UUIDs to use for newly created matchUps\n});\n"})}),"\n",(0,r.jsx)(n.hr,{}),"\n",(0,r.jsx)(n.h2,{id:"addcollectiongroup",children:"addCollectionGroup"}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-js",children:"engine.addCollectionGroup({\n  collectionIds: result.modifiedCollectionIds,\n  tieFormatName: 'Swelled',\n  groupDefinition,\n  structureId, // optional - if provided only tieFormat on structure will be modified\n  matchUpId, // optional - if provided only tieFormat on matchUp will be modified\n  eventId, // optional - if provided only tieFormat on event will be modified\n  drawId, // required if structureId is specified; if provided without structureId only tieFormat on drawDefinition will be modified\n});\n"})}),"\n",(0,r.jsx)(n.hr,{}),"\n",(0,r.jsx)(n.h2,{id:"aggregatetieformats",children:"aggregateTieFormats"}),"\n",(0,r.jsx)(n.p,{children:"Aggregates all tieFormats within an event by consolidating duplicate tieFormats. If a drawDefinition, structure, or matchUp has a tieFormat that matches an existing tieFormat in the event.tieFormats array, the inline tieFormat is replaced with a tieFormatId reference."}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-js",children:"const { addedCount } = engine.aggregateTieFormats({\n  tournamentRecord, // automatically provided by engine\n});\n\nconsole.log(`Added ${addedCount} unique tieFormats to event.tieFormats`);\n"})}),"\n",(0,r.jsx)(n.p,{children:(0,r.jsx)(n.strong,{children:"Returns:"})}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-ts",children:"{\n  success: boolean;\n  addedCount: number; // Number of unique tieFormats added to event.tieFormats array\n}\n"})}),"\n",(0,r.jsxs)(n.p,{children:[(0,r.jsx)(n.strong,{children:"Purpose:"})," Normalizes tieFormat storage by moving duplicate inline tieFormats to the event.tieFormats array and replacing them with tieFormatId references. This reduces data duplication and ensures consistency."]}),"\n",(0,r.jsx)(n.p,{children:(0,r.jsx)(n.strong,{children:"When to Use:"})}),"\n",(0,r.jsxs)(n.ul,{children:["\n",(0,r.jsx)(n.li,{children:"After importing tournament data that may have duplicate tieFormats"}),"\n",(0,r.jsx)(n.li,{children:"Before exporting tournament data to reduce file size"}),"\n",(0,r.jsx)(n.li,{children:"After bulk modifications to tieFormats across multiple structures/matchUps"}),"\n",(0,r.jsx)(n.li,{children:"To optimize tournament record storage"}),"\n"]}),"\n",(0,r.jsx)(n.p,{children:(0,r.jsx)(n.strong,{children:"Notes:"})}),"\n",(0,r.jsxs)(n.ul,{children:["\n",(0,r.jsx)(n.li,{children:"Scans all events in the tournament"}),"\n",(0,r.jsxs)(n.li,{children:["Compares tieFormats using ",(0,r.jsx)(n.code,{children:"compareTieFormats()"})," to identify duplicates"]}),"\n",(0,r.jsx)(n.li,{children:"Generates new tieFormatId for newly aggregated formats"}),"\n",(0,r.jsxs)(n.li,{children:["Replaces inline ",(0,r.jsx)(n.code,{children:"tieFormat"})," with ",(0,r.jsx)(n.code,{children:"tieFormatId"})," reference"]}),"\n",(0,r.jsx)(n.li,{children:"Only processes TEAM matchUps"}),"\n",(0,r.jsx)(n.li,{children:"Safe to run multiple times (idempotent)"}),"\n"]}),"\n",(0,r.jsx)(n.hr,{}),"\n",(0,r.jsx)(n.h2,{id:"comparetieformats",children:"compareTieFormats"}),"\n",(0,r.jsx)(n.p,{children:"Compares two tieFormat objects to determine if they are functionally equivalent."}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-js",children:"const { different } = engine.compareTieFormats({\n  considerations, // optional { collectionName?: boolean; collectionOrder?: boolean };\n  ancestor: tieFormat1,\n  descendant: tieFormat2,\n});\n\nif (!different) {\n  console.log('TieFormats are equivalent');\n}\n"})}),"\n",(0,r.jsx)(n.p,{children:(0,r.jsx)(n.strong,{children:"Returns:"})}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-ts",children:"{\n  different: boolean; // true if tieFormats differ, false if equivalent\n}\n"})}),"\n",(0,r.jsx)(n.p,{children:(0,r.jsx)(n.strong,{children:"Parameters:"})}),"\n",(0,r.jsxs)(n.ul,{children:["\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.code,{children:"ancestor"})," - The reference tieFormat to compare against"]}),"\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.code,{children:"descendant"})," - The tieFormat to compare"]}),"\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.code,{children:"considerations"})," - Optional comparison options:","\n",(0,r.jsxs)(n.ul,{children:["\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.code,{children:"collectionName: boolean"})," - Whether to consider collection names in comparison (default: false)"]}),"\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.code,{children:"collectionOrder: boolean"})," - Whether order of collections matters (default: false)"]}),"\n"]}),"\n"]}),"\n"]}),"\n",(0,r.jsx)(n.p,{children:(0,r.jsx)(n.strong,{children:"Notes:"})}),"\n",(0,r.jsxs)(n.ul,{children:["\n",(0,r.jsxs)(n.li,{children:["Used internally by ",(0,r.jsx)(n.code,{children:"aggregateTieFormats()"})," to identify duplicates"]}),"\n",(0,r.jsx)(n.li,{children:"Ignores tieFormatName unless specified in considerations"}),"\n",(0,r.jsx)(n.li,{children:"Ignores collection order unless specified in considerations"}),"\n",(0,r.jsx)(n.li,{children:"Compares collection definitions, matchUp formats, scoring values, and gender constraints"}),"\n"]}),"\n",(0,r.jsx)(n.hr,{}),"\n",(0,r.jsx)(n.h2,{id:"gettieformat",children:"getTieFormat"}),"\n",(0,r.jsx)(n.p,{children:"Retrieves the tieFormat for a specific matchUp, structure, draw, or event, following the hierarchical resolution order."}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-js",children:"const {\n  tieFormat, // resolved tieFormat for the matchUp\n  drawDefaultTieFormat, // tieFormat from drawDefinition\n  eventDefaultTieFormat, // tieFormat from event\n  structureDefaultTieFormat, // tieFormat from structure\n  matchUp, // the matchUp object\n  structure, // the structure object\n} = engine.getTieFormat({\n  matchUpId, // required - matchUp to get tieFormat for\n  structureId, // optional - optimization if structure known\n  drawId, // optional - optimization to avoid search\n  eventId, // optional - optimization if event known\n});\n"})}),"\n",(0,r.jsx)(n.p,{children:(0,r.jsx)(n.strong,{children:"Returns:"})}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-ts",children:"{\n  tieFormat?: TieFormat;              // Resolved tieFormat (most specific)\n  matchUp?: MatchUp;                  // MatchUp object\n  structure?: Structure;              // Structure object\n  drawDefaultTieFormat?: TieFormat;   // Draw-level default\n  eventDefaultTieFormat?: TieFormat;  // Event-level default\n  structureDefaultTieFormat?: TieFormat; // Structure-level default\n  error?: ErrorType;\n}\n"})}),"\n",(0,r.jsx)(n.p,{children:(0,r.jsx)(n.strong,{children:"Resolution Hierarchy:"})}),"\n",(0,r.jsxs)(n.ol,{children:["\n",(0,r.jsx)(n.li,{children:"MatchUp-level tieFormat (most specific)"}),"\n",(0,r.jsx)(n.li,{children:"Structure-level tieFormat"}),"\n",(0,r.jsx)(n.li,{children:"Draw-level tieFormat"}),"\n",(0,r.jsx)(n.li,{children:"Event-level tieFormat (least specific)"}),"\n"]}),"\n",(0,r.jsxs)(n.p,{children:[(0,r.jsx)(n.strong,{children:"Purpose:"})," Get the active tieFormat for a matchUp following the inheritance chain. Returns all levels of defaults to understand the full context."]}),"\n",(0,r.jsx)(n.p,{children:(0,r.jsx)(n.strong,{children:"When to Use:"})}),"\n",(0,r.jsxs)(n.ul,{children:["\n",(0,r.jsx)(n.li,{children:"Determining scoring format for a specific TEAM matchUp"}),"\n",(0,r.jsx)(n.li,{children:"Understanding which tieFormat is active"}),"\n",(0,r.jsx)(n.li,{children:"Building UI that shows tieFormat inheritance"}),"\n",(0,r.jsx)(n.li,{children:"Validating tieFormat configuration"}),"\n"]}),"\n",(0,r.jsx)(n.p,{children:(0,r.jsx)(n.strong,{children:"Notes:"})}),"\n",(0,r.jsxs)(n.ul,{children:["\n",(0,r.jsx)(n.li,{children:"Only applies to TEAM matchUps"}),"\n",(0,r.jsx)(n.li,{children:"Returns first tieFormat found in the hierarchy"}),"\n",(0,r.jsx)(n.li,{children:"Includes all default levels for complete context"}),"\n",(0,r.jsxs)(n.li,{children:["Use ",(0,r.jsx)(n.code,{children:"drawId"})," and ",(0,r.jsx)(n.code,{children:"structureId"})," for performance optimization"]}),"\n"]}),"\n",(0,r.jsx)(n.hr,{}),"\n",(0,r.jsx)(n.h2,{id:"modifycollectiondefinition",children:"modifyCollectionDefinition"}),"\n",(0,r.jsxs)(n.p,{children:["Modifies the ",(0,r.jsx)(n.code,{children:"collectionName"})," and/or ",(0,r.jsx)(n.code,{children:"matchUpFormat"})," for targeted ",(0,r.jsx)(n.code,{children:"collectionId"})," within the ",(0,r.jsx)(n.code,{children:"tieFormat"})," specified by ",(0,r.jsx)(n.code,{children:"eventId"}),", ",(0,r.jsx)(n.code,{children:"drawId"}),", ",(0,r.jsx)(n.code,{children:"structureId"})," or ",(0,r.jsx)(n.code,{children:"matchUpId"}),"."]}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-js",children:"engine.modifyCollectionDefinition({\n  collectionName, // optional\n  matchUpFormat, // optional\n  collectionId, // required\n  structureId, // required if modifying tieFormat for a structure\n  matchUpId, // required if modifying tieFormat for a matchUp\n  eventId, // required if modifying tieFormat for a event\n  drawId, // required if modifying tieFormat for a drawDefinition or a structure\n  gender, // optional\n\n  // value assignment, only one is allowed to have a value\n  collectionValueProfiles, // optional - [{ collectionPosition: 1, value: 2 }] - there must be a value provided for all matchUp positions\n  collectionValue, // optional - value awarded for winning more than half of the matchUps in the collection\n  matchUpValue, // optional - value awarded for each matchUp won\n  scoreValue, // optional - value awarded for each game or point won (points for tiebreak sets)\n  setValue, // optional - value awarded for each set won\n});\n"})}),"\n",(0,r.jsx)(n.hr,{}),"\n",(0,r.jsx)(n.h2,{id:"modifytieformat",children:"modifyTieFormat"}),"\n",(0,r.jsxs)(n.p,{children:["Both modifies the ",(0,r.jsx)(n.code,{children:"tieFormat"})," on the target ",(0,r.jsx)(n.code,{children:"event"}),", ",(0,r.jsx)(n.code,{children:"drawDefinition"}),", ",(0,r.jsx)(n.code,{children:"structure"})," or ",(0,r.jsx)(n.code,{children:"matchUp"})," and adds/deletes ",(0,r.jsx)(n.code,{children:"tieMatchUps"})," as necessary."]}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-js",children:"engine.modifyTieFormat({\n  considerations, // optional { collectionName?: boolean; collectionOrder?: boolean };\n  modifiedTieFormat, // will be compared to existing tieFormat that is targeted and differences calculated\n  tournamentId, // required\n  structureId, // required if modifying tieFormat for a structure\n  matchUpId, // required if modifying tieFormat for a matchUp\n  eventId, // required if modifying tieFormat for a event\n  drawId, // required if modifying tieFormat for a drawDefinition or a structure\n});\n"})}),"\n",(0,r.jsx)(n.hr,{}),"\n",(0,r.jsx)(n.h2,{id:"ordercollectiondefinitions",children:"orderCollectionDefinitions"}),"\n",(0,r.jsxs)(n.p,{children:["Modify the array order of ",(0,r.jsx)(n.code,{children:"tieFormat.collectionDefinitions"})," for an ",(0,r.jsx)(n.code,{children:"event"}),", a ",(0,r.jsx)(n.code,{children:"drawDefinition"}),", ",(0,r.jsx)(n.code,{children:"structure"}),", or ",(0,r.jsx)(n.code,{children:"matchUp"}),"."]}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-js",children:"engine.orderCollectionDefinitions({\n  orderMap: { collectionId1: 1, collectionId2: 2 },\n  tournamentId, // required\n  structureId, // required if modifying tieFormat for a structure\n  matchUpId, // required if modifying tieFormat for a matchUp\n  eventId, // required if modifying tieFormat for a event\n  drawId, // required if modifying tieFormat for a drawDefinition or a structure\n});\n"})}),"\n",(0,r.jsx)(n.hr,{}),"\n",(0,r.jsx)(n.h2,{id:"removecollectiondefinition",children:"removeCollectionDefinition"}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-js",children:"engine.removeCollectionDefinition({\n  updateInProgressMatchUps, // optional; defaults to true\n  tieFormatComparison, // optional; defaults to false; when true will not delete unique collections on unscored matchUps\n  tieFormatName, // any time a collectionDefinition is modified a new name must be provided\n  tournamentId, // required\n  collectionId, // required - id of collectionDefinition to be removed\n  structureId, // optional - if removing from tieFormat associated with a specific structure\n  matchUpId, // optional - if removing from tieFormat asscoiated with a specific matchUp\n  eventId, // optional - if removing from tieFormat asscoiated with an event\n  drawId, // required if structureId is specified or if tieFormat associated with drawDefinition is to be modified\n});\n"})}),"\n",(0,r.jsx)(n.hr,{}),"\n",(0,r.jsx)(n.h2,{id:"removecollectiongroup",children:"removeCollectionGroup"}),"\n",(0,r.jsxs)(n.p,{children:["Removes a ",(0,r.jsx)(n.code,{children:"collectionGroup"})," from the ",(0,r.jsx)(n.code,{children:"tieFormat"})," found for the ",(0,r.jsx)(n.code,{children:"event"}),", ",(0,r.jsx)(n.code,{children:"drawDefinition"}),", ",(0,r.jsx)(n.code,{children:"structure"})," or ",(0,r.jsx)(n.code,{children:"matchUp"}),"; recalculates"]}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-js",children:"engine.removeCollectionGroup({\n  updateInProgressMatchUps, // optional - defaults to true\n  tieFormatName: 'New tieFormat', // if no name is provided then there will be no name\n  collectionGroupNumber: 1,\n  tournamentId, // required\n  structureId, // optional\n  matchUpId, // optional\n  eventId, // optional\n  drawId, // optional; required if structureId is targeted\n});\n"})}),"\n",(0,r.jsx)(n.hr,{}),"\n",(0,r.jsx)(n.h2,{id:"tieformatgendervaliditycheck",children:"tieFormatGenderValidityCheck"}),"\n",(0,r.jsx)(n.p,{children:"Validates that a collection's gender specification is compatible with the reference gender (event or category gender)."}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-js",children:"const { valid, error, info } = engine.tieFormatGenderValidityCheck({\n  referenceGender, // gender of event or category (e.g., 'MALE', 'FEMALE', 'MIXED', 'ANY')\n  matchUpType, // 'SINGLES' or 'DOUBLES'\n  gender, // gender of the collection being validated\n});\n\nif (!valid) {\n  console.error(error, info);\n}\n"})}),"\n",(0,r.jsx)(n.p,{children:(0,r.jsx)(n.strong,{children:"Returns:"})}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-ts",children:"{\n  valid: boolean;\n  error?: ErrorType;  // INVALID_GENDER if validation fails\n  info?: string;      // Explanation of validation failure\n}\n"})}),"\n",(0,r.jsx)(n.p,{children:(0,r.jsx)(n.strong,{children:"Validation Rules:"})}),"\n",(0,r.jsxs)(n.ol,{children:["\n",(0,r.jsxs)(n.li,{children:["\n",(0,r.jsx)(n.p,{children:(0,r.jsx)(n.strong,{children:"Gendered Events (MALE/FEMALE):"})}),"\n",(0,r.jsxs)(n.ul,{children:["\n",(0,r.jsx)(n.li,{children:"Collection gender must match reference gender"}),"\n",(0,r.jsx)(n.li,{children:"Example: MALE event can only have MALE collections"}),"\n"]}),"\n"]}),"\n",(0,r.jsxs)(n.li,{children:["\n",(0,r.jsx)(n.p,{children:(0,r.jsx)(n.strong,{children:"MIXED Events:"})}),"\n",(0,r.jsxs)(n.ul,{children:["\n",(0,r.jsx)(n.li,{children:"Cannot contain MIXED singles collections (only MIXED doubles)"}),"\n",(0,r.jsxs)(n.li,{children:["Cannot contain collections with ",(0,r.jsx)(n.code,{children:"gender: ANY"})]}),"\n",(0,r.jsx)(n.li,{children:"Can contain MALE, FEMALE, and MIXED doubles collections"}),"\n"]}),"\n"]}),"\n",(0,r.jsxs)(n.li,{children:["\n",(0,r.jsx)(n.p,{children:(0,r.jsx)(n.strong,{children:"ANY Gender Events:"})}),"\n",(0,r.jsxs)(n.ul,{children:["\n",(0,r.jsx)(n.li,{children:"Cannot contain MIXED singles collections (only MIXED doubles)"}),"\n",(0,r.jsx)(n.li,{children:"Can contain MALE, FEMALE, and MIXED doubles collections"}),"\n"]}),"\n"]}),"\n"]}),"\n",(0,r.jsx)(n.p,{children:(0,r.jsx)(n.strong,{children:"Examples:"})}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-js",children:"// Valid: MALE collection in MALE event\nengine.tieFormatGenderValidityCheck({\n  referenceGender: 'MALE',\n  matchUpType: 'SINGLES',\n  gender: 'MALE',\n}); // { valid: true }\n\n// Invalid: FEMALE collection in MALE event\nengine.tieFormatGenderValidityCheck({\n  referenceGender: 'MALE',\n  matchUpType: 'SINGLES',\n  gender: 'FEMALE',\n}); // { valid: false, error: INVALID_GENDER }\n\n// Valid: MIXED doubles in MIXED event\nengine.tieFormatGenderValidityCheck({\n  referenceGender: 'MIXED',\n  matchUpType: 'DOUBLES',\n  gender: 'MIXED',\n}); // { valid: true }\n\n// Invalid: MIXED singles in MIXED event\nengine.tieFormatGenderValidityCheck({\n  referenceGender: 'MIXED',\n  matchUpType: 'SINGLES',\n  gender: 'MIXED',\n}); // { valid: false, error: INVALID_GENDER, info: 'MIXED events can not contain mixed singles or collections with gender: ANY' }\n\n// Invalid: ANY gender in MIXED event\nengine.tieFormatGenderValidityCheck({\n  referenceGender: 'MIXED',\n  matchUpType: 'SINGLES',\n  gender: 'ANY',\n}); // { valid: false, error: INVALID_GENDER }\n"})}),"\n",(0,r.jsx)(n.p,{children:(0,r.jsx)(n.strong,{children:"Use Cases:"})}),"\n",(0,r.jsxs)(n.ul,{children:["\n",(0,r.jsx)(n.li,{children:"Validating collectionDefinitions before adding to tieFormat"}),"\n",(0,r.jsx)(n.li,{children:"Ensuring tieFormat gender constraints match event/category requirements"}),"\n",(0,r.jsx)(n.li,{children:"Building UI that enforces gender compatibility rules"}),"\n",(0,r.jsx)(n.li,{children:"Preventing invalid tieFormat configurations"}),"\n"]}),"\n",(0,r.jsx)(n.p,{children:(0,r.jsx)(n.strong,{children:"Notes:"})}),"\n",(0,r.jsxs)(n.ul,{children:["\n",(0,r.jsx)(n.li,{children:"MIXED is only valid for DOUBLES matchUpType"}),"\n",(0,r.jsx)(n.li,{children:"ANY gender collections are not allowed in MIXED events"}),"\n",(0,r.jsx)(n.li,{children:"Automatically coerces gender values for comparison (handles variations)"}),"\n"]}),"\n",(0,r.jsx)(n.hr,{}),"\n",(0,r.jsx)(n.h2,{id:"validatecollectiondefinition",children:"validateCollectionDefinition"}),"\n",(0,r.jsx)(n.p,{children:"Validates that a collectionDefinition is properly formed and compatible with event/category constraints."}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-js",children:"const { valid } = engine.validateCollectionDefinition({\n  collectionDefinition, // required\n  checkCollectionIds, // optional boolean - check that collectionIds are present\n  referenceCategory, // optional - category for comparision if eventId is not provided\n  referenceGender, // optional - expected gender if eventId is not provided\n  checkCategory, // optional boolean - defaults to true\n  checkGender, // optional boolean - defaults to true\n  eventId, // required only for checking gender\n});\n"})}),"\n",(0,r.jsx)(n.p,{children:(0,r.jsx)(n.strong,{children:"Returns:"})}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-ts",children:"{\n  valid: boolean;\n  error?: ErrorType;\n}\n"})}),"\n",(0,r.jsx)(n.p,{children:(0,r.jsx)(n.strong,{children:"Validation Checks:"})}),"\n",(0,r.jsxs)(n.ul,{children:["\n",(0,r.jsx)(n.li,{children:"Collection structure is valid (has required fields)"}),"\n",(0,r.jsxs)(n.li,{children:["CollectionIds are present (if ",(0,r.jsx)(n.code,{children:"checkCollectionIds: true"}),")"]}),"\n",(0,r.jsxs)(n.li,{children:["Gender compatibility with event/category (if ",(0,r.jsx)(n.code,{children:"checkGender: true"}),")"]}),"\n",(0,r.jsxs)(n.li,{children:["Category compatibility (if ",(0,r.jsx)(n.code,{children:"checkCategory: true"}),")"]}),"\n",(0,r.jsx)(n.li,{children:"MatchUp formats are valid"}),"\n",(0,r.jsx)(n.li,{children:"Scoring values are properly configured"}),"\n"]}),"\n",(0,r.jsx)(n.p,{children:(0,r.jsx)(n.strong,{children:"Notes:"})}),"\n",(0,r.jsxs)(n.ul,{children:["\n",(0,r.jsx)(n.li,{children:"Use before adding collectionDefinitions to avoid invalid configurations"}),"\n",(0,r.jsx)(n.li,{children:"Gender and category checks require reference values from event or explicit params"}),"\n"]}),"\n",(0,r.jsx)(n.hr,{})]})}function h(e={}){const{wrapper:n}={...(0,o.R)(),...e.components};return n?(0,r.jsx)(n,{...e,children:(0,r.jsx)(s,{...e})}):s(e)}},8322(e,n,i){i.d(n,{R:()=>l,x:()=>a});var t=i(758);const r={},o=t.createContext(r);function l(e){const n=t.useContext(o);return t.useMemo(function(){return"function"==typeof e?e(n):{...n,...e}},[n,e])}function a(e){let n;return n=e.disableParentContext?"function"==typeof e.components?e.components(r):e.components||r:l(e.components),t.createElement(o.Provider,{value:n},e.children)}}}]);