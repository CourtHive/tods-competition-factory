"use strict";(globalThis.webpackChunkdocumentation=globalThis.webpackChunkdocumentation||[]).push([[3162],{6204(e,n,i){i.r(n),i.d(n,{assets:()=>d,contentTitle:()=>c,default:()=>h,frontMatter:()=>r,metadata:()=>t,toc:()=>o});const t=JSON.parse('{"id":"governors/matchup-governor","title":"matchUp Governor","description":"addMatchUpEndTime","source":"@site/docs/governors/matchup-governor.md","sourceDirName":"governors","slug":"/governors/matchup-governor","permalink":"/competition-factory/docs/governors/matchup-governor","draft":false,"unlisted":false,"tags":[],"version":"current","frontMatter":{"title":"matchUp Governor"},"sidebar":"docs","previous":{"title":"Generation Governor","permalink":"/competition-factory/docs/governors/generation-governor"},"next":{"title":"matchUpFormat Governor","permalink":"/competition-factory/docs/governors/matchup-format-governor"}}');var a=i(6070),s=i(8439);const r={title:"matchUp Governor"},c=void 0,d={},o=[{value:"addMatchUpEndTime",id:"addmatchupendtime",level:2},{value:"addMatchUpOfficial",id:"addmatchupofficial",level:2},{value:"addMatchUpResumeTime",id:"addmatchupresumetime",level:2},{value:"addMatchUpScheduledDate",id:"addmatchupscheduleddate",level:2},{value:"addMatchUpScheduledTime",id:"addmatchupscheduledtime",level:2},{value:"addMatchUpScheduleItems",id:"addmatchupscheduleitems",level:2},{value:"addMatchUpStartTime",id:"addmatchupstarttime",level:2},{value:"addMatchUpStopTime",id:"addmatchupstoptime",level:2},{value:"addMatchUpCourtOrder",id:"addmatchupcourtorder",level:2},{value:"applyLinueUps",id:"applylinueups",level:2},{value:"assignMatchUpSideParticipant",id:"assignmatchupsideparticipant",level:2},{value:"assignMatchUpCourt",id:"assignmatchupcourt",level:2},{value:"assignMatchUpVenue",id:"assignmatchupvenue",level:2},{value:"assignTieMatchUpParticipantId",id:"assigntiematchupparticipantid",level:2},{value:"bulkMatchUpStatusUpdate",id:"bulkmatchupstatusupdate",level:2},{value:"checkInParticipant",id:"checkinparticipant",level:2},{value:"checkOutParticipant",id:"checkoutparticipant",level:2},{value:"disableTieAutoCalc",id:"disabletieautocalc",level:2},{value:"enableTiaAutoCalc",id:"enabletiaautocalc",level:2},{value:"findMatchUp",id:"findmatchup",level:2},{value:"getHomeParticipantId",id:"gethomeparticipantid",level:2},{value:"modifyMatchUpFormatTiming",id:"modifymatchupformattiming",level:2},{value:"removeMatchUpSideParticipant",id:"removematchupsideparticipant",level:2},{value:"replaceTieMatchUpParticipantId",id:"replacetiematchupparticipantid",level:2},{value:"removeTieMatchUpParticipantId",id:"removetiematchupparticipantid",level:2},{value:"resetAdHocMatchUps",id:"resetadhocmatchups",level:2},{value:"resetScorecard",id:"resetscorecard",level:2},{value:"resetTieFormat",id:"resettieformat",level:2},{value:"setMatchUpDailyLimits",id:"setmatchupdailylimits",level:2},{value:"setMatchUpFormat",id:"setmatchupformat",level:2},{value:"setMatchUpHomeParticipantId",id:"setmatchuphomeparticipantid",level:2},{value:"setMatchUpStatus",id:"setmatchupstatus",level:2},{value:"setOrderOfFinish",id:"setorderoffinish",level:2},{value:"Validation",id:"validation",level:3},{value:"toggleParticipantCheckInState",id:"toggleparticipantcheckinstate",level:2},{value:"updateTieMatchUpScore",id:"updatetiematchupscore",level:2}];function l(e){const n={a:"a",admonition:"admonition",code:"code",em:"em",h2:"h2",h3:"h3",hr:"hr",li:"li",p:"p",pre:"pre",strong:"strong",ul:"ul",...(0,s.R)(),...e.components};return(0,a.jsxs)(a.Fragment,{children:[(0,a.jsx)(n.pre,{children:(0,a.jsx)(n.code,{className:"language-js",children:"import { matchUpGovernor } from 'tods-competition-factory';\n"})}),"\n",(0,a.jsx)(n.h2,{id:"addmatchupendtime",children:"addMatchUpEndTime"}),"\n",(0,a.jsx)(n.pre,{children:(0,a.jsx)(n.code,{className:"language-js",children:"const endTime = '2020-01-01T09:05:00Z';\nengine.addMatchUpEndTime({\n  validateTimeSeries, // optional - true by default - when false does not verify endTime is later than startTime\n  disableNotice, // when disabled subscribers will not be notified\n  matchUpId,\n  endTime,\n  drawId,\n});\n"})}),"\n",(0,a.jsx)(n.hr,{}),"\n",(0,a.jsx)(n.h2,{id:"addmatchupofficial",children:"addMatchUpOfficial"}),"\n",(0,a.jsx)(n.pre,{children:(0,a.jsx)(n.code,{className:"language-js",children:"engine.addMatchUpOfficial({\n  disableNotice, // when disabled subscribers will not be notified\n  participantId,\n  officialType,\n  matchUpId,\n  drawId,\n});\n"})}),"\n",(0,a.jsx)(n.hr,{}),"\n",(0,a.jsx)(n.h2,{id:"addmatchupresumetime",children:"addMatchUpResumeTime"}),"\n",(0,a.jsx)(n.pre,{children:(0,a.jsx)(n.code,{className:"language-js",children:"const resumeTime = '2020-01-01T09:00:00Z';\nengine.addMatchUpResumeTime({\n  removePriorValues, // optional boolean\n  disableNotice, // when disabled subscribers will not be notified\n  resumeTime,\n  matchUpId,\n  drawId,\n});\n"})}),"\n",(0,a.jsx)(n.hr,{}),"\n",(0,a.jsx)(n.h2,{id:"addmatchupscheduleddate",children:"addMatchUpScheduledDate"}),"\n",(0,a.jsx)(n.pre,{children:(0,a.jsx)(n.code,{className:"language-js",children:"const scheduledDate = '2020-01-01';\nengine.addMatchUpScheduledDate({\n  removePriorValues, // optional boolean\n  disableNotice, // when disabled subscribers will not be notified\n  scheduledDate,\n  matchUpId,\n  drawId,\n});\n"})}),"\n",(0,a.jsx)(n.hr,{}),"\n",(0,a.jsx)(n.h2,{id:"addmatchupscheduledtime",children:"addMatchUpScheduledTime"}),"\n",(0,a.jsx)(n.pre,{children:(0,a.jsx)(n.code,{className:"language-js",children:"const scheduledTime = '08:00';\nengine.addMatchUpScheduledTime({\n  removePriorValues, // optional boolean\n  disableNotice, // when disabled subscribers will not be notified\n  scheduledTime,\n  matchUpId,\n  drawId,\n});\n"})}),"\n",(0,a.jsx)(n.hr,{}),"\n",(0,a.jsx)(n.h2,{id:"addmatchupscheduleitems",children:"addMatchUpScheduleItems"}),"\n",(0,a.jsx)(n.p,{children:"Convenience function to add several schedule items at once."}),"\n",(0,a.jsx)(n.pre,{children:(0,a.jsx)(n.code,{className:"language-js",children:"engine.addMatchUpScheduleItems({\n  checkChronology, // optional boolean - returns warnings for scheduling errors; throws errors when combined with errorOnAnachronism\n  removePriorValues, // optional boolean\n  matchUpId,\n  drawId,\n  schedule: {\n    scheduledTime,\n    scheduledDate,\n    startTime,\n    courtIds, // applies only to TEAM matchUps\n    courtId, // requires scheduledDate\n    venueId,\n    endTime,\n  },\n  disableNotice, // when disabled subscribers will not be notified\n});\n"})}),"\n",(0,a.jsx)(n.hr,{}),"\n",(0,a.jsx)(n.h2,{id:"addmatchupstarttime",children:"addMatchUpStartTime"}),"\n",(0,a.jsx)(n.pre,{children:(0,a.jsx)(n.code,{className:"language-js",children:"const startTime = '2020-01-01T08:05:00Z';\nengine.addMatchUpStartTime({\n  drawId,\n  matchUpId,\n  startTime,\n  disableNotice, // when disabled subscribers will not be notified\n});\n"})}),"\n",(0,a.jsx)(n.hr,{}),"\n",(0,a.jsx)(n.h2,{id:"addmatchupstoptime",children:"addMatchUpStopTime"}),"\n",(0,a.jsx)(n.pre,{children:(0,a.jsx)(n.code,{className:"language-js",children:"const stopTime = '2020-01-01T08:15:00Z';\nengine.addMatchUpStopTime({\n  drawId,\n  matchUpId,\n  stopTime,\n  disableNotice, // when disabled subscribers will not be notified\n});\n"})}),"\n",(0,a.jsx)(n.hr,{}),"\n",(0,a.jsx)(n.h2,{id:"addmatchupcourtorder",children:"addMatchUpCourtOrder"}),"\n",(0,a.jsx)(n.p,{children:"When using Pro-scheduling, assign order on court"}),"\n",(0,a.jsx)(n.pre,{children:(0,a.jsx)(n.code,{className:"language-js",children:"engine.addMatchUpCourtOrder({\n  removePriorValues, // optional boolean\n  drawId, // drawId where matchUp is found\n  courtOrder,\n  matchUpId,\n  courtId,\n});\n"})}),"\n",(0,a.jsx)(n.hr,{}),"\n",(0,a.jsx)(n.h2,{id:"applylinueups",children:"applyLinueUps"}),"\n",(0,a.jsxs)(n.p,{children:["Applies ",(0,a.jsx)(n.code,{children:"lineUps"})," to the ",(0,a.jsx)(n.code,{children:"sides"})," of a ",(0,a.jsx)(n.em,{children:"TEAM"})," matchUp. Order is not important as team side is determined automatically. Does not check to ensure that participants in ",(0,a.jsx)(n.code,{children:"lineUps"})," are part of teams; this is assumed. It is possible to have ",(0,a.jsx)(n.strong,{children:(0,a.jsx)(n.em,{children:"some"})})," participants assigned to a team side who are not part of a team."]}),"\n",(0,a.jsx)(n.pre,{children:(0,a.jsx)(n.code,{className:"language-js",children:"result = engine.applyLineUps({\n  matchUpId, // must be { matchUpType: TEAM }\n  lineUps, // array of at most two lineUps (see TODS)\n  drawId, // reference to draw in which matchUp occurs\n});\n"})}),"\n",(0,a.jsx)(n.hr,{}),"\n",(0,a.jsx)(n.h2,{id:"assignmatchupsideparticipant",children:"assignMatchUpSideParticipant"}),"\n",(0,a.jsx)(n.p,{children:"Assign participant to AD_HOC matchUp."}),"\n",(0,a.jsx)(n.pre,{children:(0,a.jsx)(n.code,{className:"language-js",children:"engine.assignMatchUpSideParticipant({\n  participantId,\n  sideNumber,\n  matchUpId,\n  drawId,\n});\n"})}),"\n",(0,a.jsx)(n.hr,{}),"\n",(0,a.jsx)(n.h2,{id:"assignmatchupcourt",children:"assignMatchUpCourt"}),"\n",(0,a.jsx)(n.pre,{children:(0,a.jsx)(n.code,{className:"language-js",children:"engine.assignMatchUpCourt({\n  removePriorValues, // optional boolean\n  drawId, // drawId where matchUp is found\n  courtDayDate, // ISO date string\n  matchUpId,\n  courtId,\n});\n"})}),"\n",(0,a.jsx)(n.hr,{}),"\n",(0,a.jsx)(n.h2,{id:"assignmatchupvenue",children:"assignMatchUpVenue"}),"\n",(0,a.jsx)(n.pre,{children:(0,a.jsx)(n.code,{className:"language-js",children:"engine.assignMatchUVenue({\n  removePriorValues, // optional boolean\n  drawId, // drawId where matchUp is found\n  matchUpId,\n  venueId,\n});\n"})}),"\n",(0,a.jsx)(n.hr,{}),"\n",(0,a.jsx)(n.h2,{id:"assigntiematchupparticipantid",children:"assignTieMatchUpParticipantId"}),"\n",(0,a.jsxs)(n.p,{children:["Used when interactively assigning participants to ",(0,a.jsx)(n.code,{children:"matchUps"}),". When individual ",(0,a.jsx)(n.code,{children:"participantIds"})," are assigned to ",(0,a.jsx)(n.code,{children:"{ matchUpType: 'DOUBLES' }"})," it handles creating ",(0,a.jsx)(n.code,{children:"{ participantType: PAIR }"})," participants dynamically."]}),"\n",(0,a.jsx)(n.pre,{children:(0,a.jsx)(n.code,{className:"language-js",children:'engine.assignTieMatchUpParticipantId({\n  teamParticipantId, // optional - participant team can be derived from participantId. This supports assigning "borrowed" players from other teams.\n  participantId, // id of INDIVIDUAL or PAIR participant to be assigned to a matchUp\n  tieMatchUpId, // matchUpId of a SINGLES or DOUBLES that is part of a matchUp between teams\n  sideNumber, // optional - only necessary if a participant is part of both teams (edge case!)\n  drawId, // identifies draw in which matchUp is present\n});\n'})}),"\n",(0,a.jsx)(n.hr,{}),"\n",(0,a.jsx)(n.h2,{id:"bulkmatchupstatusupdate",children:"bulkMatchUpStatusUpdate"}),"\n",(0,a.jsx)(n.p,{children:"Provides the ability to update the outcomes of multiple matchUps at once."}),"\n",(0,a.jsx)(n.pre,{children:(0,a.jsx)(n.code,{className:"language-js",children:"const outcomes = [\n  {\n    eventId,\n    drawId,\n    matchUpId,\n    matchUpFormat,\n    matchUpStatus,\n    winningSide,\n    score,\n  },\n];\nengine.bulkMatchUpStatusUpdate({ outcomes });\n"})}),"\n",(0,a.jsx)(n.hr,{}),"\n",(0,a.jsx)(n.h2,{id:"checkinparticipant",children:"checkInParticipant"}),"\n",(0,a.jsx)(n.p,{children:"Set the check-in state for a participant. Used to determine when both participants in a matchUp are available to be assigned to a court."}),"\n",(0,a.jsx)(n.pre,{children:(0,a.jsx)(n.code,{className:"language-js",children:"engine.checkInParticipant({\n  participantId,\n  matchUpId,\n  drawId,\n});\n"})}),"\n",(0,a.jsx)(n.hr,{}),"\n",(0,a.jsx)(n.h2,{id:"checkoutparticipant",children:"checkOutParticipant"}),"\n",(0,a.jsx)(n.pre,{children:(0,a.jsx)(n.code,{className:"language-js",children:"engine.checkOutParticipant({\n  participantId,\n  matchUpId,\n  drawId,\n});\n"})}),"\n",(0,a.jsx)(n.hr,{}),"\n",(0,a.jsx)(n.h2,{id:"disabletieautocalc",children:"disableTieAutoCalc"}),"\n",(0,a.jsx)(n.p,{children:"Disable default behavior of auto calculating TEAM matchUp scores."}),"\n",(0,a.jsx)(n.pre,{children:(0,a.jsx)(n.code,{className:"language-js",children:"engine.disableTieAutoCalc({ drawId, matchUpId });\n"})}),"\n",(0,a.jsx)(n.hr,{}),"\n",(0,a.jsx)(n.h2,{id:"enabletiaautocalc",children:"enableTiaAutoCalc"}),"\n",(0,a.jsx)(n.p,{children:"Re-enable default behavior of auto calculating TEAM matchUp scores, and trigger auto calculation."}),"\n",(0,a.jsx)(n.pre,{children:(0,a.jsx)(n.code,{className:"language-js",children:"engine.enableTieAutoCalc({ drawId, matchUpId });\n"})}),"\n",(0,a.jsx)(n.hr,{}),"\n",(0,a.jsx)(n.h2,{id:"findmatchup",children:"findMatchUp"}),"\n",(0,a.jsx)(n.pre,{children:(0,a.jsx)(n.code,{className:"language-js",children:"const {\n  matchUp,\n  structure, // returned for convenience\n} = engine.findMatchUp({\n  inContext, // optional - boolean - returns matchUp with additional attributes\n  matchUpId,\n  drawId,\n});\n"})}),"\n",(0,a.jsx)(n.hr,{}),"\n",(0,a.jsx)(n.h2,{id:"gethomeparticipantid",children:"getHomeParticipantId"}),"\n",(0,a.jsx)(n.pre,{children:(0,a.jsx)(n.code,{className:"language-js",children:"const { homeParticipantId } = engine.getHomeParticipantId({ matchUp });\n"})}),"\n",(0,a.jsx)(n.hr,{}),"\n",(0,a.jsx)(n.h2,{id:"modifymatchupformattiming",children:"modifyMatchUpFormatTiming"}),"\n",(0,a.jsx)(n.p,{children:"Modifies the average match duration and recovery time requirements for a specific matchUp format. This function adds an extension to the tournament record that overrides default scheduling policy timing."}),"\n",(0,a.jsx)(n.p,{children:(0,a.jsx)(n.strong,{children:"How it Works:"})}),"\n",(0,a.jsxs)(n.ul,{children:["\n",(0,a.jsx)(n.li,{children:"Adds a tournament-level extension that is read by scheduling functions"}),"\n",(0,a.jsx)(n.li,{children:"Persists across scheduling operations until explicitly modified or removed"}),"\n",(0,a.jsx)(n.li,{children:"Can be scoped to specific age categories (e.g., 'U12', 'U14')"}),"\n",(0,a.jsx)(n.li,{children:"Can specify different timings for SINGLES vs. DOUBLES"}),"\n",(0,a.jsx)(n.li,{children:"Multiple calls will merge/override previous values for the same format"}),"\n"]}),"\n",(0,a.jsx)(n.p,{children:(0,a.jsx)(n.strong,{children:"Parameters:"})}),"\n",(0,a.jsxs)(n.ul,{children:["\n",(0,a.jsxs)(n.li,{children:[(0,a.jsx)(n.code,{children:"matchUpFormat"})," - TODS matchUpFormat code (e.g., 'SET3-S:6/TB7')"]}),"\n",(0,a.jsxs)(n.li,{children:[(0,a.jsx)(n.code,{children:"averageTimes"})," - Array of timing configurations by category","\n",(0,a.jsxs)(n.ul,{children:["\n",(0,a.jsxs)(n.li,{children:[(0,a.jsx)(n.code,{children:"categoryNames"})," - Array of category names (empty array = default for all categories)"]}),"\n",(0,a.jsxs)(n.li,{children:[(0,a.jsx)(n.code,{children:"minutes"})," - Object with ",(0,a.jsx)(n.code,{children:"default"})," and/or event type keys (e.g., SINGLES, DOUBLES)"]}),"\n"]}),"\n"]}),"\n",(0,a.jsxs)(n.li,{children:[(0,a.jsx)(n.code,{children:"recoveryTimes"})," - Array of recovery configurations by category (same structure as averageTimes)"]}),"\n",(0,a.jsxs)(n.li,{children:[(0,a.jsx)(n.code,{children:"event"})," - Optional - Scope modification to specific event"]}),"\n",(0,a.jsxs)(n.li,{children:[(0,a.jsx)(n.code,{children:"drawId"})," - Optional - Scope modification to specific draw"]}),"\n",(0,a.jsxs)(n.li,{children:[(0,a.jsx)(n.code,{children:"eventId"})," - Optional - Scope modification to specific event"]}),"\n"]}),"\n",(0,a.jsxs)(n.p,{children:[(0,a.jsx)(n.strong,{children:"Returns:"})," Standard result object with success/error status"]}),"\n",(0,a.jsx)(n.pre,{children:(0,a.jsx)(n.code,{className:"language-js",children:"// Modify timing for a specific format with category-based differentiation\nengine.modifyMatchUpFormatTiming({\n  matchUpFormat: 'SET3-S:6/TB7',\n  averageTimes: [\n    {\n      categoryNames: ['U12', 'U14'],\n      minutes: { DOUBLES: 110, default: 130 },\n    },\n    {\n      categoryNames: ['U16', 'U18'],\n      minutes: { DOUBLES: 100, default: 120 },\n    },\n  ],\n  recoveryTimes: [{ categoryNames: [], minutes: { default: 15, DOUBLES: 15 } }],\n});\n\n// Retrieve existing modifications before updating\nconst { matchUpFormat, averageTimes, recoveryTimes } = engine.getModifiedMatchUpFormatTiming({\n  matchUpFormat: 'SET3-S:6/TB7',\n});\n"})}),"\n",(0,a.jsx)(n.p,{children:(0,a.jsx)(n.strong,{children:"Related Functions:"})}),"\n",(0,a.jsxs)(n.ul,{children:["\n",(0,a.jsxs)(n.li,{children:[(0,a.jsx)(n.code,{children:"getModifiedMatchUpFormatTiming()"})," - Query existing format timing modifications"]}),"\n",(0,a.jsxs)(n.li,{children:["See ",(0,a.jsx)(n.a,{href:"/docs/concepts/scheduling-policy",children:"Scheduling Policy"})," for policy configuration"]}),"\n"]}),"\n",(0,a.jsx)(n.hr,{}),"\n",(0,a.jsx)(n.h2,{id:"removematchupsideparticipant",children:"removeMatchUpSideParticipant"}),"\n",(0,a.jsx)(n.p,{children:"Removes participant assigned to AD_HOC matchUp."}),"\n",(0,a.jsx)(n.pre,{children:(0,a.jsx)(n.code,{className:"language-js",children:"engine.removeMatchUpSideParticipant({\n  sideNumber, // number - required\n  matchUpId, // required\n  drawId, // required\n});\n"})}),"\n",(0,a.jsx)(n.hr,{}),"\n",(0,a.jsx)(n.h2,{id:"replacetiematchupparticipantid",children:"replaceTieMatchUpParticipantId"}),"\n",(0,a.jsx)(n.pre,{children:(0,a.jsx)(n.code,{className:"language-js",children:"engine.replaceTieMatchUpParticipantId({\n  existingParticipantId,\n  newParticipantId,\n  tieMatchUpId,\n  drawId,\n});\n"})}),"\n",(0,a.jsx)(n.hr,{}),"\n",(0,a.jsx)(n.h2,{id:"removetiematchupparticipantid",children:"removeTieMatchUpParticipantId"}),"\n",(0,a.jsx)(n.pre,{children:(0,a.jsx)(n.code,{className:"language-js",children:"engine.removeTieMatchUpParticipantId({\n  participantId, // id of INDIVIDUAL or PAIR be removed\n  tieMatchUpId, // tieMatchUp, matchUpType either DOUBLES or SINGLES\n  drawId, // draw within which tieMatchUp is found\n});\n"})}),"\n",(0,a.jsx)(n.hr,{}),"\n",(0,a.jsx)(n.h2,{id:"resetadhocmatchups",children:"resetAdHocMatchUps"}),"\n",(0,a.jsx)(n.p,{children:"Will remove all results (scores) and optionally all participant assignments from specified matchUps (via matchUpIds or roundNumbers)."}),"\n",(0,a.jsx)(n.pre,{children:(0,a.jsx)(n.code,{className:"language-js",children:"const result = engine.resetAdHocMatchUps({\n  removeAssignments, // optional; remove all assigned participants\n  roundNumbers, // optional if matchUpids provided\n  matchUpIds, // optional only if roundNumber(s) provided\n  structureId, // optional unless matchUpIds not provided\n  drawId,\n};\n\nexport function resetAdHocMatchUps(params: ResetAdHocMatchUps) {\n  const paramsCheck = checkRequiredParameters(params, [\n    { [DRAW_DEFINITION]: true, [EVENT]: true },\n    {\n      [ONE_OF]: { [MATCHUP_IDS]: false, roundNumbers: false },\n      [INVALID]: INVALID_VALUES,\n      [OF_TYPE]: ARRAY,\n    },\n  ]);\n  if (paramsCheck.error) return paramsCheck;\n\n  const structureResult = getAdHocStructureDetails(params);\n  if (structureResult.error) return structureResult;\n  const { matchUpIds } = structureResult;\n})\n"})}),"\n",(0,a.jsx)(n.hr,{}),"\n",(0,a.jsx)(n.h2,{id:"resetscorecard",children:"resetScorecard"}),"\n",(0,a.jsxs)(n.p,{children:["Removes all scores from ",(0,a.jsx)(n.code,{children:"tieMatchUps"})," within a TEAM ",(0,a.jsx)(n.code,{children:"matchUp"}),"; preserves ",(0,a.jsx)(n.code,{children:"lineUps"}),"."]}),"\n",(0,a.jsx)(n.pre,{children:(0,a.jsx)(n.code,{className:"language-js",children:"engine.resetScorecard({\n  tiebreakReset, // optional boolean - check for tiebreak scenarios and reset tieFormat\n  tournamentId, // required\n  matchUpId, // required - must be a TEAM matchUp\n  drawId, // required\n});\n"})}),"\n",(0,a.jsx)(n.hr,{}),"\n",(0,a.jsx)(n.h2,{id:"resettieformat",children:"resetTieFormat"}),"\n",(0,a.jsxs)(n.p,{children:["Remove the ",(0,a.jsx)(n.code,{children:"tieFormat"})," from a TEAM ",(0,a.jsx)(n.code,{children:"matchUp"})," if there is a ",(0,a.jsx)(n.code,{children:"tieFormat"})," further up the hierarchy; modifies ",(0,a.jsx)(n.code,{children:"matchUp.tieMatchUps"})," to correspond."]}),"\n",(0,a.jsx)(n.pre,{children:(0,a.jsx)(n.code,{className:"language-js",children:"engine.resetTieFormat({\n  tournamentId, // required\n  matchUpId, // must be a TEAM matchUp\n  drawId, // required\n  uuids, // optional - in client/server scenarios generated matchUps must have equivalent matchUpIds\n});\n"})}),"\n",(0,a.jsx)(n.hr,{}),"\n",(0,a.jsx)(n.h2,{id:"setmatchupdailylimits",children:"setMatchUpDailyLimits"}),"\n",(0,a.jsx)(n.p,{children:"Sets daily match limits for participants. This function adds an extension to the tournament record that is enforced by all scheduling functions to prevent over-scheduling players."}),"\n",(0,a.jsx)(n.p,{children:(0,a.jsx)(n.strong,{children:"How it Works:"})}),"\n",(0,a.jsxs)(n.ul,{children:["\n",(0,a.jsx)(n.li,{children:"Adds a tournament-level extension that is checked by scheduling functions"}),"\n",(0,a.jsx)(n.li,{children:"Persists across scheduling operations until explicitly modified"}),"\n",(0,a.jsx)(n.li,{children:"Enforced during both manual and automated scheduling"}),"\n",(0,a.jsx)(n.li,{children:"Can be scoped to specific tournament in multi-tournament scenarios"}),"\n",(0,a.jsx)(n.li,{children:"Multiple calls will override previous values entirely"}),"\n"]}),"\n",(0,a.jsx)(n.p,{children:(0,a.jsx)(n.strong,{children:"Parameters:"})}),"\n",(0,a.jsxs)(n.ul,{children:["\n",(0,a.jsxs)(n.li,{children:[(0,a.jsx)(n.code,{children:"dailyLimits"})," - Object specifying limits:","\n",(0,a.jsxs)(n.ul,{children:["\n",(0,a.jsxs)(n.li,{children:[(0,a.jsx)(n.code,{children:"SINGLES"})," - Maximum singles matches per day per participant"]}),"\n",(0,a.jsxs)(n.li,{children:[(0,a.jsx)(n.code,{children:"DOUBLES"})," - Maximum doubles matches per day per participant"]}),"\n",(0,a.jsxs)(n.li,{children:[(0,a.jsx)(n.code,{children:"total"})," - Maximum total matches per day per participant (across all event types)"]}),"\n"]}),"\n"]}),"\n",(0,a.jsxs)(n.li,{children:[(0,a.jsx)(n.code,{children:"tournamentId"})," - Optional - Scope to specific tournament (for multi-tournament records)"]}),"\n"]}),"\n",(0,a.jsxs)(n.p,{children:[(0,a.jsx)(n.strong,{children:"Returns:"})," Standard result object with success/error status"]}),"\n",(0,a.jsx)(n.pre,{children:(0,a.jsx)(n.code,{className:"language-js",children:"// Set tournament-wide daily limits\nengine.setMatchUpDailyLimits({\n  dailyLimits: { SINGLES: 2, DOUBLES: 1, total: 3 },\n});\n\n// Scope to specific tournament\nengine.setMatchUpDailyLimits({\n  dailyLimits: { SINGLES: 1, DOUBLES: 1, total: 2 },\n  tournamentId: 'tournament-123',\n});\n\n// Retrieve current daily limits\nconst { matchUpDailyLimits } = engine.getMatchUpDailyLimits();\nconst { SINGLES, DOUBLES, total } = matchUpDailyLimits;\n"})}),"\n",(0,a.jsx)(n.p,{children:(0,a.jsx)(n.strong,{children:"Related Functions:"})}),"\n",(0,a.jsxs)(n.ul,{children:["\n",(0,a.jsxs)(n.li,{children:[(0,a.jsx)(n.code,{children:"getMatchUpDailyLimits()"})," - Query current daily limit configuration"]}),"\n",(0,a.jsxs)(n.li,{children:["See ",(0,a.jsx)(n.a,{href:"/docs/concepts/scheduling-policy",children:"Scheduling Policy"})," for policy-based limits"]}),"\n"]}),"\n",(0,a.jsx)(n.hr,{}),"\n",(0,a.jsx)(n.h2,{id:"setmatchupformat",children:"setMatchUpFormat"}),"\n",(0,a.jsxs)(n.p,{children:["Sets the ",(0,a.jsx)(n.code,{children:"matchUpFormat"})," for a specific ",(0,a.jsx)(n.code,{children:"matchUp"})," or for any scope within the hierarchy of a ",(0,a.jsx)(n.code,{children:"tournamentRecord"}),"."]}),"\n",(0,a.jsxs)(n.admonition,{type:"info",children:[(0,a.jsxs)(n.p,{children:["If an array of ",(0,a.jsx)(n.code,{children:"scheduledDates"})," is provided then ",(0,a.jsx)(n.code,{children:"matchUps"})," which have ",(0,a.jsx)(n.code,{children:"matchUpStatus: TO_BE_PLAYED"})," and are scheduled to be played on the specified dates will have their ",(0,a.jsx)(n.code,{children:"matchUpFormat"})," fixed rather than inherited. This means that subsequent changes to the parent ",(0,a.jsx)(n.code,{children:"structure.matchUpFormat"})," will have no effect on such ",(0,a.jsx)(n.code,{children:"matchUps"}),"."]}),(0,a.jsxs)(n.p,{children:["The ",(0,a.jsx)(n.code,{children:"force"})," attribute will remove the ",(0,a.jsx)(n.code,{children:"matchUpFormat"})," from all targeted ",(0,a.jsx)(n.code,{children:"matchUps"})," which have ",(0,a.jsx)(n.code,{children:"matchUpStatus: TO_BE_PLAYED"}),"; this allows the effect of using ",(0,a.jsx)(n.code,{children:"scheduledDates"})," to be reversed. Use of this attribute will have no effect if ",(0,a.jsx)(n.code,{children:"scheduledDates"})," is also provided."]})]}),"\n",(0,a.jsx)(n.pre,{children:(0,a.jsx)(n.code,{className:"language-js",children:"engine.setMatchUpFormat({\n  matchUpFormat, // TODS matchUpFormatCode\n  eventType, // optional - restrict to SINGLES or DOUBLES\n\n  matchUpId, // optional - set matchUpFormat for a specific matchUp\n  drawId, // required only if matchUpId, structureId or structureIds is present\n  force, // optional boolean - when setting for structure, draws or events, strip any defined matchUpFormat from all TO_BE_PLAYED matchUps\n\n  // scoping options\n  scheduledDates, // optional - ['2022-01-01']\n  stageSequences, // optional - [1, 2]\n  structureIds, // optional - ['structureId1', 'structureId2']\n  structureId, // optional\n  eventIds, // optional - ['eventId1', 'eventId2']\n  eventId, // optional\n  drawIds, // optional - ['drawId1', 'drawId2']\n  stages, // optional - ['MAIN', 'CONSOLATION']\n});\n"})}),"\n",(0,a.jsx)(n.hr,{}),"\n",(0,a.jsx)(n.h2,{id:"setmatchuphomeparticipantid",children:"setMatchUpHomeParticipantId"}),"\n",(0,a.jsxs)(n.p,{children:["Value ",(0,a.jsx)(n.code,{children:"homeParticipantId"})," will appear in hydrated ",(0,a.jsx)(n.code,{children:"matchUps.schedule"}),"."]}),"\n",(0,a.jsx)(n.pre,{children:(0,a.jsx)(n.code,{className:"language-js",children:"engine.setMatchUpHomeParticipantId({\n  disableNotice, // when disabled subscribers will not be notified\n  homeParticipantId, // empty string ('') will remove\n  removePriorValues, // optional boolean\n  matchUpId,\n  drawId,\n});\n"})}),"\n",(0,a.jsx)(n.hr,{}),"\n",(0,a.jsx)(n.h2,{id:"setmatchupstatus",children:"setMatchUpStatus"}),"\n",(0,a.jsx)(n.p,{children:"Sets either matchUpStatus or score and winningSide; values to be set are passed in outcome object. Handles any winner/loser participant movements within or across structures."}),"\n",(0,a.jsx)(n.pre,{children:(0,a.jsx)(n.code,{className:"language-js",children:"const outcome = {\n  matchUpStatus, // optional\n  winningSide, // optional\n  score, // optional\n};\n\nengine.setMatchUpStatus({\n  disableScoreValidation, // optional boolean\n  allowChangePropagation, // optional boolean - allow winner/loser to be swapped and propgate change throughout draw structures\n  disableAutoCalc, // optional - applies only to { matchUpType: TEAM }\n  enableAutoCalc, // optional - applies only to { matchUpType: TEAM }\n  tournamentId,\n  matchUpTieId, // optional - if part of a TIE matchUp\n  matchUpId,\n  outcome, // optional\n  drawId,\n  schedule: {\n    // optional - set schedule items\n    courtIds, // optional - applies only to TEAM matchUps => creates .allocatedCourts\n    courtId, // requires scheduledDate\n    venueId,\n    scheduledDate,\n    scheduledTime,\n    startTime,\n    endTime,\n  },\n  notes, // optional - add note (string) to matchUp object\n});\n"})}),"\n",(0,a.jsx)(n.hr,{}),"\n",(0,a.jsx)(n.h2,{id:"setorderoffinish",children:"setOrderOfFinish"}),"\n",(0,a.jsxs)(n.p,{children:["Sets the ",(0,a.jsx)(n.code,{children:"orderOfFinish"})," attribute for ",(0,a.jsx)(n.code,{children:"matchUps"})," specified by ",(0,a.jsx)(n.code,{children:"matchUpId"})," in the ",(0,a.jsx)(n.code,{children:"finishingOrder"})," array."]}),"\n",(0,a.jsx)(n.h3,{id:"validation",children:"Validation"}),"\n",(0,a.jsxs)(n.p,{children:["Validation is done within a ",(0,a.jsx)(n.em,{children:"cohort"})," of ",(0,a.jsx)(n.code,{children:"matchUps"})," which have equivalent ",(0,a.jsx)(n.code,{children:"structureId"}),", ",(0,a.jsx)(n.code,{children:"matchUpType"}),", ",(0,a.jsx)(n.code,{children:"roundNumber"}),", and ",(0,a.jsx)(n.code,{children:"matchUpTieId"})," (if applicable)."]}),"\n",(0,a.jsxs)(n.ul,{children:["\n",(0,a.jsxs)(n.li,{children:[(0,a.jsx)(n.code,{children:"matchUpIds"})," in ",(0,a.jsx)(n.code,{children:"finishingOrder"})," must be part of the same ",(0,a.jsx)(n.em,{children:"cohort"})]}),"\n",(0,a.jsxs)(n.li,{children:[(0,a.jsx)(n.code,{children:"orderOfFinish"})," values must be unique positive integers within the ",(0,a.jsx)(n.em,{children:"cohort"})]}),"\n"]}),"\n",(0,a.jsx)(n.pre,{children:(0,a.jsx)(n.code,{className:"language-js",children:"engine.setOrderOfFinish({\n  finishingOrder: [{ matchUpId, orderOfFinish: 1 }],\n  drawId,\n});\n"})}),"\n",(0,a.jsx)(n.hr,{}),"\n",(0,a.jsx)(n.h2,{id:"toggleparticipantcheckinstate",children:"toggleParticipantCheckInState"}),"\n",(0,a.jsx)(n.pre,{children:(0,a.jsx)(n.code,{className:"language-js",children:"engine.toggleParticipantCheckInState({\n  participantId,\n  tournamentId,\n  matchUpId,\n  drawId,\n});\n"})}),"\n",(0,a.jsx)(n.hr,{}),"\n",(0,a.jsx)(n.h2,{id:"updatetiematchupscore",children:"updateTieMatchUpScore"}),"\n",(0,a.jsx)(n.p,{children:"Trigger automatic calculation of the score of a TEAM matchUp."}),"\n",(0,a.jsx)(n.pre,{children:(0,a.jsx)(n.code,{className:"language-js",children:"engine.updateTieMatchUpScore({\n  tournamentId, // optional if default tournament set\n  matchUpId,\n  drawId,\n});\n"})}),"\n",(0,a.jsx)(n.hr,{})]})}function h(e={}){const{wrapper:n}={...(0,s.R)(),...e.components};return n?(0,a.jsx)(n,{...e,children:(0,a.jsx)(l,{...e})}):l(e)}},8439(e,n,i){i.d(n,{R:()=>r,x:()=>c});var t=i(758);const a={},s=t.createContext(a);function r(e){const n=t.useContext(s);return t.useMemo(function(){return"function"==typeof e?e(n):{...n,...e}},[n,e])}function c(e){let n;return n=e.disableParentContext?"function"==typeof e.components?e.components(a):e.components||a:r(e.components),t.createElement(s.Provider,{value:n},e.children)}}}]);