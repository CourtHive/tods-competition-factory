"use strict";(globalThis.webpackChunkdocumentation=globalThis.webpackChunkdocumentation||[]).push([[485],{8039(e,n,i){i.r(n),i.d(n,{assets:()=>o,contentTitle:()=>l,default:()=>h,frontMatter:()=>s,metadata:()=>t,toc:()=>c});const t=JSON.parse('{"id":"temporal-engine/temporal-engine-overview","title":"Temporal Engine Overview","description":"The TemporalEngine is a pure JavaScript state machine that models court availability as continuous time-based capacity streams. Rather than tracking when courts are available, it tracks when they are unavailable \u2014 blocks paint unavailable time onto courts, and availability rails and capacity curves are derived on demand. The engine is UI-agnostic, fully testable, and operates as a standalone class (not attached to the factory engine pattern).","source":"@site/docs/temporal-engine/temporal-engine-overview.md","sourceDirName":"temporal-engine","slug":"/temporal-engine/temporal-engine-overview","permalink":"/competition-factory/docs/temporal-engine/temporal-engine-overview","draft":false,"unlisted":false,"tags":[],"version":"current","frontMatter":{"title":"Temporal Engine Overview"},"sidebar":"docs","previous":{"title":"Visualization Applications","permalink":"/competition-factory/docs/scoring-engine/visualization-applications"},"next":{"title":"Core API Reference","permalink":"/competition-factory/docs/temporal-engine/temporal-engine-api"}}');var r=i(6070),a=i(8322);const s={title:"Temporal Engine Overview"},l=void 0,o={},c=[{value:"When to Use TemporalEngine vs scheduleGovernor",id:"when-to-use-temporalengine-vs-schedulegovernor",level:2},{value:"Key Capabilities",id:"key-capabilities",level:2},{value:"Basic Usage",id:"basic-usage",level:2},{value:"Architecture",id:"architecture",level:2},{value:"Constructor &amp; Initialization",id:"constructor--initialization",level:2},{value:"Related Documentation",id:"related-documentation",level:2}];function d(e){const n={a:"a",admonition:"admonition",code:"code",em:"em",h2:"h2",li:"li",ol:"ol",p:"p",pre:"pre",strong:"strong",table:"table",tbody:"tbody",td:"td",th:"th",thead:"thead",tr:"tr",ul:"ul",...(0,a.R)(),...e.components};return(0,r.jsxs)(r.Fragment,{children:[(0,r.jsxs)(n.p,{children:["The ",(0,r.jsx)(n.strong,{children:"TemporalEngine"})," is a pure JavaScript state machine that models court availability as continuous time-based capacity streams. Rather than tracking when courts are ",(0,r.jsx)(n.em,{children:"available"}),", it tracks when they are ",(0,r.jsx)(n.em,{children:"unavailable"})," \u2014 blocks paint unavailable time onto courts, and availability rails and capacity curves are derived on demand. The engine is UI-agnostic, fully testable, and operates as a standalone class (not attached to the factory engine pattern)."]}),"\n",(0,r.jsx)(n.h2,{id:"when-to-use-temporalengine-vs-schedulegovernor",children:"When to Use TemporalEngine vs scheduleGovernor"}),"\n",(0,r.jsxs)(n.table,{children:[(0,r.jsx)(n.thead,{children:(0,r.jsxs)(n.tr,{children:[(0,r.jsx)(n.th,{children:"Use Case"}),(0,r.jsx)(n.th,{children:"Recommended"})]})}),(0,r.jsxs)(n.tbody,{children:[(0,r.jsxs)(n.tr,{children:[(0,r.jsx)(n.td,{children:"Interactive visual scheduling (timeline editor)"}),(0,r.jsx)(n.td,{children:(0,r.jsx)(n.strong,{children:"TemporalEngine"})})]}),(0,r.jsxs)(n.tr,{children:[(0,r.jsx)(n.td,{children:"Real-time availability queries"}),(0,r.jsx)(n.td,{children:(0,r.jsx)(n.strong,{children:"TemporalEngine"})})]}),(0,r.jsxs)(n.tr,{children:[(0,r.jsx)(n.td,{children:"What-if simulation (preview before commit)"}),(0,r.jsx)(n.td,{children:(0,r.jsx)(n.strong,{children:"TemporalEngine"})})]}),(0,r.jsxs)(n.tr,{children:[(0,r.jsx)(n.td,{children:"Capacity analysis and utilization stats"}),(0,r.jsx)(n.td,{children:(0,r.jsx)(n.strong,{children:"TemporalEngine"})})]}),(0,r.jsxs)(n.tr,{children:[(0,r.jsx)(n.td,{children:"Conflict detection with pluggable evaluators"}),(0,r.jsx)(n.td,{children:(0,r.jsx)(n.strong,{children:"TemporalEngine"})})]}),(0,r.jsxs)(n.tr,{children:[(0,r.jsx)(n.td,{children:"Plan management (round assignment to days)"}),(0,r.jsx)(n.td,{children:(0,r.jsx)(n.strong,{children:"TemporalEngine"})})]}),(0,r.jsxs)(n.tr,{children:[(0,r.jsx)(n.td,{children:"Automated Garman scheduling"}),(0,r.jsx)(n.td,{children:(0,r.jsx)(n.strong,{children:"scheduleGovernor"})})]}),(0,r.jsxs)(n.tr,{children:[(0,r.jsx)(n.td,{children:"Bulk matchUp time assignment"}),(0,r.jsx)(n.td,{children:(0,r.jsx)(n.strong,{children:"scheduleGovernor"})})]}),(0,r.jsxs)(n.tr,{children:[(0,r.jsx)(n.td,{children:"Scheduling policy enforcement"}),(0,r.jsx)(n.td,{children:(0,r.jsx)(n.strong,{children:"scheduleGovernor"})})]})]})]}),"\n",(0,r.jsx)(n.h2,{id:"key-capabilities",children:"Key Capabilities"}),"\n",(0,r.jsxs)(n.ul,{children:["\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.strong,{children:"Inverted paradigm"})," \u2014 Blocks represent unavailable time; available time is whatever remains"]}),"\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.strong,{children:"Immutable mutations"})," \u2014 All block operations return a ",(0,r.jsx)(n.code,{children:"MutationResult"})," with applied/rejected mutations and conflicts"]}),"\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.strong,{children:"Derived state"})," \u2014 Rails (non-overlapping segments) and capacity curves are computed on demand, never stored"]}),"\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.strong,{children:"Event-driven subscriptions"})," \u2014 Subscribe to ",(0,r.jsx)(n.code,{children:"STATE_CHANGED"}),", ",(0,r.jsx)(n.code,{children:"BLOCKS_CHANGED"}),", ",(0,r.jsx)(n.code,{children:"CONFLICTS_CHANGED"}),", ",(0,r.jsx)(n.code,{children:"AVAILABILITY_CHANGED"}),", and ",(0,r.jsx)(n.code,{children:"PLAN_CHANGED"})," events"]}),"\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.strong,{children:"Pluggable conflict evaluators"})," \u2014 Register built-in or custom evaluators for overlap detection, day boundary checks, lighting, maintenance windows, and more"]}),"\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.strong,{children:"Multi-phase validation pipeline"})," \u2014 PRECHECK \u2192 INTEGRITY \u2192 ORDERING \u2192 CAPACITY pipeline validates plan state"]}),"\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.strong,{children:"What-if simulation"})," \u2014 Preview mutations on a disposable snapshot without affecting real state"]}),"\n",(0,r.jsxs)(n.li,{children:[(0,r.jsxs)(n.strong,{children:[(0,r.jsx)(n.a,{href:"/docs/data-standards#codes",children:"CODES"})," bridge"]})," \u2014 Bidirectional translation between engine blocks/rails and CODES tournament record structures"]}),"\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.strong,{children:"Availability hierarchy"})," \u2014 Court-day \u2192 court-default \u2192 venue-day \u2192 venue-default \u2192 global-default \u2192 engine config fallback"]}),"\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.strong,{children:"Standalone class"})," \u2014 Instantiate directly with ",(0,r.jsx)(n.code,{children:"new TemporalEngine()"}),", no factory integration required"]}),"\n"]}),"\n",(0,r.jsx)(n.h2,{id:"basic-usage",children:"Basic Usage"}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-js",children:"import { TemporalEngine } from 'tods-competition-factory';\n\n// Create and initialize\nconst engine = new TemporalEngine();\nengine.init(tournamentRecord, {\n  dayStartTime: '08:00',\n  dayEndTime: '20:00',\n  slotMinutes: 15,\n});\n\n// Paint a maintenance block on two courts\nconst result = engine.applyBlock({\n  courts: [court1Ref, court2Ref],\n  timeRange: { start: '2026-06-15T12:00:00', end: '2026-06-15T13:00:00' },\n  type: 'MAINTENANCE',\n  reason: 'Lunch break',\n});\n\n// Query derived state\nconst timelines = engine.getDayTimeline('2026-06-15');\nconst capacity = engine.getCapacityCurve('2026-06-15');\nconst rail = engine.getCourtRail('2026-06-15', court1Ref);\n"})}),"\n",(0,r.jsx)(n.h2,{id:"architecture",children:"Architecture"}),"\n",(0,r.jsx)(n.p,{children:"The TemporalEngine follows a three-layer architecture where blocks are the only canonical state and everything else is derived:"}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-text",children:"\u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510\n\u2502        TemporalEngine            \u2502  Standalone class / facade\n\u2502  (block CRUD, plans, events,     \u2502\n\u2502   availability, simulation)      \u2502\n\u251c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2524\n\u2502      temporalGovernor            \u2502  Pure algorithm modules\n\u2502  (railDerivation, capacityCurve, \u2502\n\u2502   collisionDetection, bridge,    \u2502\n\u2502   conflictEvaluators,            \u2502\n\u2502   validationPipeline, planState, \u2502\n\u2502   timeGranularity)               \u2502\n\u251c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2524\n\u2502    CODES Tournament Record       \u2502  Standard data model\n\u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518\n"})}),"\n",(0,r.jsx)(n.admonition,{type:"note",children:(0,r.jsxs)(n.p,{children:["Unlike the ",(0,r.jsx)(n.code,{children:"ScoringEngine"})," which wraps ",(0,r.jsx)(n.code,{children:"scoreGovernor"})," functions inside the factory engine pattern, the ",(0,r.jsx)(n.code,{children:"TemporalEngine"})," is a ",(0,r.jsx)(n.strong,{children:"standalone class"}),". You instantiate it directly with ",(0,r.jsx)(n.code,{children:"new TemporalEngine()"})," and pass a tournament record via ",(0,r.jsx)(n.code,{children:"init()"}),". It does not register with the competition factory's engine infrastructure."]})}),"\n",(0,r.jsx)(n.h2,{id:"constructor--initialization",children:"Constructor & Initialization"}),"\n",(0,r.jsxs)(n.p,{children:["The ",(0,r.jsx)(n.code,{children:"TemporalEngine"})," has no constructor parameters. All configuration is passed through ",(0,r.jsx)(n.code,{children:"init()"}),":"]}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-ts",children:"const engine = new TemporalEngine();\nengine.init(tournamentRecord, config);\n"})}),"\n",(0,r.jsxs)(n.p,{children:["The ",(0,r.jsx)(n.code,{children:"EngineConfig"})," interface:"]}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-ts",children:"interface EngineConfig {\n  tournamentId: TournamentId; // Defaults to tournamentRecord.tournamentId\n  dayStartTime: string; // 'HH:MM' \u2014 default '06:00'\n  dayEndTime: string; // 'HH:MM' \u2014 default '23:00'\n  slotMinutes: number; // Rendering granularity \u2014 default 15\n  granularityMinutes?: number; // Canonical time granularity (overrides slotMinutes)\n  typePrecedence: BlockType[]; // Priority order for resolving overlapping blocks\n  conflictEvaluators?: ConflictEvaluator[]; // Pluggable conflict evaluators\n}\n"})}),"\n",(0,r.jsx)(n.p,{children:(0,r.jsxs)(n.strong,{children:["Default ",(0,r.jsx)(n.code,{children:"typePrecedence"}),":"]})}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-text",children:"HARD_BLOCK \u2192 LOCKED \u2192 MAINTENANCE \u2192 BLOCKED \u2192 PRACTICE \u2192 RESERVED \u2192 SOFT_BLOCK \u2192 AVAILABLE \u2192 UNSPECIFIED\n"})}),"\n",(0,r.jsxs)(n.p,{children:["During ",(0,r.jsx)(n.code,{children:"init()"}),", the engine:"]}),"\n",(0,r.jsxs)(n.ol,{children:["\n",(0,r.jsx)(n.li,{children:"Merges provided config with defaults"}),"\n",(0,r.jsxs)(n.li,{children:["Resolves canonical granularity (",(0,r.jsx)(n.code,{children:"granularityMinutes"})," \u2192 ",(0,r.jsx)(n.code,{children:"slotMinutes"})," \u2192 ",(0,r.jsx)(n.code,{children:"15"}),")"]}),"\n",(0,r.jsx)(n.li,{children:"Clears all plan state (plans do not survive re-init)"}),"\n",(0,r.jsxs)(n.li,{children:["Loads blocks from the tournament record's venue/court ",(0,r.jsx)(n.code,{children:"dateAvailability"})," and ",(0,r.jsx)(n.code,{children:"bookings"})]}),"\n",(0,r.jsxs)(n.li,{children:["Emits a ",(0,r.jsx)(n.code,{children:"STATE_CHANGED"})," event with reason ",(0,r.jsx)(n.code,{children:"'INIT'"})]}),"\n"]}),"\n",(0,r.jsx)(n.h2,{id:"related-documentation",children:"Related Documentation"}),"\n",(0,r.jsxs)(n.ul,{children:["\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.strong,{children:(0,r.jsx)(n.a,{href:"./temporal-engine-api",children:"Core API Reference"})})," \u2014 Complete method reference"]}),"\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.strong,{children:(0,r.jsx)(n.a,{href:"./event-system-and-validation",children:"Event System & Validation"})})," \u2014 Events, conflict evaluators, and validation pipeline"]}),"\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.strong,{children:(0,r.jsx)(n.a,{href:"./block-types-and-algorithms",children:"Block Types & Algorithms"})})," \u2014 Block types, rail derivation, capacity curves, collision detection"]}),"\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.strong,{children:(0,r.jsx)(n.a,{href:"./ui-integration-scenarios",children:"UI Integration Scenarios"})})," \u2014 Building UIs with the temporal grid and scheduling profile"]}),"\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.strong,{children:(0,r.jsx)(n.a,{href:"/docs/concepts/scheduling-overview",children:"Scheduling Overview"})})," \u2014 Scheduling concepts"]}),"\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.strong,{children:(0,r.jsx)(n.a,{href:"/docs/concepts/venues-courts",children:"Venues & Courts"})})," \u2014 Venue and court data structures"]}),"\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.strong,{children:(0,r.jsx)(n.a,{href:"/docs/governors/schedule-governor",children:"Schedule Governor"})})," \u2014 Automated scheduling functions"]}),"\n"]})]})}function h(e={}){const{wrapper:n}={...(0,a.R)(),...e.components};return n?(0,r.jsx)(n,{...e,children:(0,r.jsx)(d,{...e})}):d(e)}},8322(e,n,i){i.d(n,{R:()=>s,x:()=>l});var t=i(758);const r={},a=t.createContext(r);function s(e){const n=t.useContext(a);return t.useMemo(function(){return"function"==typeof e?e(n):{...n,...e}},[n,e])}function l(e){let n;return n=e.disableParentContext?"function"==typeof e.components?e.components(r):e.components||r:s(e.components),t.createElement(a.Provider,{value:n},e.children)}}}]);