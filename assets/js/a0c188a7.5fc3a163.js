"use strict";(globalThis.webpackChunkdocumentation=globalThis.webpackChunkdocumentation||[]).push([[6352],{4845(e,n,t){t.r(n),t.d(n,{assets:()=>l,contentTitle:()=>o,default:()=>h,frontMatter:()=>s,metadata:()=>i,toc:()=>c});const i=JSON.parse('{"id":"temporal-engine/ui-integration-scenarios","title":"UI Integration Scenarios","description":"This page demonstrates how to build real-world UIs on top of the TemporalEngine, drawn from the temporal-grid and scheduling-profile components in courthive-components.","source":"@site/docs/temporal-engine/ui-integration-scenarios.md","sourceDirName":"temporal-engine","slug":"/temporal-engine/ui-integration-scenarios","permalink":"/competition-factory/docs/temporal-engine/ui-integration-scenarios","draft":false,"unlisted":false,"tags":[],"version":"current","frontMatter":{"title":"UI Integration Scenarios"},"sidebar":"docs","previous":{"title":"Block Types & Algorithms","permalink":"/competition-factory/docs/temporal-engine/block-types-and-algorithms"},"next":{"title":"Overview","permalink":"/competition-factory/docs/governors/governors-overview"}}');var r=t(6070),a=t(8322);const s={title:"UI Integration Scenarios"},o=void 0,l={},c=[{value:"Architecture Pattern",id:"architecture-pattern",level:2},{value:"Scenario 1 \u2014 Temporal Grid (Interactive Timeline Editor)",id:"scenario-1--temporal-grid-interactive-timeline-editor",level:2},{value:"Engine Methods Used",id:"engine-methods-used",level:3},{value:"Initialization Pattern",id:"initialization-pattern",level:3},{value:"View Projections Pattern",id:"view-projections-pattern",level:3},{value:"Paint Mode \u2014 Drag-to-Create",id:"paint-mode--drag-to-create",level:3},{value:"Drag/Resize with Collision Detection",id:"dragresize-with-collision-detection",level:3},{value:"Capacity Visualization",id:"capacity-visualization",level:3},{value:"Saving Back to Tournament Record",id:"saving-back-to-tournament-record",level:3},{value:"Scenario 2 \u2014 Scheduling Profile Builder",id:"scenario-2--scheduling-profile-builder",level:2},{value:"TemporalAdapter Interface",id:"temporaladapter-interface",level:3},{value:"Plan State Integration",id:"plan-state-integration",level:3},{value:"From Plan to Factory Scheduling Profile",id:"from-plan-to-factory-scheduling-profile",level:3},{value:"What-If Simulation",id:"what-if-simulation",level:2},{value:"Shadow Scheduling",id:"shadow-scheduling",level:2},{value:"Related Documentation",id:"related-documentation",level:2}];function d(e){const n={a:"a",admonition:"admonition",code:"code",em:"em",h2:"h2",h3:"h3",hr:"hr",li:"li",p:"p",pre:"pre",strong:"strong",table:"table",tbody:"tbody",td:"td",th:"th",thead:"thead",tr:"tr",ul:"ul",...(0,a.R)(),...e.components};return(0,r.jsxs)(r.Fragment,{children:[(0,r.jsxs)(n.p,{children:["This page demonstrates how to build real-world UIs on top of the TemporalEngine, drawn from the ",(0,r.jsx)(n.code,{children:"temporal-grid"})," and ",(0,r.jsx)(n.code,{children:"scheduling-profile"})," components in ",(0,r.jsx)(n.code,{children:"courthive-components"}),"."]}),"\n",(0,r.jsx)(n.h2,{id:"architecture-pattern",children:"Architecture Pattern"}),"\n",(0,r.jsx)(n.p,{children:"All UI integrations follow the same data flow:"}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{children:"Tournament Record \u2192 TemporalEngine \u2192 View Projections \u2192 UI Layer\n                         \u2191                                  \u2502\n                         \u2514\u2500\u2500\u2500\u2500 Controller (events/mutations) \u2518\n"})}),"\n",(0,r.jsxs)(n.p,{children:["The ",(0,r.jsx)(n.strong,{children:"Controller"})," routes user interactions (clicks, drags, drops) to engine mutation methods, and engine events back to the UI layer. ",(0,r.jsx)(n.strong,{children:"View Projections"})," are pure functions that transform engine domain objects (timelines, rails, blocks) into UI-framework-specific data structures."]}),"\n",(0,r.jsx)(n.admonition,{type:"tip",children:(0,r.jsxs)(n.p,{children:["View projections are the key separation layer. The engine knows nothing about vis-timeline, React, or any UI framework. Projections translate ",(0,r.jsx)(n.code,{children:"VenueDayTimeline[]"})," into ",(0,r.jsx)(n.code,{children:"TimelineGroup[]"})," and ",(0,r.jsx)(n.code,{children:"TimelineItem[]"})," (or whatever your framework needs). This makes the engine independently testable and the projections independently testable."]})}),"\n",(0,r.jsx)(n.hr,{}),"\n",(0,r.jsx)(n.h2,{id:"scenario-1--temporal-grid-interactive-timeline-editor",children:"Scenario 1 \u2014 Temporal Grid (Interactive Timeline Editor)"}),"\n",(0,r.jsxs)(n.p,{children:["The temporal grid is an interactive calendar-style editor that uses ",(0,r.jsx)(n.a,{href:"https://visjs.github.io/vis-timeline/",children:"vis-timeline"})," for visual court availability management. Users can paint blocks, drag/resize them, and see capacity in real time."]}),"\n",(0,r.jsx)(n.h3,{id:"engine-methods-used",children:"Engine Methods Used"}),"\n",(0,r.jsxs)(n.table,{children:[(0,r.jsx)(n.thead,{children:(0,r.jsxs)(n.tr,{children:[(0,r.jsx)(n.th,{children:"User Action"}),(0,r.jsx)(n.th,{children:"Engine Method"}),(0,r.jsx)(n.th,{children:"Event Emitted"})]})}),(0,r.jsxs)(n.tbody,{children:[(0,r.jsxs)(n.tr,{children:[(0,r.jsx)(n.td,{children:"Paint a block (drag on empty space)"}),(0,r.jsx)(n.td,{children:(0,r.jsx)(n.code,{children:"applyBlock()"})}),(0,r.jsx)(n.td,{children:(0,r.jsx)(n.code,{children:"BLOCKS_CHANGED"})})]}),(0,r.jsxs)(n.tr,{children:[(0,r.jsx)(n.td,{children:"Move a block (drag existing)"}),(0,r.jsx)(n.td,{children:(0,r.jsx)(n.code,{children:"moveBlock()"})}),(0,r.jsx)(n.td,{children:(0,r.jsx)(n.code,{children:"BLOCKS_CHANGED"})})]}),(0,r.jsxs)(n.tr,{children:[(0,r.jsx)(n.td,{children:"Resize a block (drag edge)"}),(0,r.jsx)(n.td,{children:(0,r.jsx)(n.code,{children:"resizeBlock()"})}),(0,r.jsx)(n.td,{children:(0,r.jsx)(n.code,{children:"BLOCKS_CHANGED"})})]}),(0,r.jsxs)(n.tr,{children:[(0,r.jsx)(n.td,{children:"Delete a block"}),(0,r.jsx)(n.td,{children:(0,r.jsx)(n.code,{children:"removeBlock()"})}),(0,r.jsx)(n.td,{children:(0,r.jsx)(n.code,{children:"BLOCKS_CHANGED"})})]}),(0,r.jsxs)(n.tr,{children:[(0,r.jsx)(n.td,{children:"Change day"}),(0,r.jsxs)(n.td,{children:[(0,r.jsx)(n.code,{children:"getDayTimeline()"}),", ",(0,r.jsx)(n.code,{children:"getVisibleTimeRange()"})]}),(0,r.jsx)(n.td,{children:(0,r.jsx)(n.em,{children:"(read-only)"})})]}),(0,r.jsxs)(n.tr,{children:[(0,r.jsx)(n.td,{children:"View capacity chart"}),(0,r.jsx)(n.td,{children:(0,r.jsx)(n.code,{children:"getCapacityCurve()"})}),(0,r.jsx)(n.td,{children:(0,r.jsx)(n.em,{children:"(read-only)"})})]}),(0,r.jsxs)(n.tr,{children:[(0,r.jsx)(n.td,{children:"Change court hours"}),(0,r.jsx)(n.td,{children:(0,r.jsx)(n.code,{children:"setCourtAvailability()"})}),(0,r.jsx)(n.td,{children:(0,r.jsx)(n.code,{children:"AVAILABILITY_CHANGED"})})]}),(0,r.jsxs)(n.tr,{children:[(0,r.jsx)(n.td,{children:"Import scheduled matches"}),(0,r.jsx)(n.td,{children:(0,r.jsx)(n.code,{children:"importScheduledMatchUps()"})}),(0,r.jsx)(n.td,{children:(0,r.jsx)(n.code,{children:"BLOCKS_CHANGED"})})]})]})]}),"\n",(0,r.jsx)(n.h3,{id:"initialization-pattern",children:"Initialization Pattern"}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-js",children:"import { TemporalEngine, defaultEvaluators } from 'tods-competition-factory';\n\n// 1. Create and initialize the engine\nconst engine = new TemporalEngine();\nengine.init(tournamentRecord, {\n  dayStartTime: '08:00',\n  dayEndTime: '20:00',\n  slotMinutes: 15,\n  conflictEvaluators: defaultEvaluators,\n});\n\n// 2. Subscribe to events\nconst unsubscribe = engine.subscribe((event) => {\n  switch (event.type) {\n    case 'BLOCKS_CHANGED':\n    case 'STATE_CHANGED':\n      renderTimeline();\n      break;\n    case 'AVAILABILITY_CHANGED':\n      updateTimelineWindow();\n      renderTimeline();\n      break;\n  }\n});\n\n// 3. Build initial view data and render\nrenderTimeline();\n"})}),"\n",(0,r.jsx)(n.h3,{id:"view-projections-pattern",children:"View Projections Pattern"}),"\n",(0,r.jsx)(n.p,{children:"View projections are pure functions that transform engine data into vis-timeline items and groups:"}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-js",children:"function renderTimeline() {\n  const day = getCurrentDay();\n  const timelines = engine.getDayTimeline(day);\n  const courtMeta = engine.listCourtMeta();\n  const blocks = engine.getDayBlocks(day);\n\n  // Pure projection functions \u2014 engine data \u2192 vis-timeline data\n  const groups = buildResourcesFromTimelines(timelines, courtMeta, projectionConfig);\n  const segmentItems = buildEventsFromTimelines(timelines, projectionConfig);\n  const blockItems = buildBlockEvents(blocks, projectionConfig);\n\n  timeline.setGroups(groups);\n  timeline.setItems([...segmentItems, ...blockItems]);\n}\n"})}),"\n",(0,r.jsx)(n.p,{children:(0,r.jsx)(n.strong,{children:"Key projection functions:"})}),"\n",(0,r.jsxs)(n.table,{children:[(0,r.jsx)(n.thead,{children:(0,r.jsxs)(n.tr,{children:[(0,r.jsx)(n.th,{children:"Function"}),(0,r.jsx)(n.th,{children:"Input"}),(0,r.jsx)(n.th,{children:"Output"})]})}),(0,r.jsxs)(n.tbody,{children:[(0,r.jsxs)(n.tr,{children:[(0,r.jsx)(n.td,{children:(0,r.jsx)(n.code,{children:"buildResourcesFromTimelines"})}),(0,r.jsxs)(n.td,{children:[(0,r.jsx)(n.code,{children:"VenueDayTimeline[]"}),", ",(0,r.jsx)(n.code,{children:"CourtMeta[]"})]}),(0,r.jsxs)(n.td,{children:[(0,r.jsx)(n.code,{children:"TimelineGroup[]"})," (one per court)"]})]}),(0,r.jsxs)(n.tr,{children:[(0,r.jsx)(n.td,{children:(0,r.jsx)(n.code,{children:"buildEventsFromTimelines"})}),(0,r.jsx)(n.td,{children:(0,r.jsx)(n.code,{children:"VenueDayTimeline[]"})}),(0,r.jsxs)(n.td,{children:[(0,r.jsx)(n.code,{children:"TimelineItem[]"})," (background segments)"]})]}),(0,r.jsxs)(n.tr,{children:[(0,r.jsx)(n.td,{children:(0,r.jsx)(n.code,{children:"buildBlockEvents"})}),(0,r.jsx)(n.td,{children:(0,r.jsx)(n.code,{children:"Block[]"})}),(0,r.jsxs)(n.td,{children:[(0,r.jsx)(n.code,{children:"TimelineItem[]"})," (draggable range items)"]})]}),(0,r.jsxs)(n.tr,{children:[(0,r.jsx)(n.td,{children:(0,r.jsx)(n.code,{children:"buildConflictEvents"})}),(0,r.jsx)(n.td,{children:(0,r.jsx)(n.code,{children:"EngineConflict[]"})}),(0,r.jsxs)(n.td,{children:[(0,r.jsx)(n.code,{children:"TimelineItem[]"})," (overlay items)"]})]}),(0,r.jsxs)(n.tr,{children:[(0,r.jsx)(n.td,{children:(0,r.jsx)(n.code,{children:"buildCapacityVisualization"})}),(0,r.jsx)(n.td,{children:(0,r.jsx)(n.code,{children:"CapacityPoint[]"})}),(0,r.jsx)(n.td,{children:(0,r.jsx)(n.code,{children:"{ time, value, label }[]"})})]})]})]}),"\n",(0,r.jsx)(n.h3,{id:"paint-mode--drag-to-create",children:"Paint Mode \u2014 Drag-to-Create"}),"\n",(0,r.jsx)(n.p,{children:"In paint mode, the user drags across empty space on a court to create a new block:"}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-js",children:"function handlePaintDrag(courtRef, anchorTime, cursorTime) {\n  // 1. Get existing blocks on this court\n  const existingBlocks = engine.getDayBlocks(day)\n    .filter((b) => courtRefEquals(b.court, courtRef));\n\n  // 2. Clamp drag to avoid overlapping existing blocks\n  const clamped = clampDragToCollisions(anchorTime, cursorTime, existingBlocks);\n\n  // 3. Snap to granularity\n  const granularity = engine.getResolvedGranularityMinutes();\n  const start = snapToGranularity(clamped.start, granularity);\n  const end = snapToGranularity(clamped.end, granularity, 'ceil');\n\n  // 4. Apply the block\n  const result = engine.applyBlock({\n    courts: [courtRef],\n    timeRange: { start: toIso(day, start), end: toIso(day, end) },\n    type: currentPaintType,  // e.g., 'MAINTENANCE', 'PRACTICE'\n    source: 'USER',\n  });\n\n  if (result.conflicts.some((c) => c.severity === 'ERROR')) {\n    showAlert(result.conflicts);\n  }\n}\n"})}),"\n",(0,r.jsx)(n.h3,{id:"dragresize-with-collision-detection",children:"Drag/Resize with Collision Detection"}),"\n",(0,r.jsx)(n.p,{children:"When the user drags or resizes an existing block, the controller validates the move:"}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-js",children:"function handleBlockMove(blockId, newTimeRange, newCourt) {\n  const result = engine.moveBlock({ blockId, newTimeRange, newCourt });\n\n  if (result.conflicts.some((c) => c.severity === 'ERROR')) {\n    // Reject the move \u2014 revert the visual position\n    revertDrag();\n    showConflictAlert(result.conflicts);\n  }\n  // On success, the BLOCKS_CHANGED event triggers a re-render\n}\n"})}),"\n",(0,r.jsx)(n.h3,{id:"capacity-visualization",children:"Capacity Visualization"}),"\n",(0,r.jsx)(n.p,{children:"The capacity curve drives a stacked area chart showing court utilization:"}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-js",children:"const curve = engine.getCapacityCurve('2026-06-15');\n\n// Transform for chart library\nconst chartData = curve.points.map((pt) => ({\n  time: pt.time,\n  available: pt.courtsAvailable,\n  softBlocked: pt.courtsSoftBlocked,\n  hardBlocked: pt.courtsHardBlocked,\n}));\n\n// Compute summary statistics\nimport { calculateCapacityStats } from 'tods-competition-factory';\nconst stats = calculateCapacityStats(curve);\n// { peakAvailable: 8, utilizationPercent: 72.5, ... }\n"})}),"\n",(0,r.jsx)(n.h3,{id:"saving-back-to-tournament-record",children:"Saving Back to Tournament Record"}),"\n",(0,r.jsx)(n.p,{children:"After editing, write engine state back to the tournament record:"}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-js",children:"import { applyTemporalAvailabilityToTournamentRecord } from 'tods-competition-factory';\n\nconst timelines = engine.getDayTimeline(day);\nconst updatedRecord = applyTemporalAvailabilityToTournamentRecord({\n  tournamentRecord,\n  timelines,\n  engine,\n});\n"})}),"\n",(0,r.jsx)(n.hr,{}),"\n",(0,r.jsx)(n.h2,{id:"scenario-2--scheduling-profile-builder",children:"Scenario 2 \u2014 Scheduling Profile Builder"}),"\n",(0,r.jsx)(n.p,{children:"The scheduling profile builder is a 3-panel UI \u2014 date chips, venue lanes, and a round catalog \u2014 for drag-and-drop assignment of tournament rounds to days and venues."}),"\n",(0,r.jsx)(n.admonition,{type:"note",children:(0,r.jsxs)(n.p,{children:["The scheduling profile component does ",(0,r.jsx)(n.strong,{children:"not"})," import ",(0,r.jsx)(n.code,{children:"TemporalEngine"})," directly. Instead, it receives a ",(0,r.jsx)(n.code,{children:"TemporalAdapter"})," callback interface that abstracts the engine's availability queries. This keeps the profile component decoupled from the engine."]})}),"\n",(0,r.jsx)(n.h3,{id:"temporaladapter-interface",children:"TemporalAdapter Interface"}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-ts",children:"interface TemporalAdapter {\n  isDateAvailable: (date: string) => { ok: boolean; reason?: string };\n  getDayCapacityMinutes?: (date: string) => number;\n}\n"})}),"\n",(0,r.jsxs)(n.p,{children:["Create a ",(0,r.jsx)(n.code,{children:"TemporalAdapter"})," from an engine instance:"]}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-js",children:"function createTemporalAdapter(engine) {\n  return {\n    isDateAvailable: (date) => {\n      const days = engine.getTournamentDays();\n      if (!days.includes(date)) {\n        return { ok: false, reason: 'Date outside tournament' };\n      }\n      const curve = engine.getCapacityCurve(date);\n      const hasCapacity = curve.points.some((p) => p.courtsAvailable > 0);\n      return hasCapacity\n        ? { ok: true }\n        : { ok: false, reason: 'No court capacity on this day' };\n    },\n    getDayCapacityMinutes: (date) => {\n      const curve = engine.getCapacityCurve(date);\n      const stats = calculateCapacityStats(curve);\n      return stats.totalCourtHours * 60;\n    },\n  };\n}\n"})}),"\n",(0,r.jsx)(n.h3,{id:"plan-state-integration",children:"Plan State Integration"}),"\n",(0,r.jsx)(n.p,{children:"The scheduling profile translates drag-and-drop actions into engine plan state mutations:"}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-js",children:"// User drops a round onto a day/venue lane\nfunction handleRoundDrop(round, targetDay, targetVenueId) {\n  engine.addPlanItem({\n    day: targetDay,\n    venueId: targetVenueId,\n    eventId: round.eventId,\n    drawId: round.drawId,\n    roundNumber: round.roundNumber,\n    matchUpType: round.matchUpType,\n    estimatedDurationMinutes: round.estimatedMinutes,\n  });\n}\n\n// User drags a round to a different day\nfunction handleRoundMove(planItemId, newDay) {\n  engine.movePlanItem(planItemId, newDay);\n}\n\n// User sets a \"not before\" time constraint\nfunction handleSetNotBefore(planItemId, time) {\n  engine.updatePlanItem(planItemId, { notBeforeTime: time });\n}\n\n// Read plan state for rendering\nconst dayPlan = engine.getDayPlan('2026-06-15');\nfor (const item of dayPlan.items) {\n  renderRoundCard(item);\n}\n"})}),"\n",(0,r.jsx)(n.h3,{id:"from-plan-to-factory-scheduling-profile",children:"From Plan to Factory Scheduling Profile"}),"\n",(0,r.jsx)(n.p,{children:"When the user is done building the plan, convert it to a factory scheduling profile:"}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-js",children:"import {\n  buildSchedulingProfileFromUISelections,\n  validateSchedulingProfileFormat,\n} from 'tods-competition-factory';\n\n// Convert plan items to scheduling selections\nconst allPlans = engine.getAllPlans();\nconst selections = allPlans.flatMap((plan) =>\n  plan.items.map((item) => ({\n    scheduleDate: item.day,\n    venueIds: [item.venueId],\n    rounds: [{\n      eventId: item.eventId,\n      drawId: item.drawId,\n      roundNumber: item.roundNumber,\n      matchUpType: item.matchUpType,\n    }],\n  })),\n);\n\n// Build and validate the profile\nconst profile = buildSchedulingProfileFromUISelections(selections);\nconst { valid, errors } = validateSchedulingProfileFormat(profile);\n\nif (valid) {\n  // Apply to the tournament via factory\n  competitionEngine.setSchedulingProfile({ schedulingProfile: profile });\n}\n"})}),"\n",(0,r.jsx)(n.hr,{}),"\n",(0,r.jsx)(n.h2,{id:"what-if-simulation",children:"What-If Simulation"}),"\n",(0,r.jsxs)(n.p,{children:["Preview mutations before committing using ",(0,r.jsx)(n.code,{children:"simulateBlocks()"}),":"]}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-js",children:"// User hovers over a potential block placement\nconst preview = engine.simulateBlocks(\n  [{\n    kind: 'ADD_BLOCK',\n    block: {\n      id: 'preview-1',\n      court: courtRef,\n      type: 'MAINTENANCE',\n      start: '2026-06-15T12:00:00',\n      end: '2026-06-15T13:00:00',\n    },\n  }],\n  '2026-06-15',\n);\n\n// Show preview rails with a visual diff\nrenderPreviewOverlay(preview.previewRails);\n\n// Show capacity impact\nif (preview.capacityImpact) {\n  import { compareCapacityCurves } from 'tods-competition-factory';\n  const currentCurve = engine.getCapacityCurve('2026-06-15');\n  const diffs = compareCapacityCurves(currentCurve, preview.capacityImpact);\n  renderCapacityDiff(diffs);\n}\n\n// Warn about conflicts\nif (preview.conflicts.length > 0) {\n  showConflictWarning(preview.conflicts);\n}\n"})}),"\n",(0,r.jsx)(n.p,{children:"The simulation creates a disposable snapshot of the engine \u2014 the real state is never modified and subscribers are never notified."}),"\n",(0,r.jsx)(n.hr,{}),"\n",(0,r.jsx)(n.h2,{id:"shadow-scheduling",children:"Shadow Scheduling"}),"\n",(0,r.jsxs)(n.p,{children:["After running the factory's automated scheduling (via ",(0,r.jsx)(n.code,{children:"scheduleGovernor"}),"), import the results as visual blocks:"]}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-js",children:"// 1. Run automated scheduling\ncompetitionEngine.scheduleMatchUps({ schedulingProfile });\n\n// 2. Get scheduled matchUps\nconst { matchUps } = competitionEngine.allCompetitionMatchUps();\nconst scheduled = matchUps\n  .filter((m) => m.schedule?.scheduledDate && m.schedule?.courtId)\n  .map((m) => ({\n    matchUpId: m.matchUpId,\n    courtId: m.schedule.courtId,\n    venueId: m.schedule.venueId,\n    date: m.schedule.scheduledDate,\n    startTime: m.schedule.scheduledTime,\n    durationMinutes: m.schedule.averageMinutes || 60,\n  }));\n\n// 3. Import into TemporalEngine as SCHEDULED blocks\nconst result = engine.importScheduledMatchUps(scheduled);\n// The temporal grid now shows scheduled matches alongside availability blocks\n"})}),"\n",(0,r.jsxs)(n.p,{children:["This creates ",(0,r.jsx)(n.code,{children:"SCHEDULED"}),"-type blocks that appear visually in the temporal grid, allowing users to see how automated scheduling interacts with their manually configured availability."]}),"\n",(0,r.jsx)(n.hr,{}),"\n",(0,r.jsx)(n.h2,{id:"related-documentation",children:"Related Documentation"}),"\n",(0,r.jsxs)(n.ul,{children:["\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.strong,{children:(0,r.jsx)(n.a,{href:"./temporal-engine-overview",children:"Overview"})})," \u2014 Introduction and architecture"]}),"\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.strong,{children:(0,r.jsx)(n.a,{href:"./temporal-engine-api",children:"Core API Reference"})})," \u2014 Complete method reference"]}),"\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.strong,{children:(0,r.jsx)(n.a,{href:"./event-system-and-validation",children:"Event System & Validation"})})," \u2014 Events, conflict evaluators, and validation pipeline"]}),"\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.strong,{children:(0,r.jsx)(n.a,{href:"./block-types-and-algorithms",children:"Block Types & Algorithms"})})," \u2014 Block types, rail derivation, capacity curves, collision detection"]}),"\n"]})]})}function h(e={}){const{wrapper:n}={...(0,a.R)(),...e.components};return n?(0,r.jsx)(n,{...e,children:(0,r.jsx)(d,{...e})}):d(e)}},8322(e,n,t){t.d(n,{R:()=>s,x:()=>o});var i=t(758);const r={},a=i.createContext(r);function s(e){const n=i.useContext(a);return i.useMemo(function(){return"function"==typeof e?e(n):{...n,...e}},[n,e])}function o(e){let n;return n=e.disableParentContext?"function"==typeof e.components?e.components(r):e.components||r:s(e.components),i.createElement(a.Provider,{value:n},e.children)}}}]);