(self.webpackChunkdocumentation=self.webpackChunkdocumentation||[]).push([[228],{3905:function(e,t,n){"use strict";n.d(t,{Zo:function(){return c},kt:function(){return h}});var a=n(7294);function i(e,t,n){return t in e?Object.defineProperty(e,t,{value:n,enumerable:!0,configurable:!0,writable:!0}):e[t]=n,e}function r(e,t){var n=Object.keys(e);if(Object.getOwnPropertySymbols){var a=Object.getOwnPropertySymbols(e);t&&(a=a.filter((function(t){return Object.getOwnPropertyDescriptor(e,t).enumerable}))),n.push.apply(n,a)}return n}function s(e){for(var t=1;t<arguments.length;t++){var n=null!=arguments[t]?arguments[t]:{};t%2?r(Object(n),!0).forEach((function(t){i(e,t,n[t])})):Object.getOwnPropertyDescriptors?Object.defineProperties(e,Object.getOwnPropertyDescriptors(n)):r(Object(n)).forEach((function(t){Object.defineProperty(e,t,Object.getOwnPropertyDescriptor(n,t))}))}return e}function o(e,t){if(null==e)return{};var n,a,i=function(e,t){if(null==e)return{};var n,a,i={},r=Object.keys(e);for(a=0;a<r.length;a++)n=r[a],t.indexOf(n)>=0||(i[n]=e[n]);return i}(e,t);if(Object.getOwnPropertySymbols){var r=Object.getOwnPropertySymbols(e);for(a=0;a<r.length;a++)n=r[a],t.indexOf(n)>=0||Object.prototype.propertyIsEnumerable.call(e,n)&&(i[n]=e[n])}return i}var d=a.createContext({}),l=function(e){var t=a.useContext(d),n=t;return e&&(n="function"==typeof e?e(t):s(s({},t),e)),n},c=function(e){var t=l(e.components);return a.createElement(d.Provider,{value:t},e.children)},p={inlineCode:"code",wrapper:function(e){var t=e.children;return a.createElement(a.Fragment,{},t)}},u=a.forwardRef((function(e,t){var n=e.components,i=e.mdxType,r=e.originalType,d=e.parentName,c=o(e,["components","mdxType","originalType","parentName"]),u=l(n),h=i,m=u["".concat(d,".").concat(h)]||u[h]||p[h]||r;return n?a.createElement(m,s(s({ref:t},c),{},{components:n})):a.createElement(m,s({ref:t},c))}));function h(e,t){var n=arguments,i=t&&t.mdxType;if("string"==typeof e||i){var r=n.length,s=new Array(r);s[0]=u;var o={};for(var d in t)hasOwnProperty.call(t,d)&&(o[d]=t[d]);o.originalType=e,o.mdxType="string"==typeof e?e:i,s[1]=o;for(var l=2;l<r;l++)s[l]=n[l];return a.createElement.apply(null,s)}return a.createElement.apply(null,n)}u.displayName="MDXCreateElement"},8829:function(e,t,n){"use strict";n.r(t),n.d(t,{frontMatter:function(){return o},metadata:function(){return d},toc:function(){return l},default:function(){return p}});var a=n(2122),i=n(9756),r=(n(7294),n(3905)),s=["components"],o={title:"Draw Engine API"},d={unversionedId:"apis/draw-engine-api",id:"apis/draw-engine-api",isDocsHomePage:!1,title:"Draw Engine API",description:"addAdHocMatchUps",source:"@site/docs/apis/draw-engine-api.md",sourceDirName:"apis",slug:"/apis/draw-engine-api",permalink:"/tods-competition-factory/docs/apis/draw-engine-api",version:"current",frontMatter:{title:"Draw Engine API"},sidebar:"docs",previous:{title:"Draw Types",permalink:"/tods-competition-factory/docs/engines/draw-types"}},l=[{value:"addAdHocMatchUps",id:"addadhocmatchups",children:[]},{value:"addDrawEntries",id:"adddrawentries",children:[]},{value:"addDrawEntry",id:"adddrawentry",children:[]},{value:"addMatchUpEndTime",id:"addmatchupendtime",children:[]},{value:"addMatchUpOfficial",id:"addmatchupofficial",children:[]},{value:"addMatchUpResumeTime",id:"addmatchupresumetime",children:[]},{value:"addMatchUpScheduledDate",id:"addmatchupscheduleddate",children:[]},{value:"addMatchUpScheduledTime",id:"addmatchupscheduledtime",children:[]},{value:"addMatchUpScheduleItems",id:"addmatchupscheduleitems",children:[]},{value:"addMatchUpStartTime",id:"addmatchupstarttime",children:[]},{value:"addMatchUpStopTime",id:"addmatchupstoptime",children:[]},{value:"addPlayoffStructures",id:"addplayoffstructures",children:[]},{value:"addMatchUpTimeItem",id:"addmatchuptimeitem",children:[]},{value:"addVoluntaryConsolationStage",id:"addvoluntaryconsolationstage",children:[]},{value:"allDrawMatchUps",id:"alldrawmatchups",children:[]},{value:"allStructureMatchUps",id:"allstructurematchups",children:[]},{value:"analyzeMatchUp",id:"analyzematchup",children:[]},{value:"analyzeSet",id:"analyzeset",children:[]},{value:"assignDrawPosition",id:"assigndrawposition",children:[]},{value:"assignDrawPositionBye",id:"assigndrawpositionbye",children:[]},{value:"assignSeed",id:"assignseed",children:[]},{value:"attachPolicies",id:"attachpolicies",children:[]},{value:"automatedPositioning",id:"automatedpositioning",children:[]},{value:"checkInParticipant",id:"checkinparticipant",children:[]},{value:"checkOutParticipant",id:"checkoutparticipant",children:[]},{value:"clearDrawPosition",id:"cleardrawposition",children:[]},{value:"deleteAdHocMatchUps",id:"deleteadhocmatchups",children:[]},{value:"devContext",id:"devcontext",children:[]},{value:"drawMatchUps",id:"drawmatchups",children:[]},{value:"findMatchUp",id:"findmatchup",children:[]},{value:"generateAdHocMatchUps",id:"generateadhocmatchups",children:[]},{value:"generateDrawType",id:"generatedrawtype",children:[]},{value:"generateQualifyingLink",id:"generatequalifyinglink",children:[]},{value:"generateScoreString",id:"generatescorestring",children:[]},{value:"generateTieMatchUpScore",id:"generatetiematchupscore",children:[{value:"generateVoluntaryConsolationStructure",id:"generatevoluntaryconsolationstructure",children:[]}]},{value:"getAvailablePlayoffRounds",id:"getavailableplayoffrounds",children:[]},{value:"getCheckedInParticipantIds",id:"getcheckedinparticipantids",children:[]},{value:"getDrawStructures",id:"getdrawstructures",children:[]},{value:"getEliminationDrawSize",id:"geteliminationdrawsize",children:[]},{value:"getMatchUpContextIds",id:"getmatchupcontextids",children:[]},{value:"getMatchUpParticipantIds",id:"getmatchupparticipantids",children:[]},{value:"getMatchUpScheduleDetails",id:"getmatchupscheduledetails",children:[]},{value:"getNextSeedBlock",id:"getnextseedblock",children:[]},{value:"getNextUnfilledDrawPositions",id:"getnextunfilleddrawpositions",children:[]},{value:"getParticipantIdFinishingPositions",id:"getparticipantidfinishingpositions",children:[]},{value:"getPositionsPlayedOff",id:"getpositionsplayedoff",children:[]},{value:"getRoundMatchUps",id:"getroundmatchups",children:[]},{value:"getSourceRounds",id:"getsourcerounds",children:[]},{value:"getStructureSeedAssignments",id:"getstructureseedassignments",children:[]},{value:"getState",id:"getstate",children:[]},{value:"initializeStructureSeedAssignments",id:"initializestructureseedassignments",children:[]},{value:"isCompletedStructure",id:"iscompletedstructure",children:[]},{value:"isValidMatchUpFormat",id:"isvalidmatchupformat",children:[]},{value:"matchUpActions",id:"matchupactions",children:[]},{value:"matchUpDuration",id:"matchupduration",children:[]},{value:"matchUpSort",id:"matchupsort",children:[]},{value:"newDrawDefinition",id:"newdrawdefinition",children:[]},{value:"positionActions",id:"positionactions",children:[]},{value:"removeEntry",id:"removeentry",children:[]},{value:"removeStructure",id:"removestructure",children:[]},{value:"reset",id:"reset",children:[]},{value:"resetMatchUpTimeItems",id:"resetmatchuptimeitems",children:[]},{value:"resolveDrawPositions",id:"resolvedrawpositions",children:[]},{value:"setDrawDescription",id:"setdrawdescription",children:[]},{value:"setMatchUpFormat",id:"setmatchupformat",children:[]},{value:"setMatchUpStatus",id:"setmatchupstatus",children:[]},{value:"setParticipants",id:"setparticipants",children:[]},{value:"setStageAlternatesCount",id:"setstagealternatescount",children:[]},{value:"setStageDrawSize",id:"setstagedrawsize",children:[]},{value:"setStageQualifiersCount",id:"setstagequalifierscount",children:[]},{value:"setStageWildcardsCount",id:"setstagewildcardscount",children:[]},{value:"setState",id:"setstate",children:[]},{value:"setSubOrder",id:"setsuborder",children:[]},{value:"structureSort",id:"structuresort",children:[]},{value:"swapDrawPositionAssignments",id:"swapdrawpositionassignments",children:[]},{value:"getStructureMatchUps",id:"getstructurematchups",children:[]},{value:"tallyParticipantResults",id:"tallyparticipantresults",children:[]},{value:"validDrawPositions",id:"validdrawpositions",children:[]},{value:"version",id:"version",children:[]}],c={toc:l};function p(e){var t=e.components,n=(0,i.Z)(e,s);return(0,r.kt)("wrapper",(0,a.Z)({},c,n,{components:t,mdxType:"MDXLayout"}),(0,r.kt)("h2",{id:"addadhocmatchups"},"addAdHocMatchUps"),(0,r.kt)("p",null,"Draws with ",(0,r.kt)("inlineCode",{parentName:"p"},"{ drawType: AD_HOC }")," allow ",(0,r.kt)("inlineCode",{parentName:"p"},"matchUps")," to be dynamically added. In this type of draw there is no automatic participant progression between rounds. Participant assignment to ",(0,r.kt)("inlineCode",{parentName:"p"},"matchUps")," is done manually, or via ",(0,r.kt)("strong",{parentName:"p"},"DrawMatic"),". The only restriction is that a participant may appear once per round."),(0,r.kt)("div",{className:"admonition admonition-important alert alert--info"},(0,r.kt)("div",{parentName:"div",className:"admonition-heading"},(0,r.kt)("h5",{parentName:"div"},(0,r.kt)("span",{parentName:"h5",className:"admonition-icon"},(0,r.kt)("svg",{parentName:"span",xmlns:"http://www.w3.org/2000/svg",width:"14",height:"16",viewBox:"0 0 14 16"},(0,r.kt)("path",{parentName:"svg",fillRule:"evenodd",d:"M7 2.3c3.14 0 5.7 2.56 5.7 5.7s-2.56 5.7-5.7 5.7A5.71 5.71 0 0 1 1.3 8c0-3.14 2.56-5.7 5.7-5.7zM7 1C3.14 1 0 4.14 0 8s3.14 7 7 7 7-3.14 7-7-3.14-7-7-7zm1 3H6v5h2V4zm0 6H6v2h2v-2z"}))),"important")),(0,r.kt)("div",{parentName:"div",className:"admonition-content"},(0,r.kt)("p",{parentName:"div"},(0,r.kt)("inlineCode",{parentName:"p"},"matchUps")," to be added must be generated with ",(0,r.kt)("inlineCode",{parentName:"p"},"tournamentEngine.generateAdHocMatchUps")))),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-js"},"const result = drawEngine.addAdHocMatchUps({\n  drawDefinition, // required - drawDefinition in which target structure is found\n  structureId, // required - structureId of structure for which matchUps are being generated\n  matchUps, // required - matchUps are generated with tournamentEngine.generateAdHocMatchUps\n});\n")),(0,r.kt)("hr",null),(0,r.kt)("h2",{id:"adddrawentries"},"addDrawEntries"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-js"},"drawEngine.addDrawEntries({\n  participantIds, // an array of participantIds, should all be of the same participantType\n  entryStatus, // optional - defaults to DIRECT_ACCEPTANCE\n  stage, // optional - stage into which participantIds have been entered; defaults to MAIN\n  autoEntryPositions, // optional - keeps entries ordered by entryStage/entryStatus and auto-increments\n});\n")),(0,r.kt)("hr",null),(0,r.kt)("h2",{id:"adddrawentry"},"addDrawEntry"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-js"},"drawEngine.addDrawEntry({\n  participantId,\n  entryStage, // optional - stage into which participantIds have been entered; defaults to MAIN\n  entryStatus, // optional - defaults to DIRECT_ACCEPTANCE\n  entryPosition, // optional - used to order entries, e.g. { entryPosition: 1 } for 1st alternate\n});\n")),(0,r.kt)("hr",null),(0,r.kt)("h2",{id:"addmatchupendtime"},"addMatchUpEndTime"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-js"},"const endTime = '2020-01-01T09:05:00Z';\ndrawEngine.addMatchUpEndTime({\n  matchUpId,\n  endTime,\n  disableNotice, // when disabled subscribers will not be notified\n});\n")),(0,r.kt)("hr",null),(0,r.kt)("h2",{id:"addmatchupofficial"},"addMatchUpOfficial"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-js"},"drawEngine.addMatchUpOfficial({\n  matchUpId,\n  participantId,\n  officialType,\n  disableNotice, // when disabled subscribers will not be notified\n});\n")),(0,r.kt)("hr",null),(0,r.kt)("h2",{id:"addmatchupresumetime"},"addMatchUpResumeTime"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-js"},"const resumeTime = '2020-01-01T09:00:00Z';\ndrawEngine.addMatchUpResumeTime({\n  matchUpId,\n  resumeTime,\n  disableNotice, // when disabled subscribers will not be notified\n});\n")),(0,r.kt)("hr",null),(0,r.kt)("h2",{id:"addmatchupscheduleddate"},"addMatchUpScheduledDate"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-js"},"const scheduledDate = '2020-01-01';\ndrawEngine.addMatchUpScheduledDate({\n  matchUpId,\n  scheduledDate,\n  disableNotice, // when disabled subscribers will not be notified\n});\n")),(0,r.kt)("hr",null),(0,r.kt)("h2",{id:"addmatchupscheduledtime"},"addMatchUpScheduledTime"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-js"},"const scheduledTime = '08:00';\ndrawEngine.addMatchUpScheduledTime({\n  matchUpId,\n  scheduledTime,\n  disableNotice, // when disabled subscribers will not be notified\n});\n")),(0,r.kt)("hr",null),(0,r.kt)("h2",{id:"addmatchupscheduleitems"},"addMatchUpScheduleItems"),(0,r.kt)("p",null,"Convenience function to add several schedule items at once."),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-js"},"drawEngine.addMatchUpScheduleItems({\n  matchUpId,\n  schedule: {\n    scheduledTime,\n    scheduledDate,\n    startTime,\n    endTime,\n  },\n  disableNotice, // when disabled subscribers will not be notified\n});\n")),(0,r.kt)("hr",null),(0,r.kt)("h2",{id:"addmatchupstarttime"},"addMatchUpStartTime"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-js"},"const startTime = '2020-01-01T08:05:00Z';\ndrawEngine.addMatchUpStartTime({\n  matchUpId,\n  startTime,\n  disableNotice, // when disabled subscribers will not be notified\n});\n")),(0,r.kt)("hr",null),(0,r.kt)("h2",{id:"addmatchupstoptime"},"addMatchUpStopTime"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-js"},"const stopTime = '2020-01-01T08:15:00Z';\ndrawEngine.addMatchUpStopTime({\n  matchUpId,\n  stopTime,\n  disableNotice, // when disabled subscribers will not be notified\n});\n")),(0,r.kt)("hr",null),(0,r.kt)("h2",{id:"addplayoffstructures"},"addPlayoffStructures"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-js"},"drawEngine.addPlayoffStructures({\n  structureId,\n  roundNumbers: [3], // optional if playoffPositions not provided; roundNumbers of structure to be played off.\n  roundProfiles, // optional - source roundNumbers as Object.keys with depth as Object.values, e.g. [{ 1: 2}, {2: 1}]\n  playoffPositions: [3, 4], // optional if roundNumbers not provided; finishing positions to be played off.\n  playoffAttributes, // optional - mapping of exitProfile to structure names, e.g. 0-1-1 for SOUTH\n  exitProfileLimit, // limit playoff rounds generated by the attributes present in playoffAttributes\n  playoffStructureNameBase, // optional - Root word for default playoff naming, e.g. 'Playoff' for 'Playoff 3-4'\n});\n\n// example use of playoffAttributes - will generated playoff structure from 2nd round with structureName: 'bronze'\nconst playoffAttributes = {\n  '0-2': { name: 'BRONZE', abbreviation: 'B' },\n};\n")),(0,r.kt)("hr",null),(0,r.kt)("h2",{id:"addmatchuptimeitem"},"addMatchUpTimeItem"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-js"},"const timeItem = {\n  itemType: SCHEDULED_DATE,\n  itemValue: scheduledDate,\n};\ndrawEngine.addMatchUpTimeItem({\n  matchUpId,\n  timeItem,\n  duplicateValues: false,\n});\n")),(0,r.kt)("hr",null),(0,r.kt)("h2",{id:"addvoluntaryconsolationstage"},"addVoluntaryConsolationStage"),(0,r.kt)("p",null,"Modifies the entryProfile for a draw to allow ",(0,r.kt)("inlineCode",{parentName:"p"},"{ entryStage: VOLUNTARY_CONSOLATION }")),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-js"},"drawEngine.addVoluntaryConsolationStage({\n  drawSize,\n});\n")),(0,r.kt)("hr",null),(0,r.kt)("h2",{id:"alldrawmatchups"},"allDrawMatchUps"),(0,r.kt)("p",null,"Returns all matchUps from all structures within a draw."),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-js"},"const { matchUps } = drawEngine.allDrawMatchUps({\n  context, // optional context to be added into matchUps\n  inContext, // boolean - add context { drawId, structureId, participant, individualParticipants ... }\n  roundFilter, // filter to target matchUps from specified rounds\n  nextMatchUps, // optioanl - boolean - to include winnerTo and loserTo\n  matchUpFilters, // attribute filters\n  contextFilters, // filters based on context attributes\n  includeByeMatchUps, // return matchUps with { matchUpStatus: BYE }\n  tournamentParticipants, // optional - provide an array of tournamentParticipants to add into matchUps\n  requireParticipants, // optional - require that participants be loaded into drawEngine or passed into method\n  tournamentAppliedPolicies, // any policies, such as privacy, to be applied to matchUps\n});\n")),(0,r.kt)("hr",null),(0,r.kt)("h2",{id:"allstructurematchups"},"allStructureMatchUps"),(0,r.kt)("p",null,"Returns all matchUps from a single structure within a draw."),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-js"},"const { matchUps } = drawEngine.allStructureMatchUps({\n  structureId,\n  context, // optional context to be added into matchUps\n  inContext, // boolean - add context { drawId, structureId, participant, individualParticipants ... }\n  roundFilter, // filter to target matchUps from specified rounds\n  nextMatchUps, // optioanl - boolean - to include winnerTo and loserTo\n  matchUpFilters, // attribute filters\n  contextFilters, // filters based on context attributes\n  includeByeMatchUps, // return matchUps with { matchUpStatus: BYE }\n  tournamentParticipants, // optional - provide an array of tournamentParticipants to add into matchUps\n  requireParticipants, // optional - require that participants be loaded into drawEngine or passed into method\n  tournamentAppliedPolicies, // any policies, such as privacy, to be applied to matchUps\n});\n")),(0,r.kt)("hr",null),(0,r.kt)("h2",{id:"analyzematchup"},"analyzeMatchUp"),(0,r.kt)("p",null,"Method used internally by the ",(0,r.kt)("inlineCode",{parentName:"p"},"scoreGovernor")," and ",(0,r.kt)("inlineCode",{parentName:"p"},"keyValueScore"),"."),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-js"},"const {\n  isActiveSet,\n  isExistingSet,\n  existingValue,\n  hasExistingValue,\n  isValidSideNumber,\n  completedSetsCount,\n  isCompletedMatchUp,\n  isLastSetWithValues,\n  validMatchUpOutcome,\n  matchUpScoringFormat,\n  calculatedWinningSide,\n  validMatchUpWinningSide,\n  completedSetsHaveValidOutcomes,\n  specifiedSetAnalysis: {\n    expectTiebreakSet,\n    expectTimedSet,\n    hasTiebreakCondition,\n    isCompletedSet,\n    isDecidingSet,\n    isTiebreakSet,\n    isValidSet,\n    isValidSetNumber,\n    isValidSetOutcome,\n    setFormat,\n    sideGameScores,\n    sideGameScoresCount,\n    sidePointScores,\n    sidePointScoresCount,\n    sideTiebreakScores,\n    sideTiebreakScoresCount,\n    winningSide,\n  },\n} = drawEngine.analyzeMatchUp({\n  matchUp,\n  sideNumber,\n  setNumber,\n  matchUpFormat,\n});\n")),(0,r.kt)("hr",null),(0,r.kt)("h2",{id:"analyzeset"},"analyzeSet"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-js"},"const {\n  expectTiebreakSet,\n  expectTimedSet,\n  hasTiebreakCondition,\n  isCompletedSet,\n  isDecidingSet,\n  isTiebreakSet,\n  isValidSet,\n  isValidSetNumber,\n  isValidSetOutcome,\n  setFormat,\n  sideGameScores,\n  sideGameScoresCount,\n  sidePointScores,\n  sidePointScoresCount,\n  sideTiebreakScores,\n  sideTiebreakScoresCount,\n  winningSide,\n} = drawEngine.analyzeSet({\n  setObject,\n  matchUpScoringFormat,\n});\n")),(0,r.kt)("hr",null),(0,r.kt)("h2",{id:"assigndrawposition"},"assignDrawPosition"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-js"},"drawEngine.assignDrawPosition({\n  structureId,\n  drawPosition,\n  participantId,\n});\n")),(0,r.kt)("hr",null),(0,r.kt)("h2",{id:"assigndrawpositionbye"},"assignDrawPositionBye"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-js"},"drawEngine.assignDrawPositionBye({\n  structureId,\n  drawPosition,\n});\n")),(0,r.kt)("hr",null),(0,r.kt)("h2",{id:"assignseed"},"assignSeed"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-js"},"result = drawEngine.assignSeed({\n  structureId,\n  seedNumber,\n  seedValue, // optional - display value, e.g. '5-8'\n  participantId,\n});\n")),(0,r.kt)("hr",null),(0,r.kt)("h2",{id:"attachpolicies"},"attachPolicies"),(0,r.kt)("p",null,"Attaches a policy to a drawDefinition."),(0,r.kt)("p",null,"See ",(0,r.kt)("a",{parentName:"p",href:"../concepts/policies"},"Policies"),"."),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-js"},"drawEngine.attachPolicies({ policyDefinitions: SEEDING_POLICY });\n")),(0,r.kt)("hr",null),(0,r.kt)("h2",{id:"automatedpositioning"},"automatedPositioning"),(0,r.kt)("p",null,"Positions participants in a draw structure. ",(0,r.kt)("inlineCode",{parentName:"p"},"drawEngine")," is agnostic about the type of participants that are placed in a draw structure, but requires tournament participants for avoidance policies to work."),(0,r.kt)("p",null,"See ",(0,r.kt)("a",{parentName:"p",href:"../concepts/policies"},"Policies"),"."),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-js"},"drawEngine.automatedPositioning({\n  structureId,\n  participants, // optional - participants must be passed in for Avoidance Policies to be effective\n});\n")),(0,r.kt)("hr",null),(0,r.kt)("h2",{id:"checkinparticipant"},"checkInParticipant"),(0,r.kt)("p",null,"Set the check-in state for a participant. Used to determine when both participants in a matchUp are available to be assigned to a court."),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-js"},"drawEngine.checkInParticipant({\n  matchUpId,\n  participantId,\n});\n")),(0,r.kt)("hr",null),(0,r.kt)("h2",{id:"checkoutparticipant"},"checkOutParticipant"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-js"},"drawEngine.checkOutParticipant({\n  matchUpId,\n  participantId,\n});\n")),(0,r.kt)("hr",null),(0,r.kt)("h2",{id:"cleardrawposition"},"clearDrawPosition"),(0,r.kt)("p",null,"Removes a ",(0,r.kt)("inlineCode",{parentName:"p"},"participantId")," or ",(0,r.kt)("inlineCode",{parentName:"p"},"bye")," from a specified ",(0,r.kt)("inlineCode",{parentName:"p"},"drawPosition")," within a ",(0,r.kt)("inlineCode",{parentName:"p"},"structure")," or, optionally, removes a specified ",(0,r.kt)("inlineCode",{parentName:"p"},"participantId")," from a ",(0,r.kt)("inlineCode",{parentName:"p"},"structure"),"."),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-js"},"drawEngine.clearDrawPosition({\n  structureId,\n  drawPosition, // optional if participantId is provided\n  participantId, // optional if drawPosition is provided\n});\n")),(0,r.kt)("hr",null),(0,r.kt)("h2",{id:"deleteadhocmatchups"},"deleteAdHocMatchUps"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-js"},"const result = drawEngine.deleteAdHocMatchUps({\n  drawDefinition, // required - drawDefinition in which target structure is found\n  structureId, // required - structureId of structure for which matchUps are being generated\n  matchUpIds, // array of matchUpIds identifying matchUps to be deleted\n});\n")),(0,r.kt)("hr",null),(0,r.kt)("h2",{id:"devcontext"},"devContext"),(0,r.kt)("p",null,"Setting devContext(true) bypasses ",(0,r.kt)("strong",{parentName:"p"},"try {} catch (err) {}")," code block and in some cases enables logging"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-js"},"drawEngine.devContext(true);\n")),(0,r.kt)("hr",null),(0,r.kt)("h2",{id:"drawmatchups"},"drawMatchUps"),(0,r.kt)("p",null,"Returns categorized matchUps from all structures within a draw."),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-js"},"const {\n  upcomingMatchUps,\n  pendingMatchUps,\n  completedMatchUps,\n  abandonedMatchUps,\n  byeMatchUps,\n} = drawEngine.drawMatchUps({\n  context, // optional context to be added into matchUps\n  inContext, // boolean - add context { drawId, structureId, participant, individualParticipants ... }\n  roundFilter, // filter to target matchUps from specified rounds\n  nextMatchUps, // optioanl - boolean - to include winnerTo and loserTo\n  matchUpFilters, // attribute filters\n  contextFilters, // filters based on context attributes\n  includeByeMatchUps, // return matchUps with { matchUpStatus: BYE }\n  tournamentParticipants, // optional - provide an array of tournamentParticipants to add into matchUps\n  requireParticipants, // optional - require that participants be loaded into drawEngine or passed into method\n  tournamentAppliedPolicies, // any policies, such as privacy, to be applied to matchUps\n});\n")),(0,r.kt)("hr",null),(0,r.kt)("h2",{id:"findmatchup"},"findMatchUp"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-js"},"const {\n  matchUp,\n  structure, // returned for convenience\n} = drawEngine.findMatchUp({\n  matchUpId,\n  inContext, // optional - boolean - returns matchUp with additional attributes\n  tournamentParticipants, // optional - enables inContext matchUp to contain full participant objects\n});\n")),(0,r.kt)("hr",null),(0,r.kt)("h2",{id:"generateadhocmatchups"},"generateAdHocMatchUps"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-js"},"const result = drawEngine.generateAdHocMatchUps({\n  drawDefinition, // required - drawDefinition in which target structure is found\n  structureId, // required - structureId of structure for which matchUps are being generated\n  matchUpsCount, // optional - number of matchUps to generate - defaults to 1\n  matchUpIds, // optional - if matchUpIds are not specified UUIDs are generated\n  addMatchUps, // optional - boolean defaults to false - whether to add generated matchUps to structure\n  roundNumber, // optional - specify round for which matchUps will be generated\n  newRound, // optional - boolean defaults to false - whether to auto-increment to next roundNumber\n});\n")),(0,r.kt)("hr",null),(0,r.kt)("h2",{id:"generatedrawtype"},"generateDrawType"),(0,r.kt)("p",null,"Convenience method to generate pre-defined drawTypes."),(0,r.kt)("p",null,"For more information on ",(0,r.kt)("inlineCode",{parentName:"p"},"feedPolicy")," see ",(0,r.kt)("a",{parentName:"p",href:"../policies/feedPolicy"},"Feed Policies"),"."),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-js"},'drawEngine.generateDrawType({\n  drawType, // defaults to SINGLE_ELIMINATION\n\n  matchUpType, // optional - defaults to SINGLES - will check first on drawDefinition\n  matchUpFormat, // optional - default matchUpFormat\n  tieFormat, // optional - overrides drawDefinition.tieFormat, if present, for TEAM draws\n  playoffMatchUpFormat, // optional - default playoffMatchUpFormat\n\n  staggeredEntry, // optional - accepts non-base-2 drawSizes and generates feed arms for "extra" drawPositions\n  seedingProfile, // optional - WATERFALL seeding for ROUND_ROBIN structures, CLUSTER or SEPARATE seeding for elimination structures\n  feedPolicy, // optional - provides fine-grain control for FEED_IN_CONSOLATION feed links\n\n  qualifyingRound, // optional - for qualifying draw structures, roundNumber to win to qualify\n  qualifyingPositions, // optional - number of drawPositions to be filled by qualifiers\n  finishingPositionLimit, // optional - for playoff structures, limit to the number of positions to be played off\n\n  structureOptions: {\n    groupSize, // e.g. 4 participants per group\n    groupSizeLimit: 8,\n  },\n\n  goesTo, // optional - generate winnerMatchUpId and loserMatchUpId attributes\n  uuids, // optional - array of UUIDs to be used for structureIds and matchUpIds\n\n  stage, // optional - defaults to MAIN\n  structureName, // optional - defaults to stage\n});\n')),(0,r.kt)("hr",null),(0,r.kt)("h2",{id:"generatequalifyinglink"},"generateQualifyingLink"),(0,r.kt)("p",null,"Generates and adds a ",(0,r.kt)("inlineCode",{parentName:"p"},"link")," to ",(0,r.kt)("inlineCode",{parentName:"p"},"drawDefinition.links"),"."),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-js"},"drawEngine.generateQualifyingLink({\n  qualifyingStructureId,\n  mainStructureId,\n  qualifyingRound,\n});\n")),(0,r.kt)("hr",null),(0,r.kt)("h2",{id:"generatescorestring"},"generateScoreString"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-js"},"const sets = [\n  {\n    side1Score: 6,\n    side2Score: 7,\n    side1TiebreakScore: 3,\n    side2TiebreakScore: 7,\n    winningSide: 2,\n  },\n  {\n    side1Score: 7,\n    side2Score: 6,\n    side1TiebreakScore: 14,\n    side2TiebreakScore: 12,\n    winningSide: 1,\n  },\n  { side1Score: 3 },\n];\nlet result = drawEngine.generateScoreString({\n    sets, // TODS sets object\n    winningSide, // optional - 1 or 2\n    reversed, // optional - reverse the score\n    winnerFirst = true, // optional - boolean - tranform sets so that winningSide is first (on left)\n    matchUpStatus, // optional - used to annotate scoreString\n    addOutcomeString, // optional - tranform matchUpStatus into outcomeString appended to scoreString\n    autoComplete: true, // optional - complete missing set score\n  });\n")),(0,r.kt)("hr",null),(0,r.kt)("h2",{id:"generatetiematchupscore"},"generateTieMatchUpScore"),(0,r.kt)("p",null,"Returns string representation of current tieMatchUp score."),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-js"},"const { scoreStringSide1, scoreStringSide2, set, winningSide } =\n  drawEngine.generateTieMatchUpScore({\n    matchUp,\n    separator, // optional - defaults to '-'\n  });\n")),(0,r.kt)("hr",null),(0,r.kt)("h3",{id:"generatevoluntaryconsolationstructure"},"generateVoluntaryConsolationStructure"),(0,r.kt)("p",null,"Generates a new structure within a ",(0,r.kt)("inlineCode",{parentName:"p"},"drawDefinition")," if any draw entries are present for ",(0,r.kt)("inlineCode",{parentName:"p"},"{ entryStage: VOLUNTARY_CONSOLATION }"),"."),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-js"},"drawEngine.generateVoluntaryConsolationStructure({\n  automated: true, // optional\n});\n")),(0,r.kt)("hr",null),(0,r.kt)("h2",{id:"getavailableplayoffrounds"},"getAvailablePlayoffRounds"),(0,r.kt)("p",null,"If provided a ",(0,r.kt)("inlineCode",{parentName:"p"},"structureId"),", returns rounds of the selected structure which are available for adding playoff structures."),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-js"},"const { playoffRounds, playoffRoundsRanges, positionsPlayedOff } =\n  drawEngine.getAvailablePlayoffRounds({\n    structureId,\n  });\n")),(0,r.kt)("p",null,"...For a SINGLE_ELIMINATION struture with drawSize: 16 this would return:"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-js"},"    {\n      playoffRounds: [ 1, 2, 3 ],\n      playoffRoundsRanges: [\n        { round: 1, range: '9-16' },\n        { round: 2, range: '5-8' },\n        { round: 3, range: '3-4' }\n      ]\n    }\n\n")),(0,r.kt)("p",null,"When no ",(0,r.kt)("inlineCode",{parentName:"p"},"structureId")," is provided, returns an array of ",(0,r.kt)("inlineCode",{parentName:"p"},"availablePlayoffRounds")," with entries for each structure in a loaded ",(0,r.kt)("inlineCode",{parentName:"p"},"drawDefinition"),"."),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-js"},"const { availablePlayoffRounds, positionsPlayedOff } =\n  drawEngine.getAvailablePlayoffRounds();\n")),(0,r.kt)("hr",null),(0,r.kt)("h2",{id:"getcheckedinparticipantids"},"getCheckedInParticipantIds"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-js"},"const {\n  allParticipantsCheckedIn, // boolean\n  checkedInParticipantIds, // array of participantIds\n} = drawEngine.getCheckedInParticipantIds({ matchUp });\n")),(0,r.kt)("hr",null),(0,r.kt)("h2",{id:"getdrawstructures"},"getDrawStructures"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-js"},"const { structures } = drawEngine.getDrawStructures({\n  stage, // optional - filter by stage\n  stageSequence, // optiona - filter by stageSequence\n});\n")),(0,r.kt)("hr",null),(0,r.kt)("h2",{id:"geteliminationdrawsize"},"getEliminationDrawSize"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-js"},"const { drawSize } = drawEngine.getEliminationDrawSize({ participantCount });\n")),(0,r.kt)("hr",null),(0,r.kt)("h2",{id:"getmatchupcontextids"},"getMatchUpContextIds"),(0,r.kt)("p",null,"Convenience method to find a ",(0,r.kt)("inlineCode",{parentName:"p"},"matchUp")," by ",(0,r.kt)("inlineCode",{parentName:"p"},"matchUpId"),' and return "context ids". Does NOT require that drawEngine state be set, but does require an array of "inContext" ',(0,r.kt)("inlineCode",{parentName:"p"},"matchUps"),"."),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-js"},"const { matchUpId, drawId, eventId, structureId, tournamentId } =\n  drawEngine.getMatchUpContextIds({ matchUps, matchUpId });\n")),(0,r.kt)("hr",null),(0,r.kt)("h2",{id:"getmatchupparticipantids"},"getMatchUpParticipantIds"),(0,r.kt)("p",null,"Convenience function; requires inContext matchUp."),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-js"},"const { sideParticipantIds, individualParticipantIds } =\n  drawEngine.getMatchUpParticipantIds({ matchUp });\n")),(0,r.kt)("hr",null),(0,r.kt)("h2",{id:"getmatchupscheduledetails"},"getMatchUpScheduleDetails"),(0,r.kt)("p",null,"Returns the latest values for all ",(0,r.kt)("inlineCode",{parentName:"p"},"matchUp.timeItems"),", along with calculated values, that relate to the scheduling of a ",(0,r.kt)("inlineCode",{parentName:"p"},"matchUp"),"."),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-js"},"const {\n  schedule: {\n    time,\n    courtId,\n    venueId,\n    startTime,\n    endTime,\n    milliseconds,\n    scheduledDate,\n    scheduledTime,\n  },\n} = drawEngine.getMatchUpScheduleDetails({\n  scheduleVisibilityFilters,\n  matchUp,\n});\n")),(0,r.kt)("hr",null),(0,r.kt)("h2",{id:"getnextseedblock"},"getNextSeedBlock"),(0,r.kt)("p",null,"Returns the next block of drawPositions which are to be assigned seeded participants."),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-js"},"const {\n  nextSeedBlock,\n  unplacedSeedParticipantIds,\n  unplacedSeedNumbers,\n  unfilledPositions,\n  unplacedSeedAssignments,\n} = drawEngine.getNextSeedBlock({\n  structureId,\n});\n")),(0,r.kt)("hr",null),(0,r.kt)("h2",{id:"getnextunfilleddrawpositions"},"getNextUnfilledDrawPositions"),(0,r.kt)("p",null,"Returns the next valid block of unfilled drawPositions. Useful for UI to give visual indication of drawPostions valid to assign."),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-js"},"const { nextUnfilledDrawPositions } = drawEngine.getNextUnfilledDrawPositions({\n  structureId,\n});\n")),(0,r.kt)("hr",null),(0,r.kt)("h2",{id:"getparticipantidfinishingpositions"},"getParticipantIdFinishingPositions"),(0,r.kt)("p",null,"Returns the Range of finishing positions possible for all participantIds within a draw"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-js"},"const idMap = drawEngine.getParticipantIdFinishingPositions({\n  byeAdvancements, // optional boolean - whether or not to consider byeAdvancements\n});\n\nconst { relevantMatchUps, finishingPositionRanges, finishingPositionRange } =\n  idMap[participantId];\n")),(0,r.kt)("hr",null),(0,r.kt)("h2",{id:"getpositionsplayedoff"},"getPositionsPlayedOff"),(0,r.kt)("p",null,"Determines which finishing positions will be returned by a draw. For example, a First Match Loser Consolation with a draw size of 16 will playoff possitions 1, 2, 9 and 10."),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-js"},"const { positionsPlayedOff } = drawEngine.getPositionsPlayedOff({\n  drawDefinition,\n});\n")),(0,r.kt)("hr",null),(0,r.kt)("h2",{id:"getroundmatchups"},"getRoundMatchUps"),(0,r.kt)("p",null,"Organizes matchUps by roundNumber. ",(0,r.kt)("strong",{parentName:"p"},"roundMatchUps")," contains matchUp objects; ",(0,r.kt)("strong",{parentName:"p"},"roundProfile")," provides an overview of drawPositions which have advanced to each round, a matchUpsCount, finishingPositionRange for winners and losers, and finishingRound."),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-js"},"const { roundMatchUps, roundProfile } = drawEngine.getRoundMatchUps({\n  matchUps,\n});\n")),(0,r.kt)("hr",null),(0,r.kt)("h2",{id:"getsourcerounds"},"getSourceRounds"),(0,r.kt)("p",null,"Returns the round numbers for desired playoff positions."),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-js"},"const {\n  sourceRounds, // all source rounds for playedOff positions and specified playoffPositions\n  playoffSourceRounds,\n  playedOffSourceRounds,\n  playoffPositionsReturned,\n} = drawEngine.getSourceRounds({\n  structureId,\n  playoffPositions: [3, 4],\n});\n")),(0,r.kt)("hr",null),(0,r.kt)("h2",{id:"getstructureseedassignments"},"getStructureSeedAssignments"),(0,r.kt)("p",null,"Returns seedAssignments for a specific structure based on structureId or structure"),(0,r.kt)("p",null,"The structure of an ",(0,r.kt)("strong",{parentName:"p"},(0,r.kt)("em",{parentName:"strong"},"assignment object"))," is as follows:"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-json"},'{\n  "seedNumber": 1,\n  "seedValue": 1,\n  "participantId": "uuid-of-participant"\n}\n')),(0,r.kt)("p",null,"The most basic usage is to retrieve seed assignments for a draw which has a single main stage structure"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-js"},"const { seedAssignments } = drawEngine.getStructureSeedAssignments({\n  structureId,\n});\n")),(0,r.kt)("hr",null),(0,r.kt)("h2",{id:"getstate"},"getState"),(0,r.kt)("p",null,"No parameters."),(0,r.kt)("p",null,"Returns a deep copy of the current drawEngine state."),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-js"},"const { drawDefinition } = drawEngine.getState({\n  convertExtensions, // optional - convert extensions to '_' prefixed attributes\n});\n")),(0,r.kt)("hr",null),(0,r.kt)("h2",{id:"initializestructureseedassignments"},"initializeStructureSeedAssignments"),(0,r.kt)("p",null,"Creates the ",(0,r.kt)("inlineCode",{parentName:"p"},"seedAssignments")," attribute for the specified structure."),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-js"},"drawEngine.initializeStructureSeedAssignments({\n  structureId,\n  seedsCount,\n});\n")),(0,r.kt)("hr",null),(0,r.kt)("h2",{id:"iscompletedstructure"},"isCompletedStructure"),(0,r.kt)("p",null,"Returns boolean whether all matchUps in a given structure have been completed"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-js"},"const structureIsComplete = drawEngine.isCompletedStructure({\n  structureId,\n});\n")),(0,r.kt)("hr",null),(0,r.kt)("h2",{id:"isvalidmatchupformat"},"isValidMatchUpFormat"),(0,r.kt)("p",null,"Returns boolean indicating whether matchUpFormat code is valid."),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-js"},"const valid = drawEngine.isValidMatchUpFormat(matchUpFormat);\n")),(0,r.kt)("hr",null),(0,r.kt)("h2",{id:"matchupactions"},"matchUpActions"),(0,r.kt)("p",null,"Return an array of all validActions for a specific matchUp."),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-js"},"const {\n  isByeMatchUp, // boolean; true if matchUp includes a BYE\n  structureIsComplete, // boolean; true if structure is ready for positioning\n  validActions, // array of possible actions given current matchUpStatus\n} = drawEngine.matchUpActions({\n  matchUpId,\n});\n\nconst {\n  type, // 'REFEREE', 'SCHEDULE', 'PENALTY', 'STATUS', 'SCORE', 'START', 'END'.\n  method, // tournamentEngine method relating to action type\n  payload, // attributes to be passed to method\n  // additional method-specific options for values to be added to payload when calling method\n} = validAction;\n")),(0,r.kt)("hr",null),(0,r.kt)("h2",{id:"matchupduration"},"matchUpDuration"),(0,r.kt)("p",null,"Calculates matchUp duration from START, STOP, RESUME, END timeItems."),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-js"},'const {\n  milliseconds,\n  time, // string representation of elapsed time, e.g. "01:10:00" for an hour and 10 seconds\n  relevantTimeItems,\n} = drawEngine.matchUpDuration({\n  matchUp,\n});\n')),(0,r.kt)("hr",null),(0,r.kt)("h2",{id:"matchupsort"},"matchUpSort"),(0,r.kt)("p",null,"Sorting function to arrange matchUps by stage, stageSequence, roundNumber, roundPosition (where applicable)"),(0,r.kt)("p",null,"Used by ",(0,r.kt)("inlineCode",{parentName:"p"},"mocksEngine")," for automatically scoring all matchUps in connected draw structures as part of test suites."),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-js"},"const { matchUps } = drawEngine.allDrawMatchUps();\nconst sortedMatchUps = matchUps.sort(drawEngine.matchUpSort);\n")),(0,r.kt)("hr",null),(0,r.kt)("h2",{id:"newdrawdefinition"},"newDrawDefinition"),(0,r.kt)("p",null,"Creates a new drawDefinition within drawEngine state."),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-js"},"const { drawId } = drawEngine.newDrawDefinition();\nconst { drawDefinition } = drawEngine.getState();\n")),(0,r.kt)("hr",null),(0,r.kt)("h2",{id:"positionactions"},"positionActions"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-js"},"const positionActions = drawEngine.positionActions({\n  structureId,\n  drawPosition,\n  policyDefinitions: positionActionsPolicy, // optional - policy defining what actions are allowed in client context\n});\n\nconst {\n  isActiveDrawPosition, // boolean\n  isByePosition, // boolean\n  isDrawPosition, // boolean\n  hasPositionAssiged, // boolean\n  validActions,\n} = positionActions;\n\nconst {\n  type, // 'ASSIGN', 'LUCKY', 'SWAP', 'BYE', 'REMOVE'\n  method, // tournamentEngine method relating to action type\n  payload, // attributes to be passed to method\n  // additional method-specific options for values to be added to payload when calling method\n} = validAction;\n")),(0,r.kt)("hr",null),(0,r.kt)("h2",{id:"removeentry"},"removeEntry"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-js"},"drawEngine.removeEntry({\n  participantId,\n  autoEntryPositions, // optional - keeps entries ordered by entryStage/entryStatus\n});\n")),(0,r.kt)("hr",null),(0,r.kt)("h2",{id:"removestructure"},"removeStructure"),(0,r.kt)("p",null,"Removes targeted ",(0,r.kt)("inlineCode",{parentName:"p"},"drawDefinition.structure")," and all other child ",(0,r.kt)("inlineCode",{parentName:"p"},"structures")," along with all associated ",(0,r.kt)("inlineCode",{parentName:"p"},"drawDefinition.links"),"."),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-js"},"const { removedMatchUpIds } = drawEngine.removeStructure({\n  structureId,\n});\n")),(0,r.kt)("hr",null),(0,r.kt)("h2",{id:"reset"},"reset"),(0,r.kt)("p",null,"Clears the drawEngine state."),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-js"},"drawEngine.reset();\n")),(0,r.kt)("hr",null),(0,r.kt)("h2",{id:"resetmatchuptimeitems"},"resetMatchUpTimeItems"),(0,r.kt)("p",null,"Removes all timeItems from a specified matchUp."),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-js"},"drawEngine.resetMatchUpTimeItems({ matchUpId });\n")),(0,r.kt)("hr",null),(0,r.kt)("h2",{id:"resolvedrawpositions"},"resolveDrawPositions"),(0,r.kt)("p",null,"Provides an algorithmic approach to assigning drawPositions based on participant nomination of an arbitrary number of preferred positions."),(0,r.kt)("p",null,"Simple use case would be to pre-position all seeded participants, then resolve all remaining participants."),(0,r.kt)("p",null,"Variations could include grouping participants into quarters based on rankings/ratings and resolving drawPositions for each group in a sequence which gives preference to higher ranked/rated participants"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-js"},"const { drawPositionResolutions, report } = drawEngine.resolveDrawPositions({\n  participantFactors, // { [participantId]: { preferences: [1, 2, 3] }} - the length of the preference array is arbitrary\n  positionAssignments, // object from target structure containing any already assigned positions\n});\n")),(0,r.kt)("h2",{id:"setdrawdescription"},"setDrawDescription"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-js"},"const drawDescription = 'Draw Description';\ndrawEngine.setDrawDescription({ description: drawDescription });\n")),(0,r.kt)("hr",null),(0,r.kt)("h2",{id:"setmatchupformat"},"setMatchUpFormat"),(0,r.kt)("p",null,"Sets the default ",(0,r.kt)("inlineCode",{parentName:"p"},"matchUpFormat")," for a ",(0,r.kt)("inlineCode",{parentName:"p"},"drawDefintion")," or a ",(0,r.kt)("inlineCode",{parentName:"p"},"structure"),", or for a specific ",(0,r.kt)("inlineCode",{parentName:"p"},"matchUp"),"."),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-js"},"drawEngine.setMatchUpFormat({\n  matchUpFormat,\n  matchUpType, // optional - ensures that a matchUpFormat is not set on a tieMatchUp\n  tieFormat, // optional - when setting the format for a tieMatchUp\n\n  structureId, // optional - if structureId is present and not matchUpId is present, then set for structure\n  matchUpId, // optional - if matchUpId is present then only set for matchUp\n});\n")),(0,r.kt)("hr",null),(0,r.kt)("h2",{id:"setmatchupstatus"},"setMatchUpStatus"),(0,r.kt)("p",null,"Sets either matchUpStatus or score and winningSide. Handles any winner/loser participant movements within or across structures."),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-js"},"drawEngine.setMatchUpStatus({\n  matchUpId,\n  matchUpTieId, // optional - if part of a TIE matchUp\n  matchUpStatus, // optional - if matchUpFormat differs from event/draw/structure defaults\n  winningSide,\n  schedule: {\n    // optional - set schedule items\n    scheduledDate,\n    scheduledTime,\n    startTime,\n    endTime,\n  },\n  notes, // optional - add note (string) to matchUp object\n});\n")),(0,r.kt)("hr",null),(0,r.kt)("h2",{id:"setparticipants"},"setParticipants"),(0,r.kt)("p",null,"Participants are not managed by the ",(0,r.kt)("inlineCode",{parentName:"p"},"drawEngine"),", but they can be used when returning 'inContext' matchUps as well as when automated positioning relies on avoidance policies."),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-js"},"drawEngine.setParticipants(participants);\n")),(0,r.kt)("hr",null),(0,r.kt)("h2",{id:"setstagealternatescount"},"setStageAlternatesCount"),(0,r.kt)("p",null,"Sets an (optional) limit to the number of accepted alternates."),(0,r.kt)("p",null,"Modifies the 'entryProfile' of a drawDefinition before the structures have been generated."),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-js"},"drawEngine.setStageAlternatesCount({ alternatesCount: 8 });\n")),(0,r.kt)("hr",null),(0,r.kt)("h2",{id:"setstagedrawsize"},"setStageDrawSize"),(0,r.kt)("p",null,"Modifies the 'entryProfile' of a drawDefinition before the structures have been generated."),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-js"},"drawEngine.setStageDrawSize({ stage: QUALIFYING, drawSize: 8 });\ndrawEngine.setStageDrawSize({ stage: MAIN, drawSize: 16 });\n")),(0,r.kt)("hr",null),(0,r.kt)("h2",{id:"setstagequalifierscount"},"setStageQualifiersCount"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-js"},"drawEngine.setStageQualifiersCount({ qualifiersCount: 4 });\n")),(0,r.kt)("hr",null),(0,r.kt)("h2",{id:"setstagewildcardscount"},"setStageWildcardsCount"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-js"},"drawEngine.setStageWildcardsCount({ wildcardsCount: 2 });\n")),(0,r.kt)("hr",null),(0,r.kt)("h2",{id:"setstate"},"setState"),(0,r.kt)("p",null,"Loads a drawDefinition into drawEngine."),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-js"},"drawEngine.setsState(drawDefinition, deepCopy);\n")),(0,r.kt)("p",null,"By default a deep copy of the tournament record is made so that mutations made by drawEngine do not affect the source object. An optional boolean parameter, ",(0,r.kt)("em",{parentName:"p"},"deepCopy")," can be set to false to override this default behavior."),(0,r.kt)("hr",null),(0,r.kt)("h2",{id:"setsuborder"},"setSubOrder"),(0,r.kt)("p",null,"Assigns a subOrder value to a participant within a structure by drawPosition where participant has been assigned"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-js"},"drawEngine.setSubOrder({\n  structureId, // structure identifier within drawDefinition\n  drawPosition: 1, // drawPosition of the participant where subOrder is to be added\n  subOrder: 2, // order in which tied participant should receive finishing position\n});\n")),(0,r.kt)("hr",null),(0,r.kt)("h2",{id:"structuresort"},"structureSort"),(0,r.kt)("p",null,"Sorting function to arrange structures by stage, positionAssignments count (size) then stageSequence\nUsed internally to order Compass structures"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-js"},"const sortedStructures = drawDefinition.structures.sort(\n  drawEngine.structureSort\n);\n")),(0,r.kt)("hr",null),(0,r.kt)("h2",{id:"swapdrawpositionassignments"},"swapDrawPositionAssignments"),(0,r.kt)("p",null,"Swaps the ",(0,r.kt)("inlineCode",{parentName:"p"},"participantIds")," of two ",(0,r.kt)("inlineCode",{parentName:"p"},"drawPositions"),"."),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-js"},"drawEngine.swapDrawPositionAssignments({ structureId, drawPositions });\n")),(0,r.kt)("hr",null),(0,r.kt)("h2",{id:"getstructurematchups"},"getStructureMatchUps"),(0,r.kt)("p",null,"Returns categorized matchUps from a single structure."),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-js"},"const {\n  upcomingMatchUps,\n  pendingMatchUps,\n  completedMatchUps,\n  abandonedMatchUps,\n  byeMatchUps,\n} = drawEngine.getStructureMatchUps({\n  structureId,\n  context, // optional context to be added into matchUps\n  inContext, // boolean - add context { drawId, structureId, participant, individualParticipants ... }\n  roundFilter, // filter to target matchUps from specified rounds\n  nextMatchUps, // optioanl - boolean - to include winnerTo and loserTo\n  matchUpFilters, // attribute filters\n  contextFilters, // filters based on context attributes\n  includeByeMatchUps, // return matchUps with { matchUpStatus: BYE }\n  tournamentParticipants, // optional - provide an array of tournamentParticipants to add into matchUps\n  requireParticipants, // optional - require that participants be loaded into drawEngine or passed into method\n  tournamentAppliedPolicies, // any policies, such as privacy, to be applied to matchUps\n  scheduleVisibilityFilters,\n});\n")),(0,r.kt)("hr",null),(0,r.kt)("h2",{id:"tallyparticipantresults"},"tallyParticipantResults"),(0,r.kt)("p",null,"Method used to calculate finishing positions within a ROUND_ROBIN group."),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-js"},"const { participantResults } = drawEngine.tallyParticipantResults({\n  matchUps: structureMatchUps,\n  matchUpFormat,\n});\n")),(0,r.kt)("hr",null),(0,r.kt)("h2",{id:"validdrawpositions"},"validDrawPositions"),(0,r.kt)("p",null,"Returns boolean indicating whether all matchUps have valid draw positions"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-js"},"drawEngine.validDrawPositions({ matchUps });\n")),(0,r.kt)("hr",null),(0,r.kt)("h2",{id:"version"},"version"),(0,r.kt)("p",null,"Returns NPM package version. Can be used in configurations that utilize Competition Factory engines on both client and server to ensure equivalency."),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-js"},"const version = drawEngine.version();\n")),(0,r.kt)("hr",null))}p.isMDXComponent=!0}}]);