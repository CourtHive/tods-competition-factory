"use strict";(globalThis.webpackChunkdocumentation=globalThis.webpackChunkdocumentation||[]).push([[2731],{920(e,n,t){t.r(n),t.d(n,{assets:()=>l,contentTitle:()=>a,default:()=>h,frontMatter:()=>i,metadata:()=>r,toc:()=>d});const r=JSON.parse('{"id":"engines/engine-methods","title":"Engine Methods","description":"importMethods","source":"@site/docs/engines/engine-methods.md","sourceDirName":"engines","slug":"/engines/engine-methods","permalink":"/competition-factory/docs/engines/engine-methods","draft":false,"unlisted":false,"tags":[],"version":"current","frontMatter":{"title":"Engine Methods"},"sidebar":"docs","previous":{"title":"Overview","permalink":"/competition-factory/docs/engines/state-engines"},"next":{"title":"Engine Logging","permalink":"/competition-factory/docs/engines/engine-logging"}}');var s=t(6070),o=t(8322);const i={title:"Engine Methods"},a=void 0,l={},d=[{value:"importMethods",id:"importmethods",level:2},{value:"getTournament",id:"gettournament",level:2},{value:"getState",id:"getstate",level:2},{value:"reset",id:"reset",level:2},{value:"devContext",id:"devcontext",level:2},{value:"getDevContext",id:"getdevcontext",level:2},{value:"newTournamentRecord",id:"newtournamentrecord",level:2},{value:"setState",id:"setstate",level:2},{value:"setTournamentId",id:"settournamentid",level:2},{value:"getTournamentId",id:"gettournamentid",level:2},{value:"setTournamentRecord",id:"settournamentrecord",level:2},{value:"removeTournamentRecord",id:"removetournamentrecord",level:2},{value:"removeUnlinkedTournamentRecords",id:"removeunlinkedtournamentrecords",level:2},{value:"version",id:"version",level:2}];function c(e){const n={a:"a",code:"code",h2:"h2",hr:"hr",li:"li",p:"p",pre:"pre",strong:"strong",ul:"ul",...(0,o.R)(),...e.components};return(0,s.jsxs)(s.Fragment,{children:[(0,s.jsx)(n.h2,{id:"importmethods",children:"importMethods"}),"\n",(0,s.jsx)(n.p,{children:"Imports custom methods into the engine, making them available through the engine's invoke pattern with middleware, subscriptions, and logging support."}),"\n",(0,s.jsxs)(n.p,{children:[(0,s.jsx)(n.strong,{children:"Purpose:"})," Extend engine functionality with custom methods while leveraging the engine's built-in features like parameter middleware, result processing, subscriptions, logging, and error handling."]}),"\n",(0,s.jsx)(n.p,{children:(0,s.jsx)(n.strong,{children:"When to Use:"})}),"\n",(0,s.jsxs)(n.ul,{children:["\n",(0,s.jsx)(n.li,{children:"Adding custom business logic to the engine"}),"\n",(0,s.jsx)(n.li,{children:"Extending engine capabilities for specific use cases"}),"\n",(0,s.jsx)(n.li,{children:"Integrating third-party functionality"}),"\n",(0,s.jsx)(n.li,{children:"Creating reusable method collections"}),"\n",(0,s.jsxs)(n.li,{children:["Building domain-specific engines (see ",(0,s.jsx)(n.a,{href:"/docs/engines/custom-engines",children:"Custom Engines"}),")"]}),"\n"]}),"\n",(0,s.jsx)(n.p,{children:(0,s.jsx)(n.strong,{children:"Parameters:"})}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-ts",children:"methods: {\n  [key: string]: Function | {  // Method name as key\n    method: Function;           // The actual method\n    [key: string]: any;         // Additional metadata\n  };\n};\ntraverse?: boolean | string[];  // Traverse nested objects (true/false or array of keys)\nmaxDepth?: number;              // Maximum traversal depth (default: 3)\nglobal?: boolean;               // Make methods globally available across all engines\n"})}),"\n",(0,s.jsx)(n.p,{children:(0,s.jsx)(n.strong,{children:"Returns:"})}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-ts",children:"{\n  success: true;\n  methods?: string[];  // List of all available methods including imported ones\n}\n"})}),"\n",(0,s.jsx)(n.p,{children:(0,s.jsx)(n.strong,{children:"Examples:"})}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-js",children:"// Import simple methods\nengine.importMethods({\n  customValidation: (params) => {\n    // Custom validation logic\n    return { success: true, isValid: true };\n  },\n  customCalculation: (params) => {\n    return { result: params.a + params.b };\n  }\n});\n\n// Use imported methods like any engine method\nconst result = engine.customValidation({ data: {...} });\n\n// Import nested method collections\nengine.importMethods({\n  reporting: {\n    generateReport: (params) => { /* ... */ },\n    exportData: (params) => { /* ... */ }\n  }\n}, true);  // traverse: true to import nested methods\n\n// Import with metadata\nengine.importMethods({\n  specialMethod: {\n    method: (params) => { /* ... */ },\n    description: 'Special custom logic',\n    version: '1.0.0'\n  }\n});\n\n// Import globally (available to all engine instances)\nengine.importMethods({\n  sharedUtility: (params) => { /* ... */ }\n}, false, 3, true);  // global: true\n"})}),"\n",(0,s.jsx)(n.p,{children:(0,s.jsx)(n.strong,{children:"Notes:"})}),"\n",(0,s.jsxs)(n.ul,{children:["\n",(0,s.jsx)(n.li,{children:"Imported methods have access to engine middleware and subscriptions"}),"\n",(0,s.jsxs)(n.li,{children:["Methods can return standard ",(0,s.jsx)(n.code,{children:"{ success, error, ...data }"})," result objects"]}),"\n",(0,s.jsx)(n.li,{children:"Traverse option allows importing nested method collections"}),"\n",(0,s.jsx)(n.li,{children:"Global methods are shared across all engine instances (sync and async)"}),"\n",(0,s.jsx)(n.li,{children:"Imported methods appear in engine method lists"}),"\n",(0,s.jsxs)(n.li,{children:["See ",(0,s.jsx)(n.a,{href:"/docs/engines/custom-engines",children:"Custom Engines"})," for building specialized engines"]}),"\n",(0,s.jsx)(n.li,{children:"Methods can use engine's devContext for conditional logging"}),"\n"]}),"\n",(0,s.jsx)(n.p,{children:(0,s.jsx)(n.strong,{children:"Advanced Usage:"})}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-js",children:"// Create a custom engine with domain-specific methods\nconst customEngine = syncEngine();\n\ncustomEngine.importMethods({\n  tennis: {\n    calculateUTR: (params) => { /* ... */ },\n    validateScore: (params) => { /* ... */ },\n    computeRankingPoints: (params) => { /* ... */ }\n  }\n}, true);\n\n// Enable logging for custom methods\ncustomEngine.devContext({\n  params: ['calculateUTR'],\n  result: ['calculateUTR']\n});\n\n// Use custom methods\nconst utr = customEngine.calculateUTR({ matchHistory: [...] });\n"})}),"\n",(0,s.jsx)(n.hr,{}),"\n",(0,s.jsx)(n.h2,{id:"gettournament",children:"getTournament"}),"\n",(0,s.jsx)(n.p,{children:"Returns a deep copy of a specific tournament record from engine state."}),"\n",(0,s.jsxs)(n.p,{children:[(0,s.jsx)(n.strong,{children:"Purpose:"})," Retrieve a tournament record without modifying the internal engine state. The returned copy is safe to modify without affecting the engine's internal state."]}),"\n",(0,s.jsx)(n.p,{children:(0,s.jsx)(n.strong,{children:"When to Use:"})}),"\n",(0,s.jsxs)(n.ul,{children:["\n",(0,s.jsx)(n.li,{children:"When you need to inspect tournament data"}),"\n",(0,s.jsx)(n.li,{children:"When you want to export a tournament for storage"}),"\n",(0,s.jsx)(n.li,{children:"When you need a snapshot of tournament state at a specific point"}),"\n"]}),"\n",(0,s.jsx)(n.p,{children:(0,s.jsx)(n.strong,{children:"Parameters:"})}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-ts",children:"{\n  tournamentId?: string;       // Optional - specific tournament ID (defaults to current active tournament)\n  convertExtensions?: boolean; // Optional - convert extension objects to JSON strings\n  removeExtensions?: boolean;  // Optional - strip all extensions from the copy\n}\n"})}),"\n",(0,s.jsx)(n.p,{children:(0,s.jsx)(n.strong,{children:"Returns:"})}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-ts",children:"{\n  tournamentRecord?: object;   // Tournament record object (undefined if tournamentId not found)\n}\n"})}),"\n",(0,s.jsx)(n.p,{children:(0,s.jsx)(n.strong,{children:"Example:"})}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-js",children:"// Get the currently active tournament\nconst { tournamentRecord } = engine.getTournament();\n\n// Get a specific tournament by ID\nconst { tournamentRecord } = engine.getTournament({ \n  tournamentId: 'tournament-123' \n});\n\n// Get tournament without extensions (useful for storage/transmission)\nconst { tournamentRecord } = engine.getTournament({ \n  removeExtensions: true \n});\n"})}),"\n",(0,s.jsx)(n.p,{children:(0,s.jsx)(n.strong,{children:"Notes:"})}),"\n",(0,s.jsxs)(n.ul,{children:["\n",(0,s.jsxs)(n.li,{children:["Returns ",(0,s.jsx)(n.code,{children:"{}"})," if no tournamentId is provided and no tournament is active"]}),"\n",(0,s.jsx)(n.li,{children:"The returned object is a deep copy, so modifications won't affect engine state"}),"\n",(0,s.jsxs)(n.li,{children:["Use ",(0,s.jsx)(n.code,{children:"removeExtensions: true"})," when serializing for storage to reduce size"]}),"\n"]}),"\n",(0,s.jsx)(n.hr,{}),"\n",(0,s.jsx)(n.h2,{id:"getstate",children:"getState"}),"\n",(0,s.jsx)(n.p,{children:"Returns all tournament records currently loaded in engine state along with the active tournament ID."}),"\n",(0,s.jsxs)(n.p,{children:[(0,s.jsx)(n.strong,{children:"Purpose:"})," Get a complete snapshot of the engine's current state, including all loaded tournaments and which one is currently active."]}),"\n",(0,s.jsx)(n.p,{children:(0,s.jsx)(n.strong,{children:"When to Use:"})}),"\n",(0,s.jsxs)(n.ul,{children:["\n",(0,s.jsx)(n.li,{children:"When managing multiple tournaments simultaneously"}),"\n",(0,s.jsx)(n.li,{children:"When you need to save/restore the complete engine state"}),"\n",(0,s.jsx)(n.li,{children:"When debugging to see all loaded tournaments"}),"\n",(0,s.jsx)(n.li,{children:"Before clearing state to create a backup"}),"\n"]}),"\n",(0,s.jsx)(n.p,{children:(0,s.jsx)(n.strong,{children:"Parameters:"})}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-ts",children:"{\n  convertExtensions?: boolean; // Optional - convert extension objects to JSON strings\n  removeExtensions?: boolean;  // Optional - strip all extensions from copies\n}\n"})}),"\n",(0,s.jsx)(n.p,{children:(0,s.jsx)(n.strong,{children:"Returns:"})}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-ts",children:"{\n  tournamentId?: string;              // Currently active tournament ID (undefined if none set)\n  tournamentRecords: {                // Object containing all loaded tournaments\n    [tournamentId: string]: object;  // Keyed by tournament ID\n  };\n}\n"})}),"\n",(0,s.jsx)(n.p,{children:(0,s.jsx)(n.strong,{children:"Example:"})}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-js",children:"// Load multiple tournaments\nengine.setState([tournament1, tournament2, tournament3]);\n\n// Get complete state\nconst { tournamentId, tournamentRecords } = engine.getState();\n\nconsole.log(tournamentId); // Active tournament ID\nconsole.log(Object.keys(tournamentRecords)); // ['id1', 'id2', 'id3']\n\n// Get state without extensions for serialization\nconst state = engine.getState({ removeExtensions: true });\nlocalStorage.setItem('engineState', JSON.stringify(state));\n"})}),"\n",(0,s.jsx)(n.p,{children:(0,s.jsx)(n.strong,{children:"Notes:"})}),"\n",(0,s.jsxs)(n.ul,{children:["\n",(0,s.jsx)(n.li,{children:"Returns deep copies of all tournament records"}),"\n",(0,s.jsx)(n.li,{children:"Useful for implementing undo/redo functionality"}),"\n",(0,s.jsxs)(n.li,{children:["See ",(0,s.jsx)(n.a,{href:"/docs/engines/global-state",children:"Global State"})," for more on multi-tournament management"]}),"\n"]}),"\n",(0,s.jsx)(n.hr,{}),"\n",(0,s.jsx)(n.h2,{id:"reset",children:"reset"}),"\n",(0,s.jsx)(n.p,{children:"Clears all tournament records from engine state and resets the active tournament ID."}),"\n",(0,s.jsxs)(n.p,{children:[(0,s.jsx)(n.strong,{children:"Purpose:"})," Completely clear the engine state, removing all loaded tournaments. This is a destructive operation that cannot be undone."]}),"\n",(0,s.jsx)(n.p,{children:(0,s.jsx)(n.strong,{children:"When to Use:"})}),"\n",(0,s.jsxs)(n.ul,{children:["\n",(0,s.jsx)(n.li,{children:"Starting fresh with new tournament data"}),"\n",(0,s.jsx)(n.li,{children:"Cleaning up after tests"}),"\n",(0,s.jsx)(n.li,{children:"Freeing memory after tournament processing is complete"}),"\n",(0,s.jsx)(n.li,{children:"Before loading a completely different set of tournaments"}),"\n"]}),"\n",(0,s.jsxs)(n.p,{children:[(0,s.jsx)(n.strong,{children:"Parameters:"})," None"]}),"\n",(0,s.jsx)(n.p,{children:(0,s.jsx)(n.strong,{children:"Returns:"})}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-ts",children:"{\n  success: true;\n  methods?: string[];  // Available engine methods\n}\n"})}),"\n",(0,s.jsx)(n.p,{children:(0,s.jsx)(n.strong,{children:"Example:"})}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-js",children:"// Load a tournament\nengine.setState(tournamentRecord);\n\n// Process tournament...\n\n// Clear all data when done\nengine.reset();\n\n// Engine state is now empty\nconst { tournamentRecords } = engine.getState();\nconsole.log(tournamentRecords); // {}\n"})}),"\n",(0,s.jsx)(n.p,{children:(0,s.jsx)(n.strong,{children:"Notes:"})}),"\n",(0,s.jsxs)(n.ul,{children:["\n",(0,s.jsx)(n.li,{children:"This operation cannot be undone"}),"\n",(0,s.jsx)(n.li,{children:"All tournament records are removed from memory"}),"\n",(0,s.jsxs)(n.li,{children:["Consider using ",(0,s.jsx)(n.code,{children:"getState()"})," to backup data before calling ",(0,s.jsx)(n.code,{children:"reset()"})]}),"\n",(0,s.jsxs)(n.li,{children:["After ",(0,s.jsx)(n.code,{children:"reset()"}),", you must load tournaments again before using governor methods"]}),"\n"]}),"\n",(0,s.jsx)(n.hr,{}),"\n",(0,s.jsx)(n.h2,{id:"devcontext",children:"devContext"}),"\n",(0,s.jsx)(n.p,{children:"Sets the development context for controlling engine logging and debugging behavior."}),"\n",(0,s.jsxs)(n.p,{children:[(0,s.jsx)(n.strong,{children:"Purpose:"})," Enable detailed logging of engine operations for debugging and development. Control what gets logged (parameters, results, errors) on a global or per-method basis."]}),"\n",(0,s.jsx)(n.p,{children:(0,s.jsx)(n.strong,{children:"When to Use:"})}),"\n",(0,s.jsxs)(n.ul,{children:["\n",(0,s.jsx)(n.li,{children:"Debugging engine behavior during development"}),"\n",(0,s.jsx)(n.li,{children:"Tracking parameter values passed to methods"}),"\n",(0,s.jsx)(n.li,{children:"Monitoring results from specific operations"}),"\n",(0,s.jsx)(n.li,{children:"Identifying performance bottlenecks"}),"\n",(0,s.jsx)(n.li,{children:"Understanding method execution flow"}),"\n"]}),"\n",(0,s.jsx)(n.p,{children:(0,s.jsx)(n.strong,{children:"Parameters:"})}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-ts",children:"contextCriteria: boolean | {\n  errors?: boolean | string[];   // Log errors for all methods or specific methods\n  params?: boolean | string[];   // Log parameters for all methods or specific methods  \n  result?: boolean | string[];   // Log results for all methods or specific methods\n  exclude?: string[];            // Exclude specific methods from logging\n  [key: string]: any;            // Custom context properties\n}\n"})}),"\n",(0,s.jsx)(n.p,{children:(0,s.jsx)(n.strong,{children:"Returns:"})}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-ts",children:"{\n  success: true;\n  methods?: string[];  // Available engine methods\n}\n"})}),"\n",(0,s.jsx)(n.p,{children:(0,s.jsx)(n.strong,{children:"Examples:"})}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-js",children:"// Enable all logging\nengine.devContext(true);\n\n// Log only errors\nengine.devContext({ errors: true });\n\n// Log params and results for specific methods\nengine.devContext({\n  params: ['addMatchUpScheduledTime', 'bulkScheduleTournamentMatchUps'],\n  result: ['addMatchUpScheduledTime'],\n  errors: true  // Log all errors\n});\n\n// Custom context for conditional logging\nengine.devContext({ \n  WOWO: true,  // Custom flag\n  verbose: true \n});\n\n// Disable all logging\nengine.devContext(false);\n"})}),"\n",(0,s.jsx)(n.p,{children:(0,s.jsx)(n.strong,{children:"Notes:"})}),"\n",(0,s.jsxs)(n.ul,{children:["\n",(0,s.jsx)(n.li,{children:"Logging goes to console by default"}),"\n",(0,s.jsx)(n.li,{children:"Can significantly impact performance when enabled"}),"\n",(0,s.jsxs)(n.li,{children:["Use ",(0,s.jsx)(n.code,{children:"exclude"})," array to prevent logging for high-frequency methods"]}),"\n",(0,s.jsxs)(n.li,{children:["Custom properties can be checked with ",(0,s.jsx)(n.code,{children:"getDevContext(criteria)"})]}),"\n",(0,s.jsxs)(n.li,{children:["See ",(0,s.jsx)(n.a,{href:"/docs/engines/engine-logging",children:"Engine Logging"})," for more details"]}),"\n"]}),"\n",(0,s.jsx)(n.hr,{}),"\n",(0,s.jsx)(n.h2,{id:"getdevcontext",children:"getDevContext"}),"\n",(0,s.jsx)(n.p,{children:"Returns the current development context, optionally checking if it matches specified criteria."}),"\n",(0,s.jsxs)(n.p,{children:[(0,s.jsx)(n.strong,{children:"Purpose:"})," Inspect the current dev context settings or conditionally check if specific context properties are set. Useful for conditional logging or debugging logic."]}),"\n",(0,s.jsx)(n.p,{children:(0,s.jsx)(n.strong,{children:"When to Use:"})}),"\n",(0,s.jsxs)(n.ul,{children:["\n",(0,s.jsx)(n.li,{children:"Checking if dev mode is enabled before expensive logging operations"}),"\n",(0,s.jsx)(n.li,{children:"Conditional behavior based on context flags"}),"\n",(0,s.jsx)(n.li,{children:"Debugging to see what logging is currently enabled"}),"\n",(0,s.jsx)(n.li,{children:"Verifying context matches expected state"}),"\n"]}),"\n",(0,s.jsx)(n.p,{children:(0,s.jsx)(n.strong,{children:"Parameters:"})}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-ts",children:"contextCriteria?: {  // Optional - if provided, checks if all criteria match\n  [key: string]: any;\n}\n"})}),"\n",(0,s.jsx)(n.p,{children:(0,s.jsx)(n.strong,{children:"Returns:"})}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-ts",children:"// If no criteria provided:\nboolean | object  // Current devContext value\n\n// If criteria provided:\nboolean | object  // Returns devContext if all criteria match, otherwise false\n"})}),"\n",(0,s.jsx)(n.p,{children:(0,s.jsx)(n.strong,{children:"Examples:"})}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-js",children:"// Set some context\nengine.devContext({ WOWO: true, debug: true });\n\n// Get current context\nconst context = engine.getDevContext();\nconsole.log(context); // { WOWO: true, debug: true }\n\n// Check if specific criteria match\nconst matches = engine.getDevContext({ WOWO: true });\nconsole.log(matches); // { WOWO: true, debug: true } - returns full context if match\n\nconst noMatch = engine.getDevContext({ FOO: true });\nconsole.log(noMatch); // false - criteria don't match\n\n// Use in conditional logic\nif (engine.getDevContext({ verbose: true })) {\n  // Only execute expensive logging when verbose mode is on\n  console.log('Detailed state:', JSON.stringify(state, null, 2));\n}\n"})}),"\n",(0,s.jsx)(n.p,{children:(0,s.jsx)(n.strong,{children:"Notes:"})}),"\n",(0,s.jsxs)(n.ul,{children:["\n",(0,s.jsxs)(n.li,{children:["Returns ",(0,s.jsx)(n.code,{children:"false"})," if context is not set or doesn't match criteria"]}),"\n",(0,s.jsx)(n.li,{children:"Returns the full devContext object if criteria match"}),"\n",(0,s.jsx)(n.li,{children:"When no criteria provided, returns current devContext value (boolean or object)"}),"\n",(0,s.jsx)(n.li,{children:"Useful for implementing conditional debugging behavior"}),"\n"]}),"\n",(0,s.jsx)(n.hr,{}),"\n",(0,s.jsx)(n.h2,{id:"newtournamentrecord",children:"newTournamentRecord"}),"\n",(0,s.jsx)(n.p,{children:"Creates a new, empty tournament record, loads it into engine state, and sets it as the active tournament."}),"\n",(0,s.jsxs)(n.p,{children:[(0,s.jsx)(n.strong,{children:"Purpose:"})," Quickly create and load a new tournament with basic attributes. The tournament is automatically loaded and set as active, ready for adding events, participants, and other data."]}),"\n",(0,s.jsx)(n.p,{children:(0,s.jsx)(n.strong,{children:"When to Use:"})}),"\n",(0,s.jsxs)(n.ul,{children:["\n",(0,s.jsx)(n.li,{children:"Starting a new tournament from scratch"}),"\n",(0,s.jsx)(n.li,{children:"Creating a tournament programmatically"}),"\n",(0,s.jsx)(n.li,{children:"Initializing a tournament before manual data entry"}),"\n",(0,s.jsx)(n.li,{children:"Testing with fresh tournament instances"}),"\n"]}),"\n",(0,s.jsx)(n.p,{children:(0,s.jsx)(n.strong,{children:"Parameters:"})}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-ts",children:"{\n  tournamentName?: string;      // Tournament name (default: generated name)\n  startDate?: string;           // ISO date string (default: today)\n  endDate?: string;             // ISO date string (default: today + 7 days)\n  tournamentId?: string;        // Custom ID (default: auto-generated UUID)\n  [key: string]: any;           // Additional tournament attributes\n}\n"})}),"\n",(0,s.jsx)(n.p,{children:(0,s.jsx)(n.strong,{children:"Returns:"})}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-ts",children:"{\n  success: true;\n  tournamentId: string;         // The new tournament's ID\n}\n"})}),"\n",(0,s.jsx)(n.p,{children:(0,s.jsx)(n.strong,{children:"Example:"})}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-js",children:"// Create tournament with defaults\nconst result = engine.newTournamentRecord();\nconsole.log(result.tournamentId); // Auto-generated UUID\n\n// Create tournament with specific details\nconst result = engine.newTournamentRecord({\n  tournamentName: 'Summer Open 2024',\n  startDate: '2024-07-01',\n  endDate: '2024-07-07',\n  tournamentRank: 'INTERNATIONAL',\n  indoorOutdoor: 'OUTDOOR'\n});\n\n// Tournament is now loaded and active\nconst { tournamentRecord } = engine.getTournament();\nconsole.log(tournamentRecord.tournamentName); // 'Summer Open 2024'\n\n// Add events and other data\nengine.addEvent({\n  event: {\n    eventName: 'Singles',\n    eventType: 'SINGLES'\n  }\n});\n"})}),"\n",(0,s.jsx)(n.p,{children:(0,s.jsx)(n.strong,{children:"Notes:"})}),"\n",(0,s.jsxs)(n.ul,{children:["\n",(0,s.jsx)(n.li,{children:"The new tournament is automatically loaded into engine state"}),"\n",(0,s.jsxs)(n.li,{children:["The new tournament becomes the active tournament (no need to call ",(0,s.jsx)(n.code,{children:"setTournamentId"}),")"]}),"\n",(0,s.jsxs)(n.li,{children:["Equivalent to calling ",(0,s.jsx)(n.code,{children:"createTournamentRecord()"})," followed by ",(0,s.jsx)(n.code,{children:"setState()"})]}),"\n",(0,s.jsx)(n.li,{children:"Returns error if tournament creation fails"}),"\n",(0,s.jsxs)(n.li,{children:["See ",(0,s.jsx)(n.code,{children:"createTournamentRecord"})," in Tournament Governor for more creation options"]}),"\n"]}),"\n",(0,s.jsx)(n.hr,{}),"\n",(0,s.jsx)(n.h2,{id:"setstate",children:"setState"}),"\n",(0,s.jsxs)(n.p,{children:["See ",(0,s.jsx)(n.a,{href:"/docs/engines/global-state#setstate",children:"Global State"})]}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-js",children:"\n**API Reference:** [addEvent](/docs/governors/event-governor#addevent)\n\nengine.setState(tournamentRecords, deepCopyOption, deepCopyAttributes);\n"})}),"\n",(0,s.jsx)(n.hr,{}),"\n",(0,s.jsx)(n.h2,{id:"settournamentid",children:"setTournamentId"}),"\n",(0,s.jsx)(n.p,{children:"Sets the active tournament ID, making that tournament the target for all subsequent engine operations."}),"\n",(0,s.jsxs)(n.p,{children:[(0,s.jsx)(n.strong,{children:"Purpose:"})," Switch between multiple loaded tournaments. When you have multiple tournament records loaded in engine state, this method specifies which one engine methods will operate on."]}),"\n",(0,s.jsx)(n.p,{children:(0,s.jsx)(n.strong,{children:"When to Use:"})}),"\n",(0,s.jsxs)(n.ul,{children:["\n",(0,s.jsx)(n.li,{children:"Managing multiple tournaments simultaneously"}),"\n",(0,s.jsx)(n.li,{children:"Switching context between tournaments"}),"\n",(0,s.jsxs)(n.li,{children:["After loading multiple tournaments with ",(0,s.jsx)(n.code,{children:"setState([tournament1, tournament2])"})]}),"\n",(0,s.jsx)(n.li,{children:"Before performing operations on a specific tournament"}),"\n"]}),"\n",(0,s.jsx)(n.p,{children:(0,s.jsx)(n.strong,{children:"Parameters:"})}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-ts",children:"tournamentId?: string  // Tournament ID to make active (undefined clears active tournament)\n"})}),"\n",(0,s.jsxs)(n.p,{children:[(0,s.jsx)(n.strong,{children:"Returns:"})," ",(0,s.jsx)(n.code,{children:"void"})]}),"\n",(0,s.jsx)(n.p,{children:(0,s.jsx)(n.strong,{children:"Examples:"})}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-js",children:"// Load multiple tournaments\nengine.setState([tournament1, tournament2, tournament3]);\n\n// Switch to first tournament\nengine.setTournamentId(tournament1.tournamentId);\n\n// Add participants to tournament1\nengine.addParticipants({ participants: [...] });\n\n// Switch to second tournament\nengine.setTournamentId(tournament2.tournamentId);\n\n// Add participants to tournament2\nengine.addParticipants({ participants: [...] });\n\n// Clear active tournament (operations will fail until tournamentId is set)\nengine.setTournamentId();\n\n// Check which tournament is active\nconst activeId = engine.getTournamentId();\n"})}),"\n",(0,s.jsx)(n.p,{children:(0,s.jsx)(n.strong,{children:"Notes:"})}),"\n",(0,s.jsxs)(n.ul,{children:["\n",(0,s.jsx)(n.li,{children:"Does not validate that the tournamentId exists in loaded state"}),"\n",(0,s.jsxs)(n.li,{children:["Passing ",(0,s.jsx)(n.code,{children:"undefined"})," clears the active tournament"]}),"\n",(0,s.jsx)(n.li,{children:"All governor methods operate on the active tournament"}),"\n",(0,s.jsxs)(n.li,{children:["When loading a single tournament with ",(0,s.jsx)(n.code,{children:"setState(record)"}),", it's automatically set as active"]}),"\n",(0,s.jsxs)(n.li,{children:["See ",(0,s.jsx)(n.a,{href:"/docs/engines/global-state",children:"Global State"})," for multi-tournament patterns"]}),"\n"]}),"\n",(0,s.jsx)(n.hr,{}),"\n",(0,s.jsx)(n.h2,{id:"gettournamentid",children:"getTournamentId"}),"\n",(0,s.jsx)(n.p,{children:"Returns the currently active tournament ID."}),"\n",(0,s.jsxs)(n.p,{children:[(0,s.jsx)(n.strong,{children:"Purpose:"})," Determine which tournament is currently active in engine state. Useful for debugging or implementing multi-tournament logic."]}),"\n",(0,s.jsx)(n.p,{children:(0,s.jsx)(n.strong,{children:"When to Use:"})}),"\n",(0,s.jsxs)(n.ul,{children:["\n",(0,s.jsx)(n.li,{children:"Verifying which tournament is active"}),"\n",(0,s.jsx)(n.li,{children:"Implementing multi-tournament UI logic"}),"\n",(0,s.jsx)(n.li,{children:"Debugging state management issues"}),"\n",(0,s.jsx)(n.li,{children:"Conditional logic based on active tournament"}),"\n"]}),"\n",(0,s.jsxs)(n.p,{children:[(0,s.jsx)(n.strong,{children:"Parameters:"})," None"]}),"\n",(0,s.jsx)(n.p,{children:(0,s.jsx)(n.strong,{children:"Returns:"})}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-ts",children:"\n**API Reference:** [addParticipants](/docs/governors/participant-governor#addparticipants)\n\nstring | undefined  // Active tournament ID, or undefined if none set\n"})}),"\n",(0,s.jsx)(n.p,{children:(0,s.jsx)(n.strong,{children:"Examples:"})}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-js",children:"// Load a tournament\nengine.setState(tournamentRecord);\n\n// Get active tournament ID\nconst activeId = engine.getTournamentId();\nconsole.log(activeId); // tournamentRecord.tournamentId\n\n// When managing multiple tournaments\nengine.setState([tournament1, tournament2]);\nengine.setTournamentId(tournament1.tournamentId);\n\nconst currentId = engine.getTournamentId();\nif (currentId === tournament1.tournamentId) {\n  // Perform tournament1-specific operations\n}\n\n// After reset\nengine.reset();\nconsole.log(engine.getTournamentId()); // undefined\n"})}),"\n",(0,s.jsx)(n.p,{children:(0,s.jsx)(n.strong,{children:"Notes:"})}),"\n",(0,s.jsxs)(n.ul,{children:["\n",(0,s.jsxs)(n.li,{children:["Returns ",(0,s.jsx)(n.code,{children:"undefined"})," if no tournament is active"]}),"\n",(0,s.jsxs)(n.li,{children:["The active tournament is set automatically when loading a single tournament with ",(0,s.jsx)(n.code,{children:"setState(record)"})]}),"\n",(0,s.jsxs)(n.li,{children:["Use ",(0,s.jsx)(n.code,{children:"setTournamentId()"})," to change the active tournament"]}),"\n"]}),"\n",(0,s.jsx)(n.hr,{}),"\n",(0,s.jsx)(n.h2,{id:"settournamentrecord",children:"setTournamentRecord"}),"\n",(0,s.jsx)(n.p,{children:"Loads a single tournament record into engine state, replacing any existing tournament with the same ID."}),"\n",(0,s.jsxs)(n.p,{children:[(0,s.jsx)(n.strong,{children:"Purpose:"})," Load or update a tournament record in engine state. Unlike ",(0,s.jsx)(n.code,{children:"setState()"})," which can load multiple tournaments, this method handles a single tournament record."]}),"\n",(0,s.jsx)(n.p,{children:(0,s.jsx)(n.strong,{children:"When to Use:"})}),"\n",(0,s.jsxs)(n.ul,{children:["\n",(0,s.jsx)(n.li,{children:"Loading a tournament from storage"}),"\n",(0,s.jsx)(n.li,{children:"Updating an existing tournament record"}),"\n",(0,s.jsx)(n.li,{children:"Adding a new tournament to already-loaded tournaments"}),"\n",(0,s.jsx)(n.li,{children:"Replacing a specific tournament while keeping others loaded"}),"\n"]}),"\n",(0,s.jsx)(n.p,{children:(0,s.jsx)(n.strong,{children:"Parameters:"})}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-ts",children:"tournamentRecord: object  // Tournament record to load\ndeepCopyOption?: boolean  // Whether to deep copy (default: true)\ndeepCopyAttributes?: object  // Fine-tune copy behavior\n"})}),"\n",(0,s.jsx)(n.p,{children:(0,s.jsx)(n.strong,{children:"Returns:"})}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-ts",children:"{\n  success?: true;\n  error?: string;  // If record is invalid\n}\n"})}),"\n",(0,s.jsx)(n.p,{children:(0,s.jsx)(n.strong,{children:"Examples:"})}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-js",children:"// Load a tournament\nconst result = engine.setTournamentRecord(tournamentRecord);\nif (result.success) {\n  console.log('Tournament loaded');\n}\n\n// Update an existing tournament\nconst { tournamentRecord } = engine.getTournament();\ntournamentRecord.tournamentName = 'Updated Name';\nengine.setTournamentRecord(tournamentRecord);\n\n// Load additional tournament while keeping existing ones\nengine.setTournamentRecord(tournament1); // Load first\nengine.setTournamentRecord(tournament2); // Add second (tournament1 still loaded)\nengine.setTournamentRecord(tournament3); // Add third (both previous still loaded)\n\n// Replace a tournament (same ID overwrites)\nconst updatedTournament = { ...tournament1, tournamentName: 'New Name' };\nengine.setTournamentRecord(updatedTournament); // Replaces tournament1\n\n// Avoid deep copy for performance (use carefully)\nengine.setTournamentRecord(tournamentRecord, false);\n"})}),"\n",(0,s.jsx)(n.p,{children:(0,s.jsx)(n.strong,{children:"Notes:"})}),"\n",(0,s.jsxs)(n.ul,{children:["\n",(0,s.jsxs)(n.li,{children:["Requires ",(0,s.jsx)(n.code,{children:"tournamentRecord.tournamentId"})," to be present"]}),"\n",(0,s.jsxs)(n.li,{children:["Returns error if record is not an object or missing ",(0,s.jsx)(n.code,{children:"tournamentId"})]}),"\n",(0,s.jsx)(n.li,{children:"By default creates a deep copy (safe but slower)"}),"\n",(0,s.jsxs)(n.li,{children:["Set ",(0,s.jsx)(n.code,{children:"deepCopyOption: false"})," for performance when you control the record's lifecycle"]}),"\n",(0,s.jsxs)(n.li,{children:["Does NOT automatically set the tournament as active - use ",(0,s.jsx)(n.code,{children:"setTournamentId()"})," if needed"]}),"\n",(0,s.jsx)(n.li,{children:"Overwrites any existing tournament with the same ID"}),"\n"]}),"\n",(0,s.jsx)(n.hr,{}),"\n",(0,s.jsx)(n.h2,{id:"removetournamentrecord",children:"removeTournamentRecord"}),"\n",(0,s.jsx)(n.p,{children:"Removes a specific tournament record from engine state by its ID."}),"\n",(0,s.jsxs)(n.p,{children:[(0,s.jsx)(n.strong,{children:"Purpose:"})," Delete a tournament from engine state when it's no longer needed, freeing memory and cleaning up state."]}),"\n",(0,s.jsx)(n.p,{children:(0,s.jsx)(n.strong,{children:"When to Use:"})}),"\n",(0,s.jsxs)(n.ul,{children:["\n",(0,s.jsx)(n.li,{children:"Removing tournaments that are no longer needed"}),"\n",(0,s.jsx)(n.li,{children:"Cleaning up after processing"}),"\n",(0,s.jsx)(n.li,{children:"Managing memory in long-running applications"}),"\n",(0,s.jsx)(n.li,{children:"Removing tournaments selectively while keeping others"}),"\n"]}),"\n",(0,s.jsx)(n.p,{children:(0,s.jsx)(n.strong,{children:"Parameters:"})}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-ts",children:"tournamentId: string  // ID of tournament to remove\n"})}),"\n",(0,s.jsx)(n.p,{children:(0,s.jsx)(n.strong,{children:"Returns:"})}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-ts",children:"{\n  success?: true;\n  error?: string;  // If tournamentId not found or invalid\n}\n"})}),"\n",(0,s.jsx)(n.p,{children:(0,s.jsx)(n.strong,{children:"Examples:"})}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-js",children:"// Load multiple tournaments\nengine.setState([tournament1, tournament2, tournament3]);\n\n// Remove one tournament\nconst result = engine.removeTournamentRecord(tournament2.tournamentId);\nif (result.success) {\n  console.log('Tournament removed');\n}\n\n// Verify it's gone\nconst { tournamentRecords } = engine.getState();\nconsole.log(Object.keys(tournamentRecords).length); // 2 (was 3)\n\n// Remove all tournaments one by one\nconst { tournamentRecords } = engine.getState();\nObject.keys(tournamentRecords).forEach(id => {\n  engine.removeTournamentRecord(id);\n});\n"})}),"\n",(0,s.jsx)(n.p,{children:(0,s.jsx)(n.strong,{children:"Notes:"})}),"\n",(0,s.jsxs)(n.ul,{children:["\n",(0,s.jsx)(n.li,{children:"If the removed tournament was active, no tournament will be active afterward"}),"\n",(0,s.jsx)(n.li,{children:"Does not affect other loaded tournaments"}),"\n",(0,s.jsxs)(n.li,{children:["Use ",(0,s.jsx)(n.code,{children:"reset()"})," to remove all tournaments at once"]}),"\n",(0,s.jsx)(n.li,{children:"Returns success even if tournament didn't exist"}),"\n",(0,s.jsxs)(n.li,{children:["See ",(0,s.jsx)(n.code,{children:"removeUnlinkedTournamentRecords()"})," for removing based on links"]}),"\n"]}),"\n",(0,s.jsx)(n.hr,{}),"\n",(0,s.jsx)(n.h2,{id:"removeunlinkedtournamentrecords",children:"removeUnlinkedTournamentRecords"}),"\n",(0,s.jsxs)(n.p,{children:["Removes all tournament records that are not referenced in the ",(0,s.jsx)(n.code,{children:"LINKED_TOURNAMENTS"})," extension."]}),"\n",(0,s.jsxs)(n.p,{children:[(0,s.jsx)(n.strong,{children:"Purpose:"})," Clean up tournaments that are not part of a linked tournament group. Useful for managing related tournaments (like qualification and main events) where only linked tournaments should be retained."]}),"\n",(0,s.jsx)(n.p,{children:(0,s.jsx)(n.strong,{children:"When to Use:"})}),"\n",(0,s.jsxs)(n.ul,{children:["\n",(0,s.jsx)(n.li,{children:"Managing linked tournament groups (qualifications, main draws, consolations)"}),"\n",(0,s.jsx)(n.li,{children:"Cleaning up after importing tournament data"}),"\n",(0,s.jsx)(n.li,{children:"Removing orphaned tournament records"}),"\n",(0,s.jsx)(n.li,{children:"Maintaining only tournaments that are part of a defined relationship"}),"\n"]}),"\n",(0,s.jsxs)(n.p,{children:[(0,s.jsx)(n.strong,{children:"Parameters:"})," None"]}),"\n",(0,s.jsxs)(n.p,{children:[(0,s.jsx)(n.strong,{children:"Returns:"})," ",(0,s.jsx)(n.code,{children:"void"})]}),"\n",(0,s.jsxs)(n.p,{children:[(0,s.jsx)(n.strong,{children:"Background:"}),"\nThe TODS (Tennis Open Data Standards) supports linking related tournaments through the ",(0,s.jsx)(n.code,{children:"LINKED_TOURNAMENTS"})," extension. This method keeps only tournaments that are referenced in this extension, removing any others."]}),"\n",(0,s.jsx)(n.p,{children:(0,s.jsx)(n.strong,{children:"Example:"})}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-js",children:"// Load multiple tournaments\nengine.setState([tournament1, tournament2, tournament3, tournament4]);\n\n// tournament1 has LINKED_TOURNAMENTS extension listing tournament2 and tournament3\n// tournament4 is not linked\n\n// Remove unlinked tournaments\nengine.removeUnlinkedTournamentRecords();\n\n// Only tournament2 and tournament3 remain (referenced by tournament1)\n// tournament1 and tournament4 are removed\nconst { tournamentRecords } = engine.getState();\nconsole.log(Object.keys(tournamentRecords)); // IDs of tournament2 and tournament3 only\n"})}),"\n",(0,s.jsx)(n.p,{children:(0,s.jsx)(n.strong,{children:"Notes:"})}),"\n",(0,s.jsxs)(n.ul,{children:["\n",(0,s.jsxs)(n.li,{children:["Looks for the ",(0,s.jsx)(n.code,{children:"LINKED_TOURNAMENTS"})," extension across all loaded tournaments"]}),"\n",(0,s.jsxs)(n.li,{children:["Only keeps tournaments whose IDs appear in ",(0,s.jsx)(n.code,{children:"extension.value.tournamentIds"})]}),"\n",(0,s.jsx)(n.li,{children:"Removes the tournament containing the extension itself"}),"\n",(0,s.jsx)(n.li,{children:"Useful for multi-stage tournament systems (qualifying \u2192 main draw)"}),"\n",(0,s.jsxs)(n.li,{children:["Does not remove individual tournaments - use ",(0,s.jsx)(n.code,{children:"removeTournamentRecord()"})," for that"]}),"\n",(0,s.jsx)(n.li,{children:"Primarily used internally when managing linked tournament workflows"}),"\n"]}),"\n",(0,s.jsx)(n.p,{children:(0,s.jsx)(n.strong,{children:"Related:"})}),"\n",(0,s.jsxs)(n.ul,{children:["\n",(0,s.jsxs)(n.li,{children:["See ",(0,s.jsx)(n.a,{href:"/docs/concepts/extensions",children:"Extensions"})," for more on tournament extensions"]}),"\n",(0,s.jsxs)(n.li,{children:["See ",(0,s.jsx)(n.a,{href:"/docs/engines/global-state",children:"Global State"})," for state management patterns"]}),"\n"]}),"\n",(0,s.jsx)(n.hr,{}),"\n",(0,s.jsx)(n.h2,{id:"version",children:"version"}),"\n",(0,s.jsx)(n.p,{children:"Returns NPM package version. Can be used in configurations that utilize Competition Factory engines on both client and server to ensure equivalency."}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-js",children:"const version = engine.version();\n"})}),"\n",(0,s.jsx)(n.hr,{})]})}function h(e={}){const{wrapper:n}={...(0,o.R)(),...e.components};return n?(0,s.jsx)(n,{...e,children:(0,s.jsx)(c,{...e})}):c(e)}},8322(e,n,t){t.d(n,{R:()=>i,x:()=>a});var r=t(758);const s={},o=r.createContext(s);function i(e){const n=r.useContext(o);return r.useMemo(function(){return"function"==typeof e?e(n):{...n,...e}},[n,e])}function a(e){let n;return n=e.disableParentContext?"function"==typeof e.components?e.components(s):e.components||s:i(e.components),r.createElement(o.Provider,{value:n},e.children)}}}]);