"use strict";(globalThis.webpackChunkdocumentation=globalThis.webpackChunkdocumentation||[]).push([[314],{1978(n,e,t){t.r(e),t.d(e,{assets:()=>c,contentTitle:()=>r,default:()=>u,frontMatter:()=>a,metadata:()=>i,toc:()=>l});const i=JSON.parse('{"id":"engines/mutation-engines","title":"Mutation Engines","description":"Mutation engines provide state-modifying operations with built-in change tracking, notifications, and error handling. They can operate synchronously or asynchronously depending on the execution context.","source":"@site/docs/engines/mutation-engines.md","sourceDirName":"engines","slug":"/engines/mutation-engines","permalink":"/competition-factory/docs/engines/mutation-engines","draft":false,"unlisted":false,"tags":[],"version":"current","frontMatter":{"title":"Mutation Engines"},"sidebar":"docs","previous":{"title":"Engine Middleware","permalink":"/competition-factory/docs/engines/engine-middleware"},"next":{"title":"Subscriptions","permalink":"/competition-factory/docs/engines/subscriptions"}}');var o=t(6070),s=t(8439);const a={title:"Mutation Engines"},r=void 0,c={},l=[{value:"Synchronous vs Asynchronous Engines",id:"synchronous-vs-asynchronous-engines",level:2},{value:"Synchronous Engines",id:"synchronous-engines",level:3},{value:"Asynchronous Engines",id:"asynchronous-engines",level:3},{value:"Notifications",id:"notifications",level:2},{value:"Subscribing to Notifications",id:"subscribing-to-notifications",level:3},{value:"Common Notification Topics",id:"common-notification-topics",level:3},{value:"Real-World Example: Live Scoring Updates",id:"real-world-example-live-scoring-updates",level:3},{value:"Rollback on Error",id:"rollback-on-error",level:2},{value:"Basic Rollback",id:"basic-rollback",level:3},{value:"Transaction Pattern",id:"transaction-pattern",level:3},{value:"When to Use Rollback",id:"when-to-use-rollback",level:3},{value:"Global State Provider",id:"global-state-provider",level:2},{value:"Synchronous State (Default)",id:"synchronous-state-default",level:3},{value:"Asynchronous State Provider",id:"asynchronous-state-provider",level:3},{value:"Debugging and Logging",id:"debugging-and-logging",level:2}];function d(n){const e={a:"a",code:"code",h2:"h2",h3:"h3",hr:"hr",li:"li",p:"p",pre:"pre",strong:"strong",ul:"ul",...(0,s.R)(),...n.components};return(0,o.jsxs)(o.Fragment,{children:[(0,o.jsxs)(e.p,{children:["Mutation engines provide state-modifying operations with built-in change tracking, notifications, and error handling. They can operate ",(0,o.jsx)(e.strong,{children:"synchronously"})," or ",(0,o.jsx)(e.strong,{children:"asynchronously"})," depending on the execution context."]}),"\n",(0,o.jsx)(e.p,{children:(0,o.jsx)(e.strong,{children:"Key Features:"})}),"\n",(0,o.jsxs)(e.ul,{children:["\n",(0,o.jsx)(e.li,{children:"Automatic mutation logging and audit trails"}),"\n",(0,o.jsx)(e.li,{children:"Subscription-based notification system"}),"\n",(0,o.jsx)(e.li,{children:"Rollback on error capabilities"}),"\n",(0,o.jsx)(e.li,{children:"Asynchronous state management for multi-client scenarios"}),"\n",(0,o.jsx)(e.li,{children:"Integration with middleware for automatic resolution"}),"\n"]}),"\n",(0,o.jsx)(e.hr,{}),"\n",(0,o.jsx)(e.h2,{id:"synchronous-vs-asynchronous-engines",children:"Synchronous vs Asynchronous Engines"}),"\n",(0,o.jsx)(e.h3,{id:"synchronous-engines",children:"Synchronous Engines"}),"\n",(0,o.jsxs)(e.p,{children:["Use ",(0,o.jsx)(e.code,{children:"syncEngine"})," for single-threaded, single-client applications:"]}),"\n",(0,o.jsx)(e.pre,{children:(0,o.jsx)(e.code,{className:"language-js",children:"import { tournamentEngine } from 'tods-competition-factory';\n\ntournamentEngine.setState(tournamentRecord);\ntournamentEngine.addEvent({ event: { eventName: 'Singles', eventType: 'SINGLES' } });\n"})}),"\n",(0,o.jsx)(e.p,{children:(0,o.jsx)(e.strong,{children:"When to Use:"})}),"\n",(0,o.jsxs)(e.ul,{children:["\n",(0,o.jsx)(e.li,{children:"Single-user desktop applications"}),"\n",(0,o.jsx)(e.li,{children:"Command-line tools"}),"\n",(0,o.jsx)(e.li,{children:"Test suites"}),"\n",(0,o.jsx)(e.li,{children:"Simple server endpoints with isolated state per request"}),"\n"]}),"\n",(0,o.jsx)(e.h3,{id:"asynchronous-engines",children:"Asynchronous Engines"}),"\n",(0,o.jsxs)(e.p,{children:["Use ",(0,o.jsx)(e.code,{children:"asyncEngine"})," for multi-client server applications:"]}),"\n",(0,o.jsx)(e.pre,{children:(0,o.jsx)(e.code,{className:"language-js",children:"import { asyncEngine, globalState } from 'tods-competition-factory';\nimport { asyncGlobalState } from './asyncGlobalState';\n\n// Configure async state provider once at startup\nglobalState.setStateProvider(asyncGlobalState);\n\n// Each client request gets isolated state\napp.post('/api/tournament/:id/event', async (req, res) => {\n  const tournamentRecord = await loadTournament(req.params.id);\n  await asyncEngine.setState(tournamentRecord);\n  \n  const result = await asyncEngine.addEvent({ event: req.body.event });\n  await saveTournament(asyncEngine.getState());\n  \n  res.json(result);\n});\n"})}),"\n",(0,o.jsx)(e.p,{children:(0,o.jsx)(e.strong,{children:"When to Use:"})}),"\n",(0,o.jsxs)(e.ul,{children:["\n",(0,o.jsx)(e.li,{children:"Multi-user web servers"}),"\n",(0,o.jsx)(e.li,{children:"REST APIs serving multiple clients"}),"\n",(0,o.jsx)(e.li,{children:"WebSocket servers with concurrent connections"}),"\n",(0,o.jsx)(e.li,{children:"Any scenario with concurrent state modifications"}),"\n"]}),"\n",(0,o.jsxs)(e.p,{children:[(0,o.jsx)(e.strong,{children:"State Isolation:"}),"\nAsync engines use Node's ",(0,o.jsx)(e.code,{children:"executionAsyncId()"})," to maintain separate state for each async execution context, preventing state collision between concurrent requests."]}),"\n",(0,o.jsx)(e.hr,{}),"\n",(0,o.jsx)(e.h2,{id:"notifications",children:"Notifications"}),"\n",(0,o.jsx)(e.p,{children:"Mutation engines emit notifications for state changes, enabling reactive updates across your application."}),"\n",(0,o.jsx)(e.h3,{id:"subscribing-to-notifications",children:"Subscribing to Notifications"}),"\n",(0,o.jsx)(e.pre,{children:(0,o.jsx)(e.code,{className:"language-js",children:"import { tournamentEngine, addNotification } from 'tods-competition-factory';\n\n// Subscribe to specific notification topics\naddNotification({\n  topic: 'addMatchUps',\n  payload: (payload) => {\n    console.log('MatchUps added:', payload.matchUps);\n    // Update UI, trigger webhooks, etc.\n  }\n});\n\naddNotification({\n  topic: 'modifyMatchUp',\n  payload: (payload) => {\n    console.log('MatchUp modified:', payload.matchUp);\n  }\n});\n\n// Now mutations trigger notifications\ntournamentEngine.generateDrawDefinition({ /* ... */ });\n// Triggers 'addMatchUps' notification\n"})}),"\n",(0,o.jsx)(e.h3,{id:"common-notification-topics",children:"Common Notification Topics"}),"\n",(0,o.jsxs)(e.ul,{children:["\n",(0,o.jsxs)(e.li,{children:[(0,o.jsx)(e.code,{children:"addMatchUps"})," - New matchUps created"]}),"\n",(0,o.jsxs)(e.li,{children:[(0,o.jsx)(e.code,{children:"modifyMatchUp"})," - MatchUp properties changed"]}),"\n",(0,o.jsxs)(e.li,{children:[(0,o.jsx)(e.code,{children:"publishEvent"})," - Event published/unpublished"]}),"\n",(0,o.jsxs)(e.li,{children:[(0,o.jsx)(e.code,{children:"deletedMatchUpIds"})," - MatchUps removed"]}),"\n",(0,o.jsxs)(e.li,{children:[(0,o.jsx)(e.code,{children:"modifyDrawDefinition"})," - Draw structure changed"]}),"\n",(0,o.jsxs)(e.li,{children:[(0,o.jsx)(e.code,{children:"audit"})," - Any mutation for audit trail"]}),"\n"]}),"\n",(0,o.jsx)(e.h3,{id:"real-world-example-live-scoring-updates",children:"Real-World Example: Live Scoring Updates"}),"\n",(0,o.jsx)(e.pre,{children:(0,o.jsx)(e.code,{className:"language-js",children:"import { tournamentEngine, addNotification } from 'tods-competition-factory';\nimport { broadcastToWebSocketClients } from './websocket';\n\n// Broadcast score changes to connected clients\naddNotification({\n  topic: 'modifyMatchUp',\n  payload: (payload) => {\n    if (payload.matchUp.score) {\n      broadcastToWebSocketClients({\n        type: 'SCORE_UPDATE',\n        matchUpId: payload.matchUp.matchUpId,\n        score: payload.matchUp.score,\n        matchUpStatus: payload.matchUp.matchUpStatus\n      });\n    }\n  }\n});\n\n// Recording a score triggers notification\ntournamentEngine.setMatchUpStatus({\n  matchUpId: 'match-1',\n  outcome: {\n    score: {\n      sets: [\n        { side1Score: 6, side2Score: 4 },\n        { side1Score: 6, side2Score: 3 }\n      ]\n    }\n  }\n});\n// WebSocket clients receive live update\n"})}),"\n",(0,o.jsxs)(e.p,{children:["See ",(0,o.jsx)(e.a,{href:"/docs/engines/subscriptions",children:"Subscriptions"})," for complete notification documentation."]}),"\n",(0,o.jsx)(e.hr,{}),"\n",(0,o.jsx)(e.h2,{id:"rollback-on-error",children:"Rollback on Error"}),"\n",(0,o.jsx)(e.p,{children:"Protect tournament integrity by automatically reverting changes when operations fail."}),"\n",(0,o.jsx)(e.h3,{id:"basic-rollback",children:"Basic Rollback"}),"\n",(0,o.jsx)(e.pre,{children:(0,o.jsx)(e.code,{className:"language-js",children:"import { tournamentEngine } from 'tods-competition-factory';\n\ntournamentEngine.setState(tournamentRecord);\n\ntry {\n  const result = await tournamentEngine.automatedPositioning({\n    drawId: 'draw-1',\n    rollbackOnError: true  // Enable automatic rollback\n  });\n} catch (error) {\n  // State automatically reverted to pre-operation state\n  console.error('Operation failed, state rolled back:', error);\n}\n"})}),"\n",(0,o.jsx)(e.h3,{id:"transaction-pattern",children:"Transaction Pattern"}),"\n",(0,o.jsx)(e.pre,{children:(0,o.jsx)(e.code,{className:"language-js",children:"// Complex operation with multiple mutations\ntournamentEngine.setState(tournamentRecord);\nconst originalState = tournamentEngine.getState();\n\ntry {\n  // Multiple operations that must all succeed\n  await tournamentEngine.addEvent({ event, rollbackOnError: true });\n  await tournamentEngine.generateDrawDefinition({ drawSize: 32, rollbackOnError: true });\n  await tournamentEngine.attachPolicy({ policyDefinitions, rollbackOnError: true });\n  \n  // All succeeded, persist state\n  await saveToDatabase(tournamentEngine.getState());\n} catch (error) {\n  // Any failure rolls back entire transaction\n  console.error('Transaction failed:', error);\n  tournamentEngine.setState(originalState);\n}\n"})}),"\n",(0,o.jsx)(e.h3,{id:"when-to-use-rollback",children:"When to Use Rollback"}),"\n",(0,o.jsx)(e.p,{children:(0,o.jsxs)(e.strong,{children:["Use ",(0,o.jsx)(e.code,{children:"rollbackOnError: true"})," when:"]})}),"\n",(0,o.jsxs)(e.ul,{children:["\n",(0,o.jsx)(e.li,{children:"Operating on production data"}),"\n",(0,o.jsx)(e.li,{children:"Complex multi-step operations"}),"\n",(0,o.jsx)(e.li,{children:"User-initiated actions that must be atomic"}),"\n",(0,o.jsx)(e.li,{children:"Data integrity is critical"}),"\n"]}),"\n",(0,o.jsx)(e.p,{children:(0,o.jsx)(e.strong,{children:"Skip rollback when:"})}),"\n",(0,o.jsxs)(e.ul,{children:["\n",(0,o.jsx)(e.li,{children:"In test suites (let failures be visible)"}),"\n",(0,o.jsx)(e.li,{children:"Debugging (you want to see the failed state)"}),"\n",(0,o.jsx)(e.li,{children:"Bulk operations where partial success is acceptable"}),"\n",(0,o.jsx)(e.li,{children:"Performance is critical and errors are rare"}),"\n"]}),"\n",(0,o.jsx)(e.hr,{}),"\n",(0,o.jsx)(e.h2,{id:"global-state-provider",children:"Global State Provider"}),"\n",(0,o.jsx)(e.h3,{id:"synchronous-state-default",children:"Synchronous State (Default)"}),"\n",(0,o.jsx)(e.p,{children:"Synchronous engines maintain state in memory without special configuration:"}),"\n",(0,o.jsx)(e.pre,{children:(0,o.jsx)(e.code,{className:"language-js",children:"import { tournamentEngine } from 'tods-competition-factory';\n\n// No setup required for sync engines\ntournamentEngine.setState(tournamentRecord);\ntournamentEngine.addEvent({ event });\n"})}),"\n",(0,o.jsx)(e.h3,{id:"asynchronous-state-provider",children:"Asynchronous State Provider"}),"\n",(0,o.jsx)(e.p,{children:"For multi-client scenarios, implement a custom state provider:"}),"\n",(0,o.jsx)(e.pre,{children:(0,o.jsx)(e.code,{className:"language-js",children:"// asyncGlobalState.js\nimport { AsyncLocalStorage } from 'async_hooks';\n\nconst asyncLocalStorage = new AsyncLocalStorage();\n\nexport const asyncGlobalState = {\n  // Get state for current async context\n  getState: () => asyncLocalStorage.getStore() || {},\n  \n  // Set state for current async context\n  setState: (state) => {\n    const store = asyncLocalStorage.getStore();\n    if (store) {\n      Object.assign(store, state);\n    }\n  },\n  \n  // Run callback in new async context\n  run: (callback) => {\n    asyncLocalStorage.run({}, callback);\n  }\n};\n"})}),"\n",(0,o.jsx)(e.pre,{children:(0,o.jsx)(e.code,{className:"language-js",children:"// server.js\nimport { globalState, asyncEngine } from 'tods-competition-factory';\nimport { asyncGlobalState } from './asyncGlobalState';\n\n// Configure once at app startup\nglobalState.setStateProvider(asyncGlobalState);\n\n// Each request gets isolated state\napp.use((req, res, next) => {\n  asyncGlobalState.run(() => next());\n});\n\napp.post('/api/event', async (req, res) => {\n  // State isolated to this request\n  await asyncEngine.setState(req.tournament);\n  const result = await asyncEngine.addEvent({ event: req.body });\n  res.json(result);\n});\n"})}),"\n",(0,o.jsxs)(e.p,{children:[(0,o.jsx)(e.strong,{children:"Reference Implementation:"}),"\nSee ",(0,o.jsx)(e.code,{children:"src/examples/asyncEngine"})," in the source code for a complete async state provider example."]}),"\n",(0,o.jsx)(e.hr,{}),"\n",(0,o.jsx)(e.h2,{id:"debugging-and-logging",children:"Debugging and Logging"}),"\n",(0,o.jsx)(e.p,{children:"Enable detailed logging for debugging and monitoring:"}),"\n",(0,o.jsx)(e.pre,{children:(0,o.jsx)(e.code,{className:"language-js",children:"import { tournamentEngine, globalState } from 'tods-competition-factory';\n\n// Enable detailed logging\nglobalState.setDevContext({\n  errors: true,    // Log errors\n  params: true,    // Log method parameters  \n  result: true,    // Log method results\n  perf: 100        // Log methods taking >100ms\n});\n\ntournamentEngine.setState(tournamentRecord);\ntournamentEngine.addEvent({ event: { eventName: 'Singles' } });\n// Console: [addEvent] params: {...} result: {...} time: 5ms\n\ntournamentEngine.generateDrawDefinition({ drawSize: 32 });\n// Console: [generateDrawDefinition] params: {...} result: {...} time: 25ms\n"})}),"\n",(0,o.jsx)(e.p,{children:(0,o.jsx)(e.strong,{children:"Dev Context Options:"})}),"\n",(0,o.jsxs)(e.ul,{children:["\n",(0,o.jsxs)(e.li,{children:[(0,o.jsx)(e.code,{children:"errors: true"})," - Log all errors"]}),"\n",(0,o.jsxs)(e.li,{children:[(0,o.jsx)(e.code,{children:"params: true | ['methodName']"})," - Log parameters for all or specific methods"]}),"\n",(0,o.jsxs)(e.li,{children:[(0,o.jsx)(e.code,{children:"result: true | ['methodName']"})," - Log results for all or specific methods"]}),"\n",(0,o.jsxs)(e.li,{children:[(0,o.jsx)(e.code,{children:"perf: number"})," - Log methods exceeding threshold (ms)"]}),"\n",(0,o.jsxs)(e.li,{children:[(0,o.jsx)(e.code,{children:"exclude: ['methodName']"})," - Exclude specific methods from logging"]}),"\n"]}),"\n",(0,o.jsx)(e.hr,{})]})}function u(n={}){const{wrapper:e}={...(0,s.R)(),...n.components};return e?(0,o.jsx)(e,{...n,children:(0,o.jsx)(d,{...n})}):d(n)}},8439(n,e,t){t.d(e,{R:()=>a,x:()=>r});var i=t(758);const o={},s=i.createContext(o);function a(n){const e=i.useContext(s);return i.useMemo(function(){return"function"==typeof n?n(e):{...e,...n}},[e,n])}function r(n){let e;return e=n.disableParentContext?"function"==typeof n.components?n.components(o):n.components||o:a(n.components),i.createElement(s.Provider,{value:e},n.children)}}}]);