"use strict";(globalThis.webpackChunkdocumentation=globalThis.webpackChunkdocumentation||[]).push([[9464],{4049(n,e,i){i.r(e),i.d(e,{assets:()=>c,contentTitle:()=>a,default:()=>g,frontMatter:()=>o,metadata:()=>t,toc:()=>l});const t=JSON.parse('{"id":"scale-engine/scale-engine-overview","title":"Scale Engine Overview","description":"The ScaleEngine is a stateful engine for computing, persisting, and aggregating ranking points and ratings across tournaments. It combines the Ranking Governor (ranking points computation, aggregation, and write-back) with ratings functions (dynamic ratings, rating calculations) into a single engine that manages all participant competitive metrics.","source":"@site/docs/scale-engine/scale-engine-overview.md","sourceDirName":"scale-engine","slug":"/scale-engine/scale-engine-overview","permalink":"/competition-factory/docs/scale-engine/scale-engine-overview","draft":false,"unlisted":false,"tags":[],"version":"current","frontMatter":{"title":"Scale Engine Overview"},"sidebar":"docs","previous":{"title":"Global State","permalink":"/competition-factory/docs/engines/global-state"},"next":{"title":"Core API Reference","permalink":"/competition-factory/docs/scale-engine/scale-engine-api"}}');var s=i(6070),r=i(8322);const o={title:"Scale Engine Overview"},a=void 0,c={},l=[{value:"When to Use ScaleEngine vs rankingGovernor",id:"when-to-use-scaleengine-vs-rankinggovernor",level:2},{value:"Key Capabilities",id:"key-capabilities",level:2},{value:"Basic Usage",id:"basic-usage",level:2},{value:"Architecture",id:"architecture",level:2},{value:"Ranking Points Pipeline",id:"ranking-points-pipeline",level:2},{value:"Related Documentation",id:"related-documentation",level:2}];function d(n){const e={a:"a",code:"code",h2:"h2",li:"li",ol:"ol",p:"p",pre:"pre",strong:"strong",table:"table",tbody:"tbody",td:"td",th:"th",thead:"thead",tr:"tr",ul:"ul",...(0,r.R)(),...n.components};return(0,s.jsxs)(s.Fragment,{children:[(0,s.jsxs)(e.p,{children:["The ",(0,s.jsx)(e.strong,{children:"ScaleEngine"})," is a stateful engine for computing, persisting, and aggregating ranking points and ratings across tournaments. It combines the ",(0,s.jsx)(e.a,{href:"/docs/governors/ranking-governor",children:"Ranking Governor"})," (ranking points computation, aggregation, and write-back) with ratings functions (dynamic ratings, rating calculations) into a single engine that manages all participant competitive metrics."]}),"\n",(0,s.jsx)(e.h2,{id:"when-to-use-scaleengine-vs-rankinggovernor",children:"When to Use ScaleEngine vs rankingGovernor"}),"\n",(0,s.jsxs)(e.table,{children:[(0,s.jsx)(e.thead,{children:(0,s.jsxs)(e.tr,{children:[(0,s.jsx)(e.th,{children:"Use Case"}),(0,s.jsx)(e.th,{children:"Recommended"})]})}),(0,s.jsxs)(e.tbody,{children:[(0,s.jsxs)(e.tr,{children:[(0,s.jsx)(e.td,{children:"Compute ranking points for a tournament"}),(0,s.jsx)(e.td,{children:(0,s.jsx)(e.strong,{children:"ScaleEngine"})})]}),(0,s.jsxs)(e.tr,{children:[(0,s.jsx)(e.td,{children:"Persist ranking points to participant records"}),(0,s.jsx)(e.td,{children:(0,s.jsx)(e.strong,{children:"ScaleEngine"})})]}),(0,s.jsxs)(e.tr,{children:[(0,s.jsx)(e.td,{children:"Generate multi-tournament ranking lists"}),(0,s.jsx)(e.td,{children:(0,s.jsx)(e.strong,{children:"ScaleEngine"})})]}),(0,s.jsxs)(e.tr,{children:[(0,s.jsx)(e.td,{children:"Get per-participant point breakdowns"}),(0,s.jsx)(e.td,{children:(0,s.jsx)(e.strong,{children:"ScaleEngine"})})]}),(0,s.jsxs)(e.tr,{children:[(0,s.jsx)(e.td,{children:"Compute quality win bonuses"}),(0,s.jsx)(e.td,{children:(0,s.jsx)(e.strong,{children:"ScaleEngine"})})]}),(0,s.jsxs)(e.tr,{children:[(0,s.jsx)(e.td,{children:"Generate dynamic ratings"}),(0,s.jsx)(e.td,{children:(0,s.jsx)(e.strong,{children:"ScaleEngine"})})]}),(0,s.jsxs)(e.tr,{children:[(0,s.jsx)(e.td,{children:"Stateless point computation with explicit tournamentRecord"}),(0,s.jsx)(e.td,{children:(0,s.jsx)(e.strong,{children:"rankingGovernor"})})]}),(0,s.jsxs)(e.tr,{children:[(0,s.jsx)(e.td,{children:"Custom pipeline orchestration"}),(0,s.jsx)(e.td,{children:(0,s.jsx)(e.strong,{children:"rankingGovernor"})})]}),(0,s.jsxs)(e.tr,{children:[(0,s.jsx)(e.td,{children:"Profile selection without full tournament context"}),(0,s.jsx)(e.td,{children:(0,s.jsx)(e.strong,{children:"rankingGovernor"})})]})]})]}),"\n",(0,s.jsx)(e.h2,{id:"key-capabilities",children:"Key Capabilities"}),"\n",(0,s.jsxs)(e.ul,{children:["\n",(0,s.jsxs)(e.li,{children:[(0,s.jsx)(e.strong,{children:"Policy-driven point calculation"})," \u2014 ",(0,s.jsx)(e.a,{href:"/docs/policies/rankingPolicy",children:"Ranking policies"})," define position points, per-win points, bonuses, and quality win profiles"]}),"\n",(0,s.jsxs)(e.li,{children:[(0,s.jsx)(e.strong,{children:"Specificity scoring"})," \u2014 Award profiles are selected by counting populated scope fields; more constrained profiles automatically win over catch-all profiles"]}),"\n",(0,s.jsxs)(e.li,{children:[(0,s.jsx)(e.strong,{children:"CategoryScope matching"})," \u2014 Profiles match against gender, age category, ball type, wheelchair class, rating type, and more"]}),"\n",(0,s.jsxs)(e.li,{children:[(0,s.jsx)(e.strong,{children:"Quality win bonuses"})," \u2014 Bonus points for defeating ranked opponents, with configurable ranking snapshot strategies"]}),"\n",(0,s.jsxs)(e.li,{children:[(0,s.jsx)(e.strong,{children:"Multi-tournament aggregation"})," \u2014 Best-of-N counting buckets, rolling time windows, per-level caps, and tiebreakers"]}),"\n",(0,s.jsxs)(e.li,{children:[(0,s.jsx)(e.strong,{children:"Write-back mutation"})," \u2014 Persist computed points as ",(0,s.jsx)(e.a,{href:"/docs/concepts/scaleItems",children:"scale items"})," retrievable for future tournaments"]}),"\n",(0,s.jsxs)(e.li,{children:[(0,s.jsx)(e.strong,{children:"Doubles attribution"})," \u2014 Full-to-each or split-even point distribution from pair to individual participants"]}),"\n",(0,s.jsxs)(e.li,{children:[(0,s.jsx)(e.strong,{children:"FIC/multi-structure support"})," \u2014 Feed-in consolation draws produce distinct finishing positions; participants get their best finish across structures"]}),"\n",(0,s.jsxs)(e.li,{children:[(0,s.jsx)(e.strong,{children:"Dynamic ratings"})," \u2014 Generate and update participant ratings based on match outcomes"]}),"\n"]}),"\n",(0,s.jsx)(e.h2,{id:"basic-usage",children:"Basic Usage"}),"\n",(0,s.jsx)(e.pre,{children:(0,s.jsx)(e.code,{className:"language-js",children:"import { scaleEngine } from 'tods-competition-factory';\n\n// Load a tournament with completed matchUps\nscaleEngine.setState(tournamentRecord);\n\n// Compute ranking points using a policy\nconst { personPoints, success } = scaleEngine.getTournamentPoints({\n  policyDefinitions: rankingPolicy,\n  level: 3,\n});\n\n// Persist points to participant scaleItems\nconst result = scaleEngine.applyTournamentRankingPoints({\n  policyDefinitions: rankingPolicy,\n  scaleName: 'NATIONAL_RANKING',\n  level: 3,\n});\n\n// Aggregate across multiple tournaments\nimport { generateRankingList } from 'tods-competition-factory';\n\nconst rankingList = generateRankingList({\n  pointAwards: allTournamentAwards, // collected from multiple tournaments\n  aggregationRules: {\n    countingBuckets: [\n      { bucketName: 'Singles', eventTypes: ['SINGLES'], pointComponents: ['positionPoints', 'perWinPoints'], bestOfCount: 6 },\n      { bucketName: 'Doubles', eventTypes: ['DOUBLES'], pointComponents: ['positionPoints', 'perWinPoints'], bestOfCount: 2 },\n      { bucketName: 'Quality Wins', pointComponents: ['qualityWinPoints'], bestOfCount: 0 },\n    ],\n    rollingPeriodDays: 365,\n    tiebreakCriteria: ['highestSingleResult', 'mostWins'],\n  },\n  asOfDate: '2025-12-31',\n});\n"})}),"\n",(0,s.jsx)(e.h2,{id:"architecture",children:"Architecture"}),"\n",(0,s.jsxs)(e.p,{children:["The ScaleEngine follows the Competition Factory pattern where ",(0,s.jsx)(e.strong,{children:"governors"})," provide pure functions and ",(0,s.jsx)(e.strong,{children:"engines"})," provide stateful facades:"]}),"\n",(0,s.jsx)(e.pre,{children:(0,s.jsx)(e.code,{children:"+------------------------------+\n|         ScaleEngine           |  Stateful facade (setState, methods)\n|  (rankings + ratings)         |\n+---------------+--------------+\n|               |              |\n| rankingGovernor  ratingsGovernor |  Pure function modules\n|  (points, QW,    (dynamic     |\n|   aggregation,    ratings,    |\n|   write-back)     calculations)|\n+---------------+--------------+\n|    TODS Tournament Record     |  Standard data model\n|   (participants, scaleItems,  |\n|    matchUps, policies)        |\n+------------------------------+\n"})}),"\n",(0,s.jsxs)(e.p,{children:["The engine holds tournament state via ",(0,s.jsx)(e.code,{children:"setState()"}),". All ranking methods access participant data, match results, and finishing positions through the factory's ",(0,s.jsx)(e.code,{children:"getParticipants({ withRankingProfile: true })"})," pipeline."]}),"\n",(0,s.jsx)(e.h2,{id:"ranking-points-pipeline",children:"Ranking Points Pipeline"}),"\n",(0,s.jsx)(e.p,{children:"The core pipeline for computing tournament ranking points:"}),"\n",(0,s.jsxs)(e.ol,{children:["\n",(0,s.jsxs)(e.li,{children:[(0,s.jsx)(e.strong,{children:"Policy resolution"})," \u2014 Find attached or provided ",(0,s.jsx)(e.a,{href:"/docs/policies/rankingPolicy",children:"ranking policy"})]}),"\n",(0,s.jsxs)(e.li,{children:[(0,s.jsx)(e.strong,{children:"Participant hydration"})," \u2014 ",(0,s.jsx)(e.code,{children:"getParticipants({ withRankingProfile: true })"})," provides ",(0,s.jsx)(e.code,{children:"structureParticipation"})," with ",(0,s.jsx)(e.code,{children:"finishingPositionRange"}),", ",(0,s.jsx)(e.code,{children:"winCount"}),", draw metadata"]}),"\n",(0,s.jsxs)(e.li,{children:[(0,s.jsx)(e.strong,{children:"Profile selection"})," \u2014 ",(0,s.jsx)(e.a,{href:"/docs/scale-engine/ranking-points-pipeline#profile-selection",children:"getAwardProfile"})," matches each participation against ",(0,s.jsx)(e.code,{children:"awardProfiles"})," using specificity scoring"]}),"\n",(0,s.jsxs)(e.li,{children:[(0,s.jsx)(e.strong,{children:"Position points"})," \u2014 ",(0,s.jsx)(e.code,{children:"finishingPositionRanges[accessor]"})," resolved via ",(0,s.jsx)(e.code,{children:"Math.max(finishingPositionRange)"})]}),"\n",(0,s.jsxs)(e.li,{children:[(0,s.jsx)(e.strong,{children:"Per-win points"})," \u2014 Accumulated from ",(0,s.jsx)(e.code,{children:"pointsPerWin"})," or level-keyed ",(0,s.jsx)(e.code,{children:"perWinPoints"}),", subject to ",(0,s.jsx)(e.code,{children:"maxCountableMatches"})]}),"\n",(0,s.jsxs)(e.li,{children:[(0,s.jsx)(e.strong,{children:"Bonus points"})," \u2014 Champion/finalist bonus from ",(0,s.jsx)(e.code,{children:"bonusPoints"})," config"]}),"\n",(0,s.jsxs)(e.li,{children:[(0,s.jsx)(e.strong,{children:"Quality win points"})," \u2014 Bonus for beating ranked opponents (see ",(0,s.jsx)(e.a,{href:"/docs/scale-engine/quality-win-points",children:"Quality Win Points"}),")"]}),"\n",(0,s.jsxs)(e.li,{children:[(0,s.jsx)(e.strong,{children:"Doubles attribution"})," \u2014 Pair points distributed to individuals"]}),"\n"]}),"\n",(0,s.jsxs)(e.p,{children:["See ",(0,s.jsx)(e.a,{href:"/docs/scale-engine/ranking-points-pipeline",children:"Ranking Points Pipeline"})," for detailed documentation."]}),"\n",(0,s.jsx)(e.h2,{id:"related-documentation",children:"Related Documentation"}),"\n",(0,s.jsxs)(e.ul,{children:["\n",(0,s.jsxs)(e.li,{children:[(0,s.jsx)(e.strong,{children:(0,s.jsx)(e.a,{href:"./scale-engine-api",children:"Core API Reference"})})," \u2014 Complete method reference"]}),"\n",(0,s.jsxs)(e.li,{children:[(0,s.jsx)(e.strong,{children:(0,s.jsx)(e.a,{href:"./ranking-points-pipeline",children:"Ranking Points Pipeline"})})," \u2014 Profile selection, position points, per-win, bonuses"]}),"\n",(0,s.jsxs)(e.li,{children:[(0,s.jsx)(e.strong,{children:(0,s.jsx)(e.a,{href:"./quality-win-points",children:"Quality Win Points"})})," \u2014 Quality win bonus system"]}),"\n",(0,s.jsxs)(e.li,{children:[(0,s.jsx)(e.strong,{children:(0,s.jsx)(e.a,{href:"./aggregation",children:"Multi-Tournament Aggregation"})})," \u2014 Counting buckets, rolling windows, tiebreakers"]}),"\n",(0,s.jsxs)(e.li,{children:[(0,s.jsx)(e.strong,{children:(0,s.jsx)(e.a,{href:"/docs/policies/rankingPolicy",children:"Ranking Policy"})})," \u2014 Policy structure reference"]}),"\n",(0,s.jsxs)(e.li,{children:[(0,s.jsx)(e.strong,{children:(0,s.jsx)(e.a,{href:"/docs/governors/ranking-governor",children:"Ranking Governor"})})," \u2014 Stateless ranking functions"]}),"\n",(0,s.jsxs)(e.li,{children:[(0,s.jsx)(e.strong,{children:(0,s.jsx)(e.a,{href:"/docs/concepts/scaleItems",children:"Scale Items"})})," \u2014 Rankings, ratings, and seedings storage"]}),"\n"]})]})}function g(n={}){const{wrapper:e}={...(0,r.R)(),...n.components};return e?(0,s.jsx)(e,{...n,children:(0,s.jsx)(d,{...n})}):d(n)}},8322(n,e,i){i.d(e,{R:()=>o,x:()=>a});var t=i(758);const s={},r=t.createContext(s);function o(n){const e=t.useContext(r);return t.useMemo(function(){return"function"==typeof n?n(e):{...e,...n}},[e,n])}function a(n){let e;return e=n.disableParentContext?"function"==typeof n.components?n.components(s):n.components||s:o(n.components),t.createElement(r.Provider,{value:e},n.children)}}}]);