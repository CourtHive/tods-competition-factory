"use strict";(self.webpackChunkdocumentation=self.webpackChunkdocumentation||[]).push([[5410],{3805:(e,n,t)=>{t.d(n,{xA:()=>d,yg:()=>y});var a=t(758);function i(e,n,t){return n in e?Object.defineProperty(e,n,{value:t,enumerable:!0,configurable:!0,writable:!0}):e[n]=t,e}function r(e,n){var t=Object.keys(e);if(Object.getOwnPropertySymbols){var a=Object.getOwnPropertySymbols(e);n&&(a=a.filter((function(n){return Object.getOwnPropertyDescriptor(e,n).enumerable}))),t.push.apply(t,a)}return t}function s(e){for(var n=1;n<arguments.length;n++){var t=null!=arguments[n]?arguments[n]:{};n%2?r(Object(t),!0).forEach((function(n){i(e,n,t[n])})):Object.getOwnPropertyDescriptors?Object.defineProperties(e,Object.getOwnPropertyDescriptors(t)):r(Object(t)).forEach((function(n){Object.defineProperty(e,n,Object.getOwnPropertyDescriptor(t,n))}))}return e}function l(e,n){if(null==e)return{};var t,a,i=function(e,n){if(null==e)return{};var t,a,i={},r=Object.keys(e);for(a=0;a<r.length;a++)t=r[a],n.indexOf(t)>=0||(i[t]=e[t]);return i}(e,n);if(Object.getOwnPropertySymbols){var r=Object.getOwnPropertySymbols(e);for(a=0;a<r.length;a++)t=r[a],n.indexOf(t)>=0||Object.prototype.propertyIsEnumerable.call(e,t)&&(i[t]=e[t])}return i}var o=a.createContext({}),u=function(e){var n=a.useContext(o),t=n;return e&&(t="function"==typeof e?e(n):s(s({},n),e)),t},d=function(e){var n=u(e.components);return a.createElement(o.Provider,{value:n},e.children)},g="mdxType",p={inlineCode:"code",wrapper:function(e){var n=e.children;return a.createElement(a.Fragment,{},n)}},c=a.forwardRef((function(e,n){var t=e.components,i=e.mdxType,r=e.originalType,o=e.parentName,d=l(e,["components","mdxType","originalType","parentName"]),g=u(t),c=i,y=g["".concat(o,".").concat(c)]||g[c]||p[c]||r;return t?a.createElement(y,s(s({ref:n},d),{},{components:t})):a.createElement(y,s({ref:n},d))}));function y(e,n){var t=arguments,i=n&&n.mdxType;if("string"==typeof e||i){var r=t.length,s=new Array(r);s[0]=c;var l={};for(var o in n)hasOwnProperty.call(n,o)&&(l[o]=n[o]);l.originalType=e,l[g]="string"==typeof e?e:i,s[1]=l;for(var u=2;u<r;u++)s[u]=t[u];return a.createElement.apply(null,s)}return a.createElement.apply(null,t)}c.displayName="MDXCreateElement"},5491:(e,n,t)=>{t.r(n),t.d(n,{assets:()=>o,contentTitle:()=>s,default:()=>p,frontMatter:()=>r,metadata:()=>l,toc:()=>u});var a=t(2232),i=(t(758),t(3805));const r={title:"drawEngine API"},s=void 0,l={unversionedId:"apis/draw-engine-api",id:"apis/draw-engine-api",title:"drawEngine API",description:"// NOTEXPORTED: should it be?",source:"@site/docs/apis/draw-engine-api.md",sourceDirName:"apis",slug:"/apis/draw-engine-api",permalink:"/tods-competition-factory/docs/apis/draw-engine-api",draft:!1,tags:[],version:"current",frontMatter:{title:"drawEngine API"}},o={},u=[{value:"addFinishingRounds",id:"addfinishingrounds",level:2},{value:"allStructureMatchUps",id:"allstructurematchups",level:2},{value:"assignSeed",id:"assignseed",level:2},{value:"clearDrawPosition",id:"cleardrawposition",level:2},{value:"generateQualifyingLink",id:"generatequalifyinglink",level:2},{value:"getDrawStructures",id:"getdrawstructures",level:2},{value:"getEliminationDrawSize",id:"geteliminationdrawsize",level:2},{value:"getMatchUpParticipantIds",id:"getmatchupparticipantids",level:2},{value:"getNextSeedBlock",id:"getnextseedblock",level:2},{value:"getNextUnfilledDrawPositions",id:"getnextunfilleddrawpositions",level:2},{value:"getSourceRounds",id:"getsourcerounds",level:2},{value:"initializeStructureSeedAssignments",id:"initializestructureseedassignments",level:2},{value:"matchUpDuration",id:"matchupduration",level:2},{value:"newDrawDefinition",id:"newdrawdefinition",level:2},{value:"resetMatchUpTimeItems",id:"resetmatchuptimeitems",level:2},{value:"setDrawDescription",id:"setdrawdescription",level:2},{value:"setStageAlternatesCount",id:"setstagealternatescount",level:2},{value:"setStageDrawSize",id:"setstagedrawsize",level:2},{value:"setStageQualifiersCount",id:"setstagequalifierscount",level:2},{value:"setStageWildcardsCount",id:"setstagewildcardscount",level:2},{value:"getStructureMatchUps",id:"getstructurematchups",level:2},{value:"validDrawPositions",id:"validdrawpositions",level:2}],d={toc:u},g="wrapper";function p(e){let{components:n,...t}=e;return(0,i.yg)(g,(0,a.A)({},d,t,{components:n,mdxType:"MDXLayout"}),(0,i.yg)("p",null,"// NOTEXPORTED: should it be?"),(0,i.yg)("h2",{id:"addfinishingrounds"},"addFinishingRounds"),(0,i.yg)("pre",null,(0,i.yg)("code",{parentName:"pre",className:"language-js"},"addFinishingRounds({\n  finishingPositionOffset = 0, // required for sub-structures; e.g. consolation fed from R32 would have { finishingPositionOffset: 16 }\n  roundLimit, // for qualifying, offset the final round so that qualifyinground is finishingRound\n  matchUps, // required - matchUps belonging to a single structure\n});\n")),(0,i.yg)("hr",null),(0,i.yg)("p",null,"// NOTEXPORTED: should it be?"),(0,i.yg)("h2",{id:"allstructurematchups"},"allStructureMatchUps"),(0,i.yg)("p",null,"Returns all matchUps from a single structure within a draw."),(0,i.yg)("pre",null,(0,i.yg)("code",{parentName:"pre",className:"language-js"},"const { matchUps } = drawEngine.allStructureMatchUps({\n  structureId,\n  context, // optional context to be added into matchUps\n  inContext, // boolean - add context { drawId, structureId, participant, individualParticipants ... }\n  nextMatchUps, // optioanl - boolean - to include winnerTo and loserTo\n  matchUpFilters, // attribute filters\n  contextFilters, // filters based on context attributes\n  tournamentParticipants, // optional - provide an array of tournamentParticipants to add into matchUps\n  requireParticipants, // optional - require that participants be loaded into drawEngine or passed into method\n  tournamentAppliedPolicies, // any policies, such as privacy, to be applied to matchUps\n});\n")),(0,i.yg)("hr",null),(0,i.yg)("p",null,"// NOTEXPORTED: should it be?"),(0,i.yg)("h2",{id:"assignseed"},"assignSeed"),(0,i.yg)("pre",null,(0,i.yg)("code",{parentName:"pre",className:"language-js"},"result = drawEngine.assignSeed({\n  structureId,\n  seedNumber,\n  seedValue, // optional - display value, e.g. '5-8'\n  participantId,\n});\n")),(0,i.yg)("hr",null),(0,i.yg)("p",null,"// NOTEXPORTED: should it be?"),(0,i.yg)("h2",{id:"cleardrawposition"},"clearDrawPosition"),(0,i.yg)("p",null,"Removes a ",(0,i.yg)("inlineCode",{parentName:"p"},"participantId")," or ",(0,i.yg)("inlineCode",{parentName:"p"},"bye")," from a specified ",(0,i.yg)("inlineCode",{parentName:"p"},"drawPosition")," within a ",(0,i.yg)("inlineCode",{parentName:"p"},"structure")," or, optionally, removes a specified ",(0,i.yg)("inlineCode",{parentName:"p"},"participantId")," from a ",(0,i.yg)("inlineCode",{parentName:"p"},"structure"),"."),(0,i.yg)("pre",null,(0,i.yg)("code",{parentName:"pre",className:"language-js"},"drawEngine.clearDrawPosition({\n  structureId,\n  drawPosition, // optional if participantId is provided\n  participantId, // optional if drawPosition is provided\n});\n")),(0,i.yg)("hr",null),(0,i.yg)("p",null,"// NOTEXPORTED: should it be?"),(0,i.yg)("h2",{id:"generatequalifyinglink"},"generateQualifyingLink"),(0,i.yg)("p",null,"Generates and adds a ",(0,i.yg)("inlineCode",{parentName:"p"},"link")," to ",(0,i.yg)("inlineCode",{parentName:"p"},"drawDefinition.links"),"."),(0,i.yg)("pre",null,(0,i.yg)("code",{parentName:"pre",className:"language-js"},"drawEngine.generateQualifyingLink({\n  qualifyingStructureId,\n  mainStructureId,\n});\n")),(0,i.yg)("hr",null),(0,i.yg)("p",null,"// NOTEXPORTED: should it be?"),(0,i.yg)("h2",{id:"getdrawstructures"},"getDrawStructures"),(0,i.yg)("pre",null,(0,i.yg)("code",{parentName:"pre",className:"language-js"},"const { structures, stageStructures } = drawEngine.getDrawStructures({\n  withStageGrouping, // optinal, return structures collated by stage\n  stageSequences, // optional - specify stageSequences to include\n  stageSequence, // optional - filter by stageSequence\n  stages, // optional - specify stageSequences to include\n  stage, // optional - filter by stage\n});\n")),(0,i.yg)("hr",null),(0,i.yg)("p",null,"// NOTEXPORTED: should it be?"),(0,i.yg)("h2",{id:"geteliminationdrawsize"},"getEliminationDrawSize"),(0,i.yg)("pre",null,(0,i.yg)("code",{parentName:"pre",className:"language-js"},"const { drawSize } = drawEngine.getEliminationDrawSize({ participantsCount });\n")),(0,i.yg)("hr",null),(0,i.yg)("p",null,"// NOTEXPORTED: should it be?"),(0,i.yg)("h2",{id:"getmatchupparticipantids"},"getMatchUpParticipantIds"),(0,i.yg)("p",null,"Convenience function; requires inContext matchUp."),(0,i.yg)("pre",null,(0,i.yg)("code",{parentName:"pre",className:"language-js"},"const { sideParticipantIds, individualParticipantIds } = drawEngine.getMatchUpParticipantIds({ matchUp });\n")),(0,i.yg)("hr",null),(0,i.yg)("p",null,"// NOTEXPORTED: should it be?"),(0,i.yg)("h2",{id:"getnextseedblock"},"getNextSeedBlock"),(0,i.yg)("p",null,"Returns the next block of drawPositions which are to be assigned seeded participants."),(0,i.yg)("pre",null,(0,i.yg)("code",{parentName:"pre",className:"language-js"},"const { nextSeedBlock, unplacedSeedParticipantIds, unplacedSeedNumbers, unfilledPositions, unplacedSeedAssignments } =\n  drawEngine.getNextSeedBlock({\n    structureId,\n  });\n")),(0,i.yg)("hr",null),(0,i.yg)("p",null,"// NOTEXPORTED: should it be?"),(0,i.yg)("h2",{id:"getnextunfilleddrawpositions"},"getNextUnfilledDrawPositions"),(0,i.yg)("p",null,"Returns the next valid block of unfilled drawPositions. Useful for UI to give visual indication of drawPostions valid to assign."),(0,i.yg)("pre",null,(0,i.yg)("code",{parentName:"pre",className:"language-js"},"const { nextUnfilledDrawPositions } = drawEngine.getNextUnfilledDrawPositions({\n  structureId,\n});\n")),(0,i.yg)("hr",null),(0,i.yg)("p",null,"// NOTEXPORTED: should it be?"),(0,i.yg)("h2",{id:"getsourcerounds"},"getSourceRounds"),(0,i.yg)("p",null,"Returns the round numbers for desired playoff positions."),(0,i.yg)("pre",null,(0,i.yg)("code",{parentName:"pre",className:"language-js"},"const {\n  sourceRounds, // all source rounds for playedOff positions and specified playoffPositions\n  playoffSourceRounds,\n  playedOffSourceRounds,\n  playoffPositionsReturned,\n} = drawEngine.getSourceRounds({\n  structureId,\n  playoffPositions: [3, 4],\n});\n")),(0,i.yg)("hr",null),(0,i.yg)("p",null,"// NOTEXPORTED: should it be?"),(0,i.yg)("h2",{id:"initializestructureseedassignments"},"initializeStructureSeedAssignments"),(0,i.yg)("p",null,"Creates the ",(0,i.yg)("inlineCode",{parentName:"p"},"seedAssignments")," attribute for the specified structure."),(0,i.yg)("pre",null,(0,i.yg)("code",{parentName:"pre",className:"language-js"},"drawEngine.initializeStructureSeedAssignments({\n  structureId,\n  seedsCount,\n});\n")),(0,i.yg)("hr",null),(0,i.yg)("p",null,"// NOTEXPORTED: should it be?"),(0,i.yg)("h2",{id:"matchupduration"},"matchUpDuration"),(0,i.yg)("p",null,"Calculates matchUp duration from START, STOP, RESUME, END timeItems."),(0,i.yg)("pre",null,(0,i.yg)("code",{parentName:"pre",className:"language-js"},'const {\n  milliseconds,\n  time, // string representation of elapsed time, e.g. "01:10:00" for an hour and 10 seconds\n  relevantTimeItems,\n} = drawEngine.matchUpDuration({\n  matchUp,\n});\n')),(0,i.yg)("hr",null),(0,i.yg)("p",null,"// NOTEXPORTED: should it be?"),(0,i.yg)("h2",{id:"newdrawdefinition"},"newDrawDefinition"),(0,i.yg)("p",null,"Creates a new drawDefinition within drawEngine state."),(0,i.yg)("pre",null,(0,i.yg)("code",{parentName:"pre",className:"language-js"},"const { drawId } = drawEngine.newDrawDefinition();\nconst { drawDefinition } = drawEngine.getState();\n")),(0,i.yg)("hr",null),(0,i.yg)("p",null,"// NOTEXPORTED: should it be?"),(0,i.yg)("h2",{id:"resetmatchuptimeitems"},"resetMatchUpTimeItems"),(0,i.yg)("p",null,"Removes all timeItems from a specified matchUp."),(0,i.yg)("pre",null,(0,i.yg)("code",{parentName:"pre",className:"language-js"},"drawEngine.resetMatchUpTimeItems({ matchUpId });\n")),(0,i.yg)("hr",null),(0,i.yg)("p",null,"// NOTEXPORTED: should it be?"),(0,i.yg)("h2",{id:"setdrawdescription"},"setDrawDescription"),(0,i.yg)("pre",null,(0,i.yg)("code",{parentName:"pre",className:"language-js"},"const drawDescription = 'Draw Description';\ndrawEngine.setDrawDescription({ description: drawDescription });\n")),(0,i.yg)("hr",null),(0,i.yg)("p",null,"// NOTEXPORTED: should it be?"),(0,i.yg)("h2",{id:"setstagealternatescount"},"setStageAlternatesCount"),(0,i.yg)("p",null,"Sets an (optional) limit to the number of accepted alternates."),(0,i.yg)("p",null,"Modifies the 'entryProfile' of a drawDefinition before the structures have been generated."),(0,i.yg)("pre",null,(0,i.yg)("code",{parentName:"pre",className:"language-js"},"drawEngine.setStageAlternatesCount({ alternatesCount: 8 });\n")),(0,i.yg)("hr",null),(0,i.yg)("p",null,"// NOTEXPORTED: should it be?"),(0,i.yg)("h2",{id:"setstagedrawsize"},"setStageDrawSize"),(0,i.yg)("p",null,"Modifies the 'entryProfile' of a drawDefinition before the structures have been generated."),(0,i.yg)("pre",null,(0,i.yg)("code",{parentName:"pre",className:"language-js"},"drawEngine.setStageDrawSize({ stage: QUALIFYING, stageSequence, drawSize: 8 });\ndrawEngine.setStageDrawSize({ stage: MAIN, drawSize: 16 });\n")),(0,i.yg)("hr",null),(0,i.yg)("p",null,"// NOTEXPORTED: should it be?"),(0,i.yg)("h2",{id:"setstagequalifierscount"},"setStageQualifiersCount"),(0,i.yg)("pre",null,(0,i.yg)("code",{parentName:"pre",className:"language-js"},"drawEngine.setStageQualifiersCount({\n  qualifiersCount: 4,\n  stageSequence,\n  stage,\n});\n")),(0,i.yg)("hr",null),(0,i.yg)("p",null,"// NOTEXPORTED: should it be?"),(0,i.yg)("h2",{id:"setstagewildcardscount"},"setStageWildcardsCount"),(0,i.yg)("pre",null,(0,i.yg)("code",{parentName:"pre",className:"language-js"},"drawEngine.setStageWildcardsCount({ stage, stageSequence, wildcardsCount: 2 });\n")),(0,i.yg)("hr",null),(0,i.yg)("p",null,"// NOTEXPORTED: should it be?"),(0,i.yg)("h2",{id:"getstructurematchups"},"getStructureMatchUps"),(0,i.yg)("p",null,"Returns categorized matchUps from a single structure."),(0,i.yg)("pre",null,(0,i.yg)("code",{parentName:"pre",className:"language-js"},"const { upcomingMatchUps, pendingMatchUps, completedMatchUps, abandonedMatchUps, byeMatchUps } =\n  drawEngine.getStructureMatchUps({\n    tournamentAppliedPolicies, // any policies, such as privacy, to be applied to matchUps\n    scheduleVisibilityFilters, // { visibilityThreshold: Date, eventIds, drawIds }\n    tournamentParticipants, // optional - provide an array of tournamentParticipants to add into matchUps\n    requireParticipants, // optional - require that participants be loaded into drawEngine or passed into method\n    contextFilters, // filters based on context attributes\n    matchUpFilters, // attribute filters\n    structureId,\n    nextMatchUps, // optioanl - boolean - to include winnerTo and loserTo\n    inContext, // boolean - add context { drawId, structureId, participant, individualParticipants ... }\n    context, // optional context to be added into matchUps\n  });\n")),(0,i.yg)("hr",null),(0,i.yg)("p",null,"// NOTEXPORTED: should it be?"),(0,i.yg)("h2",{id:"validdrawpositions"},"validDrawPositions"),(0,i.yg)("p",null,"Returns boolean indicating whether all matchUps have valid draw positions"),(0,i.yg)("pre",null,(0,i.yg)("code",{parentName:"pre",className:"language-js"},"drawEngine.validDrawPositions({ matchUps });\n")),(0,i.yg)("hr",null))}p.isMDXComponent=!0}}]);