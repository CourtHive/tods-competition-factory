/**
 * Core data types for the Temporal Engine
 *
 * Following the principle: "Time as a First-Class Object"
 * Courts are modeled as continuous time-based capacity streams, not static assets.
 */

// ============================================================================
// Time & Identity Primitives
// ============================================================================

export type DayId = string; // 'YYYY-MM-DD'
export type BlockId = string;
export type VenueId = string;
export type CourtId = string;
export type TournamentId = string;
export type TemplateId = string;
export type RuleId = string;

// ============================================================================
// Block Types & Semantics
// ============================================================================

/**
 * BlockType defines the semantic meaning of a time segment.
 * Precedence matters for overlapping blocks (defined in EngineConfig).
 *
 * INVERTED PARADIGM: No blocks = Available Time
 * - Default state is AVAILABLE (no block needed)
 * - Paint ONLY what makes courts UNAVAILABLE
 * - AVAILABLE is derived, not stored as blocks
 */
export const BLOCK_TYPES = {
  MAINTENANCE: 'MAINTENANCE',
  PRACTICE: 'PRACTICE',
  RESERVED: 'RESERVED',
  BLOCKED: 'BLOCKED',
  CLOSED: 'CLOSED',
  SCHEDULED: 'SCHEDULED',
  SOFT_BLOCK: 'SOFT_BLOCK',
  HARD_BLOCK: 'HARD_BLOCK',
  LOCKED: 'LOCKED',
  AVAILABLE: 'AVAILABLE',
  UNSPECIFIED: 'UNSPECIFIED',
} as const;

export type BlockType =
  | 'MAINTENANCE' // Court maintenance/cleaning
  | 'PRACTICE' // Practice time reserved
  | 'RESERVED' // Reserved for recreational/paying players
  | 'BLOCKED' // Generic unavailable (miscellaneous)
  | 'CLOSED' // Court closed (outside open hours or explicitly closed)
  | 'SCHEDULED' // Tournament matches (read-only, created by scheduler)
  | 'SOFT_BLOCK' // Can be overridden if needed (legacy)
  | 'HARD_BLOCK' // Cannot be overridden (legacy)
  | 'LOCKED' // System-locked, no user modification (legacy)
  | 'AVAILABLE' // Derived status - time without any blocks
  | 'UNSPECIFIED'; // No explicit status (gray fog - for backwards compatibility)

export type BlockSource = 'USER' | 'TEMPLATE' | 'RULE' | 'SYSTEM';
export type BlockHardness = 'HARD' | 'SOFT';

// ============================================================================
// Time Ranges & Court References
// ============================================================================

export interface TimeRange {
  start: string; // ISO 8601 datetime string (e.g., '2026-06-15T08:00:00')
  end: string; // ISO 8601 datetime string
}

export interface CourtRef {
  tournamentId: TournamentId;
  venueId: VenueId;
  courtId: CourtId;
}

// ============================================================================
// Blocks (Raw Storage)
// ============================================================================

/**
 * Block represents a user-defined or system-generated time constraint
 * on a court. Blocks are the only "authoritative" objects; all other
 * structures (rails, capacity curves) are derived from blocks.
 */
export interface Block extends TimeRange {
  id: BlockId;
  court: CourtRef;
  type: BlockType;
  reason?: string; // Human-readable reason for the block
  priority?: number; // Higher priority wins in conflicts
  hardSoft?: BlockHardness;
  recurrenceKey?: string; // Link to template/recurrence pattern
  source?: BlockSource;
  matchUpId?: string; // TODS matchUp ID (set by importScheduledMatchUps)
}

// ============================================================================
// Derived Rail Segments (Computed)
// ============================================================================

/**
 * RailSegment is a derived, non-overlapping time segment on a court.
 * Generated by the rail derivation algorithm from overlapping blocks.
 */
export interface RailSegment extends TimeRange {
  status: BlockType; // Effective semantic status for this segment
  contributingBlocks: BlockId[]; // Blocks that contribute to this segment
}

/**
 * CourtRail represents the continuous timeline for a single court on a day.
 */
export interface CourtRail {
  court: CourtRef;
  segments: RailSegment[]; // Non-overlapping, sorted by start time
}

/**
 * VenueDayTimeline represents all courts in a venue for a single day.
 */
export interface VenueDayTimeline {
  day: DayId;
  venueId: VenueId;
  rails: CourtRail[];
}

// ============================================================================
// Capacity Curves
// ============================================================================

/**
 * CapacityPoint represents the number of courts in various states
 * at a specific point in time.
 */
export interface CapacityPoint {
  time: string; // ISO 8601 datetime
  courtsAvailable: number;
  courtsSoftBlocked: number;
  courtsHardBlocked: number;
}

/**
 * CapacityCurve is a time-series view of court capacity for a day.
 */
export interface CapacityCurve {
  day: DayId;
  points: CapacityPoint[];
}

// ============================================================================
// Templates & Rules
// ============================================================================

export interface Template {
  id: TemplateId;
  name: string;
  description?: string;
  operations: TemplateOperation[];
}

export interface TemplateOperation {
  target: 'TOURNAMENT' | 'VENUE' | 'COURT_GROUP' | 'COURT';
  venueIds?: VenueId[];
  courtIds?: CourtId[];
  days?: DayId[];
  relativeTime?: {
    startOffsetMinutes: number;
    endOffsetMinutes: number;
  };
  absoluteTime?: TimeRange;
  blockType: BlockType;
  reason?: string;
  hardSoft?: BlockHardness;
}

export interface Rule {
  id: RuleId;
  name: string;
  description?: string;
  // Rules are evaluated functions that return block mutations
  evaluate: (ctx: EngineContext) => BlockMutation[];
}

// ============================================================================
// Mutations & Results
// ============================================================================

export type MutationKind = 'ADD_BLOCK' | 'UPDATE_BLOCK' | 'REMOVE_BLOCK';

export interface BlockMutation {
  kind: MutationKind;
  block: Block;
  previousBlock?: Block; // For UPDATE_BLOCK, store the old version
}

export interface MutationResult {
  applied: BlockMutation[];
  rejected: BlockMutation[];
  warnings: EngineWarning[];
  conflicts: EngineConflict[];
}

export interface SimulationResult {
  previewRails: VenueDayTimeline[];
  capacityImpact?: CapacityCurve;
  conflicts: EngineConflict[];
}

// ============================================================================
// Warnings & Conflicts
// ============================================================================

export type ConflictSeverity = 'INFO' | 'WARN' | 'ERROR';

export interface EngineWarning {
  code: string;
  message: string;
  relatedBlocks?: BlockId[];
  relatedCourts?: CourtRef[];
}

export interface EngineConflict {
  code: string;
  message: string;
  severity: ConflictSeverity;
  timeRange: TimeRange;
  courts: CourtRef[];
  relatedMatches?: string[]; // TODS matchUp IDs for "shadow scheduling"
}

// ============================================================================
// Engine Configuration
// ============================================================================

export interface EngineConfig {
  tournamentId: TournamentId;
  dayStartTime: string; // 'HH:MM' (e.g., '06:00')
  dayEndTime: string; // 'HH:MM' (e.g., '23:00')
  slotMinutes: number; // Granularity for rendering (5, 10, 15)

  /**
   * Canonical time granularity in minutes. When set, this is the authoritative
   * granularity for the engine. Falls back to slotMinutes if not provided.
   * Typical values: 15, 30, 60.
   */
  granularityMinutes?: number;

  /**
   * Type precedence for resolving overlapping blocks.
   * First type in array has highest priority.
   * Example: ['HARD_BLOCK', 'LOCKED', 'MAINTENANCE', 'PRACTICE', 'SOFT_BLOCK', 'AVAILABLE']
   */
  typePrecedence: BlockType[];

  /**
   * Pluggable conflict evaluators
   */
  conflictEvaluators?: ConflictEvaluator[];
}

export interface ConflictEvaluator {
  id: string;
  description: string;
  evaluate: (ctx: EngineContext, mutations: BlockMutation[]) => EngineConflict[];
}

// ============================================================================
// Engine Context (Internal State Snapshot)
// ============================================================================

export interface EngineContext {
  config: EngineConfig;
  tournamentRecord: any; // TODS tournamentRecord

  // Internal indices
  blocksById: Map<BlockId, Block>;
  blocksByCourtDay: Map<string, BlockId[]>; // Key: courtDayKey(court, day)

  templates: Map<TemplateId, Template>;
  rules: Map<RuleId, Rule>;
}

// ============================================================================
// Engine Events
// ============================================================================

export type EngineEventType =
  | 'STATE_CHANGED'
  | 'BLOCKS_CHANGED'
  | 'CONFLICTS_CHANGED'
  | 'AVAILABILITY_CHANGED'
  | 'PLAN_CHANGED';

export interface EngineEvent {
  type: EngineEventType;
  payload: any;
}

export interface StateChangedEvent extends EngineEvent {
  type: 'STATE_CHANGED';
  payload: {
    reason: string;
  };
}

export interface BlocksChangedEvent extends EngineEvent {
  type: 'BLOCKS_CHANGED';
  payload: {
    mutations: BlockMutation[];
  };
}

export interface ConflictsChangedEvent extends EngineEvent {
  type: 'CONFLICTS_CHANGED';
  payload: {
    conflicts: EngineConflict[];
  };
}

// ============================================================================
// Command Options
// ============================================================================

export interface ApplyBlockOptions {
  courts: CourtRef[];
  timeRange: TimeRange;
  type: BlockType;
  reason?: string;
  hardSoft?: BlockHardness;
  source?: BlockSource;
}

export interface MoveBlockOptions {
  blockId: BlockId;
  newTimeRange: TimeRange;
  newCourt?: CourtRef;
}

export interface ResizeBlockOptions {
  blockId: BlockId;
  newTimeRange: TimeRange;
}

export interface ApplyTemplateOptions {
  templateId: TemplateId;
  scope?: {
    venues?: VenueId[];
    courts?: CourtRef[];
    days?: DayId[];
  };
}

// ============================================================================
// Court Availability
// ============================================================================

export interface CourtDayAvailability {
  startTime: string; // 'HH:MM'
  endTime: string; // 'HH:MM'
}

// ============================================================================
// Court Metadata (for projections)
// ============================================================================

export interface CourtMeta {
  ref: CourtRef;
  name: string;
  surface: string;
  indoor: boolean;
  hasLights: boolean;
  tags: string[];
  openTime?: string; // Default open time 'HH:mm' (e.g., '06:00')
  closeTime?: string; // Default close time 'HH:mm' (e.g., '22:00')
  closedDays?: string[]; // Days when court is closed (e.g., ['saturday', 'sunday'])
  extendedProps?: Record<string, any>; // Additional TODS properties
}

// ============================================================================
// Utility Types
// ============================================================================

/**
 * Edge used in sweep-line algorithm for rail derivation
 */
export interface Edge {
  time: string;
  type: 'START' | 'END';
  blockId: BlockId;
}
