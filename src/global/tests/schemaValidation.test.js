import mocksEngine from '../../mocksEngine';
import addFormats from 'ajv-formats';
import { expect, it } from 'vitest';
import Ajv from 'ajv';
import fs from 'fs';

import {
  COMPASS,
  CURTIS_CONSOLATION,
  FEED_IN,
  FEED_IN_CHAMPIONSHIP_TO_SF,
  FIRST_MATCH_LOSER_CONSOLATION,
  FIRST_ROUND_LOSER_CONSOLATION,
  MODIFIED_FEED_IN_CHAMPIONSHIP,
  ROUND_ROBIN,
  ROUND_ROBIN_WITH_PLAYOFF,
} from '../../constants/drawDefinitionConstants';

const ajv = new Ajv({ allowUnionTypes: true, verbose: true, allErrors: true });
ajv.addFormat('date-time', (dateTime) => {
  if (typeof dateTimeString === 'object') dateTime = dateTime.toISOString();
  return !isNaN(Date.parse(dateTime));
});
addFormats(ajv);

const schema = JSON.parse(
  fs.readFileSync('./src/global/schema/tournament.schema.json', 'UTF-8')
);
const validate = ajv.compile(schema);

const sourcePath = './src/global/testHarness';
const filenames = fs.readdirSync(sourcePath).filter(
  (filename) =>
    filename.indexOf('.tods.json') > 0 && filename.indexOf('.8') === undefined // we don't want to validate TODS v0.8
);

it.each(filenames)(
  'can validate all tods files in testHarness directory',
  (filename) => {
    const data = JSON.parse(
      fs.readFileSync(`./src/global/testHarness/${filename}`, 'UTF-8')
    );
    const result = validate(data);

    // to document pattern of use
    if (validate.errors) {
      const errors = ajv.errorsText(validate.errors, {
        dataVar: 'config',
      });
      console.log({ filename }, errors);
    }

    expect(result).toEqual(true);
  }
);

const mockProfiles = [
  { drawProfiles: [{ drawSize: 32, drawType: MODIFIED_FEED_IN_CHAMPIONSHIP }] },
  { drawProfiles: [{ drawSize: 32, drawType: FIRST_ROUND_LOSER_CONSOLATION }] },
  { drawProfiles: [{ drawSize: 32, drawType: FIRST_MATCH_LOSER_CONSOLATION }] },
  { drawProfiles: [{ drawSize: 32, drawType: FEED_IN_CHAMPIONSHIP_TO_SF }] },
  { drawProfiles: [{ drawSize: 32, drawType: ROUND_ROBIN_WITH_PLAYOFF }] },
  { drawProfiles: [{ drawSize: 32, drawType: CURTIS_CONSOLATION }] },
  { drawProfiles: [{ drawSize: 32, drawType: ROUND_ROBIN }] },
  { drawProfiles: [{ drawSize: 32, drawType: COMPASS }] },
  { drawProfiles: [{ drawSize: 48, drawType: FEED_IN }] },
];

it.each(mockProfiles)(
  'can validate tournaments generated by mocksEngine',
  (mockProfile) => {
    const { tournamentRecord } =
      mocksEngine.generateTournamentRecord(mockProfile);

    const result = validate(tournamentRecord);

    // to document pattern of use
    if (validate.errors) {
      const errors = ajv.errorsText(validate.errors, {
        dataVar: 'config',
        separator: ';',
      });
      console.log(errors);
      console.log(mockProfile);
      console.log(
        Object.keys(tournamentRecord.events[0].drawDefinitions[0].structures[1])
      );
      console.log(
        tournamentRecord.participants.map((p, i) => [
          i,
          p.person.addresses[0].countryCode,
        ]),
        tournamentRecord.events[0].drawDefinitions[0].structures[1].matchUps.map(
          (m) => m.drawPositions
        )
      );
    }
    expect(result).toEqual(true);
  }
);
